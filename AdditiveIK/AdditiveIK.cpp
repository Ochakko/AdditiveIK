#include "stdafx.h"

#include "useatl.h"

#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#include "resource.h"


#include <Coef.h>
#include "StructHistory.h"

#include <ChaScene.h>
#include <Model.h>
#include <TexBank.h>
#include <Bone.h>
//#include <MySprite.h>
#include <mqoobject.h>

//#include <OrgWindow.h>
//InfoWindowでOrgWindowをincludeしている
#include <InfoWindow.h>

#define DBGH
#include <dbg.h>

#include <shlobj.h> //shell
#include <shlobj_core.h>
#include <objbase.h>
#include <Knownfolders.h>

#include <Commdlg.h>
//#include <ChaVecCalc.h>
#include <GlobalVar.h>

#include <mqomaterial.h>

#include <ChaFile.h>
#include <RetargetFile.h>
#include <ImpFile.h>
#include <RigidElemFile.h>
#include <RigidElem.h>
#include <MNLFile.h>
#include <ChooseColorFile.h>
#include <LightsForEditFile.h>
#include <ShadowParamsFile.h>
#include "IniFile.h"


#include <BtObject.h>
#include <fbxsdk.h>

#include <BPWorld.h>
#include <GlutStuff.h>
#include <GLDebugDrawer.h>
#include <btBulletDynamicsCommon.h>

#include "ColiIDDlg.h"
#include "GColiIDDlg.h"
#include "RegistDlg.h"
#include <GColiFile.h>
#include "SettingsDlg.h"
#include "CopyHistoryDlg.h"
#include "DollyHistoryDlg.h"
#include "CpInfoDlg.h"

#include <math.h>
#include <stdio.h>

#include <EditRange.h>
#include "FrameCopyDlg.h"

#include <BVHFile.h>
#include "FBXFile.h"

#include <BntFile.h>

#include <Model.h>
#include "RMenuMain.h"
//#include <BoneProp.h>
#include <lmtFile.h>
#include <RigFile.h>
#include "MotFilter.h"
#include <MotionPoint.h>

#include "DSUpdateUnderTracking.h"
#include "PluginElem.h"

#include "SelectLSDlg.h"

//display undoR undoW sprite
#include "UndoSprite.h"

//display Fps sprite
#include "FpsSprite.h"

//#include <ThreadingUpdateTimeline.h>

#include "SetDlgPos.h"
#include "ColDlg.h"

//#include <uxtheme.h>
//#pragma ( lib, "UxTheme.lib" )


#include <Windows.h>


//gdiの中でbyteというstd::byteと被る名前を使うのでusing namespace stdよりも前でinclude
#include <gdiplus.h>

#include "../../MiniEngine/MiniEngine.h"


//for MessageLoop
//#include "system/system.h"

#include "../AdditiveIKLib/Grimoire/RenderingEngine.h"
#include "../AdditiveIKLib/Grimoire/ModelRender.h"
#include "../MiniEngine/Sprite.h"
#include "../MiniEngine/font/Font.h"
#include "../MiniEngine/TResourceBank.h"

#include "DXUTmisc/DXUTmisc.h"


using namespace std;




#define WINDOWS_CLASS_NAME TEXT("OchakkoLab.AdditiveIK.Window")

#define WM_USER_FOR_BATCH_PROGRESS	(WM_USER + 1)

#define MAXPLUGIN	255

//#define OPENHISTORYMAXNUM	10
//2022/08/01
#define OPENHISTORYMAXNUM	20

//2022/12/05
#define ANGLEDLGEDITLEN	256


enum {
	SPRIG_INACTIVE,
	SPRIG_ACTIVE,
	SPRIGMAX
};
//#define SPRIGMAX	2

enum {//２段目プレートメニュー行の種類
	//SPPLATEMENUKIND_GUI,//<--１段目は常時表示することにしたので状態遷移の種類からは外す
	SPPLATEMENUKIND_DISP,//2023/08/07
	SPPLATEMENUKIND_RIGID,
	SPPLATEMENUKIND_RETARGET,
	SPPLATEMENUKINDNUM
};
enum {//１段目のプレート種類
	SPGUISW_CAMERA_AND_IK,
	SPGUISW_DISP_AND_LIMITS,
	SPGUISW_BRUSHPARAMS,
	SPGUISW_BULLETPHYSICS,
	SPGUISW_PROJ_AND_LOD,
	SPGUISWNUM
};
//#define SPGUISWNUM	5

enum {//１段目のメニュープッシュで出る右ペインダイアログの種類
	//DLG_CAMERA_AND_IK,//<--ダイアログではなく画面上スプライト
	GUIDLG_DISP_AND_LIMITS,
	GUIDLG_BRUSHPARAMS,
	GUIDLG_BULLETPHYSICS,
	GUIDLG_PROJ_AND_LOD,
	GUIDLGNUM
};



//２段目メニューのSPGUISW_DISP_AND_LIMITS行のプレート
enum {//2023/08/07
	SPDISPSW_LIGHTS,
	SPDISPSW_DISPGROUP,
	SPDISPSW_LATERTRANSPARENT,
	SPDISPSW_SHADERTYPE,//2023/12/08
	SPDISPSW_SHADOWPARAMS,//2023/12/14
	SPDISPSWNUM
};
//#define SPDISPSWNUM	5

//２段目メニューのSPPLATEMENUKIND_RIGID行のプレート
enum {
	SPRIGIDSW_RIGIDPARAMS,
	SPRIGIDSW_IMPULSE,
	SPRIGIDSW_GROUNDPLANE,
	SPRIGIDSW_DAMPANIM,
	SPRIGIDSWNUM
};
//#define SPRIGIDSWNUM	4

//２段目メニューのSPPLATEMENUKIND_RETARGET行のプレート
enum {
	SPRETARGETSW_RETARGET,
	SPRETARGETSW_LIMITEULER,
	SPRETARGETSWNUM
};
//#define SPRETARGETSWNUM	2

enum {
	SPAIMBAR_1,
	SPAIMBAR_2,
	SPAIMBAR_3,
	SPAIMBAR_4,
	SPAIMBAR_5,
	SPAIMBARNUM
};
//#define SPAIMBARNUM	5

enum {
	SPMENU_FILE,
	SPMENU_DISP,
	SPMENU_MOTION,
	SPMENU_MODEL,
	SPMENU_EDIT,
	SPMENU_SELRIGID,
	SPMENU_SELRGD,
	SPMENU_SELRGDMORPH,
	SPMENU_SELIMPULSE,
	SPMENU_HELP,
	SPMENU_MAX
};



//typedef struct tag_spaxis
//{
//	Sprite sprite;
//	POINT dispcenter;
//	tag_spaxis() : sprite() {
//		::ZeroMemory(&dispcenter, sizeof(POINT));
//	};
//}SPAXIS, SPCAM;

class CSpAxis
{
public:
	CSpAxis() : sprite() {
		::ZeroMemory(&dispcenter, sizeof(POINT));
	};
	~CSpAxis()
	{

	};

public:
	Sprite sprite;
	POINT dispcenter;
};

class CSpCam
{
public:
	CSpCam() : sprite() {
		::ZeroMemory(&dispcenter, sizeof(POINT));
	};
	~CSpCam()
	{

	};

public:
	Sprite sprite;
	POINT dispcenter;
};

class CSpElem
{
public:
	CSpElem() : sprite() {
		::ZeroMemory(&dispcenter, sizeof(POINT));
	};
	~CSpElem()
	{

	};
public:
	Sprite sprite;
	POINT dispcenter;
};

//typedef struct tag_spsw
//{
//	bool state;//ON : 1 or OFF : 0
//	Sprite spriteON;
//	Sprite spriteOFF;
//	POINT dispcenter;
//	tag_spsw() : spriteON(), spriteOFF() {
//		state = 0;
//		::ZeroMemory(&dispcenter, sizeof(POINT));
//	};
//}SPGUISW;
class CSpGUISW
{
public:
	CSpGUISW() : spriteON(),  spriteOFF() {
		state = 0;
		::ZeroMemory(&dispcenter, sizeof(POINT));
	};
	~CSpGUISW() {};

public:
	bool state;//ON : 1 or OFF : 0
	Sprite spriteON;
	Sprite spriteOFF;
	POINT dispcenter;
};

class CSpGUISW3
{
public:
	CSpGUISW3() : sprite1(), sprite2(), sprite3() 
	{
		mode = 0;
		::ZeroMemory(&dispcenter, sizeof(POINT));
	};
	~CSpGUISW3() {};

public:
	int mode;
	Sprite sprite1;
	Sprite sprite2;
	Sprite sprite3;
	POINT dispcenter;
}SPGUISW3;

//#define FPSSAVENUM 100
#define FPSSAVENUM 120


//global
//2023/12/01 mqofileのmaterialno読込対応時に　マテリアルが被らないようにモデル単位に変更
//TResourceBank<CMQOMaterial> g_materialbank;

IShaderResource* g_shadowmapforshader = nullptr;



//staic
static HWINEVENTHOOK s_hhook = NULL;


static CColDlg s_coldlg;

static double s_fTime = 0.0;
static float s_fElapsedTime = 0.0;
static double s_befftime = 0.0;
static double s_mousemoveBefTime = 0.0;
static double s_fps100[FPSSAVENUM];
static int s_fps100index = 0;
static double s_avrgfps = 0.0;

static double s_rectime = 0.0;
static double s_reccnt = 0;

static int s_appcnt = 0;
static int s_launchbyc4 = 0;
static int s_launchc4diffx = 0;
static int s_launchc4diffy = 0;
//static int s_onefps = 0;


static vector<wstring> s_bvh2fbxout;
static LONG s_bvh2fbxnum = 0;
static LONG s_bvh2fbxcnt = 0;
static LONG s_befbvh2fbxnum = 0;
static LONG s_befbvh2fbxcnt = 0;
LONG g_bvh2fbxbatchflag = 0;
HWND s_bvh2fbxbatchwnd = 0;
HANDLE s_bvh2fbxhandle1;
HANDLE s_bvh2fbxhandle2;

static LONG s_progressnum = 0;
static LONG s_progresscnt = 0;
static LONG s_progressmodelnum = 0;
static LONG s_progressmodelcnt = 0;
static LONG s_befprogressnum = 0;
static LONG s_befprogresscnt = 0;
static LONG s_befprogressmodelnum = 0;
static LONG s_befprogressmodelcnt = 0;

HWND s_progresswnd;


static bool s_smoothBefRetarget = false;
static vector<wstring> s_retargetout;
static LONG s_retargetnum = 0;
static LONG s_retargetcnt = 0;
static LONG s_befretargetnum = 0;
static LONG s_befretargetcnt = 0;
int s_saveretargetmodel = 0;
LONG g_retargetbatchflag;
HWND s_retargetbatchwnd;
HANDLE s_retargethandle1;
HANDLE s_retargethandle2;
//static void WaitRetargetThreads();
static int s_convbone_model_batch_selindex;


LONG g_calclimitedwmflag;


static Gdiplus::GdiplusStartupInput gdiplusStartupInput;
static ULONG_PTR gdiplusToken;
Gdiplus::Image* g_mousehereimage = 0;
Gdiplus::Image* g_menuaimbarimage = 0;
int g_currentsubmenuid = 0;
POINT g_currentsubmenupos = { 0, 0 };
int g_submenuwidth = 32;
HWND g_filterdlghwnd = 0;

CRITICAL_SECTION g_CritSection_GetGP;
CRITICAL_SECTION g_CritSection_FbxSdk;


static int s_onselectplugin = 0;
static CPluginElem* s_plugin = 0;



enum {
	MB3D_WND_MAIN,
	MB3D_WND_3D,
	MB3D_WND_TREE,
	MB3D_WND_TOOL,
	MB3D_WND_TIMELINE,
	MB3D_WND_SIDE,
	MB3D_WND_MAX
};

enum {
	eLIM2BONE_LIM2BONE_ONE,
	eLIM2BONE_LIM2BONE_DEEPER,
	eLIM2BONE_LIM2BONE_ALL,
	eLIM2BONE_BONE2LIM,
	eLIM2BONE_NONE,
	eLIM2BONE_MAX
};

static int s_savebonemarkflag = 1;
static int s_saverigidmarkflag = 1;

static WCHAR s_temppath[MAX_PATH] = { 0L };


//static CDSUpdateUnderTracking* s_dsupdater = 0;
LONG g_undertrackingRMenu = 0;
LONG g_underApealingMouseHere = 0;

extern HANDLE g_hUnderTrackingThread;
//extern DSManager manager;

bool g_enableDS = false;
static void InitDSValues();
static void GetDSValues();
static void DSColorAndVibration();
static void DSSelectWindowAndCtrl();//L1, square, triangle
static void DSSelectCharactor();//(L2 or R2) and L1
static void DSCrossButton(bool firstctrlselect);
static void DSCrossButtonSelectTree(bool firstctrlselect);
static void DSCrossButtonSelectUTGUI(bool firstctrlselect);
static void DSCrossButtonSelectToolCtrls(bool firstctrlselect);
static void DSCrossButtonSelectPlayerBtns(bool firstctrlselect);
static void DSCrossButtonSelectRigidCtrls(bool firstctrlselect);
static void DSCrossButtonSelectImpulseCtrls(bool firstctrlselect);
static void DSCrossButtonSelectGPCtrls(bool firstctrlselect);
static void DSCrossButtonSelectDampCtrls(bool firstctrlselect);
static void DSCrossButtonSelectRetargetCtrls(bool firstctrlselect);
static void DSCrossButtonSelectEulLimitCtrls(bool firstctrlselect);
static void DSOptionButtonRightClick();
static void DSR1ButtonSelectCurrentBone();//R1
static void DSR1ButtonSelectMotion();//(L2 or R2) and R1
static void DSAxisLMouseMove();
//static void DSAxisLSelectingPopupMenu();
static void DSAxisRMainMenuBar();
static void DSAimBarOK();
static void DSOButtonSelectedPopupMenu();
static void DSXButtonCancel();
static void DSL3R3ButtonMouseHere();


static void SelectNextWindow(int nextwndid);

static void SetMainWindowTitle();

static RECT s_rcmainwnd;
static RECT s_rc3dwnd;
static RECT s_rctreewnd;
static RECT s_rctoolwnd;
static RECT s_rcltwnd;
static RECT s_rcsidemenuwnd;
static RECT s_rcrigidwnd;
static RECT s_rcshadertypewnd;
static RECT s_rcinfownd;
static RECT s_rcmainmenuaimbarwnd;
static RECT s_rcmodelpanel;
static RECT s_rcmotionpanel;
static RECT s_rccamerapanel;

static void ChangeMouseSetCapture();
static void ChangeMouseReleaseCapture();


#define MB3D_DSBUTTONNUM	14
#define MB3D_DSAXISNUM		6
#define MB3D_DSAXISSRH		(0.70f)
static int s_curaimbarno = -1;
static int s_dsdeviceid = -1;
static int s_currentwndid = 0;
static HWND s_currenthwnd = 0;
static int s_restorewndid = 0;
static HWND s_restorehwnd = 0;
static POINT s_restorecursorpos;
static int s_currentctrlid = -1;
static HWND s_currentctrlhwnd = 0;
//#define SUBMENUNUM	10
//static int g_currentsubmenuid = 0;//globalへ
static int s_currentsubmenuitemid = 0;
static HWND s_ofhwnd = 0;
static HWND s_messageboxhwnd = 0;
static int s_messageboxpushcnt = 0;
static HWND s_getfilenamehwnd = 0;
static HWND s_getfilenametreeview = 0;

static int s_getsym_retmode = 0;


static int s_wmlbuttonup = 0;//ゲームパッド用フラグ
static bool s_utBrushRepeatsFlag = false;//UTDialogのBrushRepeatsスライダー値変更
static bool s_utApplyRateFlag = false;//UTDialogのApplyRateスライダー値変更
static bool s_BrushMirrorUCheckBoxFlag = false;//UTDialogの
static bool s_BrushMirrorVCheckBoxFlag = false;//UTDialogの
static bool s_IfMirrorVDiv2CheckBoxFlag = false;//UTDialogの
static bool s_LimitDegCheckBoxFlag = false;//UTDialogの
static bool s_WallScrapingCheckBoxFlag = false;//UTDialogの

typedef struct tag_enumdist
{
	HWND hwnd;
	float dist;
	void Init() {
		hwnd = 0;
		dist = 0.0f;
	};
}ENUMDIST;
static std::vector<ENUMDIST> s_enumdist;

static int s_curdsutguikind = 0;
static int s_curdsutguino = 0;
//static std::vector<CDXUTControl*> s_dsutgui0;
//static std::vector<CDXUTControl*> s_dsutgui1;
//static std::vector<CDXUTControl*> s_dsutgui2;
//static std::vector<CDXUTControl*> s_dsutgui3;
//static std::vector<UINT> s_dsutguiid0;
//static std::vector<UINT> s_dsutguiid1;
//static std::vector<UINT> s_dsutguiid2;
//static std::vector<UINT> s_dsutguiid3;

static int s_curdstoolctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dstoolctrls;

static int s_curdsplayerbtnno = 0;

static int s_curdsrigidctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsrigidctrls;

static int s_curdsimpulsectrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsimpulsectrls;

static int s_curdsgpctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsgpctrls;

static int s_curdsdampctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsdampctrls;

static int s_curdsretargetctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsretargetctrls;

static int s_curdseullimitctrlno = 0;
static std::vector<UINT> s_dseullimitctrls;


static int s_dsbuttondown[MB3D_DSBUTTONNUM];
static int s_bef_dsbuttondown[MB3D_DSBUTTONNUM];
static int s_dsbuttonup[MB3D_DSBUTTONNUM];
static int s_bef_dsbuttonup[MB3D_DSBUTTONNUM];
static float s_dsaxisvalue[MB3D_DSAXISNUM];
static float s_bef_dsaxisvalue[MB3D_DSAXISNUM];
static int s_dsaxisOverSrh[MB3D_DSAXISNUM];
static int s_bef_dsaxisOverSrh[MB3D_DSAXISNUM];
static int s_dsaxisMOverSrh[MB3D_DSAXISNUM];
static int s_bef_dsaxisMOverSrh[MB3D_DSAXISNUM];
static int s_dspushedOK = 0;
static int s_dspushedL3 = 0;
static int s_dspushedR3 = 0;
//static int s_dsmousewait = 0;

static HWND s_mqodlghwnd = 0;
static bool s_underframecopydlg = false;
static CColiIDDlg* s_pcolidlg = 0;
static bool s_undercolidlg = false;
static CGColiIDDlg* s_pgcolidlg = 0;
static bool s_undergcolidlg = false;
static HWND s_motpropdlghwnd = 0;
//static HWND s_cameradollydlgwnd = 0;
static HWND s_materialratedlgwnd = 0;
static HWND s_modelworldmatdlgwnd = 0;
static HWND s_shadertypeparamsdlgwnd = 0;
static HWND s_savechadlghwnd = 0;
static HWND s_bvhdlghwnd = 0;
static HWND s_saveredlghwnd = 0;
static HWND s_saveimpdlghwnd = 0;
static HWND s_savegcodlghwnd = 0;
static HWND s_rotzisdlghwnd = 0;
static HWND s_customrighwnd = 0;
static HWND s_exportxdlghwnd = 0;


static int s_opedelmodelcnt = -1;
static int s_opedelmotioncnt = -1;
static bool s_underdelmodel = false;
static bool s_underdelmotion = false;
static bool s_underselectmodel = false;
static bool s_underselectcamera = false;
static bool s_underselectmotion = false;
static bool s_underdispmodel = false;
static bool s_underfilteringbymenu = false;
static int s_opeselectmodelcnt = -1;
static int s_opeselectcameracnt = -1;
static int s_opeselectmotioncnt = -1;
static int s_opedispmodelcnt = -1;


static int s_underanglelimithscroll = 0;


static bool s_nowloading = true;
static void OnRenderNowLoading();

extern map<CModel*, int> g_bonecntmap;
extern int gNumIslands;
extern void InitCustomRig(CUSTOMRIG* dstcr, CBone* parentbone, int rigno);
extern int IsValidCustomRig(CModel* srcmodel, CUSTOMRIG srccr, CBone* parentbone);
//void SetCustomRigBone(CUSTOMRIG* dstcr, CBone* childbone);
extern int IsValidRigElem(CModel* srcmodel, RIGELEM srcrigelem);

extern int DXUTSetOverrideSize(int srcw, int srch);

extern void OrgWinGUI::InitEulKeys();
extern void OrgWinGUI::DestroyEulKeys();
extern void OrgWinGUI::InitKeys();
extern void OrgWinGUI::DestroyKeys();

extern HANDLE g_hEvent; //手動リセットイベント



static CRITICAL_SECTION s_CritSection_LTimeline;


//ChaMatrix s_selectmat;//for display manipulator
//ChaMatrix s_ikselectmat;//for ik, fk
static ChaMatrix s_selectmat;//for display manipulator
static ChaMatrix s_selectmat_posture;//for display manipulator
static ChaMatrix s_ikselectmat;//for ik, fk
static int s_selectuserscale = 100;



static int s_onragdollik = 0;
static int s_physicskind = 0;
static int s_platemenukind = 0;
static int s_platemenuno = 1;

static bool s_guiswflag = true;//true : １段目メニュー内容を右ペインに. false : ２段目メニュー内容を右ペインに
static int s_guiswplateno = 1;


static CMQOMaterial* s_matred = 0;// = s_select->GetMQOMaterialByName("matred");
static CMQOMaterial* s_ringred = 0;// = s_select->GetMQOMaterialByName("ringred");
static CMQOMaterial* s_matblue = 0;// = s_select->GetMQOMaterialByName("matblue");
static CMQOMaterial* s_ringblue = 0;// = s_select->GetMQOMaterialByName("ringblue");
static CMQOMaterial* s_matgreen = 0;// = s_select->GetMQOMaterialByName("matgreen");
static CMQOMaterial* s_ringgreen = 0;// = s_select->GetMQOMaterialByName("ringgreen");
static CMQOMaterial* s_matyellow = 0;// = s_select->GetMQOMaterialByName("matyellow");
static CMQOObject* s_selectobj_objx = 0;
static CMQOObject* s_selectobj_objy = 0;
static CMQOObject* s_selectobj_objz = 0;
static CMQOObject* s_selectobj_ringx = 0;
static CMQOObject* s_selectobj_ringy = 0;
static CMQOObject* s_selectobj_ringz = 0;
static CMQOObject* s_selectobj_center = 0;
static ChaVector4 s_matredmat;
static ChaVector4 s_ringredmat;
static ChaVector4 s_matbluemat;
static ChaVector4 s_ringbluemat;
static ChaVector4 s_matgreenmat;
static ChaVector4 s_ringgreenmat;
static ChaVector4 s_matyellowmat;
static ChaVector4 s_ringyellowmat;





static bool s_dispanglelimit = false;
static HWND s_anglelimitdlg = 0;
static ANGLELIMIT s_anglelimit;
static ANGLELIMIT s_anglelimitcopy;
static CBone* s_anglelimitbone = 0;
static bool s_beflimitdegflag = true;
static bool s_savelimitdegflag = true;


static HWND s_lightsforeditdlg = 0;
static HWND s_latertransparentdlg = 0;
static HWND s_shadowparamsdlg = 0;
static HWND s_guidlg[GUIDLGNUM];

static HWND s_rotaxisdlg = 0;
static int s_rotaxiskind = AXIS_X;
static float s_rotaxisdeg = 0.0f;
static float s_befdeltax = 0.0f;

static HWND s_customrigdlg = 0;
static CUSTOMRIG s_customrig;
static CUSTOMRIG s_ikcustomrig;
static CBone* s_customrigbone = 0;
static int s_customrigno = 0;
static int s_tooltipdispcount = 0;
static size_t s_tooltiplen = 0;
static map<int, int> s_customrigmenuindex;

static int s_forcenewaxis = 0;
static int s_doneinit = 0;
//static int s_underselectingframe = 0;//globalに変更
static double s_buttonselectstart = 0.0;
static double s_buttonselectend = 0.0;
static int s_buttonselecttothelast = 0;



static float s_selectscale = 1.0f;
//static int s_sethipstra = 0;
//static CFrameCopyDlg s_selbonedlg;
static map<CModel*, CFrameCopyDlg*> s_selbonedlgmap;

static bool s_allmodelbone = false;

static std::vector<HISTORYELEM> s_cptfilename;
static CCopyHistoryDlg s_copyhistorydlg;
static CDollyHistoryDlg s_dollyhistorydlg;

//float g_initcamdist = 10.0f;
//static float g_projnear = 0.01f;
//float g_initcamdist = 50.0f;
//static float g_projnear = 0.001f;
//static float g_projnear = 1.0f;
//static ChaVector3 g_cameraupdir = ChaVector3(0.0f, 1.0f, 0.0f);
static double s_cameraframe = 0.0;
//static float g_camdist = g_initcamdist;
//static float g_projnear = 0.01f;
//static float g_projfar = g_initcamdist * 100.0f;
static float s_fAspectRatio = 1.0f;
//static float g_fovy = (float)(PI / 4.0);
static float s_cammvstep = 100.0f;
static int s_editmotionflag = -1;
static int s_tkeyflag = 0;

static WCHAR s_strcurrent[256] = L"Move To Current Frame";
static WCHAR s_streditrange[256] = L"Drag Edit Range";
static WCHAR s_strmark[256] = L"LongTimeLine";



//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), powf( 10.0f, 3.2f ) };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), 1e8 };
//float g_a_kval[3] = { powf( 10.0f, 0.0f ), powf( 10.0f, 0.3f ), 1e8 };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), 1000.0f };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), powf( 10.0f, 3.27f ) };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), powf( 10.0f, 3.3f ) };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), 1000.0f };


bool g_controlkey = false;
bool g_shiftkey = false;
bool g_ctrlshiftkeyformb = false;//ForMiddleButton
static bool s_skey = false;
static int s_akeycnt = 0;
static int s_dkeycnt = 0;
static int s_1keycnt = 0;

static bool s_dispsampleui = true;
static HWND s_sampleuihwnd = 0;

//double g_erp = 1.0;
double g_erp = 0.8;
//static float g_erp = 0.99f;
//static float g_erp = 0.75f;
//static double g_erp = 0.5;
//static float g_erp = 0.2f;
//static float s_impup = 0.0f;


static int s_savepreviewFlag = 0;
static int s_savecameraanimmode = 0;
static int s_saveCameraInheritMode = 0;

double s_btstartframe = 0.0;
bool g_btsimurecflag = false;

static FbxManager* s_psdk = 0;
static BPWorld* s_bpWorld = 0;
static btDynamicsWorld* s_btWorld = 0;

using namespace OrgWinGUI;

static ChaMatrix s_inimat;
static double s_time = 0.0;
//static double s_difftime = 0.0;
static int s_ikkind = 0;

//PICKRANGEを大きくするとジョイントではなく疑似ボーンドラッグまで可能になるが、マニピュレータのリングのpickが難しくなる
#define PICKRANGE	16
static UIPICKINFO s_pickinfo;
static vector<TLELEM> s_tlarray;


//static int s_curmotmenuindex = -1;
//static int s_curreindex = -1;
//static int s_rgdindex = -1;
	//each character each param //2021/03/18 
static map<CModel*, int> s_motmenuindexmap;
static map<CModel*, int> s_cameramenuindexmap;
static map<CModel*, int> s_reindexmap;
static map<CModel*, int> s_rgdindexmap;


static HWND		s_3dwnd = 0;
static HMENU	s_mainmenu = 0;
static HMENU	s_animmenu = 0;
static HMENU	s_morphmenu = 0;
static HMENU	s_modelmenu = 0;
static HMENU	s_remenu = 0;
static HMENU	s_rgdmenu = 0;
static HMENU	s_impmenu = 0;
static int s_filterindex = 1;
static HMENU	s_cursubmenu = 0;


#define MAINMENUAIMBARH		32


static int s_totalwndwidth = (1216 + 450);
static int s_totalwndheight = 950;
static int s_2ndposy = 600;

static int s_mainwidth = 800;
static int s_mainheight = (520 - MAINMENUAIMBARH);
static int s_bufwidth = 800;
static int s_bufheight = (520 - MAINMENUAIMBARH);

static int s_timelinewidth = 400;
static int s_timelineheight = s_2ndposy - MAINMENUAIMBARH;

static int s_longtimelinewidth = 970;
static int s_longtimelineheight = s_totalwndheight - s_2ndposy - MAINMENUAIMBARH - 18;

static int s_toolwidth = 230;
static int s_toolheight = 290;

static int s_modelwindowwidth = 400;
static int s_modelwindowheight = 460;
static int s_motionwindowwidth = 400;
//static int s_motionwindowheight = 700;
static int s_motionwindowheight = 400;
static int s_camerawindowwidth = 400;
static int s_camerawindowheight = 300;

static int s_infowinwidth = s_mainwidth;
static int s_infowinheight = s_2ndposy - s_mainheight - MAINMENUAIMBARH;

static int s_sidemenuwidth = 450;
static int s_sidemenuheight = MAINMENUAIMBARH;

static int s_sidewidth = s_sidemenuwidth;
static int s_sideheight = s_totalwndheight - MAINMENUAIMBARH - s_sidemenuheight - 28;

static int s_guibarX0 = 120;

static ID3D12Device* s_pdev = 0;

static CModel* s_model = NULL;
static CModel* s_cameramodel = NULL;
static CModel* s_select = NULL;
static CModel* s_select_posture = NULL;
static CModel* s_bmark = NULL;
//static CModel* s_coldisp[ COL_MAX ];
static CModel* s_ground = NULL;
static CModel* s_gplane = NULL;


static int s_rigsphere_num;
static int s_rigringX_num;
static int s_rigringY_num;
static int s_rigringZ_num;
static CModel* s_rigopemark_sphere;//2024/01/11 use Instancing
static CModel* s_rigopemark_ringX;//2024/01/11 use Instancing
static CModel* s_rigopemark_ringY;//2024/01/11 use Instancing
static CModel* s_rigopemark_ringZ;//2024/01/11 use Instancing
//static CMQOMaterial* s_rigmaterial_sphere[RIGMULTINDEXMAX + 1];
//static CMQOMaterial* s_rigmaterial_ringX[RIGMULTINDEXMAX + 1];
//static CMQOMaterial* s_rigmaterial_ringY[RIGMULTINDEXMAX + 1];
//static CMQOMaterial* s_rigmaterial_ringZ[RIGMULTINDEXMAX + 1];
static ChaVector4 s_matrigmat;


//static CModel* s_dummytri = NULL;


static int s_fbxbunki = 1;

static ChaMatrix s_matWorld;//シーン(カメラ)のworldmat. modelのworldmatでは無い.
static ChaMatrix s_matProj;
static ChaMatrix s_matVP;
static ChaMatrix s_matView;
//static ChaVector3 s_camUpVec = ChaVector3(0.00001f, 1.0f, 0.0f);

static int s_curmotid = -1;
static int s_curboneno = -1;
static int s_saveboneno = -1;
static int s_curbaseno = -1;


//select joint using shortcutkey
static int s_selecthand = 0;
static int s_selectfoot = 0;



static int s_tiprigboneno = -1;
static int s_tiprigno = -1;

static int s_ikcnt = 0;
static ChaMatrix s_selm = ChaMatrix(0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f
);
static ChaMatrix s_selm_posture = ChaMatrix(0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f
);

static void OrgWindowListenMouse(bool srcflag);

static OrgWindow* s_timelineWnd = 0;
static OWP_Timeline* s_owpTimeline = 0;
static OWP_PlayerButton* s_owpPlayerButton = 0;
static OWP_CheckBoxA* s_parentcheck = 0;

static OrgWindow* s_LtimelineWnd = 0;
static OWP_Timeline* s_owpLTimeline = 0;
static OWP_EulerGraph* s_owpEulerGraph = 0;
static OWP_Separator* s_LTSeparator = 0;

static OrgWindow* s_dmpanimWnd = 0;
static OWP_CheckBoxA* s_dmpgroupcheck = 0;
static OWP_Label* s_dmpanimLlabel = 0;
static OWP_Slider* s_dmpanimLSlider = 0;
static OWP_Label* s_dmpanimAlabel = 0;
static OWP_Slider* s_dmpanimASlider = 0;
static OWP_Button* s_dmpanimB = 0;

static OrgWindow* s_sidemenuWnd = 0;
static OWP_Separator* s_sidemenusp = 0;
static OWP_Separator* s_sidemenusp1 = 0;
static OWP_Separator* s_sidemenusp2 = 0;
static OWP_Button* s_sidemenu_rigid = 0;
static OWP_Button* s_sidemenu_limiteul = 0;
static OWP_Button* s_sidemenu_copyhistory = 0;
static OWP_Button* s_sidemenu_retarget = 0;

static OrgWindow* s_mainmenuaimbarWnd = 0;
static OWP_Label* s_mainmenulabel = 0;


static OrgWindow* s_placefolderWnd = 0;
//static OWP_Label* s_placefolderlabel_1 = 0;
//static OWP_Label* s_placefolderlabel_2 = 0;
//static OWP_Label* s_placefolderlabel_3 = 0;
//#define SHORTCUTTEXTNUM	35
//#define SHORTCUTTEXTNUM	40
//#define SHORTCUTTEXTNUM	44
#define SHORTCUTTEXTNUM	48
static OWP_Label* s_shortcuttext[SHORTCUTTEXTNUM];


static OrgWindow* s_shadertypeWnd = 0;
static OWP_ScrollWnd* s_SCshadertype = 0;
static OWP_Separator* s_shadersp1 = 0;
static OWP_Separator* s_shadersp2 = 0;
static OWP_Separator* s_shadersp3 = 0;
static OWP_Label* s_modelnamelabel = 0;
static OWP_Button* s_materialnameB[MAXMATERIALNUM + 1];//+1は見出しの分
static OWP_Label* s_shadertypelabel[MAXMATERIALNUM + 1];//+1は見出しの分
static OWP_Label* s_metalcoeflabel[MAXMATERIALNUM + 1];//+1は見出しの分
static OWP_Label* s_lightscalelabel[MAXMATERIALNUM + 1];//+1は見出しの分
static bool s_shadertypeparamsFlag = false;
static int s_shadertypeparamsindex = -1;//index==0は全てのマテリアルに設定. それ以外はindex - 1のマテリアルに設定


static OrgWindow* s_rigidWnd = 0;
static OWP_CheckBoxA* s_groupcheck = 0;
static OWP_Slider* s_sphrateSlider = 0;
static OWP_Slider* s_boxzSlider = 0;
static OWP_Slider* s_massSlider = 0;
//static OWP_Separator* s_massSeparator = 0;
//static OWP_Separator* s_massSeparator1 = 0;
//static OWP_Separator* s_massSeparator2 = 0;
static OWP_Button* s_massB = 0;
static OWP_Button* s_thicknessB = 0;
static OWP_Button* s_depthB = 0;
static OWP_Label* s_massspacelabel = 0;
static OWP_CheckBoxA* s_rigidskip = 0;
static OWP_Button* s_skipB = 0;
static OWP_Separator* s_forbidSeparator = 0;
static OWP_Button* s_forbidB = 0;
static OWP_CheckBoxA* s_forbidrot = 0;
static OWP_Label* s_shplabel = 0;
static OWP_Label* s_boxzlabel = 0;
static OWP_Separator* s_colSeparator = 0;
static OWP_Button* s_colB = 0;
static OWP_RadioButton* s_colradio = 0;
static OWP_RadioButton* s_lkradio = 0;
static OWP_RadioButton* s_akradio = 0;
static OWP_Slider* s_ldmpSlider = 0;
static OWP_Slider* s_admpSlider = 0;
static OWP_Label* s_massSLlabel = 0;
static OWP_Label* s_namelabel = 0;
static OWP_Label* s_lenglabel = 0;
static OWP_Label* s_ldmplabel = 0;
static OWP_Label* s_admplabel = 0;
static OWP_Button* s_kB = 0;
static OWP_Button* s_restB = 0;
static OWP_Button* s_dmpB = 0;
static OWP_Button* s_groupB = 0;
static OWP_Button* s_gcoliB = 0;
static OWP_Separator* s_validSeparator = 0;
static OWP_Button* s_allrigidenableB = 0;
static OWP_Button* s_allrigiddisableB = 0;


static OWP_Slider* s_lkSlider = 0;
static OWP_Label* s_lklabel = 0;
static OWP_Slider* s_akSlider = 0;
static OWP_Label* s_aklabel = 0;

static OWP_Slider* s_restSlider = 0;
static OWP_Label* s_restlabel = 0;
static OWP_Slider* s_fricSlider = 0;
static OWP_Label* s_friclabel = 0;

static OWP_Slider* s_btgSlider = 0;
static OWP_Label* s_btglabel = 0;
static OWP_Slider* s_btgscSlider = 0;
static OWP_Label* s_btgsclabel = 0;
static OWP_Button* s_btgB = 0;
static OWP_Separator* s_btforceSeparator = 0;
static OWP_CheckBoxA* s_btforce = 0;
static OWP_Button* s_btforceB = 0;

static OrgWindow* s_impWnd = 0;
static OWP_CheckBoxA* s_impgroupcheck = 0;
static OWP_Slider* s_impxSlider = 0;
static OWP_Slider* s_impySlider = 0;
static OWP_Slider* s_impzSlider = 0;
static OWP_Slider* s_impscaleSlider = 0;
static OWP_Label* s_impxlabel = 0;
static OWP_Label* s_impylabel = 0;
static OWP_Label* s_impzlabel = 0;
static OWP_Label* s_impscalelabel = 0;
static OWP_Button* s_impallB = 0;


static OrgWindow* s_gpWnd = 0;
static OWP_Slider* s_ghSlider = 0;
static OWP_Slider* s_gsizexSlider = 0;
static OWP_Slider* s_gsizezSlider = 0;
static OWP_Label* s_ghlabel = 0;
static OWP_Label* s_gsizexlabel = 0;
static OWP_Label* s_gsizezlabel = 0;
static OWP_CheckBoxA* s_gpdisp = 0;
static OWP_Slider* s_grestSlider = 0;
static OWP_Label* s_grestlabel = 0;
static OWP_Slider* s_gfricSlider = 0;
static OWP_Label* s_gfriclabel = 0;

static OrgWindow* s_toolWnd = 0;
static OWP_Separator* s_toolSeparator = 0;
static OWP_Button* s_toolCopyB = 0;
static OWP_Button* s_toolZeroFrameB = 0;
static OWP_Button* s_toolSymCopyB = 0;
static OWP_Button* s_toolCutB = 0;
static OWP_Button* s_toolPasteB = 0;
static OWP_Button* s_toolDeleteB = 0;
static OWP_Button* s_toolMotPropB = 0;
static OWP_Button* s_toolMarkB = 0;
static OWP_Button* s_toolSelBoneB = 0;
static OWP_Button* s_toolInitMPB = 0;
static OWP_Button* s_toolInterpolateB = 0;
static OWP_Button* s_toolFilterB = 0;
static OWP_Button* s_toolSelectCopyFileName = 0;
static OWP_Button* s_toolSkipRenderBoneMarkB = 0;
static OWP_Button* s_toolSkipRenderBoneMarkB2 = 0;
static OWP_Button* s_tool180deg = 0;
static OWP_Button* s_toolScaleInitAllB = 0;
static OWP_Button* s_toolCameraDollyB = 0;
static OWP_Button* s_toolMaterialRateB = 0;
static OWP_Button* s_toolModelWorldMatB = 0;


//#define CONVBONEMAX		256

//2023/07/08 TheHunt のアセット読み込み時にボーン数制限オーバーしたので　値を大きく
//#define CONVBONEMAX		1024//MAXBONENUM 2048;を使う

static OrgWindow* s_convboneWnd = 0;
static OWP_ScrollWnd* s_convboneSCWnd = 0;
static int s_convbonenum = 0;
static OWP_Label* s_cbselmodel = 0;
static OWP_Button* s_cbselbvh = 0;
static OWP_Label* s_convbonemidashi[2];
static OWP_Label* s_modelbone[MAXBONENUM];
static OWP_Button* s_bvhbone[MAXBONENUM];
static OWP_Separator* s_convbonesp = 0;
static OWP_Button* s_convboneconvert = 0;
static OWP_Label* s_convbonespace1 = 0;
static OWP_Label* s_convbonespace2 = 0;
static OWP_Label* s_convbonespace3 = 0;
static OWP_Label* s_convbonespace4 = 0;
static OWP_Label* s_convbonespace5 = 0;
static CModel* s_convbone_model = 0;
static CModel* s_convbone_model_batch = 0;
static CModel* s_convbone_bvh = 0;
static int s_maxboneno = 0;
static CBone* s_modelbone_bone[MAXBONENUM];
static CBone* s_bvhbone_bone[MAXBONENUM];
static map<CBone*, CBone*> s_convbonemap;
static int s_bvhbone_cbno = 0;
static OWP_Button* s_rtgfilesave = 0;
static OWP_Button* s_rtgfileload = 0;


static OrgWindow* s_layerWnd = 0;
static OWP_LayerTable* s_owpLayerTable = 0;

//#define MAXDISPOBJNUM	4098 //vector<>に変更したため不要に
//#define MAXDISPGROUPNUM	20 //coef.hに移動
static OrgWindow* s_groupWnd = 0;
static OWP_ScrollWnd* s_groupSCWnd = 0;
static OWP_Separator* s_groupsp0 = 0;
static OWP_Separator* s_groupsp = 0;
static OWP_Separator* s_groupsp1 = 0;
static OWP_Separator* s_groupsp2 = 0;
static OWP_Separator* s_groupsp3 = 0;
static OWP_CheckBoxA* s_groupselect[MAXDISPGROUPNUM];
static OWP_Button* s_groupsetB = 0;
static OWP_Button* s_groupgetB = 0;
static OWP_Button* s_grouponB = 0;
static OWP_Button* s_groupoffB = 0;
static OWP_Label* s_grouplabel11 = 0;
static OWP_Label* s_grouplabel12 = 0;
static OWP_Label* s_grouplabel21 = 0;
static OWP_Label* s_grouplabel22 = 0;
static bool s_groupUnderGetting = false;//s_groupgetBボタンの処理中は　groupobjvecのチェック処理をスキップ
//static OWP_CheckBoxA* s_groupobj[MAXDISPOBJNUM];
//static OWP_Button* s_grouptestB[MAXDISPOBJNUM];
static std::vector<OWP_CheckBoxA*> s_groupobjvec;
static std::vector<OWP_Button*> s_grouptestBvec;
static int s_grouplinenum = 0;
static bool s_disponlyoneobj = false;//for test button of groupWnd
static int s_onlyoneobjno = -1;//for test button of groupWnd




static bool s_closeFlag = false;			// 終了フラグ
static bool s_closetoolFlag = false;
static bool s_closeobjFlag = false;
static bool s_closemodelFlag = false;
static bool s_closecameraFlag = false;
static bool s_closemotionFlag = false;
static bool s_closeconvboneFlag = false;
static bool s_DcloseFlag = false;
static bool s_RcloseFlag = false;
static bool s_ScloseFlag = false;
static bool s_IcloseFlag = false;
static bool s_GcloseFlag = false;
static bool s_undoFlag = false;
static bool s_redoFlag = false;
static bool s_undoredoFromPlayerButton = false;
static bool s_frogFlag = false;
static bool s_plateFlag = false;
static bool s_copyFlag = false;			// コピーフラグ
static bool s_copyLW2WFlag = false;			//Limited2World ベイクフラグ
static bool s_changelimitangleFlag = false;
static bool s_zeroFrameFlag = false;
//static bool s_oneFrameFlag = false;
static bool s_selCopyHisotryFlag = false;
static bool s_symcopyFlag = false;
static bool s_symcopyFlag2 = false;
static bool s_undersymcopyFlag = false;
static bool s_cutFlag = false;			// カットフラグ
static bool s_pasteFlag = false;			// ペーストフラグ
static bool s_cursorFlag = false;			// カーソル移動フラグ
static bool s_selectFlag = false;			// キー選択フラグ
static bool s_keyShiftFlag = false;		// キー移動フラグ
static bool s_deleteFlag = false;		// キー削除フラグ
static bool s_motpropFlag = false;
static bool s_markFlag = false;
static bool s_selboneFlag = false;
static bool s_selboneAndPasteFlag = false;
static bool s_RboneAndPasteFlag = false;
static bool s_initmpFlag = false;
static bool s_filterFlag = false;
static int  s_filterState = 0;
static bool s_smoothFlag = false;//s_spsmoothボタン用
static bool s_constexeFlag = false;//s_spconstexeボタン用
static bool s_constrefreshFlag = false;//s_spconstrefreshボタン用
//static bool s_filternodlg = false;
static bool s_delmodelFlag = false;
static bool s_delallmodelFlag = false;
static bool s_changeupdatethreadsFlag = false;
static bool s_newmotFlag = false;
static bool s_delcurmotFlag = false;
static bool s_interpolateFlag = false;
static int s_interpolateState = 0;
static int s_skipJointMark = 0;
static bool s_180DegFlag = false;
static bool s_scaleAllInitFlag = false;
static bool s_cameradollyFlag = false;
static bool s_materialrateFlag = false;
static bool s_modelworldmatFlag = false;

static bool s_firstkeyFlag = false;
static bool s_lastkeyFlag = false;
static bool s_btresetFlag = false;

static bool s_LcloseFlag = false;
static bool s_LnextkeyFlag = false;
static bool s_LbefkeyFlag = false;
static bool s_LcursorFlag = false;			// カーソル移動フラグ
static bool s_LupFlag = false;
static bool s_LstartFlag = false;
static bool s_LstopFlag = false;
//static int s_LstopDoneCount = 0;
static bool s_retargetguiFlag = false;

static int s_checksimilarFlag = false;
static int s_checksimilarobjno = 0;

static int s_calclimitedwmState = 0;

static bool s_EcursorFlag = false;			// カーソル移動フラグ


static bool s_timelineRUpFlag = false;
static bool s_timelinembuttonFlag = false;
static int s_mbuttoncnt = 1;
static double s_mbuttonstart = 0.0;
static bool s_timelinewheelFlag = false;
static bool s_timelineshowposFlag = false;

static bool s_prevrangeFlag = false;
static bool s_nextrangeFlag = false;

static bool s_dispmw = true;
static bool s_disptool = true;
//static bool s_dispobj = true;
static bool s_dispobj = false;
static bool s_dispmodel = false;//!!!!!!!!!!!!!!!!!
static bool s_dispmotion = false;//!!!!!!!!!!!!!!!!!
static bool s_dispcamera = false;//!!!!!!!!!!!!!!!!!
static bool s_dispground = true;
static bool s_dispselect = true;
//static bool s_displightarrow = true;
static bool s_dispconvbone = false;

static bool s_Ldispmw = true;

static double s_keyShiftTime = 0.0;			// キー移動量
static list<KeyInfo> s_copyKeyInfoList;	// コピーされたキー情報リスト

//static multimap<CBone*, CMotionPoint> s_copymotmap;
typedef struct tag_cpelem
{
	CBone* bone;
	CMotionPoint mp;
	//ChaVector3 localscale;//mpのmatに掛け算しておく
	tag_cpelem() {
		bone = 0;
		mp.InitParams();
	};
}CPELEM2;
static vector<CPELEM2> s_copymotvec;
static vector<CPELEM2> s_pastemotvec;
static int WriteCPTFile(WCHAR* dstfilename);
static int WriteCPIFile(WCHAR* cptfilename);
static bool LoadCPTFile();
static int LoadCPIFile(HISTORYELEM* srcdstelem);

static vector<CBone*> s_pasteRJoint;
static int SetRJoint(int srcboneno);
static void AddRJointReq(CBone* srcbone);

//static int WriteTBOFile();
//static bool LoadTBOFile();


static list<KeyInfo> s_deletedKeyInfoList;	// 削除されたキー情報リスト
static list<KeyInfo> s_selectKeyInfoList;	// コピーされたキー情報リスト

static CEditRange s_editrange;
static CEditRange* s_editrangehistory = 0;
static int s_editrangehistoryno = 0;
static int s_editrangesetindex = 0;
static CEditRange s_previewrange;



//ID_RMENU_0を足して使う
#define MENUOFFSET_SETCONVBONEMODEL		(100)
#define MENUOFFSET_SETCONVBONEBVH		(MENUOFFSET_SETCONVBONEMODEL + 100)
#define MENUOFFSET_SETCONVBONE			(MENUOFFSET_SETCONVBONEBVH + 100)
//#define MENUOFFSET_SETCONVBONE			(MENUOFFSET_SETCONVBONEBVH + 500)
#define MENUOFFSET_INITMPFROMTOOL		(MENUOFFSET_SETCONVBONE + MAXBONENUM)

#define MENUOFFSET_GETSYMROOTMODE		(MENUOFFSET_INITMPFROMTOOL + 100)
#define MENUOFFSET_INTERPOLATEFROMTOOL		(MENUOFFSET_GETSYMROOTMODE + 30)
#define MENUOFFSET_FILTERFROMTOOL		(MENUOFFSET_INTERPOLATEFROMTOOL + 30)
#define MENUOFFSET_CHECKSIMILARGROUP		(MENUOFFSET_FILTERFROMTOOL + 30)



#define SPAXISNUM	3
//#define SPCAMNUM	3	//Coef.h : SPR_CAM_MAX





#define SPPLAYERBUTTONNUM	16

static Texture* s_spritetex0 = 0;
static Texture* s_spritetex1 = 0;
static Texture* s_spritetex2 = 0;
static Texture* s_spritetex3 = 0;
static Texture* s_spritetex4 = 0;
static Texture* s_spritetex5 = 0;
static Texture* s_spritetex6 = 0;
static Texture* s_spritetex7 = 0;
static Texture* s_spritetex8 = 0;
static Texture* s_spritetex9 = 0;
static Texture* s_spritetex10 = 0;
static Texture* s_spritetex11 = 0;
static Texture* s_spritetex12 = 0;
static Texture* s_spritetex13 = 0;
static Texture* s_spritetex14 = 0;
static Texture* s_spritetex15 = 0;
static Texture* s_spritetex16 = 0;
static Texture* s_spritetex17 = 0;
static Texture* s_spritetex18 = 0;
static Texture* s_spritetex19 = 0;
static Texture* s_spritetex20 = 0;
static Texture* s_spritetex21 = 0;
static Texture* s_spritetex22 = 0;
static Texture* s_spritetex23 = 0;
static Texture* s_spritetex24 = 0;
static Texture* s_spritetex25 = 0;
static Texture* s_spritetex26 = 0;
static Texture* s_spritetex27 = 0;
static Texture* s_spritetex28 = 0;
static Texture* s_spritetex29 = 0;
static Texture* s_spritetex30 = 0;
static Texture* s_spritetex31 = 0;
static Texture* s_spritetex32 = 0;
static Texture* s_spritetex33 = 0;
static Texture* s_spritetex34 = 0;
static Texture* s_spritetex35 = 0;
static Texture* s_spritetex36 = 0;
static Texture* s_spritetex37 = 0;
static Texture* s_spritetex37_1 = 0;
static Texture* s_spritetex38 = 0;
static Texture* s_spritetex39 = 0;
static Texture* s_spritetex40 = 0;
static Texture* s_spritetex40_1 = 0;
static Texture* s_spritetex41 = 0;
static Texture* s_spritetex42 = 0;
static Texture* s_spritetex43 = 0;
static Texture* s_spritetex44 = 0;
static Texture* s_spritetex45 = 0;
static Texture* s_spritetex46 = 0;
static Texture* s_spritetex47 = 0;
static Texture* s_spritetex48 = 0;
static Texture* s_spritetex49 = 0;
static Texture* s_spritetex50 = 0;
static Texture* s_spritetex51 = 0;
static Texture* s_spritetex52 = 0;
static Texture* s_spritetex53 = 0;
static Texture* s_spritetex54 = 0;
static Texture* s_spritetex55 = 0;
static Texture* s_spritetex56 = 0;
static Texture* s_spritetex57 = 0;
static Texture* s_spritetex58 = 0;
static Texture* s_spritetex59 = 0;
static Texture* s_spritetex60 = 0;
static Texture* s_spritetex61 = 0;
static Texture* s_spritetex62 = 0;
static Texture* s_spritetex63 = 0;
static Texture* s_spritetex64 = 0;
static Texture* s_spritetex65 = 0;
static Texture* s_spritetex66 = 0;
static Texture* s_spritetex67 = 0;
static Texture* s_spritetex68 = 0;
static Texture* s_spritetex69 = 0;
static Texture* s_spritetex70 = 0;
static Texture* s_spritetex71 = 0;
static Texture* s_spritetex72 = 0;
static Texture* s_spritetex73 = 0;
static Texture* s_spritetex74 = 0;
static Texture* s_spritetex75 = 0;
static Texture* s_spritetex76 = 0;
static Texture* s_spritetex77 = 0;
static Texture* s_spritetex78 = 0;
static Texture* s_spritetex79 = 0;
static Texture* s_spritetex80 = 0;
static Texture* s_spritetex81 = 0;



static int s_toolspritemode = 0;
static float s_spsize = 45.0f;//CheckResolution()でセットする
static float s_spsizeSmall = 26.0f;//CheckResolution()でセットする
static float s_sptopmargin = 35.0f;
static float s_spsidemargin = 35.0f;
static CSpElem s_spundo[2];
static CSpAxis s_spaxis[SPAXISNUM];
static CSpCam s_spcam[SPR_CAM_MAX];
static CSpElem s_sprig[SPRIGMAX];//inactive, active
//static CSpElem s_spbt;
static CSpElem s_spret2prev;
static CSpElem s_spret2prev2;
static CSpElem s_spcplw2w;
static CSpElem s_spsmooth;
static CSpElem s_spconstexe;
static CSpElem s_spconstrefresh;
static CSpElem s_spcopy;
static CSpElem s_spsymcopy;
static CSpElem s_sppaste;
static CSpElem s_spcopyhistory;
static CSpElem s_spinterpolate;
static CSpElem s_spinit;
static CSpElem s_spscaleinit;
static CSpElem s_spproperty;
static CSpElem s_spzeroframe;
static CSpElem s_spcameradolly;
static CSpElem s_spmodelposdir;
static CSpElem s_spmaterialrate;
static CSpGUISW s_spguisw[SPGUISWNUM];
static CSpGUISW s_spdispsw[SPDISPSWNUM];
static CSpGUISW s_sprigidsw[SPRIGIDSWNUM];
static CSpGUISW s_spretargetsw[SPRETARGETSWNUM];
static bool s_firstmoveaimbar = true;
//static CSpGUISW s_spaimbar[SPAIMBARNUM];
//static CSpGUISW s_spmenuaimbar[SPMENU_MAX];
static int s_oprigflag = 0;
static CSpGUISW s_spsel3d;
static CSpElem s_spmousehere;
static CSpGUISW s_spikmodesw[3];
static CSpGUISW s_splod;
static CSpGUISW s_splimiteul;
static CSpGUISW s_spscraping;
static CSpElem s_mousecenteron;
static CSpGUISW s_spcameramode;
static CSpGUISW3 s_spcamerainherit;
static InstancedSprite s_bcircle;
static Sprite s_kinsprite;
static CUndoSprite s_undosprite;
static CFpsSprite s_fpssprite;


typedef struct tag_modelpanel
{
	OrgWindow* panel;
	OWP_ScrollWnd* scroll;
	OWP_RadioButton* radiobutton;
	OWP_Separator* separator;
	OWP_Separator* separator2;
	vector<OWP_CheckBoxA*> checkvec;
	vector<OWP_Button*> delbutton;
	int modelindex;
	tag_modelpanel() {
		panel = 0;
		scroll = 0;
		radiobutton = 0;
		separator = 0;
		separator2 = 0;
		checkvec.clear();
		delbutton.clear();
		modelindex = 0;
	};
}MODELPANEL;
static MODELPANEL s_modelpanel;
static bool s_firstmodelpanelpos = true;
static WindowPos s_modelpanelpos;

typedef struct tag_motionpanel
{
	OrgWindow* panel;
	OWP_ScrollWnd* scroll;
	OWP_RadioButton* radiobutton;
	OWP_Separator* separator;
	vector<OWP_Button*> delbutton;
	int modelindex;

	tag_motionpanel() {
		panel = 0;
		scroll = 0;
		radiobutton = 0;
		separator = 0;
		delbutton.clear();
		modelindex = 0;
	};
}MOTIONPANEL;
static MOTIONPANEL s_motionpanel;
static bool s_firstmotionpanelpos = true;
static WindowPos s_motionpanelpos;

typedef struct tag_camerapanel
{
	OrgWindow* panel;
	OWP_ScrollWnd* scroll;
	OWP_RadioButton* radiobutton;
	OWP_Separator* separator;
	vector<OWP_Button*> delbutton;
	int modelindex;

	tag_camerapanel() {
		panel = 0;
		scroll = 0;
		radiobutton = 0;
		separator = 0;
		delbutton.clear();
		modelindex = 0;
	};
}CAMERAPANEL;
static CAMERAPANEL s_camerapanel;
static bool s_firstcamerapanelpos = true;
static WindowPos s_camerapanelpos;



static map<int, int> s_lineno2boneno;
static map<int, int> s_boneno2lineno;

static ChaScene* s_chascene = 0;
//static vector<MODELELEM> s_modelindex;
//static MODELBOUND	s_totalmb;
static int s_curmodelmenuindex = -1;
static int s_savemodelpanelshowposline = -1;
static int s_savemotionpanelshowposline = -1;
static int s_savecamerapanelshowposline = -1;

static WCHAR s_tmpmotname[256] = { 0L };
static double s_tmpmotframeleng = 100.0f;
//static double s_tmpmotframeleng = 5640.0f;
static int s_tmpmotloop = 1;

static WCHAR s_projectname[64] = { 0L };
static WCHAR s_projectdir[MAX_PATH] = { 0L };
static WCHAR s_chapath[MAX_PATH] = { 0 };
static WCHAR s_chasavename[64] = { 0 };
static WCHAR s_chasavedir[MAX_PATH] = { 0 };

static WCHAR s_REname[MAX_PATH] = { 0L };
static WCHAR s_Impname[MAX_PATH] = { 0L };
static WCHAR s_Gconame[MAX_PATH] = { 0L };

static bool s_cancelLButtonDown = false;
static bool s_cancelRButtonDown = false;


static int s_camtargetflag = 0;
static int s_camtargetOnceflag = 0;
static bool s_twistcameraFlag = false;
static bool s_rbuttonSelectFlag = false;
//CDXUTCheckBox* s_CamTargetCheckBox = 0;
////CDXUTCheckBox* s_LightCheckBox = 0;
//CDXUTCheckBox* s_ApplyEndCheckBox = 0;
////CDXUTCheckBox* s_SlerpOffCheckBox = 0;
////CDXUTCheckBox* s_AbsIKCheckBox = 0;
//CDXUTCheckBox* s_HighRpmCheckBox = 0;
//CDXUTCheckBox* s_BoneMarkCheckBox = 0;
//CDXUTCheckBox* s_LightingCheckBox = 0;
//CDXUTCheckBox* s_RigidMarkCheckBox = 0;
////CDXUTCheckBox* s_PseudoLocalCheckBox = 0;
////CDXUTCheckBox* s_WallScrapingIKCheckBox = 0;
////CDXUTCheckBox* s_LimitDegCheckBox = 0;
//CDXUTCheckBox* s_BrushMirrorUCheckBox = 0;
//CDXUTCheckBox* s_BrushMirrorVCheckBox = 0;
//CDXUTCheckBox* s_IfMirrorVDiv2CheckBox = 0;
////CDXUTCheckBox* s_VSyncCheckBox = 0;
//CDXUTCheckBox* s_TraRotCheckBox = 0;
//CDXUTCheckBox* s_PreciseCheckBox = 0;
//CDXUTCheckBox* s_X180CheckBox = 0;
//CDXUTCheckBox* s_TPoseCheckBox = 0;
////CDXUTCheckBox* s_EdgeSmpCheckBox = 0;
//
//
//CDXUTStatic* s_TipText1 = 0;
//CDXUTStatic* s_TipText2 = 0;
//CDXUTStatic* s_TipText3 = 0;
//CDXUTStatic* s_TipText4 = 0;
//CDXUTStatic* s_TipText5 = 0;

Font s_fontfortip;
bool s_dispfontfottip = false;
WCHAR s_strfortip[512] = { 0 };
Vector2 s_fontposfortip;

static bool s_utcontrolvisible = true;
////Left
//static CDXUTControl* s_ui_fpskind = 0;
//static CDXUTControl* s_ui_lightscale = 0;
//static CDXUTControl* s_ui_lighting = 0;
//static CDXUTControl* s_ui_dispbone = 0;
//static CDXUTControl* s_ui_disprigid = 0;
//static CDXUTControl* s_ui_boneaxis = 0;
//static CDXUTControl* s_ui_bone = 0;
//static CDXUTControl* s_ui_locktosel = 0;
//static CDXUTControl* s_ui_iklevel = 0;
//static CDXUTControl* s_ui_editmode = 0;
//static CDXUTControl* s_ui_texapplyrate = 0;
//static CDXUTControl* s_ui_slapplyrate = 0;
//static CDXUTControl* s_ui_motionbrush = 0;
//static CDXUTControl* s_ui_texikorder = 0;
//static CDXUTControl* s_ui_slikorder = 0;
////static CDXUTControl* s_ui_texikrate = 0;
////static CDXUTControl* s_ui_slikrate = 0;
//static CDXUTControl* s_ui_texref = 0;
//static CDXUTControl* s_ui_slirefpos = 0;
//static CDXUTControl* s_ui_slirefalpha = 0;
//static CDXUTControl* s_ui_applytotheend = 0;
//static CDXUTControl* s_ui_slerpoff = 0;
////static CDXUTControl* s_ui_absikon = 0;
//static CDXUTControl* s_ui_highrpmon = 0;
//
//static CDXUTControl* s_ui_texbrushrepeats = 0;
//static CDXUTControl* s_ui_brushrepeats = 0;
//static CDXUTControl* s_ui_brushmirroru = 0;
//static CDXUTControl* s_ui_brushmirrorv = 0;
//static CDXUTControl* s_ui_ifmirrorvdiv2 = 0;
//static CDXUTControl* s_ui_precise = 0;
//static CDXUTControl* s_ui_x180 = 0;
//static CDXUTControl* s_ui_tpose = 0;
//
////Left 2nd
//static CDXUTControl* s_ui_texthreadnum = 0;
//static CDXUTControl* s_ui_slthreadnum = 0;
//static CDXUTControl* s_ui_umthreads = 0;
//static CDXUTControl* s_ui_slumthreads = 0;
////static CDXUTControl* s_ui_pseudolocal = 0;
//static CDXUTControl* s_ui_wallscrapingik = 0;
//static CDXUTControl* s_ui_limiteul = 0;
//static CDXUTControl* s_ui_texspeed = 0;
//static CDXUTControl* s_ui_speed = 0;
////static CDXUTControl* s_ui_vsync = 0;
//static CDXUTControl* s_ui_trarot = 0;
////static CDXUTControl* s_ui_edgesmp = 0;
//
//
////Bullet
//static CDXUTControl* s_ui_btstart = 0;
//static CDXUTControl* s_ui_btrecstart = 0;
//static CDXUTControl* s_ui_stopbt = 0;
//static CDXUTControl* s_ui_texbtcalccnt = 0;
//static CDXUTControl* s_ui_btcalccnt = 0;
//static CDXUTControl* s_ui_texerp = 0;
//static CDXUTControl* s_ui_erp = 0;
//
//
////PhysicsIK
//static CDXUTControl* s_ui_texphysmv = 0;
//static CDXUTControl* s_ui_slphysmv = 0;
//static CDXUTControl* s_ui_physrotstart = 0;
//static CDXUTControl* s_ui_physmvstart = 0;
//static CDXUTControl* s_ui_physikstop = 0;
//
////static bool s_guivisible_left = true;
////static bool s_guivisible_left2nd = true;
////static bool s_guivisible_bullet = true;
////static bool s_guivisible_physicsik = true;



//#define DEBUG_VS   // Uncomment this line to debug vertex shaders 
//#define DEBUG_PS   // Uncomment this line to debug pixel shaders 

bool g_4kresolution = false;

ChaVector3 g_vCenter(0.0f, 0.0f, 0.0f);


std::vector<void*> g_eulpool;//allocate EULPOOLBLKLEN EulKey at onse and pool 
std::vector<void*> g_keypool;//allocate KEYPOOLBLKLEN Key at onse and pool 

void OnDSUpdate();
static void OnDSMouseHereApeal();
static void OnArrowKey();//DS関数でキーボードの矢印キーに対応


static void CalcTotalBound();
static int SetCameraModel();
static void SetCamera3DFromEyePos();

//--------------------------------------------------------------------------------------
// Global variables
//--------------------------------------------------------------------------------------
////ID3DX11Font*                  g_pFont = NULL;         // Font for drawing text
////ID3DX11Sprite                g_pSprite = NULL;       // Sprite for batching draw text calls
//CDXUTTextHelper* g_pTxtHelper = NULL;

bool                        g_bShowHelp = true;     // If true, it renders the UI control text
//CModelViewerCamera* g_Camera = 0;// A model viewing camera
////ID3DX11Effect*                g_pEffect = NULL;       // D3DX effect interface
////ID3DXMesh*                  g_pMesh = NULL;         // Mesh object
//
////IDirect3DTexture10*          g_pMeshTexture = NULL;  // Mesh texture
////LPD3DXFONT                  g_pFont9 = NULL;         // Font for drawing text
//
//
//CDXUTDialogResourceManager  g_DialogResourceManager; // manager for shared resources of dialogs
////CD3DSettingsDlg             g_SettingsDlg;          // Device settings dialog
//CDXUTDialog                 g_HUD;                  // manages the 3D UI
//CDXUTDialog                 g_SampleUI;             // dialog for sample specific controls
bool                        g_bEnablePreshader;     // if TRUE, then D3DXSHADER_NO_PRESHADER is used when compiling the shader
//ChaMatrix               g_mCenterWorld;
ChaMatrix               g_mCenterWorld;


////#define MAX_LIGHTS 3
////CDXUTDirectionWidget g_LightControl[MAX_LIGHTS];
//CDXUTDirectionWidget g_LightControl[LIGHTNUMMAX];
ChaVector4 g_lightdirforshader[LIGHTNUMMAX];
ChaVector4 g_lightdiffuseforshader[LIGHTNUMMAX];



//--------------------------------------------------------------------------------------
// UI control IDs
//--------------------------------------------------------------------------------------


//

#define MENUOFFSET_BONERCLICK		20000
//################################################
//ID_RMENU_*は　MENUOFFSET_BONERCLICKを足して使う
//################################################
#define ID_RMENU_PHYSICSCONSTRAINT	(10)
#define ID_RMENU_KINEMATIC_ON_LOWER	(ID_RMENU_PHYSICSCONSTRAINT + 13)
#define ID_RMENU_KINEMATIC_OFF_LOWER	(ID_RMENU_PHYSICSCONSTRAINT + 14)

#define ID_RMENU_IKTARGET (ID_RMENU_PHYSICSCONSTRAINT + 15)
#define ID_RMENU_IKSTOP (ID_RMENU_PHYSICSCONSTRAINT + 16)
#define ID_RMENU_COPY (ID_RMENU_PHYSICSCONSTRAINT + 17)
#define ID_RMENU_PASTE (ID_RMENU_PHYSICSCONSTRAINT + 18)



#define IDC_TOGGLEFULLSCREEN    1
#define IDC_TOGGLEREF           3
#define IDC_CHANGEDEVICE        4
#define IDC_ENABLE_PRESHADER    5
#define IDC_NUM_LIGHTS          6
#define IDC_NUM_LIGHTS_STATIC   7
#define IDC_ACTIVE_LIGHT        8
#define IDC_LIGHT_SCALE         9
#define IDC_LIGHTING  10

#define IDC_COMBO_BONE			11
#define IDC_FK_XP				12
#define IDC_FK_XM				13
#define IDC_FK_YP				14
#define IDC_FK_YM				15
#define IDC_FK_ZP				16
#define IDC_FK_ZM				17

#define IDC_T_XP				18
#define IDC_T_XM				19
#define IDC_T_YP				20
#define IDC_T_YM				21
#define IDC_T_ZP				22
#define IDC_T_ZM				23

#define IDC_SPEED_STATIC		24
#define IDC_SPEED				25

#define IDC_CAMTARGET			26

#define IDC_COMBO_EDITMODE		27
#define IDC_IK_ROT				28
#define IDC_IK_MV				29
#define IDC_IK_LIGHT			30
#define IDC_BT_RIGID			31
#define IDC_BT_IMP				32
#define IDC_BT_GP				33
#define IDC_BT_DAMP				34

#define IDC_COMBO_IKLEVEL		35

#define IDC_LIGHT_DISP			36

#define IDC_SL_IKFIRST			37
#define IDC_SL_IKRATE			38
#define IDC_STATIC_IKFIRST		39
#define IDC_STATIC_IKRATE		40

#define IDC_SLERP_OFF			41
#define IDC_ABS_IK				42

#define IDC_SL_APPLYRATE			43
#define IDC_STATIC_APPLYRATE		44

#define IDC_APPLY_TO_THEEND			45
#define IDC_BMARK					46
#define IDC_PSEUDOLOCAL				47

#define IDC_COMBO_BONEAXIS			48
#define IDC_LIMITDEG				49

#define IDC_STATIC_BTCALCCNT		50
#define IDC_BTCALCCNT				51
#define IDC_STATIC_ERP0				52
#define IDC_ERP						53

#define IDC_PHYSICS_IK				54
#define IDC_BTSTART					55
#define IDC_PHYSICS_MV_IK				56
#define IDC_PHYSICS_MV_SLIDER			57
#define IDC_STATIC_PHYSICS_MV_SLIDER	58
//#define IDC_APPLY_BT				59
#define IDC_STOP_BT					60

#define IDC_SL_NUMTHREAD			61
#define IDC_STATIC_NUMTHREAD		62

#define IDC_COMBO_MOTIONBRUSH_METHOD	63
#define IDC_RMARK					64

#define IDC_PHYSICS_IK_STOP			65
#define IDC_BTRECSTART				66

#define IDC_STATIC_BRUSHREPEATS		67
#define IDC_SL_BRUSHREPEATS			68
#define IDC_BRUSH_MIRROR_U			69
#define IDC_BRUSH_MIRROR_V			70
#define IDC_BRUSH_MIRROR_V_DIV2		71

#define IDC_IK_SC					72

#define IDC_SL_REFPOSSTEP			73
#define IDC_SL_REFARROW				74
#define IDC_STATIC_REF				75
#define IDC_SL_REFALPHA				76

#define IDC_WALLSCRAPINGIK			77
#define IDC_HIGHRPM					78
#define IDC_SL_UMTHREADS			79
#define IDC_STATIC_UMTHREADS		80

//#define IDC_VSYNC					81
#define IDC_PRECISEONPREVIEWTOO		82
#define IDC_TPOSE_MANIPULATOR		83

#define IDC_TRAROT					84
#define IDC_COMBO_FPS				85
#define IDC_X180					86

#define IDC_TIPRIG1					87
#define IDC_TIPRIG2					88
#define IDC_TIPRIG3					89
#define IDC_TIPRIG4					90
#define IDC_TIPRIG5					91
//#define IDC_EDGESMP					88


HWND g_mainhwnd = NULL;//アプリケーションウインドウハンドル
HWND g_hWnd = NULL;//3Dウィンドウハンドル。


//ゲームの初期化。
RECT InitGame(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPWSTR lpCmdLine, int nCmdShow, const TCHAR* appName, HWND srcparentwnd,
	int srcposx, int srcposy,
	int srcwidth, int srcheight);
//ウィンドウメッセージをディスパッチ。falseが返ってきたら、ゲーム終了。
bool DispatchWindowMessage();
int OnCreateDevice();


//##########################
//MessageProc of Main Window
//##########################
LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static void InitApp();
static int CheckResolution();
static HWND CreateMainWindow();
static void InitRootSignature(RootSignature& rs);
static void OnDestroyDevice();
static int InitPluginMenu();
static int OnPluginClose();

//##########################
//MessageProc of 3d window
//##########################
LRESULT CALLBACK AppMsgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static HWND Create3DWnd(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd);
static void OnUserFrameMove(double fTime, float fElapsedTime);
static void OnFrameRender(myRenderer::RenderingEngine* re, RenderContext* rc, double fTime, float fElapsedTime);

//################
//GUI Plate Menu
//################
static void GUIGetNextMenu(POINT ptCursor, int srcmenukind, int* dstmenukind, int* dstplateno);
static void GUIMenuSetVisible(int srcmenukind, int srcplateno);
static void ChangeToNextPlateMenuKind(int srcmenukind, int srcmenuno);
static void ChangeToNextPlateMenuPlate(int srcmenukind, int srcmenuno);
static void GUISetVisible(int srcplateno);
static void GUISetVisible_CameraAndIK();
static void GUISetVisible_DispAndLimits();
static void GUISetVisible_BrushParams();
static void GUISetVisible_Bullet();
static void GUISetVisible_LOD();
static void GUISetVisible_AimBar();
static void GUIDispSetVisible(int srcplateno);

static void ShowLightsWnd(bool srcflag);
static void ShowGUIDlgDispParams(bool srcflag);
static void ShowGUIDlgBrushes(bool srcflag);
static void ShowGUIDlgBullet(bool srcflag);
static void ShowGUIDlgLOD(bool srcflag);
static void CloseAllRightPainWindow();
static void CloseTheFirstRowGUI();


static void ShowLaterTransparentWnd(bool srcflag);
static void ShowShadowParamsWnd(bool srcflag);
static void ShowDispGroupWnd(bool srcflag);
static void GUIRigidSetVisible(int srcplateno);
static void ShowRigidWnd(bool srcflag);
static void ShowImpulseWnd(bool srcflag);
static void ShowGroundWnd(bool srcflag);
static void ShowDampAnimWnd(bool srcflag);
static void GUIRetargetSetVisible(int srcplateno);
static void ShowRetargetWnd(bool srcflag);
static void ShowLimitEulerWnd(bool srcflag);



static CInfoWindow* CreateInfoWnd();
static int CreateSprites();
static void DestroySprites();


//#################################
//For DualSence GamePad Controller
//#################################
static HWND GetOFWnd(POINT srcpoint);
static BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam);
static HWND GetNearestEnumDist();
static BOOL CALLBACK EnumIDOKProc(HWND hwnd, LPARAM lParam);
static BOOL CALLBACK EnumTreeViewProc(HWND hwnd, LPARAM lParam);
void CALLBACK WinEventProc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread, DWORD dwmsEventTime);
static void DSMessageBox(HWND srcparenthwnd, const WCHAR* srcmessage, const WCHAR* srctitle, LONG srcok);



static int DispToolTip();
static int CreateToolTip(POINT ptCursor, WCHAR* srctext);
static int CreateTipRig(CBone* currigbone, int currigno, POINT ptCursor);

static bool DispTipRig();
static int ClearLimitedWM(CModel* srcmodel);

static float CalcSelectScale(CBone* curboneptr);
static double CalcRefFrame();
static void ChangeCurDirFromMameMediaToTest();



//static int CreateCameraDollyWnd();//2023/08/23 CreateDollyHistoryDlg()に移行
static int ShowCameraDollyDlg();
static int CreateMaterialRateWnd();
static int ShowMaterialRateDlg();
static int SetModel2MaterialRateDlg(CModel* srcmodel);
static int CreateModelWorldMatWnd();
static int SetModel2ModelWorldMatDlg(CModel* srcmodel);
static int ShowModelWorldMatDlg();


//static void CheckShaderTypeButton(HWND hDlgWnd, int srcshadertype);//DispAndLimitプレートメニュー用

//#################################################
//ShaderPlateMenuプッシュで表示するOWPのShaderTypeWnd
//#################################################
static void ShowShaderTypeWnd(bool srcflag);//OWPの方
static int ModalShaderTypeDlg();//OWPの方
static int CreateShaderTypeWnd();//OWPの方
static void DestroyShaderTypeWnd();//OWPの方

//#######################################################
//OWPのShaderTypeWndウインドウから呼び出すWin32のparamsDlg
//#######################################################
static int CreateShaderTypeParamsDlg();//params設定用　OWPでは無い方
static int SetMaterial2ShaderTypeParamsDlg(CMQOMaterial* srcmat);//params設定用　OWPでは無い方
static int ShowShaderTypeParamsDlg();//params設定用　OWPでは無い方
static void CheckShaderTypeParamsButton(HWND hDlgWnd, int srcshadertype);//params設定用　OWPでは無い方



void CALLBACK OnKeyboard(UINT nChar, bool bKeyDown, bool bAltDown, void* pUserContext);
//void CALLBACK OnGUIEvent(UINT nEvent, int nControlID, CDXUTControl* pControl, void* pUserContext);


LRESULT CALLBACK OpenMqoDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK MotPropDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK CameraDollyDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK MaterialRateDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ModelWorldMatDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ShaderTypeParamsDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK OpenBvhDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK SaveChaDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK ExportXDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK SaveREDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK SaveImpDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK SaveGcoDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK CheckAxisTypeProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK AngleLimitDlgProc2(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK LightsForEditDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK GUIDispParamsDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK GUIBrushesDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK GUIBulletDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK GUILODDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK LaterTransparentDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK ShadowParamsDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK RotAxisDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK CustomRigDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK AboutDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK bvh2FbxBatchDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK RetargetBatchDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK ProgressDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);


static int OwnerDrawLightColorBar(HWND hDlgWnd, int lightindex, int idcolorbar);
static int ChooseLightColorBar(HWND hDlgWnd, int lightindex, int idcolorbar);







//HRESULT LoadMesh( ID3D12Device* pd3dDevice, WCHAR* strFileName, ID3DXMesh** ppMesh );
void CalcFps(double fTime);
static int RetargetFile(char* fbxpath);

static int OnMouseMoveFunc();


static int RollbackCurBoneNo();
static void PrepairUndo();
static void RollbackBrushState(BRUSHSTATE srcbrushstate);
static int OnFrameUndo(bool fromds, int fromdskind);
static int OnSpriteUndo();
static void OnGUIEventSpeed();
static int SetShowPosTime();
//static int CallFilterFunc(int callnum);
static int FilterFuncDlg();
static int FilterNoDlg(bool copylw2w);

static void SavePlayingStartEnd();
static void SetButtonStartEndFromPlaying();

static void AutoCameraTarget();

static int CreateUtDialog();
static int VisibleUtDialog();
static bool UnderDragOperation_L();
static bool UnderDragOperation_R();
static bool IsClickedSpriteButton();
static int CreateTimelineWnd();
static int CreateLongTimelineWnd();
static int CreateDmpAnimWnd();
static int CreateRigidWnd();
static int CreateSideMenuWnd();
static int CreateMainMenuAimBarWnd();
static int CreateImpulseWnd();
static int CreateGPlaneWnd();
static int CreateToolWnd();
static int CreateLayerWnd();
static int CreatePlaceFolderWnd();

static int CreateCopyHistoryDlg();
static int CreateDollyHistoryDlg();

static void InitTimelineSelection();

static int CreateLightsWnd();
static int Lights2Dlg(HWND hDlgWnd);
static int Lights2DlgEach(HWND hDlgWnd, int lightindex,
	int iddirx, int iddiry, int iddirz,
	int idenable, int idwithviewrot, int idslider, int idtextlight);
static int Dlg2Lights(HWND hDlgWnd, int lightindex);
static int Dlg2LightsEach(HWND hDlgWnd, int lightindex,
	int iddirx, int iddiry, int iddirz,
	int idenable, int idwithviewrot, int idslider);
static int CheckStr_float(const WCHAR* srcstr);

static int CreateGUIDlgDispParams();
static int CreateGUIDlgBrushes();
static int CreateGUIDlgBullet();
static int CreateGUIDlgLOD();
static int LODParams2Dlg(HWND hDlgWnd);




static int CreateLaterTransparentWnd();
static int LaterTransparent2Dlg(HWND hDlgWnd);
static int Dlg2LaterTransparent(HWND hDlgWnd);

static int CreateShadowParamsWnd();
static int ShadowParams2Dlg(HWND hDlgWnd);
static void CheckShadowDirectionButton(HWND hDlgWnd, int srcshadowdir);


static int CreateDispGroupWnd();
static int DestroyDispGroupWnd();
static int CheckSimilarMenu();
static int CheckSimilarGroup(int opetype);

static int UpdateCameraPosAndTarget();


static int OnFrameAngleLimit(bool updateonlycheckeul);
static int OnFrameLightsForEdit();
static int OnFrameKeyboard();
static bool FocusEditWnd();
static int ChangeToolSpriteMode();
static int OnFrameUtCheckBox();
static int OnFrameProcessTime(double difftime, double* pnextframe, int* pendflag, int* ploopstartflag);
static int OnFrameProcessCameraTime(double difftime, double* pnextframe, int* pendflag, int* ploopstartflag);
static int OnFramePreviewCamera(double nextframe);
static int OnFramePreviewStop();
static int OnFramePreviewNormal(double nextframe, double difftime, int endflag, int loopstartflag);
static int OnFramePreviewBt(double nextframe, double difftime, int endflag, int loopstartflag);
//int OnFramePreviewBtAftFunc(double nextframe, CModel* curmodel);
//static int OnFramePreviewRagdoll(double* pnextframe, double* pdifftime);
static int OnFrameCloseFlag();
static int OnFrameTimeLineWnd();
static int OnFrameMouseButton();
static int OnFrameToolWnd();
static int OnFrameStartPreview(double curtime, double* psavetime);
static int OnFrameBatchThread();
//static int OnFrame();
static int OnFrameUpdateGround();
static int OnFrameInitBtWorld();
int StopBtRec();
static int ToggleRig();
//static void UpdateBtSimu(double nextframe, CModel* curmodel);
//static void SetKinematicToHand(CModel* srcmodel, bool srcflag);
//static void SetKinematicToHandReq(CModel* srcmodel, CBone* srcbone, bool srcflag);
static void DispProgressCalcLimitedWM();

static int SetLightDirection();

static int OnRenderModel(RenderContext* pRenderContext);
static int OnRenderOnlyOneObj(RenderContext* pRenderContext);
//static int OnRenderRefPos(RenderContext* pRenderContext, CModel* curmodel);
static int OnRenderGround(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderBoneMark(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderSelect(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderSprite(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderFontForTip(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderUtDialog(RenderContext* pRenderContext, float fElapsedTime);

static int PasteMotionPoint(CBone* srcbone, CMotionPoint srcmp, double newframe);
static int PasteNotMvParMotionPoint(CBone* srcbone, 
	double copystarttime, double srcframe, double srcframe2, double interpolaterate, 
	double dststartframe, double newframe);
static int PasteMotionPointJustInTerm(double copyStartTime, double copyEndTime, double startframe, double endframe);
//static int PasteMotionPointAfterCopyEnd(double copyStartTime, double copyEndTime, double startframe, double endframe);
static CMotionPoint CalcPasteMotionPoint(CBone* srcbone, double srcframe, double srcframe2, double interpolaterate);
static void ResetPasteDoneFlagReq(CBone* srcbone);


static int ChangeCurrentBone();
static int ChangeLimitDegFlag(bool srcflag, bool setcheckflag, bool updateeulflag);
static int ChangeWallScrapingIKFlag(bool srcflag);
static int ChangeCameraMode(int forcemode);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2
static int ChangeCameraInherit();

static int InitCurMotion(int selectflag, double expandmotion);

static int OpenChaFile();
CModel* OpenMQOFile();
CModel* OpenFBXFile(bool callfromcha, bool dorefreshtl, int skipdefref, int inittimelineflag, std::vector<std::string> ikstopname);
static int OpenREFile();
static int OpenImpFile();
static int OpenGcoFile();
static int OpenMNLFile();

int OnDelMotion(int delindex, bool ondelbutton = false);
int OnAddMotion(int srcmotid, bool dorefreshtl);

static int StartBt(CModel* curmodel, BOOL isfirstmodel, int flag, int btcntzero);
static int StopBt();
static int GetShaderHandle();
static int SetBaseDir();
static int LoadIniFile();
static int SaveIniFile();
static int LoadChooseColor();
static int SaveChooseColor();
static int LoadLightsForEdit();
static int SaveLightsForEdit();
static int LoadShadowParamsFile();
static int SaveShadowParamsFile();

static int OpenFile();
static int BVH2FBX();
static void FindF(std::vector<wstring>& out, const wstring& directory, const wstring& findext);
static int BVH2FBXBatch();
static int RetargetBatch();
static int SaveBatchHistory(WCHAR* selectname);
static int GetBatchHistoryDir(WCHAR* dstname, int dstlen);
static int Savebvh2FBXHistory(WCHAR* selectname);
static int SaveRtgHistory(WCHAR* selectname);
static int GetbvhHistoryDir(std::vector<wstring>& dstvecopenfilename);
static int GetchaHistoryDir(std::vector<wstring>& dstvecopenfilename, int filter_cha);
static int GetCPTFileName(std::vector<HISTORYELEM>& dstcptfilename);
static int GetRtgHistoryDir(std::vector<wstring>& dstvecopenfilename);
static int SaveProject();
static int SaveREFile();
static int SaveImpFile();
static int SaveGcoFile();
static int ExportFBXFile();

static void refreshTimeline(OWP_Timeline& timeline);
static int refreshEulerGraph();
static int AddBoneTra(int kind, float srctra);
static int AddBoneTra2(ChaVector3 diffvec);
//static int AddBoneTraPhysics(ChaVector3 diffvec);

static int AddBoneScale(int kind, float srctra);
static int AddBoneScale2(ChaVector3 diffvec);

static int DispMotionWindow();
static int DispToolWindow();
static int DispObjPanel();
static int DispModelPanel();
static int DispMotionPanel();
static int DispCameraPanel();
//static int DispConvBoneWindow();
static int DispAngleLimitDlg();
static int DispRotAxisDlg();
static int DispCustomRigDlg(int rigno);
static int InvalidateCustomRig(int rigno);
static int BoneRClick(int srcboneno);

static int DisplayApplyRateText();


//CustomRigDlg
static int Bone2CustomRig(int rigno);
static int CustomRig2Bone();
static int GetCustomRigRateVal(HWND hDlgWnd, int resid, float* dstptr);
static int CustomRig2Dlg(HWND hDlgWnd);
static int SetCustomRigDlgLevel(HWND hDlgWnd, int levelnum);
static int SetRigRigCombo(HWND hDlgWnd, int elemno);
static int CheckRigRigCombo(HWND hDlgWnd, int elemno);
static int EnableRigAxisUV(HWND hDlgWnd);

//angle limit dlg
static int Bone2AngleLimit();
static int AngleLimit2Bone(int limit2boneflag);
static int AngleLimit2Bone_One(CBone* srconbe);
static void AngleLimit2Bone_Req(CBone* srcbone, int setbroflag);
static int AngleLimit2Dlg(HWND hDlgWnd, bool updateonlycheckeul);
static int InitAngleLimitEditInt(HWND hDlgWnd, int editresid, int srclimit);
static int InitAngleLimitEditFloat(HWND hDlgWnd, int editresid, float srcfloat);
static int InitAngleLimitSlider(HWND hDlgWnd, int slresid, int txtresid, int srclimit);
static int GetAngleLimitSliderVal(HWND hDlgWnd, int slresid, int txtresid, int* dstptr);
static int InitAngleLimitSliderFloat(HWND hDlgWnd, int slresid, int txtresid, float srclimit);
static int GetAngleLimitSliderValFloat(HWND hDlgWnd, int slresid, int txtresid, float* dstptr);
static int AngleDlg2AngleLimit(HWND hDlgWnd);//2022/12/05
static int GetAngleLimitEditInt(HWND hDlgWnd, int editresid, int* dstlimit);//2022/12/05
static int CheckStr_SInt(const WCHAR* srcstr);//2022/12/05
static int UpdateAfterEditAngleLimit(int limit2boneflag, bool setcursorflag = true);//2022/12/06
static int CopyWorldToLimitedWorld(CModel* srcmodel);
static int CopyLimitedWorldToWorld(CModel* srcmodel, bool allframeflag, bool setcursorflag,
	int operatingjointno, bool onpasteflag);
static int ApplyNewLimitsToWM(CModel* srcmodel);
static int ApplyNewLimitsToWMSelected();

static int InitRotAxis();
static int RotAxis(HWND hDlgWnd);

static int EraseKeyList();
static int DestroyTimeLine(int dellist);
static int AddTimeLine(int newmotid, bool dorefreshtl);
static int AddMotion(const WCHAR* wfilename, double srcleng = 0.0);
static int OnCameraMenu(bool dorefreshflag, int selindex, int saveundoflag = 1);
static int OnAnimMenu(bool dorefreshflag, int selindex, int saveundoflag = 1);
static int OnRgdMorphMenu(int selindex);
static int AddModelBound(MODELBOUND* mb, MODELBOUND* addmb);
static int OnSetMotSpeed();

static int OnModelMenu(bool dorefreshtl, int selindex, int callbymenu);
static int SetTimelineHasRigFlag();
static int OnREMenu(int selindex, int callbymenu);
static int OnRgdMenu(int selindex, int callbymenu);
static int OnImpMenu(int selindex);
static int OnDelModel(int delindex, bool ondelbutton = false);
static int OnDispModel(int dispindex);
static int OnDelAllModel();
static int refreshModelPanel();
//static int refreshMotionPanel();
static int RenderSelectMark(myRenderer::RenderingEngine* re, RenderContext* pRenderContext, int renderflag);
static int RenderSelectFunc(myRenderer::RenderingEngine* re);
static int RenderSelectPostureFunc(myRenderer::RenderingEngine* re);
static int RenderRigMarkFunc(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int SetSelectState();


static void ResetRigModelNum();
static CModel* GetCurRigModel(CUSTOMRIG currig, int* pinstanceno, ChaVector4* prigmat);
static CFrameCopyDlg* GetCurrentFrameCopyDlg();


static int CreateModelPanel();
static int DestroyModelPanel();
static int CreateMotionPanel();
static int DestroyMotionPanel();
static int CreateCameraPanel();
static int DestroyCameraPanel();
static int CreateConvBoneWnd();
static int DestroyConvBoneWnd();
static int SetConvBoneModel();
static int SetConvBoneBvh();
static int SetConvBone(int cbno);
static int SaveRetargetFile();
static int LoadRetargetFile(WCHAR* srcfilename);
static int SaveMotionNameListFile();
//static int LoadMotionNameListFile(WCHAR* srcfilename);
static int SetJointPair2ConvBoneWnd();
static int InitJointPair2ConvBoneWnd();


//static int ConvBoneConvert();//--> RetargetMotion()に改名
static int RetargetMotion();

//AdditiveIKLibのRetarget.h, Retarget.cppへ移動
//static void ConvBoneConvertReq(CBone* modelbone, double srcframe, CBone* befbvhbone, float hrate);
//static int ConvBoneRotation(int selfflag, CBone* srcbone, CBone* bvhbone, double srcframe, CBone* befbvhbone, float hrate);


static int CalcTargetPos(ChaVector3* dstpos);
static int CalcPickRay(ChaVector3* start3d, ChaVector3* end3d);
static void ActivatePanel(int state);
static int SetCamera6Angle();

//static int SetSelectCol();
static int RigidElem2WndParam();
static int SetRigidLeng();
static int SetImpWndParams();
static int SetGpWndParams();
static int SetDmpWndParams();

static int SetSpParams();
static int SetSpSel3DParams();
static int SetSpAimBarParams();
static int SetSpMenuAimBarParams();
static int SetSpAxisParams();
static int SetSpUndoParams();
static int SetSpMouseCenterParams();
static int PickSpAxis(POINT srcpos);
static int PickSpUndo(POINT srcpos);

static int SetSpGUISWParams();
static int PickSpGUISW(POINT srcpos);
static int SetSpDispSWParams();
static int PickSpDispSW(POINT srcpos);
static int SetSpRigidSWParams();
static int PickSpRigidSW(POINT srcpos);
static int PickSpRetargetSW(POINT srcpos);
static int SetSpRetargetSWParams();
static int SetSpCamParams();
static int PickSpCam(POINT srcpos);
static int SetSpRigParams();
static int PickSpRig(POINT srcpos);
static int SetSpCpLW2WParams();
static int PickSpCpLW2W(POINT srcpos);
static int SetSpSmoothParams();
static int PickSpSmooth(POINT srcpos);
static int SetSpLimitEulSWParams();
static int PickSpLimitEulSW(POINT srcpos);
static int SetSpScrapingSWParams();
static int PickSpScrapingSW(POINT srcpos);
static int SetSpConstExeParams();
static int PickSpConstExe(POINT srcpos);
static int SetSpConstRefreshParams();
static int PickSpConstRefresh(POINT srcpos);
static int SetSpCameraModeSWParams();
static int PickSpCameraModeSW(POINT srcpos);
static int SetSpCameraInheritSWParams();
static int PickSpCameraInheritSW(POINT srcpos);

static int SetSpRet2PrevParams();
static bool PickSpFrog(POINT srcpos);
static bool PickSpFrog2(POINT srcpos);

static int SetSpCopyParams();
static int PickSpCopy(POINT srcpos);
static int SetSpSymCopyParams();
static int PickSpSymCopy(POINT srcpos);
static int SetSpPasteParams();
static int PickSpPaste(POINT srcpos);
static int SetSpCopyHistoryParams();
static int PickSpCopyHistory(POINT srcpos);

static int SetSpInterpolateParams();
static int PickSpInterpolate(POINT srcpos);
static int SetSpInitParams();
static int PickSpInit(POINT srcpos);
static int SetSpScaleInitParams();
static int PickSpScaleInit(POINT srcpos);
static int SetSpPropertyParams();
static int PickSpProperty(POINT srcpos);

static int SetSpZeroFrameParams();
static int PickSpZeroFrame(POINT srcpos);
static int SetSpCameraDollyParams();
static int PickSpCameraDolly(POINT srcpos);
static int SetSpModelPosDirParams();
static int PickSpModelPosDir(POINT srcpos);
static int SetSpMaterialRateParams();
static int PickSpMaterialRate(POINT srcpos);


static int PickRigBone(UIPICKINFO* ppickinfo, bool forrigtip = false, int* dstrigno = 0);
static ChaMatrix CalcRigMat(CUSTOMRIG* currig, CBone* curbone, int curmotid, double curframe, int dispaxis, int disporder, bool posinverse);

static int PickManipulator(UIPICKINFO* ppickinfo, bool pickring);



//static int SetSpBtParams();
//static int PickSpBt(POINT srcpos);
static int SetSpMouseHereParams();
static int SetSpIkModeSWParams();
static int PickSpIkModeSW(POINT srcpos);
static int SetSpLODSWParams();
static int PickSpLODSW(POINT srcpos);



static int InsertCopyMP(bool limitdegflag, CBone* curbone, double curframe);
static void InsertCopyMPReq(bool limitdegflag, CBone* curbone, double curframe);
static int InsertSymMP(bool limitdegflag, CBone* curbone, double curframe, int symrootmode);
static void InsertSymMPReq(bool limitdegflag, CBone* curbone, double curframe, int symrootmode);

static int InterpolateFromTool();
static int FilterFromTool();
static int InitMpFromTool();
//static int InitMP( CBone* curbone, double curframe );
//static void InitMPReq(CBone* curbone, double curframe);
static int InitMpByEul(int initmode, CBone* curbone, int srcmotid, double srcframe);
static void InitMpByEulReq(int initmode, CBone* curbone, int srcmotid, double srcframe, bool broflag);
static void InitMpByEulEndJointReq(int initmode, CBone* curbone, int srcmotid, double srcframe, bool broflag);

static void SkipJointMarkReq(int srcstate, CBone* srcbone, bool setbrotherflag);

static int AdjustBoneTra(CBone* curbone, double frame);
static int CreateTimeLineMark(int topboneno = -1);
static void CreateMarkReq(int curboneno, int broflag);
static int SetLTimelineMark(int curboneno);
static int SetTimelineMark();
static int CreateMotionBrush(double srcstart, double srcend, bool onrefreshflag);
static int UpdateTopPosText();


static int ExportBntFile();

static const int s_appindex = 1;

static void AboutMotionBrush();
static int s_registflag = 1;//!!!!!!!!!!!
static HKEY s_hkey;
static int RegistKey();
static int IsRegist();

static int TimelineCursorToMotion();
int OnTimeLineCursor();
static int OnTimeLineButtonSelectFromSelectStartEnd(int tothelastflag);
static int OnTimeLineSelectFromSelectedKey();
static int OnTimeLineMButtonDown(bool ctrlshiftflag);
static int OnTimeLineWheel();
static int AddEditRangeHistory();
static int RollBackEditRange(int prevrangeFlag, int nextrangeFlag);
static int RecalcBoneAxisX(CBone* srcbone);
static void RecalcAxisX_All();

static int GetSymRootMode();

static int UpdateEditedEuler();


static void SetDlgHistory(HWND hDlgWnd, std::vector<wstring> vecopenfilename, int pagenum, int currentpage);
static bool FindAtTheLast(std::wstring const& strsource, std::wstring const& strpat);


static int ChangeUpdateMatrixThreads();
static int FindModelIndex(CModel* srcmodel);


static std::wstring ReplaceString
(
	std::wstring String1  // 置き換え対象
	, std::wstring String2  // 検索対象
	, std::wstring String3  // 置き換える内容
);


std::wstring ReplaceString
(
	std::wstring String1  // 置き換え対象
	, std::wstring String2  // 検索対象
	, std::wstring String3  // 置き換える内容
)
{
	std::wstring::size_type  Pos(String1.find(String2));

	while (Pos != std::string::npos)
	{
		String1.replace(Pos, String2.length(), String3);
		Pos = String1.find(String2, Pos + String3.length());
	}

	return String1;
}

//#############################################
//保存時のダイアログの初期フォルダ設定用　メモ
//#############################################
//// パス取得バッファ
//TCHAR waFolderPath[MAX_PATH];
//// デスクトップのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_DESKTOP, 0);
//// デスクトップのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_DESKTOPDIRECTORY, 0);
//// スタートメニューのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_STARTMENU, 0);
//// Program Filesのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PROGRAMS, 0);
//// Startupのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_STARTUP, 0);
//// Startup(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_ALTSTARTUP, 0);
//// My Documentsのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PERSONAL, 0);
//// お気に入りのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_FAVORITES, 0);
//// ゴミ箱のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_RECENT, 0);
//// Sendtoのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_SENDTO, 0);
//// NetHoodのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_NETHOOD, 0);
//// Fontsのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_FONTS, 0);
//// ShellNewのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_TEMPLATES, 0);
//// AppDataのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_APPDATA, 0);
//// PrintHoodのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PRINTHOOD, 0);
//// INetキャッシュのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_INTERNET_CACHE, 0);
//// INet Cookiesのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COOKIES, 0);
//// 履歴のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_HISTORY, 0);
//// デスクトップ(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_DESKTOPDIRECTORY, 0);
//// スタートメニュー(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_STARTMENU, 0);
//// Program Files(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_PROGRAMS, 0);
//// スタートアップ(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_STARTUP, 0);
//// スタートアップ(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_ALTSTARTUP, 0);
//// お気に入りのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_FAVORITES, 0);
//実行結果
//CSIDL_DESKTOP : C:\Users\testuser\Desktop
//CSIDL_DESKTOPDIRECTORY : C:\Users\testuser\Desktop
//CSIDL_STARTMENU : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Start Menu
//CSIDL_PROGRAMS : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Start Menu\Programs
//CSIDL_STARTUP : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
//CSIDL_ALTSTARTUP : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
//CSIDL_PERSONAL : C:\Users\testuser\Documents
//CSIDL_FAVORITES : C:\Users\testuser\Favorites
//CSIDL_RECENT : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Recent
//CSIDL_SENDTO : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\SendTo
//CSIDL_NETHOOD : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Network Shortcuts
//CSIDL_FONTS : C:\WINDOWS\Fonts
//CSIDL_TEMPLATES : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Templates
//CSIDL_APPDATA : C:\Users\testuser\AppData\Roaming
//CSIDL_PRINTHOOD : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Printer Shortcuts
//CSIDL_INTERNET_CACHE : C:\Users\testuser\AppData\Local\Microsoft\Windows\INetCache
//CSIDL_COOKIES : C:\Users\testuser\AppData\Local\Microsoft\Windows\INetCookies
//CSIDL_HISTORY : C:\Users\testuser\AppData\Local\Microsoft\Windows\History
//CSIDL_COMMON_DESKTOPDIRECTORY : C:\Users\Public\Desktop
//CSIDL_COMMON_STARTMENU : C:\ProgramData\Microsoft\Windows\Start Menu
//CSIDL_COMMON_PROGRAMS : C:\ProgramData\Microsoft\Windows\Start Menu\Programs
//CSIDL_COMMON_STARTUP : C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup
//CSIDL_COMMON_ALTSTARTUP : C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup
//CSIDL_COMMON_FAVORITES : C:\Users\testuser\Favorites



LRESULT CALLBACK AboutDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);
		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
		}
	case WM_CLOSE:
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}


void AboutMotionBrush()
{
	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_DIALOG1),
		s_3dwnd, (DLGPROC)AboutDlgProc);

}



int RegistKey()
{
	/*
		CRegistDlg dlg;
		dlg.DoModal();

		if( strcmp( s_appkey[ s_appindex ], dlg.m_regkey ) == 0 ){
			if( s_registflag == 0 ){
				LONG lret;
				DWORD dwret;
				lret = RegCreateKeyExA( HKEY_CURRENT_USER, "Software\\OchakkoLab\\AdditiveIK_0003", 0, "",
					REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &s_hkey, &dwret );
				if( dwret == REG_CREATED_NEW_KEY ){
					lret = RegSetValueExA( s_hkey, "registkey", 0, REG_SZ, (LPBYTE)(dlg.m_regkey), sizeof(char) * 36 );
					if( lret != ERROR_SUCCESS ){
						::MessageBoxA( NULL, "エラー　：　レジストに失敗しました。", "レジストエラー", MB_OK );
					}
					RegCloseKey( s_hkey );
					::MessageBoxA( NULL, "成功　：　レジストに成功しました。", "レジスト成功", MB_OK );
				}else{
					::MessageBoxA( NULL, "エラー　：　レジストに失敗しました。", "レジストエラー", MB_OK );
				}
			}
		}else{
			::MessageBoxA( NULL, "エラー　：　不正なレジストキーです。", "レジストエラー", MB_OK );
		}
	*/
	return 0;
}

int IsRegist()
{
	s_registflag = 1;
	//	s_registflag = 0;

	/*
		LONG lret;
		lret = RegOpenKeyExA( HKEY_CURRENT_USER, "Software\\OchakkoLab\\AdditiveIK_0003", 0, KEY_ALL_ACCESS, &s_hkey );
		if( lret == ERROR_SUCCESS ){
			DWORD dwtype;
			char strkey[37] = {0};
			DWORD dwsize = 37;
			lret = RegQueryValueExA( s_hkey, "registkey", NULL, &dwtype, (LPBYTE)strkey, &dwsize );
			if( lret == ERROR_SUCCESS ){
				if( dwtype == REG_SZ ){
					if( strncmp( strkey, s_appkey[ s_appindex ], 36 ) == 0 ){
						s_registflag = 1;
					}
				}
			}
			RegCloseKey( s_hkey );
		}
	*/

	return 0;
}



//--------------------------------------------------------------------------------------
// Entry point to the program. Initializes everything and goes into a message processing 
// loop. Idle time is used to render the scene.
//--------------------------------------------------------------------------------------
//INT WINAPI wWinMain( HINSTANCE, HINSTANCE, LPWSTR, int )
//INT WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
INT WINAPI wWinMain(
	_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR lpCmdLine,
	_In_ int nShowCmd)//SAL付き
{
	// Enable run-time memory check for debug builds.
#if defined(DEBUG) | defined(_DEBUG)
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

	//SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

	//_CrtSetBreakAlloc(3879301);
	//_CrtSetBreakAlloc(3879304);
	//_CrtSetBreakAlloc(3879308);

	//_CrtSetBreakAlloc(297);
	//_CrtSetBreakAlloc(303);
	//_CrtSetBreakAlloc(307);

//_CrtSetBreakAlloc(10309);
//_CrtSetBreakAlloc(10833);

//_CrtSetBreakAlloc(787);
//_CrtSetBreakAlloc(2806);
//_CrtSetBreakAlloc(758);
//_CrtSetBreakAlloc(469193);
//_CrtSetBreakAlloc(5557505);
//_CrtSetBreakAlloc(5557507);
//_CrtSetBreakAlloc(1750750);
//_CrtSetBreakAlloc(602);

//_CrtSetBreakAlloc(65234);
//_CrtSetBreakAlloc(1526483);

	SetBaseDir();

	LoadIniFile();


	//s_appcntのセット。CheckResolution()よりも前
	s_appcnt = 0;
	s_launchbyc4 = 0;
	int    i;
	int    nArgs;
	//WCHAR  szBuf[256];
	LPWSTR* lplpszArgs;
	lplpszArgs = CommandLineToArgvW(GetCommandLine(), &nArgs);
	for (i = 0; i < nArgs; i++) {
		//wsprintf(szBuf, TEXT("%d番目の引数"), i + 1);
		//MessageBox(NULL, lplpszArgs[i], szBuf, MB_OK);
		if (wcscmp(lplpszArgs[i], L"-progno") == 0) {
			s_launchbyc4 = 1;
			if ((i + 1) < nArgs) {
				i++;
				WCHAR strprogno[MAX_PATH] = { 0L };
				wcscpy_s(strprogno, MAX_PATH, lplpszArgs[i]);
				s_appcnt = _wtoi(strprogno);
			}
		}
		else if (wcscmp(lplpszArgs[i], L"-diffx") == 0) {
			if ((i + 1) < nArgs) {
				i++;
				WCHAR strdiffx[MAX_PATH] = { 0L };
				wcscpy_s(strdiffx, MAX_PATH, lplpszArgs[i]);
				s_launchc4diffx = _wtoi(strdiffx);
			}
		}
		else if (wcscmp(lplpszArgs[i], L"-diffy") == 0) {
			if ((i + 1) < nArgs) {
				i++;
				WCHAR strdiffy[MAX_PATH] = { 0L };
				wcscpy_s(strdiffy, MAX_PATH, lplpszArgs[i]);
				s_launchc4diffy = _wtoi(strdiffy);
			}
		}
	}

	LocalFree(lplpszArgs);


	OpenDbgFile(s_appcnt);


	s_doneinit = 0;
	InitApp();
	if (s_doneinit != 1) {
		_ASSERT(0);
		return 1;
	}


	//2K TV or 4K TV. Create*Window()よりも前
	int chkresult = CheckResolution();
	if (chkresult != 0) {//大小選択ダイアログでキャンセルボタンを押した場合はアプリ終了
		return 0;
	}

	if (g_4kresolution) {
		s_dispmodel = true;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
		s_dispmotion = true;//!!!!!!!!!!!!!!!! motionpanelのdispflag
		s_dispcamera = true;//!!!!!!!!!!!!!!!! camerapanelのdispflag
	}
	else {
		s_dispmodel = false;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
		s_dispmotion = false;//!!!!!!!!!!!!!!!! motionpanelのdispflag
		s_dispcamera = false;//!!!!!!!!!!!!!!!! camerapanelのdispflag
	}

	s_copyKeyInfoList.clear();	// コピーされたキー情報リスト
	s_copymotvec.clear();
	s_pastemotvec.clear();
	s_deletedKeyInfoList.clear();	// 削除されたキー情報リスト
	s_selectKeyInfoList.clear();	// コピーされたキー情報リスト

	s_pasteRJoint.clear();



	g_mainhwnd = CreateMainWindow();
	if (g_mainhwnd == NULL) {
		_ASSERT(0);
		return 1;
	}

	::SetPriorityClass(GetModuleHandle(NULL), REALTIME_PRIORITY_CLASS);
	::SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

	//#############################
	//SetTreadAffinityはヒントでしかない
	//#############################
	//SYSTEM_INFO sys;
	//::GetSystemInfo(&sys);
	//DWORD cpunum = sys.dwNumberOfProcessors;
	//DWORD_PTR affinitymask = 0;
	//DWORD cpucnt;
	////for (cpucnt = 0; cpucnt < cpunum; cpucnt++) {
	////affinitymask |= (DWORD_PTR)(1 << (cpunum - 1));
	////}
	//DWORD_PTR befaffinity = ::SetThreadAffinityMask(GetCurrentThread(), affinitymask);
	//--------------------------------------------------------------------------------------
	// Limit the current thread to one processor (the current one). This ensures that timing code 
	// runs on only one processor, and will not suffer any ill effects from power management.
	// See "Game Timing and Multicore Processors" for more details
	//--------------------------------------------------------------------------------------
	//	void CDXUTTimer::LimitThreadAffinityToCurrentProc()


/*
#define SPAXISNUM	3
//#define SPCAMNUM	3	//Coef.h : SPR_CAM_MAX
#define SPRIGMAX	2
#define SPGUISWNUM	5
#define SPRIGIDSWNUM	4
#define SPRETARGETSWNUM	2
#define SPAIMBARNUM	5
*/

	s_chascene = new ChaScene();
	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}


	//CreateUtDialog();
	//int spgno;
	//for (spgno = 0; spgno < SPGUISWNUM; spgno++) {
	//	GUISetVisible(spgno + 2);
	//}


	if (!Create3DWnd(hInstance, hPrevInstance, lpCmdLine, nShowCmd)) {
		_ASSERT(0);
		return 1;
	}

	InitPluginMenu();


	//// 背景モデルのレンダラーを初期化
	//myRenderer::ModelRender bgModelRender;
	//bgModelRender.InitDeferredRendering(renderingEngine, "Assets/modelData/bg/bg.tkm", true);
	//// step-1 ティーポットの描画処理を初期化する
	//myRenderer::ModelInitDataFR modelInitData;
	//modelInitData.m_tkmFilePath = "Assets/modelData/teapot.tkm";
	//modelInitData.m_fxFilePath = "Assets/shader/sample.fx";
	//// 拡張SRVにZPrepassで作成された深度テクスチャを指定する
	//modelInitData.m_expandShaderResoruceView[0] = &renderingEngine.GetZPrepassDepthTexture();
	//// 初期化情報を使って描画処理を初期化する
	//myRenderer::ModelRender teapotModelRender;
	//// InitForwardRendering()を利用すると、
	//// フォワードレンダリングの描画パスで描画される
	//teapotModelRender.InitForwardRendering(renderingEngine, modelInitData);
	////シャドウキャスターフラグをオンにする
	//teapotModelRender.SetShadowCasterFlag(true);
	//teapotModelRender.UpdateWorldMatrix({ 0.0f, 50.0f, 0.0f }, g_quatIdentity, g_vec3One);
	////////////////////////////////////////
	//// 初期化を行うコードを書くのはここまで！！！
	////////////////////////////////////////
	s_pdev = g_graphicsEngine->GetD3DDevice();
	OnCreateDevice();


	CreatePlaceFolderWnd();
	CreateTimelineWnd();
	CreateToolWnd();
	CreateLongTimelineWnd();
	CreateDmpAnimWnd();
	CreateRigidWnd();
	CreateShaderTypeWnd();
	CreateImpulseWnd();
	CreateGPlaneWnd();
	CreateLayerWnd();
	CreateInfoWnd();
	CreateSideMenuWnd();
	CreateMainMenuAimBarWnd();

	CreateLightsWnd();
	CreateGUIDlgDispParams();
	CreateGUIDlgBrushes();
	CreateGUIDlgBullet();
	CreateGUIDlgLOD();

	CreateDispGroupWnd();
	//CreateLaterTransparentWnd();//s_modelが設定されてから作成する

	if (s_dollyhistorydlg.GetCreatedFlag() == false) {
		int result = CreateDollyHistoryDlg();
		if (result != 0) {
			_ASSERT(0);
		}
	}
	CreateMaterialRateWnd();
	CreateModelWorldMatWnd();
	CreateShaderTypeParamsDlg();



	//CreateCopyHistoryDlg();//s_modelが出来てから呼ぶ　OnModelMenu()に移動

	//CallF( InitializeSdkObjects(), return 1 );

	s_psdk = FbxManager::Create();
	if (!s_psdk)
	{
		_ASSERT(0);
		return 1;
	}
	FbxIOSettings* ios = FbxIOSettings::Create(s_psdk, IOSROOT);
	s_psdk->SetIOSettings(ios);
	// Load plugins from the executable directory
	FbxString lPath = FbxGetApplicationDirectory();
#if defined(KARCH_ENV_WIN)
	FbxString lExtension = "dll";
#elif defined(KARCH_ENV_MACOSX)
	FbxString lExtension = "dylib";
#elif defined(KARCH_ENV_LINUX)
	FbxString lExtension = "so";
#endif
	s_psdk->LoadPluginsDirectory(lPath.Buffer(), "dll");


	GUIMenuSetVisible(s_platemenukind, s_platemenuno);


	//if (!s_eventhook) {
	HRESULT hr1 = CoInitialize(NULL);
	if (FAILED(hr1)) {
		//すでに初期化済なだけでエラーリターンするのでそのまま続行する
		//_ASSERT(0);
		//return 1;
	}



	//s_eventhook = SetWinEventHook(
	//	//EVENT_SYSTEM_DIALOGSTART,
	//	//EVENT_SYSTEM_DIALOGSTART,
	//	//EVENT_SYSTEM_DIALOGEND,
	//	EVENT_MIN,
	//	EVENT_MAX,
	//	NULL,
	//	WinEventProc,
	//	//GetDlgItemInt(IDC_PROCESSID),
	//	//GetProcessId(GetModuleHandle(NULL)),
	//	//GetThreadId(g_hUnderTrackingThread),
	//	//GetThreadId(s_messageboxthread),
	//	0,
	//	0,
	//	WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS
	//);
	//IntPtr hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, IntPtr.Zero,
	//	procDelegate, 0, 0, WINEVENT_OUTOFCONTEXT);
	//// MessageBox provides the necessary mesage loop that SetWinEventHook requires.
	//MessageBox.Show("Tracking focus, close message box to exit.");
	////UnhookWinEvent(hhook);
	//}


	//s_iktimerid = (int)::SetTimer(g_mainhwnd, s_iktimerid, 16, NULL);

	//if (g_mainhwnd) {
	//	SetCapture(g_mainhwnd);
	//}

	s_hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);

	if (g_4kresolution) {
		s_dispmodel = true;
		DispModelPanel();
		s_dispmotion = true;
		DispMotionPanel();
		s_dispcamera = true;
		DispCameraPanel();
	}
	
	// ルートシグネチャを作成
	RootSignature rootSignature;
	InitRootSignature(rootSignature);
	//レンダリングエンジンを初期化
	myRenderer::RenderingEngine renderingEngine;
	//renderingEngine.Init();//RenderingEngineのコンストラクタについて分からない部分があるので　Initはコンストラクタで呼んで初期化することにした

	int dbgcount = 0;
	while (DispatchWindowMessage())
	{
		if (s_chascene && (g_underloading == false)) {
			// レンダリング開始
			auto& renderContext = g_graphicsEngine->GetRenderContext();

			//g_camera3D->MoveForward(g_pad[0]->GetLStickYF());
			//g_camera3D->MoveRight(g_pad[0]->GetLStickXF());
			//g_camera3D->MoveUp(g_pad[0]->GetRStickYF());

			//double fTime = 0.0;
			//float fElapsedTime = 0.0;
			if (DXUTGetGlobalTimer()) {
				s_fTime = DXUTGetGlobalTimer()->GetTime();
				s_fElapsedTime = DXUTGetGlobalTimer()->GetElapsedTime();
			}
			CalcFps(s_fTime);

			
			////for tmp check
			//WCHAR strmaintitle[MAX_PATH * 3] = { 0L };
			//int dispfps = (int)(s_avrgfps + 0.5);
			//swprintf_s(strmaintitle, MAX_PATH * 3, L"AdditiveIK Ver1.0.0.1 : No.%d : fps %d", s_appcnt, dispfps);
			//SetWindowText(g_mainhwnd, strmaintitle);


			//ドキュメント更新
			OnUserFrameMove(s_fTime, s_fElapsedTime);

			//ビュー更新
			OnFrameRender(&renderingEngine, &renderContext, s_fTime, s_fElapsedTime);

			if (g_infownd && (dbgcount < 60)) {
				g_infownd->UpdateWindow();//起動時に白くなる不具合に対して　応急処置
			}
			dbgcount++;
		}
	}

	OnDestroyDevice();

	//return DXUTGetExitCode();
	return 0;
}


//--------------------------------------------------------------------------------------
// Initialize the app 
//--------------------------------------------------------------------------------------
int CheckResolution()
{
	g_4kresolution = false;

	/*
	//基準とする大きさ　mainwindowの大きさ
	(1216 + 450) * 2, (950 - MAINMENUAIMBARH) * 2
	*/


	int cXborder = GetSystemMetrics(SM_CXBORDER);
	int cYborder = GetSystemMetrics(SM_CYBORDER);
	int cXFrame = GetSystemMetrics(SM_CXDLGFRAME);
	int cYFrame = GetSystemMetrics(SM_CYDLGFRAME);


	if ((s_appcnt == 0) && (s_launchbyc4 == 0)) {

		HWND desktopwnd;
		desktopwnd = ::GetDesktopWindow();
		if (desktopwnd) {
			RECT desktoprect;
			::GetClientRect(desktopwnd, &desktoprect);
			if ((desktoprect.right >= (s_totalwndwidth * 2)) && (desktoprect.bottom >= ((s_totalwndheight - MAINMENUAIMBARH) * 2))) {

				CSelectLSDlg dlg;
				int dlgret = (int)dlg.DoModal();
				if (dlgret != IDOK) {
					return 1;//キャンセルボタンはアプリ終了
				}
				BOOL selectL = dlg.GetIsLarge();//4K可能の場合には大小を選択可能
								
				if (selectL == TRUE) {
					g_4kresolution = true;//!!!!!!!!!!!!!!!!
					g_zpreflag = true;//2023/12/30 4Kのときだけtrue

					s_modelwindowwidth = 400;
					s_motionwindowwidth = s_modelwindowwidth;
					s_camerawindowwidth = s_modelwindowwidth;

					s_spsize = 80.0f;
					s_spsizeSmall = 50.0f;
					s_sptopmargin = 60.0f;
					s_spsidemargin = 60.0f;

					s_totalwndwidth = (1216 + 450) * 2;
					s_totalwndheight = (950 - MAINMENUAIMBARH) * 2;
					s_2ndposy = 600 * 2;


					//s_timelinewidth = 400 * 2;
					//s_timelinewidth = s_toolwidth;
					s_timelinewidth = 600;
					s_timelineheight = s_2ndposy - MAINMENUAIMBARH;

					s_toolwidth = 400;
					s_toolheight = s_totalwndheight - s_2ndposy - (MAINMENUAIMBARH + 18) * 2 + MAINMENUAIMBARH + 8;

					s_sidemenuwidth = 600;
					s_sidemenuheight = MAINMENUAIMBARH;
					s_sidewidth = s_sidemenuwidth;
					s_sideheight = s_totalwndheight - s_sidemenuheight - 28 * 2 - 4;

					//s_mainwidth = 800 * 2 + 340 + 450 - 64 + 60 - s_modelwindowwidth;
					//s_mainwidth = s_totalwndwidth - s_timelinewidth - s_modelwindowwidth - s_sidewidth - cXFrame * 2 - cXborder * 8;
					s_mainwidth = s_totalwndwidth - s_timelinewidth - s_modelwindowwidth - s_sidewidth - 16;
					s_mainheight = (520 * 2 - MAINMENUAIMBARH);
					
					//s_bufwidth = (800 * 2);
					//s_bufwidth = 800 * 2 + 340 + 450 - 64 + 60 - s_modelwindowwidth;
					s_bufwidth = s_mainwidth;
					s_bufheight = s_mainheight;


					//s_longtimelinewidth = 970 * 2;
					//s_longtimelinewidth = s_mainwidth + s_modelwindowwidth;
					s_longtimelinewidth = s_totalwndwidth - s_toolwidth - s_sidewidth - 16;
					//s_longtimelineheight = (s_totalwndheight - s_2ndposy - MAINMENUAIMBARH - 18) * 2;
					s_longtimelineheight = s_totalwndheight - s_2ndposy - (MAINMENUAIMBARH + 18) * 2 + MAINMENUAIMBARH + 8;

					s_infowinwidth = s_mainwidth;
					s_infowinheight = (s_2ndposy - s_mainheight - MAINMENUAIMBARH);


					s_modelwindowheight = 460;
					s_camerawindowheight = 300;
					s_motionwindowheight = s_mainheight - s_modelwindowheight - s_camerawindowheight + s_infowinheight;


					//s_guibarX0 = s_mainwidth / 2 - 180 - 2 * 180 - 30;
					s_guibarX0 = s_mainwidth / 2 - 130 * 2;

					g_4kresolution = true;

				}
				else {
					g_4kresolution = false;
				}
			}
		}
	}


	if (!g_4kresolution) {
		g_zpreflag = false;//2023/12/30 4Kのときだけtrue


		//s_spsize = 38.0f;
		s_spsize = 32.0f;
		s_spsizeSmall = 22.0f;
		s_sptopmargin = 35.0f;
		s_spsidemargin = 35.0f;

		s_totalwndwidth = (1216 + 450);
		s_totalwndheight = 950;
		s_2ndposy = 600;

		s_modelwindowwidth = 400;
		s_motionwindowwidth = s_modelwindowwidth;
		s_camerawindowwidth = s_modelwindowwidth;

		s_modelwindowheight = 460;
		//s_motionwindowheight = 700;
		s_motionwindowheight = 400;
		s_camerawindowheight = 300;


		s_toolwidth = 230;
		//s_toolheight = 290;
		s_toolheight = s_totalwndheight - s_2ndposy - MAINMENUAIMBARH - 28;

		s_mainwidth = 800 - 64;
		s_mainheight = (520 - MAINMENUAIMBARH);

		s_bufwidth = 800 - 64;
		s_bufheight = (520 - MAINMENUAIMBARH);


		s_timelinewidth = 400;
		s_timelineheight = s_2ndposy - MAINMENUAIMBARH;

		s_longtimelinewidth = 970 - 64;
		s_longtimelineheight = s_toolheight;


		s_infowinwidth = s_mainwidth;
		s_infowinheight = (s_2ndposy - s_mainheight - MAINMENUAIMBARH);

		s_sidemenuwidth = 450 + 64 - 4;
		s_sidemenuheight = MAINMENUAIMBARH;

		s_sidewidth = s_sidemenuwidth;
		s_sideheight = s_totalwndheight - MAINMENUAIMBARH - s_sidemenuheight - 28;

		s_guibarX0 = 120;

	}

	return 0;
}


void InitApp()
{
	s_hhook = NULL;
	g_hWnd = NULL;
	//g_shadertype = -1;//マテリアル毎に設定することに

	InitializeCriticalSection(&s_CritSection_LTimeline);
	InitializeCriticalSection(&g_CritSection_GetGP);
	InitializeCriticalSection(&g_CritSection_FbxSdk);

	InitCommonControls();

	CBone::InitColDisp();

	//g_materialbank.InitParams();

	s_platemenukind = SPPLATEMENUKIND_DISP;
	s_platemenuno = 1;
	s_guiswflag = true;//true : １段目メニュー内容を右ペインに. false : ２段目メニュー内容を右ペインに
	s_guiswplateno = 1;

	g_hdrpbloom = true;
	g_freefps = true;
	s_befftime = 0.0;
	s_mousemoveBefTime = 0.0;
	g_dspeed = 1.0;//2024/01/13  3.0-->1.0に変更
	g_physicsmvrate = 0.3f;


	g_uvset = 0;
	g_bonemark_bright = 1.0f;//inifile読み込み処理で上書きされる
	g_rigidmark_alpha = 0.75f;//inifile読み込み処理で上書きされる
	g_rigmark_alpha = 0.75f;//inifile読み込み処理で上書きされる

	g_boneaxis = BONEAXIS_CURRENT;


	g_lodrate2L[CHKINVIEW_LOD0] = 0.05f;//rate * projfar.  distance of clipping
	g_lodrate2L[CHKINVIEW_LOD1] = 1.0f;
	g_lodrate2L[CHKINVIEW_LOD2] = 1.0f;

	g_lodrate3L[CHKINVIEW_LOD0] = 0.05f;//rate * projfar.  distance of clipping
	g_lodrate3L[CHKINVIEW_LOD1] = 0.15f;
	g_lodrate3L[CHKINVIEW_LOD2] = 1.0f;


	{
		s_spritetex0 = 0;
		s_spritetex1 = 0;
		s_spritetex2 = 0;
		s_spritetex3 = 0;
		s_spritetex4 = 0;
		s_spritetex5 = 0;
		s_spritetex6 = 0;
		s_spritetex7 = 0;
		s_spritetex8 = 0;
		s_spritetex9 = 0;
		s_spritetex10 = 0;
		s_spritetex11 = 0;
		s_spritetex12 = 0;
		s_spritetex13 = 0;
		s_spritetex14 = 0;
		s_spritetex15 = 0;
		s_spritetex16 = 0;
		s_spritetex17 = 0;
		s_spritetex18 = 0;
		s_spritetex19 = 0;
		s_spritetex20 = 0;
		s_spritetex21 = 0;
		s_spritetex22 = 0;
		s_spritetex23 = 0;
		s_spritetex24 = 0;
		s_spritetex25 = 0;
		s_spritetex26 = 0;
		s_spritetex27 = 0;
		s_spritetex28 = 0;
		s_spritetex29 = 0;
		s_spritetex30 = 0;
		s_spritetex31 = 0;
		s_spritetex32 = 0;
		s_spritetex33 = 0;
		s_spritetex34 = 0;
		s_spritetex35 = 0;
		s_spritetex36 = 0;
		s_spritetex37 = 0;
		s_spritetex37_1 = 0;
		s_spritetex38 = 0;
		s_spritetex39 = 0;
		s_spritetex40 = 0;
		s_spritetex40_1 = 0;
		s_spritetex41 = 0;
		s_spritetex42 = 0;
		s_spritetex43 = 0;
		s_spritetex44 = 0;
		s_spritetex45 = 0;
		s_spritetex46 = 0;
		s_spritetex47 = 0;
		s_spritetex48 = 0;
		s_spritetex49 = 0;
		s_spritetex50 = 0;
		s_spritetex51 = 0;
		s_spritetex52 = 0;
		s_spritetex53 = 0;
		s_spritetex54 = 0;
		s_spritetex55 = 0;
		s_spritetex56 = 0;
		s_spritetex57 = 0;
		s_spritetex58 = 0;
		s_spritetex59 = 0;
		s_spritetex60 = 0;
		s_spritetex61 = 0;
		s_spritetex62 = 0;
		s_spritetex63 = 0;
		s_spritetex64 = 0;
		s_spritetex65 = 0;
		s_spritetex66 = 0;
		s_spritetex67 = 0;
		s_spritetex68 = 0;
		s_spritetex69 = 0;
		s_spritetex70 = 0;
		s_spritetex71 = 0;
		s_spritetex72 = 0;
		s_spritetex73 = 0;
		s_spritetex74 = 0;
		s_spritetex75 = 0;
		s_spritetex76 = 0;
		s_spritetex77 = 0;
		s_spritetex78 = 0;
		s_spritetex79 = 0;
		s_spritetex80 = 0;
		s_spritetex81 = 0;
	}

	{
		g_enableshadow = true;
		g_shadowmapforshader = nullptr;
		g_shadowmap_slotno = 0;
		int slotno;
		for (slotno = 0; slotno < SHADOWSLOTNUM; slotno++) {
			g_shadowmap_fov[slotno] = 60.0f;
			g_shadowmap_projscale[slotno] = 1.0f;
			g_shadowmap_near[slotno] = 50.0f;
			g_shadowmap_far[slotno] = 2000.0f;
			g_shadowmap_color[slotno] = 0.5f;
			g_shadowmap_bias[slotno] = 0.0010f;
			g_shadowmap_plusup[slotno] = 300.0f;
			g_shadowmap_distscale[slotno] = 1.0f;
			g_shadowmap_lightdir[slotno] = 1;
		}
	}

	s_chascene = 0;

	s_dispfontfottip = false;
	ZeroMemory(s_strfortip, sizeof(WCHAR) * 512);
	s_fontposfortip = Vector2(0.0f, 0.0f);
	s_fontfortip.SetShadowParam(true, 1.0, 
		Vector4(15.0f / 255.0f, 77.0f / 255.0f, 33.0f / 255.0f, 1.0f));//font縁取り設定


	s_coldlg.InitParams();
	s_selbonedlgmap.clear();

	s_utcontrolvisible = true;

	s_cancelLButtonDown = false;
	s_cancelRButtonDown = false;

	//########################################################################
	// s_mainwidth, s_mainheightはInitApp()よりも前にCheckResolution()でセットする
	// ここでs_mainwidth, s_mainheightを初期化してはいけない
	//########################################################################
	//s_mainwidth = 800;
	//s_mainheight = (520 - MAINMENUAIMBARH);
	//s_bufwidth = 800;
	//s_bufheight = (520 - MAINMENUAIMBARH);

	//{
	//	g_hRenderBoneL0 = 0;
	//	g_hRenderBoneL1 = 0;
	//	g_hRenderBoneL2 = 0;
	//	g_hRenderBoneL3 = 0;
	//	g_hRenderBoneL4 = 0;
	//	g_hRenderBoneL5 = 0;
	//	g_hRenderBoneL6 = 0;
	//	g_hRenderBoneL7 = 0;
	//	g_hRenderBoneL8 = 0;
	//	g_hRenderNoBoneL0 = 0;
	//	g_hRenderNoBoneL1 = 0;
	//	g_hRenderNoBoneL2 = 0;
	//	g_hRenderNoBoneL3 = 0;
	//	g_hRenderNoBoneL4 = 0;
	//	g_hRenderNoBoneL5 = 0;
	//	g_hRenderNoBoneL6 = 0;
	//	g_hRenderNoBoneL7 = 0;
	//	g_hRenderNoBoneL8 = 0;
	//	g_hRenderLine = 0;
	//	g_hRenderSprite = 0;

	//	g_hm4x4Mat = 0;
	//	g_hmWorld = 0;
	//	g_hmVP = 0;

	//	g_hEyePos = 0;
	//	g_hnNumLight = 0;
	//	g_hLightDir = 0;
	//	g_hLightDiffuse = 0;
	//	g_hLightAmbient = 0;
	//	g_hSpriteOffset = 0;
	//	g_hSpriteScale = 0;
	//	g_hPm3Scale = 0;
	//	g_hPm3Offset = 0;


	//	g_hdiffuse = 0;
	//	g_hambient = 0;
	//	g_hspecular = 0;
	//	g_hpower = 0;
	//	g_hemissive = 0;
	//	g_hMeshTexture = 0;
	//}


	g_controlkey = false;
	g_shiftkey = false;
	g_ctrlshiftkeyformb = false;//ForMiddleButton
	s_skey = false;

	//////check
	//WCHAR strchk[256] = { 0L };
	//swprintf_s(strchk, 256, L"NULL == %p\nINVALID_HANDLE_VALUE == %p", NULL, INVALID_HANDLE_VALUE);
	//::MessageBox(NULL, strchk, L"check", MB_OK);

	{
		s_matred = 0;// = s_select->GetMQOMaterialByName("matred");
		s_ringred = 0;// = s_select->GetMQOMaterialByName("ringred");
		s_matblue = 0;// = s_select->GetMQOMaterialByName("matblue");
		s_ringblue = 0;// = s_select->GetMQOMaterialByName("ringblue");
		s_matgreen = 0;// = s_select->GetMQOMaterialByName("matgreen");
		s_ringgreen = 0;// = s_select->GetMQOMaterialByName("ringgreen");
		s_matyellow = 0;// = s_select->GetMQOMaterialByName("matyellow");
		s_selectobj_objx = 0;
		s_selectobj_objy = 0;
		s_selectobj_objz = 0;
		s_selectobj_ringx = 0;
		s_selectobj_ringy = 0;
		s_selectobj_ringz = 0;
		s_selectobj_center = 0;
		s_matredmat = ChaVector4(1.0f, 0.0f, 0.0f, 1.0f);
		s_ringredmat = ChaVector4(1.0f, 0.0f, 0.0f, 1.0f);
		s_matbluemat = ChaVector4(0.0f, 0.0f, 1.0f, 1.0f);
		s_ringbluemat = ChaVector4(0.0f, 0.0f, 1.0f, 1.0f);
		s_matgreenmat = ChaVector4(0.0f, 1.0f, 0.0f, 1.0f);
		s_ringgreenmat = ChaVector4(0.0f, 1.0f, 0.0f, 1.0f);
		s_matyellowmat = ChaVector4(1.0f, 1.0f, 0.0f, 1.0f);
		s_ringyellowmat = ChaVector4(1.0f, 1.0f, 0.0f, 1.0f);
	}


	s_rigopemark_sphere = nullptr;
	s_rigopemark_ringX = nullptr;
	s_rigopemark_ringY = nullptr;
	s_rigopemark_ringZ = nullptr;
	//::ZeroMemory(s_rigmaterial_sphere, sizeof(CMQOMaterial*) * (RIGMULTINDEXMAX + 1));
	//::ZeroMemory(s_rigmaterial_ringX, sizeof(CMQOMaterial*) * (RIGMULTINDEXMAX + 1));
	//::ZeroMemory(s_rigmaterial_ringY, sizeof(CMQOMaterial*) * (RIGMULTINDEXMAX + 1));
	//::ZeroMemory(s_rigmaterial_ringZ, sizeof(CMQOMaterial*) * (RIGMULTINDEXMAX + 1));
	s_matrigmat = ChaVector4(255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f);


	s_curmotid = -1;
	s_curboneno = -1;
	s_saveboneno = -1;
	s_curbaseno = -1;


	//select joint using shortcutkey
	s_selecthand = 0;
	s_selectfoot = 0;



	s_tiprigboneno = -1;
	s_tiprigno = -1;
	s_tooltipdispcount = 0;
	s_tooltiplen = 0;

	//g_edgesmp = false;


	g_previewFlag = 0;
	s_savepreviewFlag = 0;
	g_cameraanimmode = 0;//0: OFF, 1:ON
	s_savecameraanimmode = 0;
	g_cameraInheritMode = CAMERA_INHERIT_ALL;
	s_saveCameraInheritMode = g_cameraInheritMode;

	s_camtargetflag = 0;
	s_camtargetOnceflag = 0;

	{
		s_twistcameraFlag = false;
		s_rbuttonSelectFlag = false;
		s_cameraframe = 0.0;
		g_cameraupdir = ChaVector3(0.0f, 1.0f, 0.0f);

		g_initcamdist = 50.0f;
		g_camdist = g_initcamdist;
		g_projnear = 0.01f;
		g_projfar = g_initcamdist * 100.0f;
		s_fAspectRatio = 1.0f;
		g_fovy = (float)(PI / 4.0);
		s_cammvstep = 100.0f;
	}

	{
		s_model = NULL;
		s_curmodelmenuindex = -1;
		s_cameramodel = NULL;//2023/05/23
		s_select = NULL;
		s_select_posture = NULL;
		s_bmark = NULL;
		s_ground = NULL;
		s_gplane = NULL;
	}




	s_layerWnd = 0;
	s_owpLayerTable = 0;
	

	{
		s_groupWnd = 0;
		s_groupSCWnd = 0;
		s_groupsp0 = 0;
		s_groupsp = 0;
		s_groupsp1 = 0;
		s_groupsp2 = 0;
		s_groupsp3 = 0;
		ZeroMemory(s_groupselect, sizeof(OWP_CheckBoxA*)* MAXDISPGROUPNUM);
		s_groupsetB = 0;
		s_groupgetB = 0;
		s_grouponB = 0;
		s_groupoffB = 0;
		s_grouplabel11 = 0;
		s_grouplabel12 = 0;
		s_grouplabel21 = 0;
		s_grouplabel22 = 0;
		s_groupUnderGetting = false;//s_groupgetBボタンの処理中は　groupobjvecのチェック処理をスキップ
		//ZeroMemory(s_groupobj, sizeof(OWP_CheckBoxA*) * MAXDISPOBJNUM);
		//ZeroMemory(s_grouptestB, sizeof(OWP_Button*)* MAXDISPOBJNUM);
		s_groupobjvec.clear();
		s_grouptestBvec.clear();

		s_grouplinenum = 0;
		s_disponlyoneobj = false;//for test button of groupWnd
		s_onlyoneobjno = -1;//for test button of groupWnd
	}


	{
		s_shadertypeparamsFlag = false;
		s_shadertypeparamsindex = -1;//index==0は全てのマテリアルに設定. それ以外はindex - 1のマテリアルに設定

		s_shadertypeWnd = 0;
		s_SCshadertype = 0;

		s_shadersp1 = 0;
		s_shadersp2 = 0;
		s_shadersp3 = 0;

		s_modelnamelabel = 0;

		//+1は見出しの分
		int objno;
		for (objno = 0; objno < (MAXMATERIALNUM + 1); objno++) {
			s_materialnameB[objno] = 0;//+1は見出しの分
			s_shadertypelabel[objno] = 0;//+1は見出しの分
			s_metalcoeflabel[objno] = 0;//+1は見出しの分
			s_lightscalelabel[objno] = 0;//+1は見出しの分
		}
	}


	{
		s_placefolderWnd = 0;
		//s_placefolderlabel_1 = 0;
		//s_placefolderlabel_2 = 0;
		//s_placefolderlabel_3 = 0;
		ZeroMemory(s_shortcuttext, sizeof(OWP_Label*) * SHORTCUTTEXTNUM);
	}


	s_cameradollyFlag = false;
	s_materialrateFlag = false;
	s_modelworldmatFlag = false;

	g_zpreflag = false;
	g_zcmpalways = false;
	g_lightflag = 1;

	//g_btcalccnt = 2.0;
	g_btcalccnt = 1.0;//2023/11/04 物理ダブルバッファ化で表示速度が速くなったので　2だった値を1に変更

	s_befdeltax = 0.0f;

	g_rotatetanim = true;
	g_tpose = true;
	g_preciseOnPreviewToo = false;
	g_x180flag = false;

	g_refposstep = 10;
	g_refalpha = 50;

	g_underloading = false;
	//g_underIKRot = false;
	//g_underIKRotApplyFrame = false;
	g_fpsforce30 = false;
	//g_underRetargetFlag = false;
	s_retargetguiFlag = false;
	s_smoothBefRetarget = false;

	g_underWriteFbx = false;
	//g_underCalcEul = false;
	//g_underPostFKTra = false;
	//g_underInitMp = false;
	//g_underCopyW2LW = false;
	g_changeUpdateThreadsNum = false;

	g_VSync = false;
	g_fpskind = 0;

	g_rotatetanim = false;
	g_HighRpmMode = true;//2023/12/30 起動時にオン
	g_UpdateMatrixThreads = 2;


	s_fTime = 0.0;
	s_fElapsedTime = 0.0;

	int saveno;
	for (saveno = 0; saveno < FPSSAVENUM; saveno++) {
		s_fps100[saveno] = 60.0;
	}
	s_fps100index = 0;
	s_avrgfps = 0.0;

	s_utBrushRepeatsFlag = false;//UTDialogのBrushRepeatsスライダー値変更
	s_utApplyRateFlag = false;//UTDialogのApplyRateスライダー値変更
	s_BrushMirrorUCheckBoxFlag = false;//UTDialogの
	s_BrushMirrorVCheckBoxFlag = false;//UTDialogの
	s_IfMirrorVDiv2CheckBoxFlag = false;//UTDialogの
	s_LimitDegCheckBoxFlag = false;
	s_WallScrapingCheckBoxFlag = false;

	//s_totalmb.center = ChaVector3(0.0f, 0.0f, 0.0f);
	//s_totalmb.max = ChaVector3(5.0f, 5.0f, 5.0f);
	//s_totalmb.min = ChaVector3(-5.0f, -5.0f, -5.0f);
	//s_totalmb.r = (float)ChaVector3LengthDbl(&s_totalmb.max);

	//s_undosprite = 0;
	//s_fpssprite = 0;


	g_wallscrapingikflag = 0;

	s_ikkind = 0;


	//g_wmatDirectSetFlag = false;
	g_limitdegflag = false;
	s_beflimitdegflag = g_limitdegflag;
	s_savelimitdegflag = g_limitdegflag;


	s_progressnum = 0;
	s_progresscnt = 0;
	s_progressmodelnum = 0;
	s_progressmodelcnt = 0;
	s_befprogressnum = 0;
	s_befprogresscnt = 0;
	s_befprogressmodelnum = 0;
	s_befprogressmodelcnt = 0;


	//g_ClearColorIndex = 0;//inifileで読み込み
	//g_ClearColor[BGCOL_MAX][4] = {
	//	{0.0f, 0.0f, 0.0f, 1.0f},
	//	{1.0f, 1.0f, 1.0f, 1.0f},
	//	{0.0f, 0.0f, 1.0f, 1.0f},
	//	{0.0f, 0.5f, 0.25f, 1.0f},
	//	{1.0f, 0.5f, 0.5f, 1.0f}
	//};
	g_ClearColor[BGCOL_BLACK][0] = 0.0f;
	g_ClearColor[BGCOL_BLACK][1] = 0.0f;
	g_ClearColor[BGCOL_BLACK][2] = 0.0f;
	g_ClearColor[BGCOL_BLACK][3] = 1.0f;
	g_ClearColor[BGCOL_WHITE][0] = 1.0f;
	g_ClearColor[BGCOL_WHITE][1] = 1.0f;
	g_ClearColor[BGCOL_WHITE][2] = 1.0f;
	g_ClearColor[BGCOL_WHITE][3] = 1.0f;
	g_ClearColor[BGCOL_BLUE][0] = 0.0f;
	g_ClearColor[BGCOL_BLUE][1] = 0.0f;
	g_ClearColor[BGCOL_BLUE][2] = 1.0f;
	g_ClearColor[BGCOL_BLUE][3] = 1.0f;
	g_ClearColor[BGCOL_GREEN][0] = 0.0f;
	g_ClearColor[BGCOL_GREEN][1] = 0.5f;
	g_ClearColor[BGCOL_GREEN][2] = 0.25f;
	g_ClearColor[BGCOL_GREEN][3] = 1.0f;
	g_ClearColor[BGCOL_RED][0] = 1.0f;
	g_ClearColor[BGCOL_RED][1] = 0.5f;
	g_ClearColor[BGCOL_RED][2] = 0.5f;
	g_ClearColor[BGCOL_RED][3] = 1.0f;
	g_ClearColor[BGCOL_GRAY][0] = 0.5f;
	g_ClearColor[BGCOL_GRAY][1] = 0.5f;
	g_ClearColor[BGCOL_GRAY][2] = 0.5f;
	g_ClearColor[BGCOL_GRAY][3] = 1.0f;



	s_firstmodelpanelpos = true;
	s_modelpanelpos = WindowPos(0, 0);;
	s_firstmotionpanelpos = true;
	s_motionpanelpos = WindowPos(0, 0);;
	s_firstcamerapanelpos = true;
	s_camerapanelpos = WindowPos(0, 0);;



	s_opedelmodelcnt = -1;
	s_opedelmotioncnt = -1;
	s_underdelmodel = false;
	s_underdelmotion = false;
	s_opeselectmodelcnt = -1;
	s_opeselectcameracnt = -1;
	s_opeselectmotioncnt = -1;
	s_underselectmodel = false;
	s_underselectcamera = false;
	s_underselectmotion = false;
	s_underfilteringbymenu = false;
	s_underanglelimithscroll = 0;
	s_underdispmodel = false;
	s_opedispmodelcnt = -1;


	s_dispanglelimit = false;
	s_dispsampleui = true;
	s_dispmw = true;
	s_disptool = true;
	s_dispobj = false;
	s_dispmodel = false;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
	s_dispmotion = false;//!!!!!!!!!!!!!!!! motionpanelのdispflag
	s_dispcamera = false;//!!!!!!!!!!!!!!!! camerapanelのdispflag
	s_dispground = true;
	s_dispselect = true;
	//s_displightarrow = true;
	s_dispconvbone = false;

	s_oprigflag = 0;

	s_tkeyflag = 0;//bone twist
	s_closeFlag = false;			// 終了フラグ
	s_closetoolFlag = false;
	s_closeobjFlag = false;
	s_closemodelFlag = false;
	s_closemotionFlag = false;
	s_closecameraFlag = false;
	s_closeconvboneFlag = false;
	s_DcloseFlag = false;
	s_RcloseFlag = false;
	s_ScloseFlag = false;
	s_IcloseFlag = false;
	s_GcloseFlag = false;
	s_undoFlag = false;
	s_redoFlag = false;
	s_undoredoFromPlayerButton = false;
	s_frogFlag = false;
	s_plateFlag = false;
	s_copyFlag = false;			// コピーフラグ
	s_copyLW2WFlag = false;
	s_changelimitangleFlag = false;
	s_zeroFrameFlag = false;
	//s_oneFrameFlag = false;
	s_selCopyHisotryFlag = false;
	s_symcopyFlag = false;
	s_symcopyFlag2 = false;
	s_undersymcopyFlag = false;
	s_cutFlag = false;			// カットフラグ
	s_pasteFlag = false;			// ペーストフラグ
	s_cursorFlag = false;			// カーソル移動フラグ
	s_selectFlag = false;			// キー選択フラグ
	s_keyShiftFlag = false;		// キー移動フラグ
	s_deleteFlag = false;		// キー削除フラグ
	s_motpropFlag = false;
	s_markFlag = false;
	s_selboneFlag = false;
	s_selboneAndPasteFlag = false;
	s_RboneAndPasteFlag = false;
	s_initmpFlag = false;
	s_filterFlag = false;
	s_filterState = 0;
	s_smoothFlag = false;
	s_constexeFlag = false;
	s_constrefreshFlag = false;
	//s_filternodlg = false;
	s_interpolateFlag = false;
	s_interpolateState = 0;
	s_skipJointMark = 0;
	s_firstkeyFlag = false;
	s_lastkeyFlag = false;
	s_btresetFlag = false;
	s_LcloseFlag = false;
	s_LnextkeyFlag = false;
	s_LbefkeyFlag = false;
	s_LcursorFlag = false;			// カーソル移動フラグ
	s_LupFlag = false;
	s_LstartFlag = false;
	s_LstopFlag = false;
	//s_LstopDoneCount = 0;
	s_EcursorFlag = false;			// カーソル移動フラグ
	s_timelineRUpFlag = false;
	s_timelinembuttonFlag = false;
	s_delmodelFlag = false;
	s_delallmodelFlag = false;
	s_mbuttoncnt = 1;
	s_mbuttonstart = 0.0;
	s_timelinewheelFlag = false;
	s_timelineshowposFlag = false;
	s_prevrangeFlag = false;
	s_nextrangeFlag = false;
	s_changeupdatethreadsFlag = false;
	s_newmotFlag = false;
	s_delcurmotFlag = false;
	s_calclimitedwmState = 0;
	s_180DegFlag = false;
	s_scaleAllInitFlag = false;
	s_checksimilarFlag = false;
	s_checksimilarobjno = 0;

	s_temppath[0] = 0L;
	::GetTempPathW(MAX_PATH, s_temppath);
	_ASSERT(s_temppath[0]);
	s_cptfilename.clear();
	GetCPTFileName(s_cptfilename);//s_temppathセットより後。初回。


	LoadChooseColor();//s_temppathのセットよりも後


	InitDSValues();

	s_onselectplugin = 0;
	s_plugin = 0;

	//s_onefps = 0;

	s_rectime = 0.0;
	s_reccnt = 0;
	g_btsimurecflag = false;

	s_bvh2fbxhandle1 = INVALID_HANDLE_VALUE;
	s_bvh2fbxhandle2 = INVALID_HANDLE_VALUE;
	s_bvh2fbxnum = 0;
	s_bvh2fbxcnt = 0;
	s_befbvh2fbxnum = 0;
	s_befbvh2fbxcnt = 0;
	g_bvh2fbxbatchflag = 0;
	s_bvh2fbxbatchwnd = 0;
	s_bvh2fbxout.clear();

	s_saveretargetmodel = 0;
	s_convbone_model_batch_selindex = 0;
	s_retargethandle1 = INVALID_HANDLE_VALUE;
	s_retargethandle2 = INVALID_HANDLE_VALUE;
	s_retargetnum = 0;
	s_retargetcnt = 0;
	s_befretargetnum = 0;
	s_befretargetcnt = 0;
	g_retargetbatchflag = 0;
	s_retargetbatchwnd = 0;
	s_retargetout.clear();

	g_calclimitedwmflag = 0;

	g_mousehereimage = 0;
	g_menuaimbarimage = 0;
	g_currentsubmenuid = 0;
	g_currentsubmenupos.x = 0;
	g_currentsubmenupos.y = 0;

	g_submenuwidth = 32;

	g_filterdlghwnd = 0;

	Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

	s_cursubmenu = 0;

	g_dsmousewait = 0;
	g_mouseherebmp = 0;
	g_tranbmp = 0;

	s_sampleuihwnd = 0;
	s_nowloading = true;

	s_getsym_retmode = 0;

	s_rcmainwnd.top = 0;
	s_rcmainwnd.left = 0;
	s_rcmainwnd.bottom = 0;
	s_rcmainwnd.right = 0;
	s_rc3dwnd.top = 0;
	s_rc3dwnd.left = 0;
	s_rc3dwnd.bottom = 0;
	s_rc3dwnd.right = 0;
	s_rctreewnd.top = 0;
	s_rctreewnd.left = 0;
	s_rctreewnd.bottom = 0;
	s_rctreewnd.right = 0;
	s_rctoolwnd.top = 0;
	s_rctoolwnd.left = 0;
	s_rctoolwnd.bottom = 0;
	s_rctoolwnd.right = 0;
	s_rcltwnd.top = 0;
	s_rcltwnd.left = 0;
	s_rcltwnd.bottom = 0;
	s_rcltwnd.right = 0;
	s_rcsidemenuwnd.top = 0;
	s_rcsidemenuwnd.left = 0;
	s_rcsidemenuwnd.bottom = 0;
	s_rcsidemenuwnd.right = 0;
	s_rcrigidwnd.top = 0;
	s_rcrigidwnd.left = 0;
	s_rcrigidwnd.bottom = 0;
	s_rcrigidwnd.right = 0;
	s_rcshadertypewnd.top = 0;
	s_rcshadertypewnd.left = 0;
	s_rcshadertypewnd.bottom = 0;
	s_rcshadertypewnd.right = 0;
	s_rcinfownd.top = 0;
	s_rcinfownd.left = 0;
	s_rcinfownd.bottom = 0;
	s_rcinfownd.right = 0;
	s_rcmainmenuaimbarwnd.top = 0;
	s_rcmainmenuaimbarwnd.left = 0;
	s_rcmainmenuaimbarwnd.bottom = 0;
	s_rcmainmenuaimbarwnd.right = 0;
	s_rcmodelpanel.top = 0;
	s_rcmodelpanel.left = 0;
	s_rcmodelpanel.bottom = 0;
	s_rcmodelpanel.right = 0;
	s_rcmotionpanel.top = 0;
	s_rcmotionpanel.left = 0;
	s_rcmotionpanel.bottom = 0;
	s_rcmotionpanel.right = 0;
	s_rccamerapanel.top = 0;
	s_rccamerapanel.left = 0;
	s_rccamerapanel.bottom = 0;
	s_rccamerapanel.right = 0;


	//s_CamTargetCheckBox = 0;
	////s_LightCheckBox = 0;
	//s_ApplyEndCheckBox = 0;
	////s_SlerpOffCheckBox = 0;
	////s_AbsIKCheckBox = 0;
	//s_HighRpmCheckBox = 0;
	//s_BoneMarkCheckBox = 0;
	//s_LightingCheckBox = 0;
	//s_RigidMarkCheckBox = 0;
	////s_PseudoLocalCheckBox = 0;
	////s_WallScrapingIKCheckBox = 0;
	////s_LimitDegCheckBox = 0;
	//s_BrushMirrorUCheckBox = 0;
	//s_BrushMirrorVCheckBox = 0;
	//s_IfMirrorVDiv2CheckBox = 0;
	////s_VSyncCheckBox = 0;
	//s_TraRotCheckBox = 0;
	////s_EdgeSmpCheckBox = 0;
	//s_PreciseCheckBox = 0;
	//s_X180CheckBox = 0;
	//s_TPoseCheckBox = 0;
	//s_TipText1 = 0;
	//s_TipText2 = 0;
	//s_TipText3 = 0;
	//s_TipText4 = 0;
	//s_TipText5 = 0;

	////Left
	//s_ui_fpskind = 0;
	//s_ui_lightscale = 0;
	//s_ui_lighting = 0;
	//s_ui_dispbone = 0;
	//s_ui_disprigid = 0;
	//s_ui_boneaxis = 0;
	//s_ui_bone = 0;
	//s_ui_locktosel = 0;
	//s_ui_iklevel = 0;
	//s_ui_editmode = 0;
	//s_ui_texapplyrate = 0;
	//s_ui_slapplyrate = 0;
	//s_ui_motionbrush = 0;
	//s_ui_texikorder = 0;
	//s_ui_slikorder = 0;
	////s_ui_texikrate = 0;
	////s_ui_slikrate = 0;
	//s_ui_texref = 0;
	//s_ui_slirefpos = 0;
	//s_ui_slirefalpha = 0;
	//s_ui_applytotheend = 0;
	//s_ui_slerpoff = 0;
	////s_ui_absikon = 0;
	//s_ui_highrpmon = 0;
	//s_ui_texbrushrepeats = 0;
	//s_ui_brushrepeats = 0;
	//s_ui_brushmirroru = 0;
	//s_ui_brushmirrorv = 0;
	//s_ui_ifmirrorvdiv2 = 0;

	////Left 2nd
	//s_ui_texthreadnum = 0;
	//s_ui_slthreadnum = 0;
	//s_ui_umthreads = 0;
	//s_ui_slumthreads = 0;
	////s_ui_pseudolocal = 0;
	//s_ui_wallscrapingik = 0;
	//s_ui_limiteul = 0;
	//s_ui_texspeed = 0;
	//s_ui_speed = 0;
	////s_ui_vsync = 0;
	//s_ui_trarot = 0;
	////s_ui_edgesmp = 0;
	//s_ui_precise = 0;
	//s_ui_x180 = 0;
	//s_ui_tpose = 0;

	////Bullet
	//s_ui_btstart = 0;
	//s_ui_btrecstart = 0;
	//s_ui_stopbt = 0;
	//s_ui_texbtcalccnt = 0;
	//s_ui_btcalccnt = 0;
	//s_ui_texerp = 0;
	//s_ui_erp = 0;
	////PhysicsIK
	//s_ui_texphysmv = 0;
	//s_ui_slphysmv = 0;
	//s_ui_physrotstart = 0;
	//s_ui_physmvstart = 0;
	//s_ui_physikstop = 0;



	//bool bsuccess1 = false;
	//bool bsuccess2 = false;
	//if ((s_appcnt == 0) && (s_launchbyc4 == 0)) {//C4から起動時にはゲームパッド未対応。//2021/08/30
	//	bsuccess1 = StartDS4();
	//}
	//else {
	//	bsuccess1 = false;
	//}
	//if (bsuccess1) {
	//	bsuccess2 = GetController();
	//}
	//if (bsuccess1 && bsuccess2) {
	//	g_enableDS = true;
	//	s_dsdeviceid = 0;
	//	s_curaimbarno = 0;
	//}
	//else {
		g_enableDS = false;
		s_dsdeviceid = -1;
		s_curaimbarno = -1;
	//}


	CRigidElem::InitRigidElems();
	CBone::InitBones();
	CMotionPoint::InitMotionPoints();
	OrgWinGUI::InitEulKeys();
	OrgWinGUI::InitKeys();

	s_motmenuindexmap.clear();
	s_cameramenuindexmap.clear();
	s_reindexmap.clear();
	s_rgdindexmap.clear();

	s_anglelimitbone = 0;
	s_anglelimitdlg = 0;
	s_anglelimit.Init();
	s_anglelimitcopy.Init();


	s_lightsforeditdlg = 0;
	s_latertransparentdlg = 0;
	s_shadowparamsdlg = 0;
	int dlgno;
	for (dlgno = 0; dlgno < GUIDLGNUM; dlgno++) {
		s_guidlg[GUIDLGNUM] = nullptr;
	}
	

	s_rotaxisdlg = 0;

	g_motionbrush_method = 0;
	g_motionbrush_startframe = 0.0;
	g_motionbrush_endframe = 0.0;
	g_motionbrush_applyframe = 0.0;
	g_motionbrush_numframe = 0.0;
	g_motionbrush_frameleng = 0;
	g_motionbrush_value = 0;

	s_timelineWnd = 0;
	s_owpTimeline = 0;
	s_owpPlayerButton = 0;
	s_parentcheck = 0;
	s_LtimelineWnd = 0;
	s_owpLTimeline = 0;
	s_owpEulerGraph = 0;
	s_LTSeparator = 0;
	s_sidemenusp = 0;
	s_sidemenusp1 = 0;
	s_sidemenusp2 = 0;

	s_mainmenuaimbarWnd = 0;
	s_mainmenulabel = 0;

	s_toolWnd = 0;
	s_toolSeparator = 0;
	s_toolCopyB = 0;
	s_toolZeroFrameB = 0;
	s_toolSymCopyB = 0;
	s_toolCutB = 0;
	s_toolPasteB = 0;
	s_toolDeleteB = 0;
	s_toolMotPropB = 0;
	s_toolMarkB = 0;
	s_toolSelBoneB = 0;
	s_toolInitMPB = 0;
	s_toolFilterB = 0;
	s_toolInterpolateB = 0;
	s_toolSelectCopyFileName = 0;
	s_toolSkipRenderBoneMarkB = 0;
	s_toolSkipRenderBoneMarkB2 = 0;
	s_tool180deg = 0;
	s_toolScaleInitAllB = 0;
	s_toolCameraDollyB = 0;
	s_toolMaterialRateB = 0;
	s_toolModelWorldMatB = 0;

	s_customrigbone = 0;
	s_customrigdlg = 0;

	g_underselectingframe = 0;
	s_buttonselectstart = 0.0;
	s_buttonselectend = 0.0;

	g_playingstart = 1.0;
	g_playingend = 1.0;

	s_editrangehistoryno = 0;
	s_editrangesetindex = 0;
	s_editrangehistory = new CEditRange[EDITRANGEHISTORYNUM];
	if (!s_editrangehistory) {
		_ASSERT(0);
		return;
	}
	int erhno;
	for (erhno = 0; erhno < EDITRANGEHISTORYNUM; erhno++) {
		(s_editrangehistory + erhno)->Clear();
	}

	ChaMatrixIdentity(&s_selectmat);
	ChaMatrixIdentity(&s_selectmat_posture);
	ChaMatrixIdentity(&s_ikselectmat);
	s_selectuserscale = 100;


	s_convbone_model = 0;
	s_convbone_model_batch = 0;
	s_convbone_bvh = 0;
	s_maxboneno = 0;
	int cbno;
	for (cbno = 0; cbno < MAXBONENUM; cbno++) {
		s_modelbone[cbno] = 0;
		s_bvhbone[cbno] = 0;
		s_modelbone_bone[cbno] = 0;
		s_bvhbone_bone[cbno] = 0;
	}
	s_convbonemidashi[0] = 0;
	s_convbonemidashi[1] = 0;
	s_convbonemap.clear();

	s_bvhbone_cbno = 0;


	{
		s_toolspritemode = 0;
		//::ZeroMemory(s_spundo, sizeof(CSpElem) * 2);
		//::ZeroMemory(s_spaxis, sizeof(SPAXIS) * SPAXISNUM);
		//::ZeroMemory(s_spcam, sizeof(SPCAM) * SPR_CAM_MAX);
		//::ZeroMemory(s_sprig, sizeof(CSpElem) * SPRIGMAX);
		//::ZeroMemory(&s_spbt, sizeof(CSpElem));
		//::ZeroMemory(&s_spmousehere, sizeof(CSpElem));
		//::ZeroMemory(&s_spret2prev, sizeof(CSpElem));
		//::ZeroMemory(&s_spret2prev2, sizeof(CSpElem));
		//::ZeroMemory(&s_spcplw2w, sizeof(CSpElem));
		//::ZeroMemory(&s_spsmooth, sizeof(CSpElem));
		//::ZeroMemory(&s_spconstexe, sizeof(CSpElem));
		//::ZeroMemory(&s_spconstrefresh, sizeof(CSpElem));
		//::ZeroMemory(&s_spcopy, sizeof(CSpElem));
		//::ZeroMemory(&s_spsymcopy, sizeof(CSpElem));
		//::ZeroMemory(&s_sppaste, sizeof(CSpElem));
		//::ZeroMemory(&s_spcopyhistory, sizeof(CSpElem));
		//::ZeroMemory(&s_spinterpolate, sizeof(CSpElem));
		//::ZeroMemory(&s_spinit, sizeof(CSpElem));
		//::ZeroMemory(&s_spscaleinit, sizeof(CSpElem));
		//::ZeroMemory(&s_spproperty, sizeof(CSpElem));
		//::ZeroMemory(&s_spzeroframe, sizeof(CSpElem));
		//::ZeroMemory(&s_spcameradolly, sizeof(CSpElem));
		//::ZeroMemory(&s_spmodelposdir, sizeof(CSpElem));
		//::ZeroMemory(&s_spmaterialrate, sizeof(CSpElem));
		//::ZeroMemory(&s_mousecenteron, sizeof(CSpElem));
	}
	//{
	//	::ZeroMemory(&s_spaimbar, sizeof(SPGUISW) * SPAIMBARNUM);
	//	int spgno;
	//	for (spgno = 0; spgno < SPAIMBARNUM; spgno++) {
	//		s_spaimbar[spgno].state = false;
	//	}
	//}
	//{
	//	::ZeroMemory(&s_spmenuaimbar, sizeof(SPGUISW) * SPMENU_MAX);
	//	int spgno;
	//	for (spgno = 0; spgno < SPMENU_MAX; spgno++) {
	//		s_spmenuaimbar[spgno].state = false;
	//	}
	//}
	//{
	//	::ZeroMemory(&s_spsel3d, sizeof(SPGUISW));
	//	s_spsel3d.state = false;
	//}
	//{
	//	::ZeroMemory(&s_spikmodesw, sizeof(SPGUISW) * 3);
	//	s_spikmodesw[0].state = true;
	//	s_spikmodesw[1].state = false;
	//	s_spikmodesw[2].state = false;
	//}
	//{
	//	::ZeroMemory(&s_splod, sizeof(SPGUISW));
	//	//s_splod.state = true;
	//	s_splod.state = false;//2021/11/22 ReferencePose Off by default
	//}
	//{
	//	::ZeroMemory(&s_splimiteul, sizeof(SPGUISW));
	//	//s_splimiteul.state = true;
	//	s_splimiteul.state = false;
	//}
	//{
	//	::ZeroMemory(&s_spcameramode, sizeof(SPGUISW));
	//	//s_splimiteul.state = true;
	//	s_spcameramode.state = false;
	//}
	//{
	//	::ZeroMemory(&s_spcamerainherit, sizeof(SPGUISW3));
	//	//s_splimiteul.state = true;
	//	s_spcamerainherit.mode = CAMERA_INHERIT_ALL;
	//}
	//{
	//	::ZeroMemory(&s_spscraping, sizeof(SPGUISW));
	//	//s_spscraping.state = true;
	//	s_spscraping.state = false;
	//}
	//{
	//	::ZeroMemory(&s_spguisw, sizeof(SPGUISW) * SPGUISWNUM);
	//	int spgno;
	//	for (spgno = 0; spgno < SPGUISWNUM; spgno++) {
	//		s_spguisw[spgno].state = false;
	//	}
	//}
	//{
	//	::ZeroMemory(&s_spdispsw, sizeof(SPGUISW) * SPDISPSWNUM);
	//	int spgno;
	//	for (spgno = 0; spgno < SPDISPSWNUM; spgno++) {
	//		s_spdispsw[spgno].state = false;
	//	}
	//	s_spdispsw[SPDISPSW_LIGHTS].state = true;
	//}
	//{
	//	::ZeroMemory(&s_sprigidsw, sizeof(SPGUISW) * SPRIGIDSWNUM);
	//	int spgno;
	//	for (spgno = 0; spgno < SPRIGIDSWNUM; spgno++) {
	//		s_sprigidsw[spgno].state = false;
	//	}
	//	s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].state = true;
	//}
	//::ZeroMemory(&s_spretargetsw, sizeof(SPGUISW) * SPRETARGETSWNUM);
	//s_spretargetsw[SPRETARGETSW_RETARGET].state = false;
	//s_spretargetsw[SPRETARGETSW_LIMITEULER].state = false;


	g_bonecntmap.clear();

	ChaMatrixIdentity(&s_inimat);

	g_bEnablePreshader = true;


	//for (int i = 0; i < MAX_LIGHTS; i++) {
	//	g_LightControl[i].SetLightDirection(
	//		ChaVector3((float)sin(PI * 2 * (MAX_LIGHTS - i - 1) / MAX_LIGHTS - PI / 6),
	//			0.0f,
	//			(float)-cos(PI * 2 * (MAX_LIGHTS - i - 1) / MAX_LIGHTS - PI / 6)).D3DX());
	//}
	//g_nActiveLight = 0;
	ZeroMemory(g_lightNo, sizeof(int)* LIGHTNUMMAX);
	g_nNumActiveLights = 1;
	g_fLightScale = 1.0f;
	int slotindex;
	int lightindex;
	for (slotindex = 0; slotindex < LIGHTSLOTNUM; slotindex++) {
		for (lightindex = 0; lightindex < LIGHTNUMMAX; lightindex++) {
			double initrad = PI * 2.0 * (double)lightindex / (double)LIGHTNUMMAX;// -PI / 6;
			ChaVector3 dir0, ndir;
			dir0 = ChaVector3((float)sin(initrad),
				-0.5f,
				(float)-cos(initrad));
			ChaVector3Normalize(&ndir, &dir0);
			g_lightDir[slotindex][lightindex] = ndir;
			//g_lightdirforshader[lightindex] = -g_lightdir[lightindex];//-lightdir

			g_lightDiffuse[slotindex][lightindex] = ChaVector3(1.0f, 1.0f, 1.0f);
			//g_lightdiffuseforshader[lightindex] = ChaVector4(g_lightdiffuse[lightindex].x, g_lightdiffuse[lightindex].y, g_lightdiffuse[lightindex].z, 1.0f);

			if (lightindex == 0) {//初期状態では lightindex == 0のときキャラの正面を照らす向き
				g_lightEnable[slotindex][lightindex] = true;
			}
			else {
				g_lightEnable[slotindex][lightindex] = false;
			}
			g_lightDirWithView[slotindex][lightindex] = true;

			g_lightScale[slotindex][lightindex] = 1.0f;

			//g_LightControl[lightindex].SetLightDirection(g_lightdir[lightindex].D3DX());

		}
	}
	LoadLightsForEdit();//ファイルに保存してあるLight情報を g_lightdirとg_ligthdiffuseとg_lightenableとg_lightdirwithviewに読込
	
	g_lightSlot = 0;
	SetLightDirection();


	LoadShadowParamsFile();//ファイルに保存してあるShadowParams情報をg_shadowmap_*に読み込む



	//CreateUtDialog();



	//s_updatetimeline = new CThreadingUpdateTimeline();
	//if(!s_updatetimeline){
	//	return;
	//}
	//s_updatetimeline->CreateThread();



//////////
	::ZeroMemory(&s_pickinfo, sizeof(UIPICKINFO));

	s_modelpanel.panel = 0;
	s_modelpanel.scroll = 0;
	s_modelpanel.radiobutton = 0;
	s_modelpanel.separator = 0;
	s_modelpanel.separator2 = 0;
	s_modelpanel.checkvec.clear();
	s_modelpanel.delbutton.clear();
	s_modelpanel.modelindex = -1;

	s_motionpanel.panel = 0;
	s_motionpanel.scroll = 0;
	s_motionpanel.radiobutton = 0;
	s_motionpanel.separator = 0;
	s_motionpanel.delbutton.clear();
	s_motionpanel.modelindex = -1;

	s_camerapanel.panel = 0;
	s_camerapanel.scroll = 0;
	s_camerapanel.radiobutton = 0;
	s_camerapanel.separator = 0;
	s_camerapanel.delbutton.clear();
	s_camerapanel.modelindex = -1;


	//s_cameradollydlgwnd = 0;
	s_materialratedlgwnd = 0;
	s_modelworldmatdlgwnd = 0;
	s_shadertypeparamsdlgwnd = 0;

	{
		char strtitle[256];
		strcpy_s(strtitle, 256, "BpPiyo");
		s_bpWorld = new BPWorld(NULL, s_matWorld, strtitle, // ウィンドウのタイトル
			460, 460,         // ウィンドウの幅と高さ [pixels]
			NULL);    // モニタリング用関数へのポインタ  
		_ASSERT(s_bpWorld);


		s_bpWorld->enableFixedTimeStep(false);
		//s_bpWorld->enableFixedTimeStep(false);
		//s_bpWorld->setTimeStep(0.015);// seconds
		s_bpWorld->setGlobalERP(btScalar(g_erp));// ERP
		//s_bpWorld->start();// ウィンドウを表示して，シミュレーションを開始する
		s_btWorld = s_bpWorld->getDynamicsWorld();
		s_bpWorld->setNumThread(g_numthread);
	}


	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	InterlockedExchange(&g_underApealingMouseHere, (LONG)0);
	//if (g_enableDS == true) {
	//	s_dsupdater = new CDSUpdateUnderTracking();
	//	if (s_dsupdater) {
	//		int isuccess = s_dsupdater->CreateDSUpdateUnderTracking(GetModuleHandle(NULL));
	//		if (isuccess != 0) {
	//			delete s_dsupdater;
	//			s_dsupdater = 0;
	//		}
	//	}
	//}
	//else {
	//	s_dsupdater = 0;
	//}

	s_doneinit = 1;
}


int OnPluginClose()
{
	if (!s_plugin) {
		return 0;
	}

	int pluginno;
	for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
		if ((s_plugin + pluginno)->validflag == 1) {
			(s_plugin + pluginno)->CallOnClose();
		}
	}
	return 0;
}


void OnDestroyDevice()
{
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//DirectX11 : because of DX11 defferd destroy, some ref count will be alive.//!!!!!!!!!!!!!!!
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


	g_endappflag = 1;
	//UNREFERENCED_PARAMETER(pUserContext);

	OrgWindowListenMouse(false);

	SaveIniFile();
	SaveChooseColor();
	SaveLightsForEdit();
	SaveShadowParamsFile();


	//if (s_updatetimeline) {
	//	delete s_updatetimeline;
	//	s_updatetimeline = 0;
	//}


	OnPluginClose();
	if (s_plugin) {
		delete[] s_plugin;
		s_plugin = 0;
	}

	if (s_hhook) {
		UnhookWinEvent(s_hhook);
		s_hhook = NULL;
	}




	//if (s_eventhook) {
		////UnhookWinEvent(s_eventhook);
		//s_eventhook = 0;
	CoUninitialize();
	//}


	DestroySprites();

	//if (s_dsupdater) {
	//	delete s_dsupdater;
	//	s_dsupdater = 0;
	//}

	//EndDS4();

	if (g_mousehereimage) {
		delete g_mousehereimage;
		g_mousehereimage = 0;
	}
	if (g_menuaimbarimage) {
		delete g_menuaimbarimage;
		g_menuaimbarimage = 0;
	}
	Gdiplus::GdiplusShutdown(gdiplusToken);


	if (g_mouseherebmp) {
		::DeleteObject(g_mouseherebmp);
		g_mouseherebmp = 0;
	}


	s_motmenuindexmap.clear();
	s_cameramenuindexmap.clear();
	s_reindexmap.clear();
	s_rgdindexmap.clear();


	//::KillTimer(g_mainhwnd, s_iktimerid);


	if (s_editrangehistory) {
		delete[] s_editrangehistory;
		s_editrangehistory = 0;
	}
	s_editrangehistoryno = 0;

	if (s_anglelimitdlg) {
		s_underanglelimithscroll = 0;
		if (IsWindow(s_anglelimitdlg)) {
			DestroyWindow(s_anglelimitdlg);
		}
		s_anglelimitdlg = 0;
	}
	if (s_lightsforeditdlg) {
		if (IsWindow(s_lightsforeditdlg)) {
			DestroyWindow(s_lightsforeditdlg);
		}
		s_lightsforeditdlg = 0;
	}
	if (s_latertransparentdlg) {
		if (IsWindow(s_latertransparentdlg)) {
			DestroyWindow(s_latertransparentdlg);
		}
		s_latertransparentdlg = nullptr;
	}
	if (s_shadowparamsdlg) {
		if (IsWindow(s_shadowparamsdlg)) {
			DestroyWindow(s_shadowparamsdlg);
		}
		s_shadowparamsdlg = nullptr;
	}
	int guidlgno;
	for (guidlgno = 0; guidlgno < GUIDLGNUM; guidlgno++) {
		HWND delhwnd = s_guidlg[guidlgno];
		if ((delhwnd != nullptr) && IsWindow(delhwnd)) {
			DestroyWindow(delhwnd);
		}
		s_guidlg[guidlgno] = nullptr;
	}


	if (s_rotaxisdlg) {
		DestroyWindow(s_rotaxisdlg);
		s_rotaxisdlg = 0;
	}
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}

	if (s_copyhistorydlg.GetCreatedFlag() == true) {
		if (::IsWindow(s_copyhistorydlg.m_hWnd)) {
			s_copyhistorydlg.DestroyWindow();
		}
	}
	if (s_dollyhistorydlg.GetCreatedFlag() == true) {
		if (::IsWindow(s_dollyhistorydlg.m_hWnd)) {
			s_dollyhistorydlg.DestroyWindow();
		}
	}

	//if (s_cameradollydlgwnd) {
	//	DestroyWindow(s_cameradollydlgwnd);
	//	s_cameradollydlgwnd = 0;
	//}
	if (s_materialratedlgwnd) {
		DestroyWindow(s_materialratedlgwnd);
		s_materialratedlgwnd = 0;
	}
	if (s_modelworldmatdlgwnd) {
		DestroyWindow(s_modelworldmatdlgwnd);
		s_modelworldmatdlgwnd = 0;
	}
	if (s_shadertypeparamsdlgwnd) {
		DestroyWindow(s_shadertypeparamsdlgwnd);
		s_shadertypeparamsdlgwnd = 0;
	}

	CloseDbgFile();
	if (g_infownd) {
		delete g_infownd;
		g_infownd = 0;
	}



	s_oprigflag = 0;
	s_customrigbone = 0;

	map<CModel*, CFrameCopyDlg*>::iterator itrcpdlg;
	for (itrcpdlg = s_selbonedlgmap.begin(); itrcpdlg != s_selbonedlgmap.end(); itrcpdlg++) {
		CFrameCopyDlg* curcpdlg = itrcpdlg->second;
		if (curcpdlg) {
			delete curcpdlg;
		}
	}
	s_selbonedlgmap.clear();


	if (s_chascene) {
		delete s_chascene;
		s_chascene = 0;
	}
	s_model = 0;


	CBone::DestroyColDisp();


	//if (s_undosprite) {
	//	delete s_undosprite;
	//	s_undosprite = 0;
	//}
	//if (s_fpssprite) {
	//	delete s_fpssprite;
	//	s_fpssprite = 0;
	//}


	if (s_select) {
		delete s_select;
		s_select = 0;
	}
	if (s_select_posture) {
		delete s_select_posture;
		s_select_posture = 0;
	}


	if (s_rigopemark_sphere) {
		delete s_rigopemark_sphere;
		s_rigopemark_sphere = nullptr;
	}
	if (s_rigopemark_ringX) {
		delete s_rigopemark_ringX;
		s_rigopemark_ringX = nullptr;
	}
	if (s_rigopemark_ringY) {
		delete s_rigopemark_ringY;
		s_rigopemark_ringY = nullptr;
	}
	if (s_rigopemark_ringZ) {
		delete s_rigopemark_ringZ;
		s_rigopemark_ringZ = nullptr;
	}


	if (s_ground) {
		delete s_ground;
		s_ground = 0;
	}
	if (s_gplane) {
		delete s_gplane;
		s_gplane = 0;
	}
	if (s_bmark) {
		delete s_bmark;
		s_bmark = 0;
	}


	//if (s_bcircle) {
	//	delete s_bcircle;
	//	s_bcircle = 0;
	//}
	//if (s_kinsprite) {
	//	delete s_kinsprite;
	//	s_kinsprite = 0;
	//}

	if (g_texbank) {
		delete g_texbank;
		g_texbank = 0;
	}

	if (s_mainmenu) {
		DestroyMenu(s_mainmenu);
		s_mainmenu = 0;
	}

	DestroyTimeLine(1);

	if (s_timelineWnd) {
		delete s_timelineWnd;
		s_timelineWnd = 0;
	}
	if (s_LtimelineWnd) {
		delete s_LtimelineWnd;
		s_LtimelineWnd = 0;
	}

	if (s_toolWnd) {
		delete s_toolWnd;
		s_toolWnd = 0;
	}
	if (s_toolSeparator) {
		delete s_toolSeparator;
		s_toolSeparator = 0;
	}

	if (s_toolCopyB) {
		delete s_toolCopyB;
		s_toolCopyB = 0;
	}
	if (s_toolZeroFrameB) {
		delete s_toolZeroFrameB;
		s_toolZeroFrameB = 0;
	}

	if (s_toolSymCopyB) {
		delete s_toolSymCopyB;
		s_toolSymCopyB = 0;
	}
	if (s_toolCutB) {
		delete s_toolCutB;
		s_toolCutB = 0;
	}
	if (s_toolPasteB) {
		delete s_toolPasteB;
		s_toolPasteB = 0;
	}
	if (s_toolDeleteB) {
		delete s_toolDeleteB;
		s_toolDeleteB = 0;
	}
	if (s_toolMotPropB) {
		delete s_toolMotPropB;
		s_toolMotPropB = 0;
	}
	if (s_toolMarkB) {
		delete s_toolMarkB;
		s_toolMarkB = 0;
	}
	if (s_toolSelBoneB) {
		delete s_toolSelBoneB;
		s_toolSelBoneB = 0;
	}
	if (s_toolInitMPB) {
		delete s_toolInitMPB;
		s_toolInitMPB = 0;
	}
	if (s_toolFilterB) {
		delete s_toolFilterB;
		s_toolFilterB = 0;
	}
	if (s_toolInterpolateB) {
		delete s_toolInterpolateB;
		s_toolInterpolateB = 0;
	}
	if (s_toolSelectCopyFileName) {
		delete s_toolSelectCopyFileName;
		s_toolSelectCopyFileName = 0;
	}
	if (s_toolSkipRenderBoneMarkB) {
		delete s_toolSkipRenderBoneMarkB;
		s_toolSkipRenderBoneMarkB = 0;
	}
	if (s_toolSkipRenderBoneMarkB2) {
		delete s_toolSkipRenderBoneMarkB2;
		s_toolSkipRenderBoneMarkB2 = 0;
	}
	if (s_tool180deg) {
		delete s_tool180deg;
		s_tool180deg = 0;
	}
	if (s_toolScaleInitAllB) {
		delete s_toolScaleInitAllB;
		s_toolScaleInitAllB = 0;
	}
	if (s_toolCameraDollyB) {
		delete s_toolCameraDollyB;
		s_toolCameraDollyB = 0;
	}
	if (s_toolMaterialRateB) {
		delete s_toolMaterialRateB;
		s_toolMaterialRateB = 0;
	}
	if (s_toolModelWorldMatB) {
		delete s_toolModelWorldMatB;
		s_toolModelWorldMatB = 0;
	}


	if (s_owpTimeline) {
		delete s_owpTimeline;
		s_owpTimeline = 0;
	}
	if (s_owpPlayerButton) {
		delete s_owpPlayerButton;
		s_owpPlayerButton = 0;
	}
	if (s_owpLTimeline) {
		delete s_owpLTimeline;
		s_owpLTimeline = 0;
	}
	if (s_owpEulerGraph) {
		delete s_owpEulerGraph;
		s_owpEulerGraph = 0;
	}
	if (s_LTSeparator) {
		delete s_LTSeparator;
		s_LTSeparator = 0;
	}

	if (s_layerWnd) {
		delete s_layerWnd;
		s_layerWnd = 0;
	}
	if (s_owpLayerTable) {
		delete s_owpLayerTable;
		s_owpLayerTable = 0;
	}

	if (s_sphrateSlider) {
		delete s_sphrateSlider;
		s_sphrateSlider = 0;
	}
	if (s_boxzSlider) {
		delete s_boxzSlider;
		s_boxzSlider = 0;
	}
	if (s_boxzlabel) {
		delete s_boxzlabel;
		s_boxzlabel = 0;
	}
	if (s_massSlider) {
		delete s_massSlider;
		s_massSlider = 0;
	}
	if (s_massSLlabel) {
		delete s_massSLlabel;
		s_massSLlabel = 0;
	}
	//if (s_massSeparator) {
	//	delete s_massSeparator;
	//	s_massSeparator = 0;
	//}
	//if (s_massSeparator1) {
	//	delete s_massSeparator1;
	//	s_massSeparator1 = 0;
	//}
	//if (s_massSeparator2) {
	//	delete s_massSeparator2;
	//	s_massSeparator2 = 0;
	//}
	if (s_massB) {
		delete s_massB;
		s_massB = 0;
	}
	if (s_thicknessB) {
		delete s_thicknessB;
		s_thicknessB = 0;
	}
	if (s_depthB) {
		delete s_depthB;
		s_depthB = 0;
	}
	if (s_massspacelabel) {
		delete s_massspacelabel;
		s_massspacelabel = 0;
	}
	if (s_namelabel) {
		delete s_namelabel;
		s_namelabel = 0;
	}
	if (s_lenglabel) {
		delete s_lenglabel;
		s_lenglabel = 0;
	}
	if (s_skipB) {
		delete s_skipB;
		s_skipB = 0;
	}
	if (s_rigidskip) {
		delete s_rigidskip;
		s_rigidskip = 0;
	}
	if (s_forbidSeparator) {
		delete s_forbidSeparator;
		s_forbidSeparator = 0;
	}
	if (s_forbidB) {
		delete s_forbidB;
		s_forbidB = 0;
	}
	if (s_forbidrot) {
		delete s_forbidrot;
		s_forbidrot = 0;
	}

	if (s_validSeparator) {
		delete s_validSeparator;
		s_validSeparator = 0;
	}
	if (s_allrigidenableB) {
		delete s_allrigidenableB;
		s_allrigidenableB = 0;
	}
	if (s_allrigiddisableB) {
		delete s_allrigiddisableB;
		s_allrigiddisableB = 0;
	}


	if (s_shplabel) {
		delete s_shplabel;
		s_shplabel = 0;
	}
	if (s_colSeparator) {
		delete s_colSeparator;
		s_colSeparator = 0;
	}
	if (s_colB) {
		delete s_colB;
		s_colB = 0;
	}
	if (s_colradio) {
		delete s_colradio;
		s_colradio = 0;
	}
	if (s_lkradio) {
		delete s_lkradio;
		s_lkradio = 0;
	}
	if (s_lkSlider) {
		delete s_lkSlider;
		s_lkSlider = 0;
	}
	if (s_lklabel) {
		delete s_lklabel;
		s_lklabel = 0;
	}
	if (s_akradio) {
		delete s_akradio;
		s_akradio = 0;
	}
	if (s_akSlider) {
		delete s_akSlider;
		s_akSlider = 0;
	}
	if (s_aklabel) {
		delete s_aklabel;
		s_aklabel = 0;
	}
	if (s_restSlider) {
		delete s_restSlider;
		s_restSlider = 0;
	}
	if (s_restlabel) {
		delete s_restlabel;
		s_restlabel = 0;
	}
	if (s_fricSlider) {
		delete s_fricSlider;
		s_fricSlider = 0;
	}
	if (s_friclabel) {
		delete s_friclabel;
		s_friclabel = 0;
	}
	if (s_ldmpSlider) {
		delete s_ldmpSlider;
		s_ldmpSlider = 0;
	}
	if (s_admpSlider) {
		delete s_admpSlider;
		s_admpSlider = 0;
	}
	if (s_kB) {
		delete s_kB;
		s_kB = 0;
	}
	if (s_restB) {
		delete s_restB;
		s_restB = 0;
	}
	if (s_ldmplabel) {
		delete s_ldmplabel;
		s_ldmplabel = 0;
	}
	if (s_admplabel) {
		delete s_admplabel;
		s_admplabel = 0;
	}
	if (s_dmpB) {
		delete s_dmpB;
		s_dmpB = 0;
	}
	if (s_groupB) {
		delete s_groupB;
		s_groupB = 0;
	}
	if (s_gcoliB) {
		delete s_gcoliB;
		s_gcoliB = 0;
	}
	if (s_btgSlider) {
		delete s_btgSlider;
		s_btgSlider = 0;
	}
	if (s_btglabel) {
		delete s_btglabel;
		s_btglabel = 0;
	}
	if (s_btgscSlider) {
		delete s_btgscSlider;
		s_btgscSlider = 0;
	}
	if (s_btgsclabel) {
		delete s_btgsclabel;
		s_btgsclabel = 0;
	}
	if (s_btforceSeparator) {
		delete s_btforceSeparator;
		s_btforceSeparator = 0;
	}
	if (s_btforce) {
		delete s_btforce;
		s_btforce = 0;
	}
	if (s_btforceB) {
		delete s_btforceB;
		s_btforceB = 0;
	}
	if (s_groupcheck) {
		delete s_groupcheck;
		s_groupcheck = 0;
	}
	if (s_btgB) {
		delete s_btgB;
		s_btgB = 0;
	}
	if (s_rigidWnd) {
		delete s_rigidWnd;
		s_rigidWnd = 0;
	}

	DestroyDispGroupWnd();
	DestroyShaderTypeWnd();


	//if (s_placefolderlabel_1) {
	//	delete s_placefolderlabel_1;
	//	s_placefolderlabel_1 = 0;
	//}
	//if (s_placefolderlabel_2) {
	//	delete s_placefolderlabel_2;
	//	s_placefolderlabel_2 = 0;
	//}
	//if (s_placefolderlabel_3) {
	//	delete s_placefolderlabel_3;
	//	s_placefolderlabel_3 = 0;
	//}
	if (s_placefolderWnd) {
		delete s_placefolderWnd;
		s_placefolderWnd = 0;
	}
	int textno;
	for (textno = 0; textno < SHORTCUTTEXTNUM; textno++) {
		if (s_shortcuttext[textno]) {
			delete s_shortcuttext[textno];
			s_shortcuttext[textno] = 0;
		}
	}



	if (s_sidemenu_rigid) {
		delete s_sidemenu_rigid;
		s_sidemenu_rigid = 0;
	}
	if (s_sidemenu_limiteul) {
		delete s_sidemenu_limiteul;
		s_sidemenu_limiteul = 0;
	}
	if (s_sidemenu_copyhistory) {
		delete s_sidemenu_copyhistory;
		s_sidemenu_copyhistory = 0;
	}
	if (s_sidemenu_retarget) {
		delete s_sidemenu_retarget;
		s_sidemenu_retarget = 0;
	}
	if (s_sidemenusp) {
		delete s_sidemenusp;
		s_sidemenusp = 0;
	}
	if (s_sidemenusp1) {
		delete s_sidemenusp1;
		s_sidemenusp1 = 0;
	}
	if (s_sidemenusp2) {
		delete s_sidemenusp2;
		s_sidemenusp2 = 0;
	}
	if (s_sidemenu_rigid) {
		delete s_sidemenu_rigid;
		s_sidemenu_rigid = 0;
	}
	if (s_sidemenu_limiteul) {
		delete s_sidemenu_limiteul;
		s_sidemenu_limiteul = 0;
	}
	if (s_sidemenu_copyhistory) {
		delete s_sidemenu_copyhistory;
		s_sidemenu_copyhistory = 0;
	}
	if (s_sidemenu_retarget) {
		delete s_sidemenu_retarget;
		s_sidemenu_retarget = 0;
	}
	if (s_sidemenuWnd) {
		delete s_sidemenuWnd;
		s_sidemenuWnd = 0;
	}

	if (s_mainmenuaimbarWnd) {
		delete s_mainmenuaimbarWnd;
		s_mainmenuaimbarWnd = 0;
	}
	if (s_mainmenulabel) {
		delete s_mainmenulabel;
		s_mainmenulabel = 0;
	}


	if (s_dmpgroupcheck) {
		delete s_dmpgroupcheck;
		s_dmpgroupcheck = 0;
	}
	if (s_dmpanimLlabel) {
		delete s_dmpanimLlabel;
		s_dmpanimLlabel = 0;
	}
	if (s_dmpanimLSlider) {
		delete s_dmpanimLSlider;
		s_dmpanimLSlider = 0;
	}
	if (s_dmpanimAlabel) {
		delete s_dmpanimAlabel;
		s_dmpanimAlabel = 0;
	}
	if (s_dmpanimASlider) {
		delete s_dmpanimASlider;
		s_dmpanimASlider = 0;
	}
	if (s_dmpanimB) {
		delete s_dmpanimB;
		s_dmpanimB = 0;
	}
	if (s_dmpanimWnd) {
		delete s_dmpanimWnd;
		s_dmpanimWnd = 0;
	}


	if (s_impgroupcheck) {
		delete s_impgroupcheck;
		s_impgroupcheck = 0;
	}
	if (s_impzSlider) {
		delete s_impzSlider;
		s_impzSlider = 0;
	}
	if (s_impySlider) {
		delete s_impySlider;
		s_impySlider = 0;
	}
	if (s_impxSlider) {
		delete s_impxSlider;
		s_impxSlider = 0;
	}
	if (s_impzlabel) {
		delete s_impzlabel;
		s_impzlabel = 0;
	}
	if (s_impylabel) {
		delete s_impylabel;
		s_impylabel = 0;
	}
	if (s_impxlabel) {
		delete s_impxlabel;
		s_impxlabel = 0;
	}
	if (s_impscaleSlider) {
		delete s_impscaleSlider;
		s_impscaleSlider = 0;
	}
	if (s_impscalelabel) {
		delete s_impscalelabel;
		s_impscalelabel = 0;
	}
	if (s_impallB) {
		delete s_impallB;
		s_impallB = 0;
	}
	if (s_impWnd) {
		delete s_impWnd;
		s_impWnd = 0;
	}
	if (s_gpWnd) {
		delete s_gpWnd;
		s_gpWnd = 0;
	}
	if (s_ghSlider) {
		delete s_ghSlider;
		s_ghSlider = 0;
	}
	if (s_gsizexSlider) {
		delete s_gsizexSlider;
		s_gsizexSlider = 0;
	}
	if (s_gsizezSlider) {
		delete s_gsizezSlider;
		s_gsizezSlider = 0;
	}
	if (s_ghlabel) {
		delete s_ghlabel;
		s_ghlabel = 0;
	}
	if (s_gsizexlabel) {
		delete s_gsizexlabel;
		s_gsizexlabel = 0;
	}
	if (s_gsizezlabel) {
		delete s_gsizezlabel;
		s_gsizezlabel = 0;
	}
	if (s_gpdisp) {
		delete s_gpdisp;
		s_gpdisp = 0;
	}
	if (s_grestSlider) {
		delete s_grestSlider;
		s_grestSlider = 0;
	}
	if (s_grestlabel) {
		delete s_grestlabel;
		s_grestlabel = 0;
	}
	if (s_gfricSlider) {
		delete s_gfricSlider;
		s_gfricSlider = 0;
	}
	if (s_gfriclabel) {
		delete s_gfriclabel;
		s_gfriclabel = 0;
	}

	if (g_motionbrush_value) {
		free(g_motionbrush_value);
		g_motionbrush_value = 0;
	}



	//if (g_Camera) {
	//	delete g_Camera;
	//	g_Camera = 0;
	//}

	DestroyModelPanel();
	DestroyMotionPanel();
	DestroyCameraPanel();
	DestroyConvBoneWnd();

	//DestroySdkObjects();


	if (s_psdk) {
		s_psdk->Destroy();
		s_psdk = 0;
	}

	if (s_bpWorld) {
		delete s_bpWorld;
		s_bpWorld = 0;
	}


	CMotionPoint::DestroyMotionPoints();
	CBone::DestroyBones();
	CRigidElem::DestroyRigidElems();

	DestroyEulKeys();
	DestroyKeys();

	//エンジンの破棄。
	if (g_engine) {
		delete g_engine;
		g_engine = nullptr;
	}


	if (s_3dwnd && IsWindow(s_3dwnd)) {
		DestroyWindow(s_3dwnd);
		s_3dwnd = 0;
	}
	s_3dwnd = 0;
	if (g_mainhwnd && IsWindow(g_mainhwnd)) {
		DestroyWindow(g_mainhwnd);
		g_mainhwnd = 0;
	}
	g_mainhwnd = 0;



	DeleteCriticalSection(&s_CritSection_LTimeline);
	DeleteCriticalSection(&g_CritSection_GetGP);
	DeleteCriticalSection(&g_CritSection_FbxSdk);

}


void OnUserFrameMove(double fTime, float fElapsedTime)
{

	static double savetime = 0.0;
	static int capcnt = 0;

	//if (g_bvh2fbxbatchflag || g_motioncachebatchflag || g_retargetbatchflag) {
	//if((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)){
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		OnFrameBatchThread();
		return;//!!!!!!!!!!!!!!!!!!!
	}

	DisplayApplyRateText();

	SetCameraModel();


	//マウスがUtDialogのコントロールの上を通るとSetCaptureが生じるのでIK中は非表示にする
	//VisibleUtDialog();


	if (s_underdelmotion || s_underdelmodel || 
		s_underselectmotion || s_underselectcamera || s_underselectmodel || s_underdispmodel || 
		g_changeUpdateThreadsNum) {

		OnFrameCloseFlag();
		OnFrameToolWnd();

		if (s_model) {
			if (s_model->GetBefInView() != s_model->GetInView()) {
				if (s_owpEulerGraph) {
					//2023/08/27 オイラーグラフの表示非表示の条件が変わった場合には　再描画
					//オイラーグラフのdraw()は OrgWindow.cppにある
					s_owpEulerGraph->callRewrite();
				}
			}
		}
	}
	else {

		//if ((UnderDragOperation_R() == false) && (UnderDragOperation_L() == false) && ((s_tooltipdispcount % 6) == 0)) {
		if ((UnderDragOperation_R() == false) && (UnderDragOperation_L() == false)) {
			//マウスがUtDialogのコントロールの上を通るとSetCaptureが生じるのでIK中は非表示にする
			DispToolTip();
		}
		s_tooltipdispcount++;


		//WCHAR sz[100];
		////swprintf_s(sz, 100, L"ThreadNum:%d(%d)", g_numthread, gNumIslands);
		////g_SampleUI.GetStatic(IDC_STATIC_NUMTHREAD)->SetText(sz);
		//swprintf_s(sz, 100, L"UpdateThreads:%d", g_UpdateMatrixThreads);
		//g_SampleUI.GetStatic(IDC_STATIC_UMTHREADS)->SetText(sz);


		if (g_undertrackingRMenu == 0) {
			OnDSUpdate();
		}


		OnFrameStartPreview(fTime, &savetime);


		OnFrameUtCheckBox();
		SetCamera6Angle();
		AutoCameraTarget();

		OnFrameKeyboard();

		if ((g_previewFlag == 0) && (s_savepreviewFlag != 0)) {
			s_cursorFlag = true;
		}
		OnFrameTimeLineWnd();


		OnFrameMouseButton();

		s_time = fTime;
		////#replacing comment out#g_Camera->FrameMove(fElapsedTime);
		double difftime = fTime - savetime;
		//double difftime = fElapsedTime;

		//Preview前に　CameraAnimのために　時間を確定する必要がある
		//時間が確定 --> CameraAnim --> s_matWorld, s_matProj, s_matVP確定 --> Preview時のUpdataMatrix(  s_matVP )

		//##############
		//Process Time
		//##############
		double nextframe = 0.0;
		int endflag = 0;
		int loopstartflag = 0;
		OnFrameProcessTime(difftime, &nextframe, &endflag, &loopstartflag);


		//#############
		//Camera Anim
		//#############
		double cameranextframe = 0.0;
		int cameraendflag = 0;
		int cameraloopstartflag = 0;
		OnFrameProcessCameraTime(difftime, &cameranextframe, &cameraendflag, &cameraloopstartflag);
		OnFramePreviewCamera(cameranextframe);
	

		SetCamera3DFromEyePos();

		//if (g_previewFlag != 0) {
		//	WCHAR dbgline[1024] = { 0 };
		//	swprintf_s(dbgline, 1024, L"difftime %f, nextframe %.3f, caemranextframe %.3f\n",
		//		difftime, nextframe, cameranextframe);
		//	OutputDebugString(dbgline);
		//}


		////###################
		////Set Updated Params
		////###################
		////FLOAT fObjectRadius;
		////if (s_chascene) {
		////	g_vCenter = s_chascene->GetTotalModelBound().center;
		////	fObjectRadius = s_chascene->GetTotalModelBound().r;
		////}
		////else {
		////	_ASSERT(0);
		////	g_vCenter = ChaVector3(0.0f, 0.0f, 0.0f);
		////	fObjectRadius = 10.0f;
		////}
		////if (fObjectRadius < 0.1f) {
		////	fObjectRadius = 10.0f;
		////}
		//////#replacing comment out#g_Camera->SetProjParams(g_fovy, s_fAspectRatio, g_projnear, g_projfar);
		//////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		//////#replacing comment out#g_Camera->SetRadius(fObjectRadius * 3.0f, fObjectRadius * 0.5f, fObjectRadius * 6.0f);
		//s_matWorld = ChaMatrix(//#replacing comment out#g_Camera->GetWorldMatrix());
		//s_matView = ChaMatrix(//#replacing comment out#g_Camera->GetViewMatrix());
		//s_matProj = ChaMatrix(//#replacing comment out#g_Camera->GetProjMatrix());
		s_matWorld.SetTranslationZero();
		////s_matW = s_matWorld;
		s_matVP = s_matView * s_matProj;



		//int modelno;
		//int modelnum = (int)s_modelindex.size();
		//for (modelno = 0; modelno < modelnum; modelno++) {
		//	s_modelindex[modelno].modelptr->SetWorldMatFromCamera(s_matWorld);
		//}


		//##########
		//Preview
		//##########
		if (g_previewFlag) {
			if (s_model && s_model->GetCurMotInfo()) {
				if (g_previewFlag <= 3) {
					OnFramePreviewNormal(nextframe, difftime, endflag, loopstartflag);
				}
				else if (g_previewFlag == 4) {//BTの物理
					OnFramePreviewBt(nextframe, difftime, endflag, loopstartflag);
				}
				else if (g_previewFlag == 5) {//ラグドール
					//OnFramePreviewRagdoll(&nextframe, &difftime);

					//ラグドール休止中
					_ASSERT(0);
					OnFramePreviewNormal(nextframe, difftime, endflag, loopstartflag);
				}
				else {
					OnTimeLineCursor();
				}
			}
			else {
				g_previewFlag = 0;
			}
		}
		else {
			OnFramePreviewStop();
		}
		

		if (s_model) {
			if (s_model->GetBefInView() != s_model->GetInView()) {
				if (s_owpEulerGraph) {
					//2023/08/27 オイラーグラフの表示非表示の条件が変わった場合には　再描画
					//オイラーグラフのdraw()は OrgWindow.cppにある
					s_owpEulerGraph->callRewrite();
				}
			}
		}


		//s_difftime = difftime;
		savetime = fTime;


		OnFrameCloseFlag();
		OnFrameToolWnd();
		OnFrameUndo(false, 0);

		OnFrameUpdateGround();
		OnFrameInitBtWorld();


		if (s_spretargetsw[1].state == true) {
			bool updateonlycheckeul = true;
			OnFrameAngleLimit(updateonlycheckeul);//2022/12/30 AngleLimitDlgのcheck値のリアルタイム更新のため
		}
		if (s_spdispsw[SPDISPSW_LIGHTS].state == true) {
			OnFrameLightsForEdit();
		}

		OnDSMouseHereApeal();


		//s_tum.WaitUpdateMatrix();
	}

	s_savepreviewFlag = g_previewFlag;
}

void InsertCopyMPReq(bool limitdegflag, CBone* curbone, double curframe)
{
	if (curbone) {

		if (curbone->IsSkeleton()) {
			InsertCopyMP(limitdegflag, curbone, curframe);
		}
		
		if (curbone->GetChild(false)) {
			InsertCopyMPReq(limitdegflag, curbone->GetChild(false), curframe);
		}
		if (curbone->GetBrother(false)) {
			InsertCopyMPReq(limitdegflag, curbone->GetBrother(false), curframe);
		}
	}
}

int InsertCopyMP(bool limitdegflag, CBone* curbone, double curframe)
{
	double roundingframe = RoundingTime(curframe);

	if (curbone && (curbone->IsSkeleton())) {

		/*
		CMotionPoint* pcurmp = 0;
		pcurmp = curbone->GetMotionPoint(s_model->GetCurMotInfo()->motid, curframe);
		if(pcurmp){
			CPELEM cpelem;
			ZeroMemory(&cpelem, sizeof(CPELEM));
			cpelem.bone = curbone;
			cpelem.mp.SetFrame(curframe);
			cpelem.mp.SetWorldMat(pcurmp->GetWorldMat());
			cpelem.mp.SetLocalMatFlag(0);//!!!!!!!!!!
			s_copymotvec.push_back(cpelem);
		}
		*/

		int rotcenterflag1 = 1;
		ChaMatrix localmat = curbone->CalcLocalScaleRotMat(limitdegflag,
			rotcenterflag1, s_model->GetCurMotInfo()->motid, curframe);
		ChaVector3 curanimtra = curbone->CalcLocalTraAnim(limitdegflag,
			s_model->GetCurMotInfo()->motid, curframe);
		ChaVector3 localscale = curbone->CalcLocalScaleAnim(limitdegflag,
			s_model->GetCurMotInfo()->motid, curframe);

		localmat.AddTranslation(curanimtra);

		////localmat._11 *= localscale.x;
		////localmat._12 *= localscale.x;
		////localmat._13 *= localscale.x;
		////localmat._21 *= localscale.y;
		////localmat._22 *= localscale.y;
		////localmat._23 *= localscale.y;
		////localmat._31 *= localscale.z;
		////localmat._32 *= localscale.z;
		////localmat._33 *= localscale.z;

		//ChaMatrix curmat;
		//ChaMatrix localmat;
		//curmat = curbone->GetWorldMat(limitdegflag,
		//	s_model->GetCurMotInfo()->motid, roundingframe, 0);
		//ChaMatrix parmat, invparmat;
		//ChaMatrixIdentity(&parmat);
		//ChaMatrixIdentity(&invparmat);
		//if (curbone->GetParent()) {
		//	parmat = curbone->GetParent()->GetWorldMat(limitdegflag, 
		//		s_model->GetCurMotInfo()->motid, roundingframe, 0);
		//	invparmat = ChaMatrixInv(parmat);
		//	localmat = curmat * invparmat;
		//}
		//else {
		//	localmat = curmat;
		//}


		CPELEM2 cpelem;
		ZeroMemory(&cpelem, sizeof(CPELEM2));
		cpelem.bone = curbone;
		cpelem.mp.SetFrame(curframe);
		cpelem.mp.SetWorldMat(localmat);
		cpelem.mp.SetLocalMatFlag(1);//!!!!!!!!!!
		s_copymotvec.push_back(cpelem);
	}

	return 0;
}

void InsertSymMPReq(bool limitdegflag, CBone* curbone, double curframe, int symrootmode)
{
	if (curbone) {
		if (curbone->IsSkeleton()) {
			InsertSymMP(limitdegflag, curbone, curframe, symrootmode);
		}

		if (curbone->GetChild(false)) {
			InsertSymMPReq(limitdegflag, curbone->GetChild(false), curframe, symrootmode);
		}
		if (curbone->GetBrother(false)) {
			InsertSymMPReq(limitdegflag, curbone->GetBrother(false), curframe, symrootmode);
		}
	}
}
int InsertSymMP(bool limitdegflag, CBone* curbone, double curframe, int symrootmode)
{
	if (curbone && (curbone->IsSkeleton())) {

		ChaMatrix symmat = curbone->CalcSymXMat2(limitdegflag,
			s_model->GetCurMotInfo()->motid, curframe, symrootmode);

		CPELEM2 cpelem;
		ZeroMemory(&cpelem, sizeof(CPELEM2));
		cpelem.bone = curbone;
		cpelem.mp.SetFrame(curframe);
		cpelem.mp.SetWorldMat(symmat);
		cpelem.mp.SetLocalMatFlag(1);//!!!!!!!!!!
		s_copymotvec.push_back(cpelem);
	}

	return 0;
}



//int AdjustBoneTra( CBone* curbone, double curframe )
//{
//	CMotionPoint* pcurmp = 0;
//	pcurmp = curbone->GetMotionPoint(s_model->GetCurMotInfo()->motid, curframe);
//	if(pcurmp){
//		ChaVector3 orgpos;
//		ChaVector3 tmpfpos = curbone->GetJointFPos();
//		ChaMatrix tmpbefwm = pcurmp->GetBefWorldMat();
//		ChaVector3TransformCoord( &orgpos, &tmpfpos, &tmpbefwm);
//
//		ChaVector3 newpos;
//		ChaMatrix tmpwm = pcurmp->GetWorldMat();
//		ChaVector3TransformCoord( &newpos, &tmpfpos, &tmpwm);
//
//		ChaVector3 diffpos;
//		diffpos = orgpos - newpos;
//
//		CEditRange tmper;
//		KeyInfo tmpki;
//		tmpki.time = curframe;
//		list<KeyInfo> tmplist;
//		tmplist.push_back( tmpki );
//		tmper.SetRange( tmplist, curframe );
//		s_model->FKBoneTra( 0, &tmper, curbone->GetBoneNo(), diffpos );
//	}
//
//	return 0;
//}


//--------------------------------------------------------------------------------------
// This callback function will be called at the end of every frame to perform all the 
// rendering calls for the scene, and it will also be called if the window needs to be 
// repainted. After this function has returned, DXUT will call 
// IDirect3DDevice9::Present to display the contents of the next buffer in the swap chain
//--------------------------------------------------------------------------------------

void OnRenderNowLoading()
{
	/*
	HBRUSH GetSysColorBrush(
		int nIndex
	);

	　システムカラーのインデックスまたは定義されている定数名を指定します。
	　定義されているシステムカラーは以下の通りです。重複している定数もありますので、インデックスも表記しています。

	定数	 	内容
	COLOR_SCROLLBAR	0	スクロールバーの灰色の領域。
	COLOR_DESKTOP
	COLOR_BACKGROUND	1	デスクトップの色。
	COLOR_ACTIVECAPTION	2	アクティブなウィンドウのタイトルバーの色。
	グラデーションが有効な場合はグラデーションの左側の色。
	COLOR_INACTIVECAPTION	3	非アクティブなウィンドウのタイトルバーの色。
	グラデーションが有効な場合はグラデーションの左側の色。
	COLOR_MENU	4	メニューの背景色。
	COLOR_WINDOW	5	ウィンドウの背景色。
	COLOR_WINDOWFRAME	6	ウィンドウフレームの色。
	COLOR_MENUTEXT	7	メニュー内のテキストの色。
	COLOR_WINDOWTEXT	8	ウィンドウ内のテキストの色。
	COLOR_CAPTIONTEXT	9	キャプション、サイズボックス、スクロールバーの矢印ボックス内のテキストの色。
	COLOR_ACTIVEBORDER	10	アクティブなウィンドウの境界線の色。
	COLOR_INACTIVEBORDER	11	非アクティブなウィンドウの境界線の色。
	COLOR_APPWORKSPACE	12	MDIウィンドウの背景色。
	COLOR_HIGHLIGHT	13	コントロールで選択された時の反転色。
	COLOR_HIGHLIGHTTEXT	14	コントロールで選択された時のテキストの色。
	COLOR_3DFACE
	COLOR_BTNFACE	15	3D表示及びダイアログボックスの背景色。
	COLOR_3DSHADOW
	COLOR_BTNSHADOW	16	3D表示の影の色。
	COLOR_GRAYTEXT	17	無効のテキストの色。
	COLOR_BTNTEXT	18	プッシュボタンのテキストの色。
	COLOR_INACTIVECAPTIONTEXT	19	非アクティブウィンドウのキャプションのテキスト色。
	COLOR_3DHILIGHT
	COLOR_3DHIGHLIGHT
	COLOR_BTNHILIGHT
	COLOR_BTNHIGHLIGHT	20	3D表示のハイライト色。
	COLOR_3DDKSHADOW	21	3D表示の暗い影の色。
	COLOR_3DLIGHT	22	3D表示の光の色。
	COLOR_INFOTEXT	23	ツールチップのテキスト色。
	COLOR_INFOBK	24	ツールチップの背景色。
	-	25	不明
	COLOR_HOTLIGHT	26	ハイパーリンクされたアイテムの色。
	COLOR_GRADIENTACTIVECAPTION	27	アクティブウィンドウのタイトルバーのグラデーション右側の色。
	COLOR_GRADIENTINACTIVECAPTION	28	非アクティブウィンドウのタイトルバーのグラデーション右側の色。
	COLOR_MENUHILIGHT	29	ハイライトされたメニューアイテムの色。
	COLOR_MENUBAR	29	メニューバーの背景色。
	 */


	HDC hdc;
	RECT rect;
	HBRUSH brush;
	hdc = ::GetDC(s_3dwnd);
	::GetClientRect(s_3dwnd, &rect);
	brush = CreateSolidBrush(BLACK_BRUSH);
	//brush = CreateSolidBrush(RGB(64, 128, 256));
	//brush = ::GetSysColorBrush(COLOR_HIGHLIGHT);//黒と青でちらくつ
	//brush = ::GetSysColorBrush(COLOR_HIGHLIGHT);
	::FillRect(hdc, &rect, brush);
	::DeleteObject(brush);
	::ReleaseDC(s_3dwnd, hdc);

	return;

}

void OnFrameRender(myRenderer::RenderingEngine* re, RenderContext* rc, double fTime, float fElapsedTime)
{
	if (!re || !rc) {
		_ASSERT(0);
		return;
	}

	////OnRenderNowLoadingも何も無しだとdevice->Presentで固まる。 OnRenderNowLoadingを入れると３Dモデル表示がちらつく。よって通常描画する。
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	//	//OnRenderNowLoading();
	//	return;
	//}

	if (!s_chascene) {
		_ASSERT(0);
		return;
	}
	if ((s_chascene->GetModelNum() > 0) && 
		s_model && s_model->GetLoadedFlag() && (s_nowloading == false)) {
		SetCamera3DFromEyePos();
	}
	else {
		OnRenderNowLoading();
		Sleep(1);
		return;//!!!!!!!!!!!! ModelNum == 0のときは　すぐにリターン
	}


	// レンダリング開始
	g_engine->BeginFrame();


	//g_camera3D->MoveForward(g_pad[0]->GetLStickYF());
	//g_camera3D->MoveRight(g_pad[0]->GetLStickXF());
	//g_camera3D->MoveUp(g_pad[0]->GetRStickYF());

	//// Render the light arrow so the user can visually see the light dir
	//for (int i = 0; i < g_nNumActiveLights; i++)
	//{
	//	DirectX::XMFLOAT4 arrowColor = (i == g_nActiveLight) ? DirectX::XMFLOAT4(1, 1, 0, 1) : DirectX::XMFLOAT4(1, 1, 1, 1);
	//	//V(g_LightControl[i].OnRender10(arrowColor, &mView, &mProj, //#replacing comment out#g_Camera->GetEyePt()));
	//	vLightDir[i] = ChaVector3(g_LightControl[i].GetLightDirection());
	//	vLightDiffuse[i] = ChaVector4(1, 1, 1, 1) * g_fLightScale;
	//}

	////V(g_pLightDir->SetRawValue(vLightDir, 0, sizeof(ChaVector3) * MAX_LIGHTS));
	////V(g_pLightDiffuse->SetFloatVectorArray((float*)vLightDiffuse, 0, MAX_LIGHTS));
	////V(g_pmWorldViewProjection->SetMatrix((float*)&mWorldViewProjection));
	////V(g_pmWorld->SetMatrix((float*)&mWorld));
	////V(g_pfTime->SetFloat((float)fTime));
	////V(g_pnNumLights->SetInt(g_nNumActiveLights));


	//if ((InterlockedAdd(&g_retargetbatchflag, 0) == 0) && (InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 0) && (InterlockedAdd(&g_motioncachebatchflag, 0) == 0) &&
	if ((InterlockedAdd(&g_retargetbatchflag, 0) == 0) && (InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 0) && (InterlockedAdd(&g_calclimitedwmflag, 0) == 0) &&
		!s_underdelmodel && !s_underdelmotion && 
		!s_underselectmodel && !s_underselectmotion && !s_underselectcamera && !s_underdispmodel && !g_changeUpdateThreadsNum) {

		if (s_disponlyoneobj == false) {

			int lightflag = 1;
			ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, 1.0f);
			int btflag;
			if ((g_previewFlag != 4) && (g_previewFlag != 5)) {
				btflag = 0;
			}
			else {
				btflag = 1;
			}

			bool calcslotflag = false;
			s_chascene->SetBoneMatrixForShader(btflag, calcslotflag);
			s_chascene->RenderModels(re, lightflag, diffusemult, btflag);

			if (s_ground) {
				OnRenderGround(re, rc);//メッシュではなくラインオブジェクト
			}

			OnRenderBoneMark(re, rc);

			if (s_dispselect && s_select) {
				OnRenderSelect(re, rc);
			}


		}
		else {
			//OnRenderOnlyOneObj(pRenderContext);
		}
		
		//OnRenderUtDialog(fElapsedTime);

		if (s_dispsampleui) {//ctrl + 1 (one) key --> toggle
			OnRenderSprite(re, rc);
		}

		OnRenderFontForTip(re, rc);

	}
	else {
		OnRenderNowLoading();
	}


	////font test
	//s_fontfortip.Begin(rc);
	//Vector2 fontpos = Vector2(0.0f, 100.0f);
	//Vector4 fontcol = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
	//Vector2 fontpivot = Vector2(0.0f, 0.0f);
	//s_fontfortip.SetShadowParam(true, 1.0, Vector4(0.0f, 1.0f, 0.0f, 1.0f));
	//s_fontfortip.Draw(L"Font Test", fontpos, fontcol, 0.0, 1.0, fontpivot);
	//s_fontfortip.End(rc);



	//レンダリングエンジンを実行
	re->Execute(rc);
	// レンダリング終了
	g_engine->EndFrame(s_chascene);

	

}

//--------------------------------------------------------------------------------------
// Render the help and statistics text. This function uses the ID3DX10Font interface for 
// efficient text rendering.
//--------------------------------------------------------------------------------------

void CalcFps(double fTime)
{
	static double s_savetime = 0.0;
	//double g_calcfps;
	if (fTime != s_savetime) {
		g_calcfps = 1.0 / (fTime - s_savetime);
	}
	else {
		g_calcfps = 100.0;
	}

	if ((s_fps100index >= 0) && (s_fps100index < FPSSAVENUM)) {
		s_fps100[s_fps100index] = g_calcfps;
		s_fps100index++;
		if (s_fps100index >= FPSSAVENUM) {
			s_fps100index = 0;
		}
	}


	//2023/12/15
	//表示用の数字の更新は10fps程にしておく
	if ((s_befftime == 0.0) || ((fTime - s_befftime) >= 0.10)) {
		s_avrgfps = 0.0;
		int saveno;
		for (saveno = 0; saveno < FPSSAVENUM; saveno++) {
			s_avrgfps += s_fps100[saveno];
		}
		s_avrgfps /= (double)FPSSAVENUM;

		s_befftime = fTime;//値を更新した時だけセット
	}


	s_savetime = fTime;
}

void PrepairUndo()
{
	if (!s_model) {
		return;
	}

	//リターゲットバッチ中はSaveUndoしない
	//モデル削除時、モーション削除時はSaveUndoしない
	//UndoRedoボタンを押した場合にはSaveUndoしない

	if ((InterlockedAdd(&g_retargetbatchflag, 0) == 0) && (s_underdelmodel == 0) &&
		(s_underdelmotion == 0) && (s_undoFlag == false) && (s_redoFlag == false)) {
		//2022/09/13 選択範囲だけをアンドゥリドゥするようにした
		//その影響で選択範囲の未編集状態も保存する必要が生じた
		//よって次のif文はコメントアウト
		//if ((s_editmotionflag >= 0) || (g_btsimurecflag == true)) {

		if (s_model) {
			//CreateTimeLineMark();
			SetLTimelineMark(s_curboneno);

			BRUSHSTATE brushstate;
			brushstate.Init();
			brushstate.brushmirrorUflag = g_brushmirrorUflag;
			brushstate.brushmirrorVflag = g_brushmirrorVflag;
			brushstate.ifmirrorVDiv2flag = g_ifmirrorVDiv2flag;
			brushstate.limitdegflag = g_limitdegflag;
			brushstate.motionbrush_method = g_motionbrush_method;
			brushstate.wallscrapingikflag = g_wallscrapingikflag;
			brushstate.brushrepeats = g_brushrepeats;

			HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));//長いフレームの保存は数秒時間がかかることがあるので砂時計カーソルにする

			bool allframeflag;
			if ((s_copyLW2WFlag == true) || (s_changelimitangleFlag == true) ||
				(s_scaleAllInitFlag == true)) {
				allframeflag = true;
			}
			else {
				allframeflag = false;
			}

			//2023/10/27 1.2.0.27 RC5 : s_LimitDegCheckBoxFlag == true時　つまり　LimitEulボタンのオンオフ時はモーションの保存をスキップ
			s_model->SaveUndoMotion(s_LimitDegCheckBoxFlag, g_limitdegflag, s_curboneno, s_curbaseno,
				&s_editrange, (double)g_applyrate, brushstate, allframeflag);

			SetCursor(oldcursor);//カーソルを元に戻す

		}
		s_editmotionflag = -1;

		//}
	}
}


//--------------------------------------------------------------------------------------
// Before handling window messages, DXUT passes incoming windows 
// messages to the application through this callback function. If the application sets 
// *pbNoFurtherProcessing to TRUE, then DXUT will not process this message.
//--------------------------------------------------------------------------------------
LRESULT CALLBACK AppMsgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam
//	, bool* pbNoFurtherProcessing,
//	void* pUserContext
)
{
	if (!s_sampleuihwnd && hWnd && IsWindow(hWnd)) {
		s_sampleuihwnd = hWnd;
	}

	////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	////DXUTのスライダーのマウスアップを捕まえたかった
	////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//if (uMsg == WM_NOTIFY) {
	//	int c;
	//	c = 1;
	//}
	//if(wParam == NM_RELEASEDCAPTURE) {
	//	int d;
	//	d = 1;
	//}



////	DbgOut( L"msgproc!!! %d, %d\r\n", uMsg, WM_LBUTTONDOWN );
//	//if(s_anglelimitdlg && IsDialogMessage(s_anglelimitdlg, &msg))
//
//	// Always allow dialog resource manager calls to handle global messages
//	// so GUI state is updated correctly
//	//g_DialogResourceManager.MsgProc(hWnd, uMsg, wParam, lParam);
//	*pbNoFurtherProcessing = g_DialogResourceManager.MsgProc(hWnd, uMsg, wParam, lParam);
//	if (*pbNoFurtherProcessing) {
//		//_ASSERT(0);
//		return 0;
//	}

	////if( g_SettingsDlg.IsActive() )
	////{
	////    g_SettingsDlg.MsgProc( hWnd, uMsg, wParam, lParam );
	////    //return 0;
	////}

	//// Give the dialogs a chance to handle the message first
	////g_SampleUI.MsgProc(hWnd, uMsg, wParam, lParam);
	//*pbNoFurtherProcessing = g_SampleUI.MsgProc(hWnd, uMsg, wParam, lParam);
	//if (*pbNoFurtherProcessing) {
	//	//_ASSERT(0);
	//	return 0;
	//}

	// Pass all remaining windows messages to camera so it can respond to user input
	////#replacing comment out#g_Camera->HandleMessages(hWnd, uMsg, wParam, lParam);
	CBone* curbone = 0;
	CBone* opebone = 0;
	CRigidElem* curre = 0;
	//if (g_retargetbatchflag == 0) {
	if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
		//int maxboneno = 0;
		if (s_model && (s_curboneno >= 0)) {
			curbone = s_model->GetBoneByID(s_curboneno);
			curre = s_model->GetRigidElem(s_curboneno);
		}
		else {
			curbone = 0;
			curre = 0;
		}

		//if (curbone && curbone->GetParent()) {
		//2023/02/08 opeboneにparentをセットするのは　IKRotのときだけ
		if (curbone && curbone->GetParent(false) && curbone->GetParent(false)->IsSkeleton() && (s_ikkind == 0)) {
			opebone = curbone->GetParent(false);
		}
		else {
			opebone = curbone;
		}



		////if (g_retargetbatchflag == 0) {
		//if (s_model && s_convbone_bvh) {
		//	map<int, CBone*>::iterator itrbone;
		//	for (itrbone = s_convbone_bvh->GetBoneListBegin(); itrbone != s_convbone_bvh->GetBoneListEnd(); itrbone++) {
		//		CBone* curbone = itrbone->second;
		//		if (curbone) {
		//			int boneno = curbone->GetBoneNo();
		//			if (boneno > maxboneno) {
		//				maxboneno = boneno;
		//			}
		//		}
		//	}
		//}
		////}
	}

	if (uMsg == WM_COMMAND) {

		WORD menuid;
		menuid = LOWORD(wParam);
		int modelnum;
		if (s_chascene) {
			modelnum = s_chascene->GetModelNum();
		}
		else {
			modelnum = 0;
		}



		//if ((menuid >= (ID_RMENU_0 + MENUOFFSET_SETCONVBONEMODEL)) && (menuid < (ID_RMENU_0 + modelnum + MENUOFFSET_SETCONVBONEMODEL))) {
		//	int modelindex = menuid - ID_RMENU_0 - MENUOFFSET_SETCONVBONEMODEL;
		//	s_convbone_model = s_modelindex[modelindex].modelptr;

		//	WCHAR strmes[1024];
		//	if (!s_convbone_model) {
		//		swprintf_s(strmes, 1024, L"convbone : sel model : modelptr NULL !!!");
		//		::DSMessageBox(NULL, strmes, L"check!!!", MB_OK);
		//	}
		//	else {
		//		swprintf_s(strmes, 1024, L"%s", s_convbone_model->GetFileName());
		//		s_cbselmodel->setName(strmes);
		//	}
		//}


		//else 



		//if (menuid == (ID_RMENU_IKTARGET + MENUOFFSET_BONERCLICK)) {
		//	int dbgflag1 = 1;
		//}

		if ((menuid >= (ID_RMENU_0 + MENUOFFSET_SETCONVBONEBVH)) && (menuid < (ID_RMENU_0 + modelnum + MENUOFFSET_SETCONVBONEBVH))) {
			int modelindex = menuid - ID_RMENU_0 - MENUOFFSET_SETCONVBONEBVH;
			if (s_chascene) {
				s_convbone_bvh = s_chascene->GetModel(modelindex);
			}
			else {
				s_convbone_bvh = 0;
			}

			WCHAR strmes[1024];
			if (!s_convbone_bvh) {
				swprintf_s(strmes, 1024, L"convbone : sel model : modelptr NULL !!!");
				::DSMessageBox(NULL, strmes, L"check!!!", MB_OK);
				s_maxboneno = 0;
			}
			else {
				swprintf_s(strmes, 1024, L"%s", s_convbone_bvh->GetFileName());
				s_cbselbvh->setName(strmes);
				COLORREF importantcol = RGB(168, 129, 129);
				s_cbselbvh->setTextColor(importantcol);
				//s_maxboneno = s_convbone_bvh->GetBoneListSize();
				//s_maxboneno = s_convbone_bvh->GetBoneForMotionSize();
				s_maxboneno = s_convbone_bvh->GetMaxBoneNo();
			}
		}

		//else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_SETCONVBONE)) && (menuid <= (ID_RMENU_0 + s_maxboneno + 1 + MENUOFFSET_SETCONVBONE))) {
		else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_SETCONVBONE)) && (menuid < (ID_RMENU_0 + MAXBONENUM + MENUOFFSET_SETCONVBONE))) {
			if ((s_bvhbone_cbno >= 0) && (s_bvhbone_cbno < MAXBONENUM)) {
				if (menuid == (ID_RMENU_0 + 0 + MENUOFFSET_SETCONVBONE)) {
					//未設定
					s_bvhbone_bone[s_bvhbone_cbno] = 0;
					CBone* modelbone = s_modelbone_bone[s_bvhbone_cbno];
					_ASSERT(modelbone);
					if (modelbone) {
						s_convbonemap[modelbone] = 0;
					}
					s_bvhbone[s_bvhbone_cbno]->setName(L"NotSet");
					s_bvhbone[s_bvhbone_cbno]->callRewrite();
				}
				else {
					int boneno = menuid - ID_RMENU_0 - 1 - MENUOFFSET_SETCONVBONE;
					curbone = s_convbone_bvh->GetBoneByID(boneno);
					WCHAR strmes[1024];
					if (!curbone) {
						s_bvhbone_bone[s_bvhbone_cbno] = 0;
						CBone* modelbone = s_modelbone_bone[s_bvhbone_cbno];
						_ASSERT(modelbone);
						if (modelbone) {
							s_convbonemap[modelbone] = 0;
						}
						s_bvhbone[s_bvhbone_cbno]->setName(L"NotSet");
						s_bvhbone[s_bvhbone_cbno]->callRewrite();

						swprintf_s(strmes, 1024, L"convbone : sel bvh bone : curbone NULL !!!");
						::DSMessageBox(NULL, strmes, L"check!!!", MB_OK);
					}
					else {
						swprintf_s(strmes, 1024, L"%s", curbone->GetWBoneName());
						s_bvhbone[s_bvhbone_cbno]->setName(strmes);
						s_bvhbone[s_bvhbone_cbno]->callRewrite();
						s_bvhbone_bone[s_bvhbone_cbno] = curbone;

						CBone* modelbone = s_modelbone_bone[s_bvhbone_cbno];
						if (modelbone) {
							s_convbonemap[modelbone] = curbone;
						}
					}
				}
			}

		}

		else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_INTERPOLATEFROMTOOL)) && 
			(menuid < (ID_RMENU_0 + MENUOFFSET_INTERPOLATEFROMTOOL + 3))) {
			if (s_model && s_model->GetTopBone() && curbone) {
				s_interpolateState = (menuid - ID_RMENU_0 - MENUOFFSET_INTERPOLATEFROMTOOL + 1);

				CBone* interpolatebone;
				if (s_ikkind == 0) {
					interpolatebone = opebone;
				}
				else {
					interpolatebone = curbone;
				}


				int operatingjointno = -1;
				operatingjointno = s_model->InterpolateBetweenSelection(g_limitdegflag,
					s_buttonselectstart, s_buttonselectend, interpolatebone, s_interpolateState);

				if ((g_limitdegflag == true) && (operatingjointno >= 0)) {
					bool allframeflag = false;
					bool setcursorflag = false;
					bool onpasteflag = false;
					CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);
				}
				refreshEulerGraph();
				PrepairUndo();
				s_interpolateState = 0;
			}
		}
		else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_FILTERFROMTOOL)) &&
			(menuid < (ID_RMENU_0 + MENUOFFSET_FILTERFROMTOOL + 3))) {
			if (s_model && s_model->GetTopBone() && curbone && (s_underfilteringbymenu == false)) {
				s_underfilteringbymenu = true;
				s_filterState = (menuid - ID_RMENU_0 - MENUOFFSET_FILTERFROMTOOL + 1);
				FilterFuncDlg();
				//s_filterState = 0;//2023/08/09コメントアウト:前回の値を保持
				s_underfilteringbymenu = false;
			}
		}
		else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_CHECKSIMILARGROUP)) &&
			(menuid <= (ID_RMENU_0 + MENUOFFSET_CHECKSIMILARGROUP + 3))) {
			if (s_model && s_groupWnd) {
				int opetype = menuid - (ID_RMENU_0 + MENUOFFSET_CHECKSIMILARGROUP);
				CheckSimilarGroup(opetype);
			}
		}
		//else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_INITMPFROMTOOL)) && (menuid <= (ID_RMENU_0 + 3 * 3 + MENUOFFSET_INITMPFROMTOOL))) {
		else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_INITMPFROMTOOL)) && (menuid <= (ID_RMENU_0 + 4 * 4 + MENUOFFSET_INITMPFROMTOOL))) {//### 2022/07/04
			if (s_model) {
				int subid = (menuid - ID_RMENU_0 - MENUOFFSET_INITMPFROMTOOL) / 4;//4 * 3 / 4 --> 0, 1, 2, 3 : submenu
							//int initmode = (menuid - ID_RMENU_0 - MENUOFFSET_INITMPFROMTOOL) - subid * 4;//0, 1, 2, 3
				int initmode = (menuid - ID_RMENU_0 - MENUOFFSET_INITMPFROMTOOL) % 4;//0, 1, 2, 3 //### 2022/07/04 : subsubmenu
				MOTINFO* mi = s_model->GetCurMotInfo();
				if (mi) {
					s_copymotvec.clear();
					s_copyKeyInfoList.clear();
					//s_copyKeyInfoList = s_owpLTimeline->getSelectedKey();
					//s_editrange.SetRange(s_copyKeyInfoList, s_owpTimeline->getCurrentTime());
					//CEditRange::SetApplyRate((double)g_applyrate);

					OnTimeLineButtonSelectFromSelectStartEnd(0);
					OnTimeLineSelectFromSelectedKey();
					if (s_owpTimeline) {
						s_copyKeyInfoList = s_owpLTimeline->getSelectedKey();
					}

					int updatejointno = -1;

					if (subid == 0) {//all
						list<KeyInfo>::iterator itrcp;
						for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
							double curframe = itrcp->time;
							CBone* topbone = s_model->GetTopBone(false);
							if (topbone) {
								bool broflag = false;
								InitMpByEulReq(initmode, topbone, mi->motid, curframe, broflag);//topbone req
								updatejointno = topbone->GetBoneNo();
							}
						}
					}
					else if (subid == 1) {//one
						if (opebone) {
							list<KeyInfo>::iterator itrcp;
							for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
								double curframe = itrcp->time;
								InitMpByEul(initmode, opebone, mi->motid, curframe);//opebone
								updatejointno = opebone->GetBoneNo();
							}
						}
					}
					else if (subid == 2) {//deeper
						if (opebone) {
							list<KeyInfo>::iterator itrcp;
							for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
								double curframe = itrcp->time;
								bool broflag = false;
								InitMpByEulReq(initmode, opebone, mi->motid, curframe, broflag);//opebone req
								updatejointno = opebone->GetBoneNo();
							}
						}
					}
					else if (subid == 3) {//deeperEndJoint
						if (opebone) {
							list<KeyInfo>::iterator itrcp;
							for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
								double curframe = itrcp->time;
								bool broflag = false;
								InitMpByEulEndJointReq(initmode, opebone, mi->motid, curframe, broflag);//opebone req
								updatejointno = opebone->GetBoneNo();
							}
						}
					}

					if (g_limitdegflag == true) {
						bool allframeflag = false;
						bool setcursorflag = false;
						bool onpasteflag = false;
						CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, updatejointno, onpasteflag);
					}

					s_model->CalcBoneEul(g_limitdegflag, mi->motid);//2023/11/07
					

					refreshEulerGraph();
					PrepairUndo();
				}
			}
		}


		else if (menuid == (ID_RMENU_COPY + MENUOFFSET_BONERCLICK)) {
			if (s_copyFlag == false) {
				s_copyFlag = true;
			}
		}
		else if (menuid == (ID_RMENU_PASTE + MENUOFFSET_BONERCLICK)) {
			if ((s_pasteFlag == false) && (s_RboneAndPasteFlag == false)) {
				s_RboneAndPasteFlag = true;
			}
		}

		else if (menuid == (ID_RMENU_IKTARGET + MENUOFFSET_BONERCLICK)) {
			//toggle
			if (curbone->GetIKTargetFlag() == false){
				curbone->SetIKTargetFlag(true);
			}
			else{
				curbone->SetIKTargetFlag(false);
			}
			if (s_owpTimeline) {
				refreshTimeline(*s_owpTimeline);
			}
		}
		else if (menuid == (ID_RMENU_IKSTOP + MENUOFFSET_BONERCLICK)) {
			//toggle
			if (curbone->GetIKStopFlag() == false) {
				curbone->SetIKStopFlag(true);
			}
			else {
				curbone->SetIKStopFlag(false);
			}
			if (s_owpTimeline) {
				refreshTimeline(*s_owpTimeline);
			}
		}
		//else if (menuid == (ID_RMENU_KINEMATIC_ON_LOWER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->SetKinematicTmpLower(curbone, true);
		//	}
		//}
		//else if (menuid == (ID_RMENU_KINEMATIC_OFF_LOWER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->SetKinematicTmpLower(curbone, false);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_ON_ALL + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_All(true);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_OFF_ALL + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_All(false);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_ON_UPPER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_Upper(true, curbone);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_OFF_UPPER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_Upper(false, curbone);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_ON_LOWER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_Lower(true, curbone);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_OFF_LOWER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_Lower(false, curbone);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0 + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		//toggle
		//		if (curbone->GetMass0() == 0) {
		//			s_model->SetMass0(curbone);
		//		}
		//		else {
		//			s_model->RestoreMass(curbone);
		//		}
		//	}
		//}
		//else if (menuid == (ID_RMENU_EXCLUDE_MV + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		//toggle
		//		if (curbone->GetExcludeMv() == 0) {
		//			curbone->SetExcludeMv(1);
		//		}
		//		else {
		//			curbone->SetExcludeMv(0);
		//		}
		//	}
		//}
		//else if (menuid == (ID_RMENU_FORBIDROT_ONE + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curre) {
		//		curre->SetForbidRotFlag(1);
		//	}
		//}
		//else if (menuid == (ID_RMENU_ENABLEROT_ONE + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curre) {
		//		curre->SetForbidRotFlag(0);
		//	}
		//}
		//else if (menuid == (ID_RMENU_FORBIDROT_CHILDREN + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curre) {
		//		s_model->EnableRotChildren(curbone, false);
		//	}
		//}
		//else if (menuid == (ID_RMENU_ENABLEROT_CHILDREN + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curre) {
		//		s_model->EnableRotChildren(curbone, true);
		//	}
		//}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_BONERCLICK)) {
			//新規
			GUIMenuSetVisible(-1, -1);
			int currigno = -1;
			DispCustomRigDlg(currigno);
		}
		else if ((menuid >= (ID_RMENU_0 + MAXRIGNUM + MENUOFFSET_BONERCLICK)) && (menuid < (ID_RMENU_0 + MAXRIGNUM * 2 + MENUOFFSET_BONERCLICK))) {
			//設定
			GUIMenuSetVisible(-1, -1);
			int currigno = s_customrigmenuindex[menuid - (ID_RMENU_0 + MAXRIGNUM) - MENUOFFSET_BONERCLICK];
			DispCustomRigDlg(currigno);
		}
		else if ((menuid >= (ID_RMENU_0 + MAXRIGNUM * 2 + MENUOFFSET_BONERCLICK)) && (menuid < (ID_RMENU_0 + MAXRIGNUM * 3 + MENUOFFSET_BONERCLICK))) {
			//実行
			int currigno = s_customrigmenuindex[menuid - (ID_RMENU_0 + MAXRIGNUM * 2) - MENUOFFSET_BONERCLICK];
			//Bone2CustomRig(currigno);
			GUIMenuSetVisible(-1, -1);
			DispCustomRigDlg(currigno);//2024/01/21 設定ダイアログ表示をピックしたリグの内容に更新
			if (s_customrigbone) {
				s_oprigflag = 1;
			}
		}
		else if ((menuid >= (ID_RMENU_0 + MAXRIGNUM * 3 + MENUOFFSET_BONERCLICK)) && (menuid < (ID_RMENU_0 + MAXRIGNUM * 4 + MENUOFFSET_BONERCLICK))) {
			//削除(無効化)
			int currigno = s_customrigmenuindex[menuid - (ID_RMENU_0 + MAXRIGNUM * 3) - MENUOFFSET_BONERCLICK];
			InvalidateCustomRig(currigno);
		}


		if ((menuid >= (ID_RMENU_0 + MENUOFFSET_GETSYMROOTMODE)) && (menuid <= (ID_RMENU_0 + 3 + MENUOFFSET_GETSYMROOTMODE))) {
			switch (menuid) {
			case (ID_RMENU_0 + MENUOFFSET_GETSYMROOTMODE):
				s_getsym_retmode = SYMROOTBONE_SAMEORG;
				break;
			case (ID_RMENU_0 + 1 + MENUOFFSET_GETSYMROOTMODE):
				s_getsym_retmode = SYMROOTBONE_SYMDIR | SYMROOTBONE_SYMPOS;
				break;
			case (ID_RMENU_0 + 2 + MENUOFFSET_GETSYMROOTMODE):
				s_getsym_retmode = SYMROOTBONE_SYMDIR;
				break;
			case (ID_RMENU_0 + 3 + MENUOFFSET_GETSYMROOTMODE):
				s_getsym_retmode = SYMROOTBONE_SYMPOS;
				break;
			default:
				s_getsym_retmode = SYMROOTBONE_SYMDIR | SYMROOTBONE_SYMPOS;
				break;
			}
		}






		else if ((menuid >= 59900) && (menuid <= (59900 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 59900;
			OnAnimMenu(true, selindex);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 61000) && (menuid <= (61000 + MAXMODELNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 61000;
			OnModelMenu(true, selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 62000) && (menuid <= (62000 + MAXRENUM))) {
			ActivatePanel(0);
			int selindex = menuid - 62000;
			OnREMenu(selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 63000) && (menuid <= (63000 + MAXRENUM))) {
			ActivatePanel(0);
			int selindex = menuid - 63000;
			OnRgdMenu(selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 64000) && (menuid <= (64000 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 64000;
			OnRgdMorphMenu(selindex);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 64500) && (menuid <= (64500 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 64500;
			OnImpMenu(selindex);
			ActivatePanel(1);
			//return 0;
		}
		else {
			switch (menuid) {
			case ID_40047:
				// "編集・変換"
				// "ボーン軸をXに再計算"
				ActivatePanel(0);
				//RecalcBoneAxisX(0);
				RecalcAxisX_All();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_CAMERADOLLY:
				ActivatePanel(0);
				ShowCameraDollyDlg();
				ActivatePanel(1);
				break;
			case 29800:
				ActivatePanel(0);
				//RegistKey();
				AboutMotionBrush();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_EXPORTBNT:
				ActivatePanel(0);
				ExportBntFile();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_OPEN40001:
				ActivatePanel(0);
				OpenFile();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_BVH2FBX:
				if (s_registflag == 1) {
					ActivatePanel(0);
					BVH2FBX();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_FILE_BVH2FBXBATCH:
				if (s_registflag == 1) {
					ActivatePanel(0);
					BVH2FBXBatch();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_FILE_RETARGETBATCH:
				if (s_registflag == 1) {
					ActivatePanel(0);
					RetargetBatch();
					ActivatePanel(1);
				}
				//return 0;
				break;

				/***
							case ID_SAVE_FBX40039:
								if( s_registflag == 1 ){
									ActivatePanel( 0 );
									ExportFBXFile();
									ActivatePanel( 1 );
								}
								break;
				***/
			case ID_SAVEPROJ_40035:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveProject();
					ActivatePanel(1);
				}
				break;
			case ID_RESAVE_40028:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveREFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_IMPSAVE_40030:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveImpFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_SAVEGCOLI_40033:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveGcoFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_SAVE_MOTIONNAMELIST:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveMotionNameListFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_DISPMW40002:
				DispMotionWindow();
				//return 0;
				break;
			case 4007:
				DispToolWindow();
				//return 0;
				break;
			case 40012:
			{
				bool savedispflag = s_dispobj;
				s_dispobj = !savedispflag;
				DispObjPanel();
				//return 0;
			}
			break;
			case ID_40048:
				//DispConvBoneWindow();
				s_platemenukind = SPPLATEMENUKIND_RETARGET;
				GUIMenuSetVisible(s_platemenukind, 1);
				//return 0;
				break;
			case ID_40049:
				//DispAngleLimitDlg();
				s_platemenukind = SPPLATEMENUKIND_RETARGET;
				GUIMenuSetVisible(s_platemenukind, 2);
				//return 0;
				break;
			case ID_40050:
				DispRotAxisDlg();
				//return 0;
				break;
			case ID_DISPMODELPANEL:
			{
				bool savedispflag = s_dispmodel;
				s_dispmodel = !savedispflag;
				DispModelPanel();
				//return 0;
			}
			break;
			case ID_MOTIONPANEL:
			{
				bool savedispflag = s_dispmotion;
				s_dispmotion = !savedispflag;
				DispMotionPanel();
				//return 0;
			}
			break;
			case ID_CAMERAPANEL:
			{
				bool savedispflag = s_dispcamera;
				s_dispcamera = !savedispflag;
				DispCameraPanel();
				//return 0;
			}
			break;
			case ID_SETTINGS:
			{
				CSettingsDlg dlg;
				dlg.DoModal();
			}
			break;

			case ID_DISPGROUND:
				s_dispground = !s_dispground;
				//return 0;
				break;
			case ID_NEWMOT:
				s_newmotFlag = true;
				//AddMotion( 0 );
				//InitCurMotion(0, 0);
				////return 0;
				break;
			case ID_DELCURMOT:
				if (s_model) {
					s_delcurmotFlag = true;
					//OnDelMotion(s_motmenuindexmap[s_model]);
				}
				//return 0;
				break;
			case ID_DELMODEL:
				s_delmodelFlag = true;
				//OnDelModel( s_curmodelmenuindex );
				//return 0;
				break;
			case ID_DELALLMODEL:
				s_delallmodelFlag = true;
				//OnDelAllModel();
				//return 0;
				break;
			default:
				break;
			}
		}
	}
	else if (uMsg == WM_MOUSEWHEEL) {
		if ((g_keybuf['T'] & 0x80) != 0) {
			if (s_model && (s_curboneno > 0)) {
				s_tkeyflag = 1;

				int delta;
				delta = GET_WHEEL_DELTA_WPARAM(wParam);
				s_ikselectmat = s_selm;
				//s_editmotionflag = s_model->TwistBoneAxisDelta(&s_editrange, s_curboneno, (float)delta, g_iklevel, s_ikcnt, s_ikselectmat);
				s_editmotionflag = s_model->IKRotateAxisDelta(g_limitdegflag,
					&s_editrange, PICK_X, s_curboneno, (float)delta, g_iklevel, s_ikcnt, s_ikselectmat);

				//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
				//UpdateEditedEuler();
			}
		}

		/*
		int delta;
		delta = GET_WHEEL_DELTA_WPARAM(wParam);
		if (g_underselectingframe == 1){
			OnTimeLineButtonSelectFromSelectStartEnd((double)delta, 0);
		}
		else{
			OnTimeLineCursor();
		}
		*/
		/*
		if( g_keybuf[VK_CONTROL] & 0x80 ){
			float radstep = 0.5f * (float)DEG2PAI;
			float delta;

			int curdelta;
			curdelta = GET_WHEEL_DELTA_WPARAM(wParam);
			if( curdelta >= 0 ){
				delta = radstep;
			}else{
				delta = -1.0f * radstep;
			}

			if( s_model && s_model->GetTopBt() ){
//s_model->CalcBtAxismat( delta );//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			}
		}
		*/


	}
	else if(uMsg == WM_CAPTURECHANGED){
		//if ((HWND)lParam != hWnd) {
		//	::SendMessage(hWnd, WM_LBUTTONUP, 0, 0);
		//}
	}
	else if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_LBUTTONDBLCLK)) {

		if (UnderDragOperation_R()) {
			s_cancelLButtonDown = true;
			return 0;//!!!!!!!!!!!!!!!!
		}

		if (!s_model) {
			//!!!!!!!!!!!!!! 
			return DefWindowProc(hWnd, uMsg, wParam, lParam);
		}


		if (s_curboneno >= 0) {
			s_saveboneno = s_curboneno;
		}
		//s_curboneno = -1;

		s_ikcnt = 0;
		s_rectime = 0.0;
		s_reccnt = 0;

		
		if (s_model) {
			s_model->ClearIKRotRec();
			s_model->ClearIKRotRecUV();
		}

		//!!!!!!!!!!!!!!!!!!!!!!!!!!
		//DS deviceがあっても、マウスを併用する場合があるのでマウスのSetCaptureとReleaseCaptureは必要
		//!!!!!!!!!!!!!!!!!!!!!!!!!!

		//if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
			//DS deviceが無い場合
		//SetCapture(s_3dwnd);
		//}
		//SetCapture( s_3dwnd );


		//SetCapture(DXUTGetHWND());
		SetCapture(s_3dwnd);
		
		


		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);

		{
			//UndoRedo
			int pickundo = 0;
			pickundo = PickSpUndo(ptCursor);
			if (pickundo == PICK_UNDO) {
				//RollbackCurBoneNo();
				if ((s_undoFlag == false) && (s_redoFlag == false)) {
					s_undoFlag = true;
				}
				//PostMessage(g_mainhwnd, WM_KEYDOWN, VK_CONTROL | 'Z', 0);
				//PostMessage(s_3dwnd, WM_KEYDOWN, VK_CONTROL | 'Z', 0);
			}
			else if (pickundo == PICK_REDO)
			{
				//RollbackCurBoneNo();
				if ((s_undoFlag == false) && (s_redoFlag == false)) {
					s_redoFlag = true;
				}
				//PostMessage(g_mainhwnd, WM_KEYDOWN, VK_CONTROL | VK_SHIFT | 'Z', 0);
				//PostMessage(s_3dwnd, WM_KEYDOWN, VK_CONTROL | VK_SHIFT | 'Z', 0);
			}
		}


		s_pickinfo.clickpos = ptCursor;
		s_pickinfo.mousepos = ptCursor;
		s_pickinfo.mousebefpos = ptCursor;
		s_pickinfo.diffmouse = ChaVector2(0.0f, 0.0f);
		s_pickinfo.firstdiff = ChaVector2(0.0f, 0.0f);

		//s_pickinfo.winx = (int)DXUTGetWindowWidth();
		//s_pickinfo.winy = (int)DXUTGetWindowHeight();
		s_pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
		s_pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
		s_pickinfo.pickrange = PICKRANGE;

		s_pickinfo.pickobjno = -1;

		int platemenukind = s_platemenukind;
		int nextplatemenukind = 0;
		int nextplateno = 0;


		//if (s_dispmodel && s_modelpanel.panel && s_modelpanel.separator) {
		//	
		//	//SetCapture(s_modelpanel.panel->getHWnd());//!!!!!!!!!!!!
		//	POINT tmppos;
		//	GetCursorPos(&tmppos);
		//	LPARAM panallparam;
		//	panallparam = (tmppos.y << 16) | tmppos.x;
		//	SendMessage(s_modelpanel.panel->getHWnd(), WM_LBUTTONDOWN, MK_LBUTTON, panallparam);
		//}

		//check and op rigflag : s_oprigflag turn to 1 when RClickRigMenu selected too.
		{
			//IK Mode
			int pickikmodeflag = 0;
			pickikmodeflag = PickSpIkModeSW(ptCursor);
			if (pickikmodeflag == 1) {
				s_ikkind = 0;
				s_spikmodesw[0].state = true;
				s_spikmodesw[1].state = false;
				s_spikmodesw[2].state = false;
				SetLTimelineMark(s_curboneno);//グラフの操作ジョイント名表示も
				refreshEulerGraph();
			}
			else if (pickikmodeflag == 2) {
				s_ikkind = 1;
				s_spikmodesw[0].state = false;
				s_spikmodesw[1].state = true;
				s_spikmodesw[2].state = false;
				SetLTimelineMark(s_curboneno);//グラフの操作ジョイント名表示も
				refreshEulerGraph();
			}
			else if (pickikmodeflag == 3) {
				s_ikkind = 2;
				s_spikmodesw[0].state = false;
				s_spikmodesw[1].state = false;
				s_spikmodesw[2].state = true;
				SetLTimelineMark(s_curboneno);//グラフの操作ジョイント名表示も
				refreshEulerGraph();
			}
		}
		{
			//RefPos switch
			int picklodflag = 0;
			picklodflag = PickSpLODSW(ptCursor);
			if (picklodflag == 1) {
				s_splod.state = !s_splod.state;
			}
		}
		{
			//limiteul switch
			int picklimiteulflag = 0;
			picklimiteulflag = PickSpLimitEulSW(ptCursor);
			if (picklimiteulflag == 1) {
				//2023/02/15
				bool newstate = !s_splimiteul.state;
				ChangeLimitDegFlag(newstate, true, true);
			}
		}
		{
			//cameramode switch
			int pickcameramodeflag = 0;
			pickcameramodeflag = PickSpCameraModeSW(ptCursor);
			if (pickcameramodeflag == 1) {
				ChangeCameraMode(0);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2
			}
		}
		{
			//camerainherit switch
			int pickcamerainheritflag = 0;
			pickcamerainheritflag = PickSpCameraInheritSW(ptCursor);
			if (pickcamerainheritflag == 1) {
				ChangeCameraInherit();
			}
		}
		{
			//wallscraping switch
			int pickscrapingflag = 0;
			pickscrapingflag = PickSpScrapingSW(ptCursor);
			if (pickscrapingflag == 1) {
				bool newstate = !s_spscraping.state;
				ChangeWallScrapingIKFlag(newstate);
			}
		}

		//2023/02/04
		//Bake LimitedWorld-->World : currentmotion fullframe
		if (PickSpCpLW2W(ptCursor) != 0) {
			if (s_copyLW2WFlag == false) {
				s_copyLW2WFlag = true;
			}
		}

		if (PickSpSmooth(ptCursor) != 0) {
			if (s_smoothFlag == false) {
				s_smoothFlag = true;
			}
		}

		if (PickSpConstExe(ptCursor) != 0) {
			if (s_constexeFlag == false) {
				s_constexeFlag = true;
			}
		}
		if (PickSpConstRefresh(ptCursor) != 0) {
			if (s_constrefreshFlag == false) {
				s_constrefreshFlag = true;
			}
		}


		if (PickSpFrog2(ptCursor) != 0) {
			if (s_model) {
				ChangeToolSpriteMode();
			}
		}
		if (PickSpCopy(ptCursor) != 0) {
			if (s_model) {
				if (s_copyFlag == false) {
					s_copyFlag = true;
				}
			}
		}
		if (PickSpSymCopy(ptCursor) != 0) {
			if (s_model) {
				if (s_symcopyFlag == false) {
					s_symcopyFlag = true;
				}
			}
		}
		if (PickSpPaste(ptCursor) != 0) {
			if (s_model) {
				if (s_pasteFlag == false) {
					s_pasteFlag = true;
				}
			}
		}
		if (PickSpCopyHistory(ptCursor) != 0) {
			if (s_model) {
				if (s_selCopyHisotryFlag == false) {
					s_selCopyHisotryFlag = true;
				}
			}
		}

		if (PickSpInterpolate(ptCursor) != 0) {
			if (s_model) {
				if (s_interpolateFlag == false) {
					s_interpolateFlag = true;
				}
			}
		}
		if (PickSpInit(ptCursor) != 0) {
			if (s_model) {
				if (s_initmpFlag == false) {
					s_initmpFlag = true;
				}
			}
		}
		if (PickSpScaleInit(ptCursor) != 0) {
			if (s_model) {
				if (s_scaleAllInitFlag == false) {
					s_scaleAllInitFlag = true;
				}
			}
		}
		if (PickSpProperty(ptCursor) != 0) {
			if (s_model) {
				if (s_motpropFlag == false) {
					s_motpropFlag = true;
				}
			}
		}


		if (PickSpZeroFrame(ptCursor) != 0) {
			if (s_model) {
				if (s_zeroFrameFlag == false) {
					s_LstopFlag = true;
					g_previewFlag = 0;
					s_LcursorFlag = true;
					s_zeroFrameFlag = true;
				}
			}
		}
		if (PickSpCameraDolly(ptCursor) != 0) {
			if (s_model) {
				if (s_cameradollyFlag == false) {
					s_cameradollyFlag = true;
				}
			}
		}
		if (PickSpModelPosDir(ptCursor) != 0) {
			if (s_model) {
				if (s_modelworldmatFlag == false) {
					s_modelworldmatFlag = true;
				}
			}
		}
		if (PickSpMaterialRate(ptCursor) != 0) {
			if (s_model) {
				if (s_materialrateFlag == false) {
					s_materialrateFlag = true;
				}
			}
		}



		int oprigdoneflag = 0;
		int pickrigflag = 0;
		pickrigflag = PickSpRig(ptCursor);
		if (pickrigflag == 1) {


			//開いている設定ダイアログを閉じないと、設定ダイアログのrigboneと新たなrigboneが異なってしまい、Applyボタンで異なるリグを保存することがある
			if (s_customrigdlg) {
				DestroyWindow(s_customrigdlg);
				s_customrigdlg = 0;
			}


			if (s_oprigflag == 1) {

				//オンだったRigをオフにする
				RollbackCurBoneNo();
				ToggleRig();
				oprigdoneflag = 1;

				s_curboneno = -1;//Sprite Menuより後で。Rigid作成に選択済s_curbonenoが必要。
			}
			else {

				//オフだったリグをオンにする
				RollbackCurBoneNo();

				ToggleRig();
				oprigdoneflag = 1;
				//s_oprigflag == 1 のときのpickrigflag == 0　だから　rigはオン
				//s_curboneno はそのまま
			}
		}


		//menukind : from 0 to 4
		//plateno : from 1 to platenum
		GUIGetNextMenu(ptCursor, platemenukind, &nextplatemenukind, &nextplateno);
		if ((nextplatemenukind >= 0) && (nextplateno != 0)) {
			s_platemenukind = nextplatemenukind;
			s_platemenuno = nextplateno;
			GUIMenuSetVisible(s_platemenukind, nextplateno);
		}

		//s_curboneno = -1;//Sprite Menuより後で。Rigid作成に選択済s_curbonenoが必要。

		int spckind = 0;
		if (s_spguisw[SPGUISW_CAMERA_AND_IK].state && ((spckind = PickSpCam(ptCursor)) != 0)) {
			s_pickinfo.buttonflag = spckind;
			s_pickinfo.pickobjno = -1;
			RollbackCurBoneNo();
		}
		else if (s_model) {
			int spakind = 0;
			//int pickrigflag = 0;
			if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
				spakind = PickSpAxis(ptCursor);
				//pickrigflag = PickSpRig(ptCursor);
			}
			if ((spakind != 0) && (s_saveboneno >= 0)) {
				RollbackCurBoneNo();
				s_pickinfo.buttonflag = spakind;
				s_pickinfo.pickobjno = s_curboneno;

				//g_underIKRot = true;//2023/10/14 !!!!! 設定し忘れていた
				//g_underIKRotApplyFrame = true;//2023/10/14 !!!!! 設定し忘れていた
				s_model->SetUnderIKRot(true);
				s_model->SetUnderIKRotApplyFrame(true);


				//} else if ((oprigdoneflag == 0) && (pickrigflag == 1)){
				//	RollbackCurBoneNo();
				//	ToggleRig();

			}
			else {
				if (s_oprigflag == 0) {
					if (g_shiftkey == false) {
						CallF(s_model->PickBone(&s_pickinfo), return 1);
					}
					if (s_pickinfo.pickobjno >= 0) {
						s_curboneno = s_pickinfo.pickobjno;//!!!!!!!

						if (s_owpTimeline) {
							s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
						}

						ChangeCurrentBone();


						//if (s_model->GetInitAxisMatX() == 0){//OnAnimMenuに移動
						//	s_owpLTimeline->setCurrentTime(0.0, true);
						//	s_owpEulerGraph->setCurrentTime(0.0, false);
						//	s_model->SetMotionFrame(0.0);
						//	s_model->UpdateMatrix(&s_model->GetWorldMat(), &s_matVP);
						//	//ここでAxisMatXの初期化
						//	s_model->CreateBtObject(1);
						//	s_model->CalcBtAxismat(2);//2
						//	s_model->SetInitAxisMatX(1);
						//}

						s_pickinfo.buttonflag = PICK_CENTER;//!!!!!!!!!!!!!
						//g_underIKRot = true;
						//g_underIKRotApplyFrame = true;
						s_model->SetUnderIKRot(true);
						s_model->SetUnderIKRotApplyFrame(true);


						//IK中は30fpsにする
						//IK中の描画回数が多いと　IKROTRECの保存数が多すぎて
						//ドラッグ終了後のウェイトカーソルが長くなりすぎる
						//IKROTREC保存数を減らすため30fps
						g_fpsforce30 = true;


						//CModel::PickBone内でセット
						//s_pickinfo.firstdiff.x = (float)s_pickinfo.clickpos.x - s_pickinfo.objscreen.x;
						//s_pickinfo.firstdiff.y = (float)s_pickinfo.clickpos.y - s_pickinfo.objscreen.y;

					}
					else {
						bool pickring = false;
						int pickmanipulator = PickManipulator(&s_pickinfo, pickring);
						if (pickmanipulator >= 0) {
							//g_underIKRot = true;
							//g_underIKRotApplyFrame = true;
							s_model->SetUnderIKRot(true);
							s_model->SetUnderIKRotApplyFrame(true);

							//IK中は30fpsにする
							//IK中の描画回数が多いと　IKROTRECの保存数が多すぎて
							//ドラッグ終了後のウェイトカーソルが長くなりすぎる
							//IKROTREC保存数を減らすため30fps
							g_fpsforce30 = true;
						}
					}
				}
				else {
					int savecurboneno = s_curboneno;
					CBone* saverigbone = s_customrigbone;
					int pickrigboneno = PickRigBone(&s_pickinfo);
					if (pickrigboneno < 0) {
						s_curboneno = savecurboneno;
						s_customrigbone = saverigbone;

						//ZeroMemory(&s_pickinfo, sizeof(UIPICKINFO));
						s_pickinfo.pickobjno = savecurboneno;
					}
					else {
						//g_underIKRot = true;
						//g_underIKRotApplyFrame = true;
						s_model->SetUnderIKRot(true);
						s_model->SetUnderIKRotApplyFrame(true);

						//IK中は30fpsにする
						//IK中の描画回数が多いと　IKROTRECの保存数が多すぎて
						//ドラッグ終了後のウェイトカーソルが長くなりすぎる
						//IKROTREC保存数を減らすため30fps
						g_fpsforce30 = true;
					}
				}
				//if( s_owpLTimeline && s_model && s_model->GetCurMotInfo() ){
				//	int curlineno = s_owpLTimeline->getCurrentLine();
				//	if( curlineno == 1 ){
				//		s_editrange.SetRange( s_owpLTimeline->getSelectedKey(), s_owpTimeline->getCurrentTime() );
				//	}
				//}
			}
		}
		else {
			ZeroMemory(&s_pickinfo, sizeof(UIPICKINFO));
			s_pickinfo.pickobjno = -1;
		}

		//ChaMatrixIdentity(&s_ikselectmat);
		if (s_model && (s_curboneno >= 0)) {
			curbone = s_model->GetBoneByID(s_curboneno);
			_ASSERT(curbone);
			if (curbone) {
				s_saveboneno = s_curboneno;

				if (s_camtargetflag) {
					g_befcamtargetpos = g_camtargetpos;
					g_camtargetpos = curbone->GetChildWorld();
				}
				MOTINFO* curmi = s_model->GetCurMotInfo();
				if (curmi) {
					//int multworld = 1;
					//s_ikselectmat = curbone->CalcManipulatorMatrix(0, 0, multworld, curmi->motid, curmi->curframe);//curmotinfo!!!
					s_ikselectmat = s_selm;
					//if (curbone && curbone->GetParent()) {
					//	curbone->GetParent()->CalcAxisMatX(0, curbone, &s_ikselectmat, 0);
					//}
					//else {
					//	s_ikselectmat = s_selm;
					//}
					s_ikselectmat.SetTranslationZero();
				}
			}
		}


		//pickでボーン選択が変わらなかったとき。モーションフレーム選択をした場合など。
		if ((s_curboneno <= 0) && (s_saveboneno > 0)) {
			s_curboneno = s_saveboneno;
		}


		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));//!!!!!!!!!!
		//////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));//!!!!!!!!!!
		ChaVector3 diffv = g_camEye - g_camtargetpos;
		g_camdist = (float)ChaVector3LengthDbl(&diffv);


		//if (s_model && (s_pickinfo.pickobjno >= 0) && (g_previewFlag == 5)){
		if (s_model && (g_previewFlag == 5)) {
			if ((s_pickinfo.pickobjno >= 0)) {// && 
				//((s_spguisw[SPGUISW_CAMERA_AND_IK].state == false)) || (PickSpBt(ptCursor) == 0))){//物理IK中でジョイントをクリックしていて、Applyボタンを押していないとき
				StartBt(s_model, TRUE, 1, 1);
				//s_model->BulletSimulationStart();
			}
		}


		if (s_model && (s_curboneno >= 0)) {
			SetRigidLeng();
			SetImpWndParams();
			SetDmpWndParams();
			RigidElem2WndParam();
		}

	}
	else if (uMsg == WM_MBUTTONDOWN) {

	}
	else if (uMsg == WM_MOUSEMOVE) {

		OnMouseMoveFunc();

	}
	else if (uMsg == WM_LBUTTONUP) {
		if (s_cancelLButtonDown) {
			s_cancelLButtonDown = false;
			return 0;
		}

		if (!s_model) {
			//!!!!!!!!!!!!!! 
			return DefWindowProc(hWnd, uMsg, wParam, lParam);
		}


		//if (s_dispmodel && s_modelpanel.panel && s_modelpanel.separator) {
		//	POINT tmppos;
		//	GetCursorPos(&tmppos);
		//	LPARAM panallparam;
		//	panallparam = (tmppos.y << 16) | tmppos.x;
		//	SendMessage(s_modelpanel.panel->getHWnd(), WM_LBUTTONUP, MK_LBUTTON, panallparam);
		//}


		//!!!!!!!!!!!!!!!!!!!!!!!!!!
		//DS deviceがあっても、マウスを併用することがあるのでマウスのSetCaptureとReleaseCaptureは必要
		//!!!!!!!!!!!!!!!!!!!!!!!!!!

		//if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
			//DS deviceが無い場合
		ReleaseCapture();
		//}
		//ReleaseCapture();


		bool ikdoneflag = false;
		int ikframenum = 0;
		double startframe = 1.0;
		double endframe = 1.0;
		if (s_editmotionflag >= 0) {
			//s_editrangeがクリアされないうちにフレーム数を保存
			//ikframenum = s_editrange.GetKeyNum();
			s_editrange.GetRange(&ikframenum, &startframe, &endframe);
		}


		//マウスによるIKとFKの後処理　applyframe以外のフレームの処理
		//g_underIKRotApplyFrame = false;
		s_model->SetUnderIKRotApplyFrame(false);

		g_fpsforce30 = false;
		int editmotionflag = s_editmotionflag;
		if ((s_undoFlag == false) && (s_redoFlag == false)) {
			if (s_oprigflag == 0) {
				if ((s_ikkind == 0) && (editmotionflag >= 0)) {
					if (s_pickinfo.buttonflag == PICK_CENTER) {
						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
						s_editmotionflag = s_model->IKRotatePostIK(g_limitdegflag,
							&s_editrange, s_pickinfo.pickobjno, g_iklevel);

						if (oldcursor != NULL) {
							SetCursor(oldcursor);
						}
						ikdoneflag = true;
					}
					else if ((s_pickinfo.buttonflag == PICK_X) ||
						(s_pickinfo.buttonflag == PICK_Y) ||
						(s_pickinfo.buttonflag == PICK_Z) ||
						(s_pickinfo.buttonflag == PICK_SPA_X) ||
						(s_pickinfo.buttonflag == PICK_SPA_Y) ||
						(s_pickinfo.buttonflag == PICK_SPA_Z)) {
						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

						s_editmotionflag = s_model->IKRotateAxisDeltaPostIK(
							g_limitdegflag,
							&s_editrange, s_pickinfo.buttonflag, s_pickinfo.pickobjno,
							g_iklevel, s_ikcnt);


						if (oldcursor != NULL) {
							SetCursor(oldcursor);
						}
						ikdoneflag = true;
					}
				}
				else if ((s_ikkind == 1) && (editmotionflag >= 0)) {
					if (s_pickinfo.buttonflag == PICK_CENTER) {
						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

						//g_underPostFKTra = true;
						s_model->SetUnderPostFKTra(true);

						s_model->FKBoneTraPostFK(g_limitdegflag,
							&s_editrange, s_curboneno);
						s_editmotionflag = s_curboneno;

						//g_underPostFKTra = false;
						s_model->SetUnderPostFKTra(false);

						if (oldcursor != NULL) {
							SetCursor(oldcursor);
						}
						ikdoneflag = true;
					}
					else if ((s_pickinfo.buttonflag == PICK_X) ||
						(s_pickinfo.buttonflag == PICK_Y) ||
						(s_pickinfo.buttonflag == PICK_Z) ||
						(s_pickinfo.buttonflag == PICK_SPA_X) ||
						(s_pickinfo.buttonflag == PICK_SPA_Y) ||
						(s_pickinfo.buttonflag == PICK_SPA_Z)) {
						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

						//g_underPostFKTra = true;
						s_model->SetUnderPostFKTra(true);

						s_model->FKBoneTraAxisPostFK(
							g_limitdegflag,
							&s_editrange, s_curboneno);
						s_editmotionflag = s_curboneno;

						//g_underPostFKTra = false;
						s_model->SetUnderPostFKTra(false);

						if (oldcursor != NULL) {
							SetCursor(oldcursor);
						}
						ikdoneflag = true;
					}
				}

			}
			else {
				if (s_customrigbone && (s_customrigno >= 0) && (editmotionflag >= 0)) {

					HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

					s_ikcustomrig = s_customrigbone->GetCustomRig(s_customrigno);
					s_model->RigControlPostRig(g_limitdegflag,
						0, &s_editrange, s_pickinfo.pickobjno,
						0,
						s_ikcustomrig, s_pickinfo.buttonflag);
					ChaMatrix tmpwm = s_model->GetWorldMat();
					s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
					s_model->RigControlPostRig(g_limitdegflag,
						0, &s_editrange, s_pickinfo.pickobjno,
						1,
						s_ikcustomrig, s_pickinfo.buttonflag);
					tmpwm = s_model->GetWorldMat();
					s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
					s_editmotionflag = s_curboneno;

					if (oldcursor != NULL) {
						SetCursor(oldcursor);
					}
					ikdoneflag = true;
				}
			}
		}


		//g_underIKRot = false;
		s_model->SetUnderIKRot(false);


		s_wmlbuttonup = 1;//ゲームパッド用フラグ

		s_befdeltax = 0.0f;

		if (s_model && (s_onragdollik != 0)) {
			//s_model->BulletSimulationStop();
			//s_model->SetBtKinFlagReq(s_model->GetTopBt(), 1);
			s_model->BulletSimulationStop();
			g_previewFlag = 0;
			s_model->ApplyPhysIkRec(g_limitdegflag);
		}



		HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));


		//2023/08/09
		//自動フィルターは選択フレーム数が少ないときに動かなくなる　また　他の制限を満たしているジョイントの角度まで小さくなる
		//よって　自動フィルターは止めてみる　手動でSmoothボタンを押すことに
		//
		//2023/02/13
		//IKRot終了時　LimitEulオンで　編集ボーンがあった場合
		//グラフが波打つことは分かっているので(XYZどれか１つでも制限に掛かると　XYZ全て動かなくなるため)
		//自動で　フィルターを掛けて　滑らかにする
		//if ((((s_ikkind == 0) || (s_ikkind == 1)) || ((s_oprigflag != 0) && s_customrigbone)) &&
		//	(g_limitdegflag == true) && 
		//	(s_editmotionflag >= 0) &&
		//	(ikframenum >= 14)) {
		//	//ギザギザを平滑化
		//	bool copylw2w = false;
		//	FilterNoDlg(copylw2w);
		//}


		if ((s_undoFlag == false) && (s_redoFlag == false)) {

			//2023//11/06 CopyLimitedWorldToWorldよりも後ろに移動
			//if (s_model && ikdoneflag) {
			//	//############################################################################################################
			//	//2023/10/16 - 2023/10/19
			//	//マルチスレッドのコンテクストを　揃っている情報と要求される計算順序によって決めた
			//	//親のボーンの姿勢を使う階層順の計算では　フレーム番号単位のマルチスレッド
			//	//全ボーンの姿勢が揃った後で　前のフレームの姿勢を元にオイラー角を計算する際には　ボーンごとのマルチスレッド
			//	// 
			//	//befeul.currentframeeulでオイラーは　フレーム番号ごとのマルチスレッドで計算されている状態
			//	// ！！！！！　g_underIKRot = falseとした後で　！！！！！
			//	//後処理として　befeul.befframeeulで　ボーンごとのマルチスレッドで計算して正しいオイラーにする
			//	//############################################################################################################
			//	MOTINFO* curmi = s_model->GetCurMotInfo();
			//	if (curmi) {
			//		s_model->CalcBoneEul(g_limitdegflag, curmi->motid);
			//	}
			//}

			//2023/02/04
			//LimitEulにチェックを入れて編集したモーション部分を　角度制限無しの姿勢にベイクする
			//if ((g_limitdegflag == true) && (s_editmotionflag >= 0)) {
			if ((g_limitdegflag == true) && ikdoneflag) {
				bool allframeflag = false;
				bool setcursorflag = true;
				bool onpasteflag = false;


				//CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, s_editmotionflag, onpasteflag);

				//2023/03/04
				//rigの場合や　IKTargetの場合があるので　operatingjointnoはTopBoneの番号
				CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag,
					s_model->GetTopBone(false)->GetBoneNo(), onpasteflag);
			}


			//2023//11/06 CopyLimitedWorldToWorldよりも後ろに移動
			if (s_model && ikdoneflag) {
				//############################################################################################################
				//2023/10/16 - 2023/10/19
				//マルチスレッドのコンテクストを　揃っている情報と要求される計算順序によって決めた
				//親のボーンの姿勢を使う階層順の計算では　フレーム番号単位のマルチスレッド
				//全ボーンの姿勢が揃った後で　前のフレームの姿勢を元にオイラー角を計算する際には　ボーンごとのマルチスレッド
				// 
				//befeul.currentframeeulでオイラーは　フレーム番号ごとのマルチスレッドで計算されている状態
				// ！！！！！　g_underIKRot = falseとした後で　！！！！！
				//後処理として　befeul.befframeeulで　ボーンごとのマルチスレッドで計算して正しいオイラーにする
				//############################################################################################################
				MOTINFO* curmi = s_model->GetCurMotInfo();
				if (curmi) {
					s_model->CalcBoneEul(g_limitdegflag, curmi->motid);
				}
			}



			UpdateEditedEuler();
			//refreshEulerGraph();


			if (oldcursor != NULL) {
				SetCursor(oldcursor);
			}

			s_pickinfo.buttonflag = 0;
			s_ikcnt = 0;
			s_onragdollik = 0;

			//if ((s_editmotionflag >= 0) || (g_btsimurecflag == true)) {
			if (ikdoneflag || (g_btsimurecflag == true)) {
				PrepairUndo();//３Dウインドウでの編集後状態保存を想定		
			}

		}
		else {
			s_pickinfo.buttonflag = 0;
			s_ikcnt = 0;
			s_onragdollik = 0;

			OnSpriteUndo();
		}

	}
	else if (uMsg == WM_RBUTTONDOWN) {

		if (UnderDragOperation_L()) {
			s_cancelRButtonDown = true;
			return 0;
		}


		//SetCapture(DXUTGetHWND());
		SetCapture(s_3dwnd);

		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);

		s_pickinfo.clickpos = ptCursor;
		s_pickinfo.mousepos = ptCursor;
		s_pickinfo.mousebefpos = ptCursor;
		s_pickinfo.diffmouse = ChaVector2(0.0f, 0.0f);
		s_pickinfo.firstdiff = ChaVector2(0.0f, 0.0f);

		//s_pickinfo.winx = (int)DXUTGetWindowWidth();
		//s_pickinfo.winy = (int)DXUTGetWindowHeight();
		s_pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
		s_pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
		s_pickinfo.pickrange = PICKRANGE;

		s_pickinfo.pickobjno = -1;

		bool doneflag = false;


		if (s_skey) {
			//マニピュレータユーザー倍率
			//Sキーが押されているRDragは　ジョイント選択時も倍率設定
			if (doneflag == false) {
				if (s_rbuttonSelectFlag == false) {
					s_rbuttonSelectFlag = true;
				}
				doneflag = true;
			}
		}
		else if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {

			if (PickSpSmooth(ptCursor) != 0) {
				//SmoothSpriteButton上で右クリックした場合は　Smooth用のメニューを出す
				//SmoothSpriteButton上で左クリックした場合には　前回のSmooth設定にてSmoothをすぐに実行
				FilterFromTool();
				doneflag = true;
			}

			if (doneflag == false) {
				//ペーストスプライトボタン右クリック：操作対象ボーン設定ダイアログを出した後にペースト処理
				if (PickSpPaste(ptCursor) != 0) {
					if (s_model) {
						if ((s_selboneFlag == false) && (s_selboneAndPasteFlag == false)) {
							s_selboneFlag = true;
							s_selboneAndPasteFlag = true;
							doneflag = true;
						}
					}
				}
			}

			if (doneflag == false) {
				//カメラの回転を右ドラッグした場合は　OnMouseMoveFunc()にて　カメラのupvecをツイストする
				if (PickSpCam(ptCursor) == PICK_CAMROT) {
					if (s_twistcameraFlag == false) {
						s_twistcameraFlag = true;
					}
					doneflag = true;
				}
			}

			if (doneflag == false) {
				//スプライトボタンクリック時には　ボーン右クリック用のメニューを出さないように
				doneflag = IsClickedSpriteButton();
			}
		}

		int pickboneorrig = 0;
		if (doneflag == false) {
			//ボーン右クリック用のメニュー
			pickboneorrig = BoneRClick(-1);
			if (pickboneorrig != 0) {
				doneflag = true;
			}
		}
	}
	else if (uMsg == WM_RBUTTONDBLCLK) {
		//右ボタン　ダブルクリック

		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);

		//カメラの回転を　右ダブルクリックした場合は　カメラのupvecを初期化する
		if (PickSpCam(ptCursor) == PICK_CAMROT) {
			g_cameraupdir = ChaVector3(0.0f, 1.0f, 0.0f);

			//////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
			////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
			////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();
			g_befcamEye = g_camEye;
			ChaVector3 diffv;
			diffv = g_camEye - g_camtargetpos;
			g_camdist = (float)ChaVector3LengthDbl(&diffv);
		}
	}
	else if (uMsg == WM_RBUTTONUP) {
		if (s_cancelRButtonDown) {
			s_cancelRButtonDown = false;
			return 0;
		}

		ReleaseCapture();
		
		s_pickinfo.buttonflag = 0;
		s_twistcameraFlag = false;
		s_rbuttonSelectFlag = false;
	}
	else if (uMsg == WM_MBUTTONUP) {
		//ReleaseCapture();
		s_pickinfo.buttonflag = 0;
	}
	else if (uMsg == WM_DESTROY) {
		//ここでOnDestroyDevice()を呼ぶと　何回もOnDestroyDevice()が呼ばれる
		//WM_QUITでメッセージループを抜けて　ループを出たところでOnDestroyDevice()を呼ぶ
		PostQuitMessage(0);
		return 0;
	}
	else if (uMsg == WM_ACTIVATE) {
		if (wParam == 1) {
			DbgOut(L"%f, activate wparam 1\r\n", s_time);
			ActivatePanel(1);
		}
	}
	else if (uMsg == WM_SYSCOMMAND) {
		switch (wParam) {
		case SC_CLOSE:
			DbgOut(L"%f, syscommand close\r\n", s_time);
			break;
		case SC_MINIMIZE:
			DbgOut(L"%f, syscommand minimize\r\n", s_time);
			ActivatePanel(0);
			break;
		case SC_MAXIMIZE:
			DbgOut(L"%f, syscommand maximize\r\n", s_time);
			DefWindowProc(s_3dwnd, uMsg, wParam, lParam);
			ActivatePanel(1);
			//return 1;//!!!!!!!!!!!!!
			break;
		}
	}
	else {
		return DefWindowProc(hWnd, uMsg, wParam, lParam);
	}

	/*
	if( uMsg == WM_LBUTTONDOWN ){
		//#replacing comment out#g_Camera->HandleMessages( hWnd, WM_RBUTTONDOWN, wParam, lParam );
		if( s_ikkind == 2 ){
			g_LightControl[g_nActiveLight].HandleMessages( hWnd, WM_RBUTTONDOWN, wParam, lParam );
		}
	}else if( uMsg == WM_LBUTTONDBLCLK ){
	}else if( uMsg == WM_LBUTTONUP ){
		//#replacing comment out#g_Camera->HandleMessages( hWnd, WM_RBUTTONUP, wParam, lParam );
		if( s_ikkind == 2 ){
			g_LightControl[g_nActiveLight].HandleMessages( hWnd, WM_RBUTTONUP, wParam, lParam );
		}
	}else if( uMsg == WM_RBUTTONDOWN ){
	}else if( uMsg == WM_RBUTTONUP ){
	}else if( uMsg == WM_RBUTTONDBLCLK ){
	}else if( uMsg == WM_MBUTTONDOWN ){
	}else if( uMsg == WM_MBUTTONUP ){
	}else if( uMsg == WM_MOUSEWHEEL ){
		//if( (g_keybuf[VK_CONTROL] & 0x80) == 0 ){
		//	float mdelta = (float)GET_WHEEL_DELTA_WPARAM(wParam);
		//	//deltadist = mdelta * g_camdist * 0.00010f;
		//	deltadist = mdelta * g_camdist * 0.0010f;
		//
		//	g_camdist += deltadist;
		//	if( g_camdist < 0.0001f ){
		//		g_camdist = 0.0001f;
		//	}
		//
		//	ChaVector3 camvec = g_camEye - g_camtargetpos;
		//	ChaVector3Normalize( &camvec, &camvec );
		//	g_camEye = g_camtargetpos + g_camdist * camvec;
		//	ChaMatrixLookAtRH( &s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec );
		//}
	}else{
		//#replacing comment out#g_Camera->HandleMessages( hWnd, uMsg, wParam, lParam );
		if( s_ikkind == 2 ){
			g_LightControl[g_nActiveLight].HandleMessages( hWnd, uMsg, wParam, lParam );
		}
	}
	*/




	//if ((s_doneinit == 1) && (g_undertrackingRMenu == 1)) {
	//	OnDSUpdate();
	//}


	return 0;
}


//--------------------------------------------------------------------------------------
// As a convenience, DXUT inspects the incoming windows messages for
// keystroke messages and decodes the message parameters to pass relevant keyboard
// messages to the application.  The framework does not remove the underlying keystroke 
// messages, which are still passed to the application's MsgProc callback.
//--------------------------------------------------------------------------------------
//void CALLBACK KeyboardProc( UINT nChar, bool bKeyDown, bool bAltDown, void* pUserContext )
void CALLBACK OnKeyboard(UINT nChar, bool bKeyDown, bool bAltDown, void* pUserContext)
{
	if (bKeyDown)
	{
		switch (nChar)
		{
		case VK_F1:
			g_bShowHelp = !g_bShowHelp; break;
		}
	}
}

int RollbackCurBoneNo()
{
	if ((s_curboneno < 0) && (s_saveboneno >= 0)) {
		s_curboneno = s_saveboneno;
	}
	return 0;
}


//--------------------------------------------------------------------------------------
// Handles the GUI events
//--------------------------------------------------------------------------------------
//void CALLBACK OnGUIEvent(UINT nEvent, int nControlID, CDXUTControl* pControl, void* pUserContext)
//{
//
//	CDXUTComboBox* pComboBox;
//	ChaVector3 cureul, neweul;
//	//int tmpboneno;
//	//CBone* tmpbone;
//	WCHAR sz[100];
//	ChaVector3 weye;
//	float trastep;
//	int modelnum;
//	if (s_chascene) {
//		trastep = s_chascene->GetTotalModelBound().r * 0.05f;
//		modelnum = s_chascene->GetModelNum();
//	}
//	else {
//		trastep = 10.0f * 0.05f;
//		modelnum = 0;
//	}
//
//
//	//int modelno;
//	//int tmpikindex;
//
//	//if (nEvent == EVENT_SLIDER_VALUE_CHANGED_UP) {
//	//	int e;
//	//	e = 1;
//	//}
//
//
//
//	switch (nControlID)
//	{
//		//      case IDC_ACTIVE_LIGHT:
//		//          if( !g_LightControl[g_nActiveLight].IsBeingDragged() )
//		//          {
//		//              g_nActiveLight++;
//		//              g_nActiveLight %= g_nNumActiveLights;
//		//          }
//		//          break;
//			  //
//		//      case IDC_NUM_LIGHTS:
//		//          if( !g_LightControl[g_nActiveLight].IsBeingDragged() )
//		//          {
//		//              WCHAR sz[100];
//		//              swprintf_s( sz, 100, L"# Lights: %d", g_SampleUI.GetSlider( IDC_NUM_LIGHTS )->GetValue() );
//		//              g_SampleUI.GetStatic( IDC_NUM_LIGHTS_STATIC )->SetText( sz );
//
//		//              g_nNumActiveLights = g_SampleUI.GetSlider( IDC_NUM_LIGHTS )->GetValue();
//		//              g_nActiveLight %= g_nNumActiveLights;
//		//          }
//		//          break;
//	case IDC_BTSTART:
//		s_calclimitedwmState = 101;
//		break;
//	case IDC_BTRECSTART:
//	{
//		if (g_motionbrush_numframe < 10) {
//			WCHAR strmes[1024] = { 0L };
//			swprintf_s(strmes, 1024, L"複数フレームを選択してから再試行してください。\nRetry after selecting frames range.");
//			::DSMessageBox(NULL, strmes, L"error!!!", MB_OK);
//		}
//		else {
//			s_calclimitedwmState = 1001;
//		}
//	}
//	break;
//	//case IDC_PHYSICS_IK:
//	//	s_physicskind = 0;
//	//	s_savelimitdegflag = g_limitdegflag;
//	//	ChangeLimitDegFlag(false, true, true);
//	//	//g_limitdegflag = false;
//	//	//if (s_LimitDegCheckBox) {
//	//	//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
//	//	//}
//	//	StartBt(s_model, TRUE, 1, 1);
//	//	break;
//	//case IDC_PHYSICS_MV_IK:
//	//	s_physicskind = 1;
//	//	s_savelimitdegflag = g_limitdegflag;
//	//	ChangeLimitDegFlag(false, true, true);
//	//	//g_limitdegflag = false;
//	//	//if (s_LimitDegCheckBox) {
//	//	//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
//	//	//}
//	//	StartBt(s_model, TRUE, 1, 1);
//	//	break;
//	case IDC_PHYSICS_MV_SLIDER:
//		RollbackCurBoneNo();
//		g_physicsmvrate = (float)(g_SampleUI.GetSlider(IDC_PHYSICS_MV_SLIDER)->GetValue()) * 0.01f;
//		swprintf_s(sz, 100, L"EditRate : %.3f", g_physicsmvrate);
//		g_SampleUI.GetStatic(IDC_STATIC_PHYSICS_MV_SLIDER)->SetText(sz);
//		break;
//	//	//case IDC_APPLY_BT:
//	//	//	if (s_model){
//	//	//		s_model->BulletSimulationStop();
//	//	//		g_previewFlag = 0;
//	//	//		s_model->ApplyBtToMotion();
//	//	//	}
//	//	//	break;
//	case IDC_STOP_BT:
//	case IDC_PHYSICS_IK_STOP:
//		StopBt();
//		//g_limitdegflag = s_savelimitdegflag;//StopBt内で呼ぶ
//		break;
//
//	case IDC_LIGHT_SCALE:
//		RollbackCurBoneNo();
//		g_fLightScale = (float)(g_SampleUI.GetSlider(IDC_LIGHT_SCALE)->GetValue() * 0.10f);
//
//		swprintf_s(sz, 100, L"Light : %0.2f", g_fLightScale);
//		//g_SampleUI.GetStatic( IDC_LIGHTING )->SetText( sz );
//		break;
//
//	case IDC_SL_IKFIRST:
//		//RollbackCurBoneNo();
//		//g_ikfirst = (float)(g_SampleUI.GetSlider(IDC_SL_IKFIRST)->GetValue()) * 0.04f;
//	 //   swprintf_s( sz, 100, L"IK Order : %f", g_ikfirst );
////         g_SampleUI.GetStatic( IDC_STATIC_IKFIRST )->SetText( sz );
//		break;
//		//     case IDC_SL_IKRATE:
//				 //RollbackCurBoneNo();
//				 //g_ikrate = (float)(g_SampleUI.GetSlider(IDC_SL_IKRATE)->GetValue()) * 0.01f;
//			  //   swprintf_s( sz, 100, L"IK Trans : %f", g_ikrate );
//		//         g_SampleUI.GetStatic( IDC_STATIC_IKRATE )->SetText( sz );
//		//         break;
//	case IDC_SL_REFPOSSTEP:
//	{
//		RollbackCurBoneNo();
//		g_refposstep = g_SampleUI.GetSlider(IDC_SL_REFPOSSTEP)->GetValue();
//		swprintf_s(sz, 100, L"ReferencePos : %d", g_refposstep);
//		g_SampleUI.GetStatic(IDC_STATIC_REF)->SetText(sz);
//	}
//	break;
//	case IDC_SL_REFALPHA:
//	{
//		RollbackCurBoneNo();
//		g_refalpha = g_SampleUI.GetSlider(IDC_SL_REFALPHA)->GetValue();
//	}
//	break;
//	case IDC_SL_NUMTHREAD:
//		//RollbackCurBoneNo();
//		//g_numthread = (int)(g_SampleUI.GetSlider(IDC_SL_NUMTHREAD)->GetValue());
//		//swprintf_s(sz, 100, L"ThreadNum:%d(%d)", g_numthread, gNumIslands);
//		//g_SampleUI.GetStatic(IDC_STATIC_NUMTHREAD)->SetText(sz);
//		//s_bpWorld->setNumThread(g_numthread);
//		break;
//	case IDC_SL_UMTHREADS:
//
//		if (nEvent == EVENT_SLIDER_VALUE_CHANGED_UP) {//マウスアップのイベント
//			g_SampleUI.GetSlider(IDC_SL_UMTHREADS)->SetEnabled(false);//!!!!!!!!!
//
//			RollbackCurBoneNo();
//			g_UpdateMatrixThreads = (int)(g_SampleUI.GetSlider(IDC_SL_UMTHREADS)->GetValue());
//			swprintf_s(sz, 100, L"UpdateThreads:%d", g_UpdateMatrixThreads);
//			g_SampleUI.GetStatic(IDC_STATIC_UMTHREADS)->SetText(sz);
//			s_changeupdatethreadsFlag = true;
//		}
//
//		break;
//	case IDC_BRUSH_MIRROR_U:
//		if (s_BrushMirrorUCheckBox) {
//			g_brushmirrorUflag = (int)s_BrushMirrorUCheckBox->GetChecked();
//			if (s_editmotionflag < 0) {//IK中でないとき
//				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
//				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
//					_ASSERT(0);
//					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
//					PostQuitMessage(result);
//				}
//				//PrepairUndo();//保存はOnFrameUtCheckBoxにて
//			}
//			s_BrushMirrorUCheckBoxFlag = true;//UTDialogの
//		}
//		break;
//	case IDC_BRUSH_MIRROR_V:
//		if (s_BrushMirrorVCheckBox) {
//			g_brushmirrorVflag = (int)s_BrushMirrorVCheckBox->GetChecked();
//			if (s_editmotionflag < 0) {//IK中でないとき
//				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
//				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
//					_ASSERT(0);
//					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
//					PostQuitMessage(result);
//				}
//				//PrepairUndo();//保存はOnFrameUtCheckBoxにて
//			}
//			s_BrushMirrorVCheckBoxFlag = true;//UTDialogの
//		}
//		break;
//	case IDC_BRUSH_MIRROR_V_DIV2:
//		if (s_IfMirrorVDiv2CheckBox) {
//			if (s_editmotionflag < 0) {//IK中でないとき
//				g_ifmirrorVDiv2flag = (int)s_IfMirrorVDiv2CheckBox->GetChecked();
//				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
//				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
//					_ASSERT(0);
//					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
//					PostQuitMessage(result);
//				}
//				//PrepairUndo();//保存はOnFrameUtCheckBoxにて
//			}
//			s_IfMirrorVDiv2CheckBoxFlag = true;//UTDialogの
//		}
//		break;
//	case IDC_SL_BRUSHREPEATS:
//		RollbackCurBoneNo();
//		g_brushrepeats = (int)(g_SampleUI.GetSlider(IDC_SL_BRUSHREPEATS)->GetValue());
//		swprintf_s(sz, 100, L"Brush Repeats : %d", g_brushrepeats);
//		g_SampleUI.GetStatic(IDC_STATIC_BRUSHREPEATS)->SetText(sz);
//		if (s_editmotionflag < 0) {//IK中でないとき
//			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
//			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
//				_ASSERT(0);
//				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
//				PostQuitMessage(result);
//			}
//		}
//		if (nEvent == EVENT_SLIDER_VALUE_CHANGED_UP) {//マウスアップのイベント
//		//if (nEvent == EVENT_SLIDER_RELEASEDCAPTURE) {
//			s_utBrushRepeatsFlag = true;//PrepairUndo();//保存はOnFrameUtCheckBoxにて
//		}
//		break;
//	case IDC_SL_APPLYRATE:
//		RollbackCurBoneNo();
//		g_applyrate = g_SampleUI.GetSlider(IDC_SL_APPLYRATE)->GetValue();
//		CEditRange::SetApplyRate((double)g_applyrate);
//		//swprintf_s( sz, 100, L"TopPos : %d%% : %d", g_applyrate, (int)(s_editrange.GetApplyFrame()) );
//		//g_SampleUI.GetStatic( IDC_STATIC_APPLYRATE )->SetText( sz );
//		OnTimeLineSelectFromSelectedKey();
//		DisplayApplyRateText();
//		SetShowPosTime();//2022/10/22
//		if (s_editmotionflag < 0) {//IK中でないとき
//			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
//			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
//				_ASSERT(0);
//				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
//				PostQuitMessage(result);
//			}
//		}
//		if (nEvent == EVENT_SLIDER_VALUE_CHANGED_UP) {//マウスアップのイベント
//		//if (nEvent == EVENT_SLIDER_RELEASEDCAPTURE){
//			s_utApplyRateFlag = true;//PrepairUndo();//保存はOnFrameUtCheckBoxにて
//		}
//		break;
//
//	case IDC_SPEED:
//		OnGUIEventSpeed();
//		break;
//	case IDC_BTCALCCNT:
//		RollbackCurBoneNo();
//		g_btcalccnt = (double)(g_SampleUI.GetSlider(IDC_BTCALCCNT)->GetValue());
//
//		swprintf_s(sz, 100, L"BT CalcCnt: %0.2f", g_btcalccnt);
//		g_SampleUI.GetStatic(IDC_STATIC_BTCALCCNT)->SetText(sz);
//		break;
//
//	case IDC_ERP:
//		RollbackCurBoneNo();
//		g_erp = (double)(g_SampleUI.GetSlider(IDC_ERP)->GetValue() * 0.0002);
//
//		swprintf_s(sz, 100, L"BT ERP: %0.5f", g_erp);
//		g_SampleUI.GetStatic(IDC_STATIC_ERP0)->SetText(sz);
//		break;
//	case IDC_COMBO_MOTIONBRUSH_METHOD:
//		RollbackCurBoneNo();
//		if (s_model) {
//			int saveval = g_motionbrush_method;
//			pComboBox = g_SampleUI.GetComboBox(IDC_COMBO_MOTIONBRUSH_METHOD);
//			g_motionbrush_method = (int)PtrToUlong(pComboBox->GetSelectedData());
//			if (s_editmotionflag < 0) {
//				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
//				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
//					_ASSERT(0);
//					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
//					PostQuitMessage(result);
//				}
//			}
//			if (g_motionbrush_method != saveval) {
//				PrepairUndo();
//			}
//		}
//		break;
//	case IDC_COMBO_BONEAXIS:
//		RollbackCurBoneNo();
//		if (s_model) {
//			pComboBox = g_SampleUI.GetComboBox(IDC_COMBO_BONEAXIS);
//			g_boneaxis = (int)PtrToUlong(pComboBox->GetSelectedData());
//
//		}
//		break;
//	case IDC_COMBO_BONE:
//		//RollbackCurBoneNo();
//		//if (s_model){
//		//	pComboBox = g_SampleUI.GetComboBox( IDC_COMBO_BONE );
//		//	tmpboneno = (int)PtrToUlong( pComboBox->GetSelectedData() );
//		//	tmpbone = s_model->GetBoneByID( tmpboneno );
//		//	if( tmpbone ){
//		//		s_curboneno = tmpboneno;
//		//	}
//
//		//	if( s_curboneno >= 0 ){
//		//		int lineno = s_boneno2lineno[ s_curboneno ];
//		//		if( lineno >= 0 ){
//		//			s_owpTimeline->setCurrentLine( lineno, true );					
//		//		}
//		//	}
//		//}
//		break;
//
//		//case IDC_COMBO_EDITMODE:
//		//	if( s_model ){
//		//		RollbackCurBoneNo();
//		//		pComboBox = g_SampleUI.GetComboBox(IDC_COMBO_EDITMODE);
//		//		tmpikindex = (int)PtrToUlong(pComboBox->GetSelectedData());
//
//		//		switch( tmpikindex ){
//		//		case IDC_IK_ROT:
//		//			s_ikkind = 0;
//		//			refreshEulerGraph();
//		//			break;
//		//		case IDC_IK_MV:
//		//			s_ikkind = 1;
//		//			refreshEulerGraph();
//		//			break;
//		//		case IDC_IK_SC:
//		//			s_ikkind = 2;
//		//			refreshEulerGraph();
//		//			break;
//		//		//case IDC_IK_LIGHT:
//		//		//	s_ikkind = 2;
//		//		//	s_displightarrow = true;
//		//		//	if (s_LightCheckBox){
//		//		//		s_LightCheckBox->SetChecked(true);
//		//		//	}
//		//		//	break;
//		//		case IDC_BT_RIGID:
//		//			GUIMenuSetVisible(1, 1);
//		//			break;
//		//		case IDC_BT_IMP:
//		//			GUIMenuSetVisible(1, 2);
//		//			break;
//		//		case IDC_BT_GP:
//		//			GUIMenuSetVisible(1, 3);
//		//			break;
//		//		case IDC_BT_DAMP:
//		//			GUIMenuSetVisible(1, 4);
//		//			break;
//		//		default:
//		//			break;
//		//		}
//		//	}
//		//	break;
//
//	case IDC_COMBO_FPS:
//		RollbackCurBoneNo();
//		pComboBox = g_SampleUI.GetComboBox(IDC_COMBO_FPS);
//		if (pComboBox) {
//			g_fpskind = (int)PtrToUlong(pComboBox->GetSelectedData());
//			if (g_fpskind != 0) {
//				g_VSync = true;
//			}
//			else {
//				g_VSync = false;
//			}
//		}
//		break;
//	case IDC_COMBO_IKLEVEL:
//		RollbackCurBoneNo();
//		pComboBox = g_SampleUI.GetComboBox(IDC_COMBO_IKLEVEL);
//		if (pComboBox) {
//			g_iklevel = (int)PtrToUlong(pComboBox->GetSelectedData());
//		}
//		break;
//	case IDC_CAMTARGET:
//		RollbackCurBoneNo();
//		AutoCameraTarget();
//
//		break;
//	case IDC_APPLY_TO_THEEND:
//		RollbackCurBoneNo();
//		break;
//	case IDC_SLERP_OFF:
//		RollbackCurBoneNo();
//		break;
//		//case IDC_ABS_IK:
//	case IDC_HIGHRPM:
//		RollbackCurBoneNo();
//		break;
//	case IDC_PSEUDOLOCAL:
//		RollbackCurBoneNo();
//		break;
//	//case IDC_LIMITDEG:
//	//	RollbackCurBoneNo();
//	//	s_LimitDegCheckBoxFlag = true;//2022/11/23 For PrepairUndoMotion at OnFrameUtCheckBox
//	//	break;
//	//case IDC_WALLSCRAPINGIK:
//	//	RollbackCurBoneNo();
//	//	s_WallScrapingCheckBoxFlag = true;//2022/11/23 For PrepairUndoMotion at OnFrameUtCheckBox
//	//	break;
//	//case IDC_VSYNC:
//	//	RollbackCurBoneNo();
//	//	break;
//	case IDC_TRAROT:
//		RollbackCurBoneNo();
//		break;
//	//case IDC_EDGESMP:
//	//	RollbackCurBoneNo();
//	//	break;
//
//	default:
//		break;
//
//	}
//
//}



int DestroyTimeLine(int dellist)
{
	if (dellist) {
		EraseKeyList();
	}

	s_tlarray.clear();

	if (s_parentcheck) {
		delete s_parentcheck;
		s_parentcheck = 0;
	}

	return 0;
}

int GetShaderHandle()
{
	//if (!g_pEffect) {
	//	_ASSERT(0);
	//	return 1;
	//}

	//g_hRenderBoneL0 = g_pEffect->GetTechniqueByName("RenderBoneL0");
	//_ASSERT(g_hRenderBoneL0);
	//g_hRenderBoneL1 = g_pEffect->GetTechniqueByName("RenderBoneL1");
	//_ASSERT(g_hRenderBoneL1);
	//g_hRenderBoneL2 = g_pEffect->GetTechniqueByName("RenderBoneL2");
	//_ASSERT(g_hRenderBoneL2);
	//g_hRenderBoneL3 = g_pEffect->GetTechniqueByName("RenderBoneL3");
	//_ASSERT(g_hRenderBoneL3);
	//g_hRenderBoneL4 = g_pEffect->GetTechniqueByName("RenderBoneL4");
	//_ASSERT(g_hRenderBoneL4);
	//g_hRenderBoneL5 = g_pEffect->GetTechniqueByName("RenderBoneL5");
	//_ASSERT(g_hRenderBoneL5);
	//g_hRenderBoneL6 = g_pEffect->GetTechniqueByName("RenderBoneL6");
	//_ASSERT(g_hRenderBoneL6);
	//g_hRenderBoneL7 = g_pEffect->GetTechniqueByName("RenderBoneL7");
	//_ASSERT(g_hRenderBoneL7);
	//g_hRenderBoneL8 = g_pEffect->GetTechniqueByName("RenderBoneL8");
	//_ASSERT(g_hRenderBoneL8);

	//g_hRenderNoBoneL0 = g_pEffect->GetTechniqueByName("RenderNoBoneL0");
	//_ASSERT(g_hRenderNoBoneL0);
	//g_hRenderNoBoneL1 = g_pEffect->GetTechniqueByName("RenderNoBoneL1");
	//_ASSERT(g_hRenderNoBoneL1);
	//g_hRenderNoBoneL2 = g_pEffect->GetTechniqueByName("RenderNoBoneL2");
	//_ASSERT(g_hRenderNoBoneL2);
	//g_hRenderNoBoneL3 = g_pEffect->GetTechniqueByName("RenderNoBoneL3");
	//_ASSERT(g_hRenderNoBoneL3);
	//g_hRenderNoBoneL4 = g_pEffect->GetTechniqueByName("RenderNoBoneL4");
	//_ASSERT(g_hRenderNoBoneL4);
	//g_hRenderNoBoneL5 = g_pEffect->GetTechniqueByName("RenderNoBoneL5");
	//_ASSERT(g_hRenderNoBoneL5);
	//g_hRenderNoBoneL6 = g_pEffect->GetTechniqueByName("RenderNoBoneL6");
	//_ASSERT(g_hRenderNoBoneL6);
	//g_hRenderNoBoneL7 = g_pEffect->GetTechniqueByName("RenderNoBoneL7");
	//_ASSERT(g_hRenderNoBoneL7);
	//g_hRenderNoBoneL8 = g_pEffect->GetTechniqueByName("RenderNoBoneL8");
	//_ASSERT(g_hRenderNoBoneL8);

	//g_hRenderLine = g_pEffect->GetTechniqueByName("RenderLine");
	//_ASSERT(g_hRenderLine);
	//g_hRenderSprite = g_pEffect->GetTechniqueByName("RenderSprite");
	//_ASSERT(g_hRenderSprite);



	//g_hm4x4Mat = g_pEffect->GetVariableByName("g_m4x4Mat")->AsMatrix();
	//_ASSERT(g_hm4x4Mat);
	//g_hmWorld = g_pEffect->GetVariableByName("g_mWorld")->AsMatrix();
	//_ASSERT(g_hmWorld);
	//g_hmVP = g_pEffect->GetVariableByName("g_mVP")->AsMatrix();
	//_ASSERT(g_hmVP);
	//g_hEyePos = g_pEffect->GetVariableByName("g_EyePos")->AsVector();
	//_ASSERT(g_hEyePos);


	////	g_hnNumLight = g_pEffect->GetVariableByName("g_nNumLights" );
	////	_ASSERT( g_hnNumLight );
	//g_hLightDir = g_pEffect->GetVariableByName("g_LightDir")->AsVector();
	//_ASSERT(g_hLightDir);
	//g_hLightDiffuse = g_pEffect->GetVariableByName("g_LightDiffuse")->AsVector();
	//_ASSERT(g_hLightDiffuse);
	////	g_hLightAmbient = g_pEffect->GetVariableByName("g_LightAmbient" );
	////	_ASSERT( g_hLightAmbient );
	//g_hSpriteOffset = g_pEffect->GetVariableByName("g_spriteoffset")->AsVector();
	//_ASSERT(g_hSpriteOffset);
	//g_hSpriteScale = g_pEffect->GetVariableByName("g_spritescale")->AsVector();
	//_ASSERT(g_hSpriteScale);

	//g_hPm3Offset = g_pEffect->GetVariableByName("g_pm3offset")->AsVector();
	//_ASSERT(g_hPm3Offset);
	//g_hPm3Scale = g_pEffect->GetVariableByName("g_pm3scale")->AsVector();
	//_ASSERT(g_hPm3Scale);

	//g_hdiffuse = g_pEffect->GetVariableByName("g_diffuse")->AsVector();
	//_ASSERT(g_hdiffuse);
	//g_hambient = g_pEffect->GetVariableByName("g_ambient")->AsVector();
	//_ASSERT(g_hambient);
	//g_hspecular = g_pEffect->GetVariableByName("g_specular")->AsVector();
	//_ASSERT(g_hspecular);
	//g_hpower = g_pEffect->GetVariableByName("g_power")->AsScalar();
	//_ASSERT(g_hpower);
	//g_hemissive = g_pEffect->GetVariableByName("g_emissive")->AsVector();
	//_ASSERT(g_hemissive);
	//g_hMeshTexture = g_pEffect->GetVariableByName("g_MeshTexture")->AsShaderResource();
	//_ASSERT(g_hMeshTexture);


	///*
	//// Obtain variables
	//g_ptxDiffuse = g_pEffect10->GetVariableByName("g_MeshTexture")->AsShaderResource();
	//g_pLightDir = g_pEffect10->GetVariableByName("g_LightDir")->AsVector();
	//g_pLightDiffuse = g_pEffect10->GetVariableByName("g_LightDiffuse")->AsVector();
	//g_pmWorldViewProjection = g_pEffect10->GetVariableByName("g_mWorldViewProjection")->AsMatrix();
	//g_pmWorld = g_pEffect10->GetVariableByName("g_mWorld")->AsMatrix();
	//g_pfTime = g_pEffect10->GetVariableByName("g_fTime")->AsScalar();
	//g_pMaterialAmbientColor = g_pEffect10->GetVariableByName("g_MaterialAmbientColor")->AsVector();
	//g_pMaterialDiffuseColor = g_pEffect10->GetVariableByName("g_MaterialDiffuseColor")->AsVector();
	//g_pnNumLights = g_pEffect10->GetVariableByName("g_nNumLights")->AsScalar();

	//// Create our vertex input layout
	//const D3D11_INPUT_ELEMENT_DESC layout[] =
	//{
	//{ "POSITION",  0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
	//{ "NORMAL",    0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	//{ "TEXCOORD",  0, DXGI_FORMAT_R32G32_FLOAT,    0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	//};

	//D3DX11_PASS_DESC PassDesc;
	//V_RETURN(g_pTechRenderSceneWithTexture1Light->GetPassByIndex(0)->GetDesc(&PassDesc));
	//V_RETURN(pd3dDevice->CreateInputLayout(layout, 3, PassDesc.pIAInputSignature,
	//PassDesc.IAInputSignatureSize, &g_pVertexLayout));

	//// Load the mesh
	//V_RETURN(g_Mesh10.Create(pd3dDevice, L"tiny\\tiny.sdkmesh", true));

	//// Set effect variables as needed
	//D3DXCOLOR colorMtrlDiffuse(1.0f, 1.0f, 1.0f, 1.0f);
	//D3DXCOLOR colorMtrlAmbient(0.35f, 0.35f, 0.35f, 0);
	//V_RETURN(g_pMaterialAmbientColor->SetFloatVector((float*)&colorMtrlAmbient));
	//V_RETURN(g_pMaterialDiffuseColor->SetFloatVector((float*)&colorMtrlDiffuse));

	//*/

	return 0;
}

int SetBaseDir()
{
	WCHAR filename[MAX_PATH] = { 0 };
	WCHAR* endptr = 0;

	int ret;
	ret = GetModuleFileNameW(NULL, filename, MAX_PATH);
	if (ret == 0) {
		_ASSERT(0);
		return 1;
	}


	WCHAR* lasten = NULL;
	lasten = wcsrchr(filename, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		DbgOut(L"SetMediaDir : strrchr error !!!\n");
		return 1;
	}

	//*.exeの頭
	*lasten = 0;

	WCHAR* last2en = 0;
	WCHAR* last3en = 0;
	WCHAR* last4en = 0;
	last2en = wcsrchr(filename, TEXT('\\'));//Release, Debugの頭の円かどうか調べる
	if (last2en) {
		*last2en = 0;
		last3en = wcsrchr(filename, TEXT('\\'));//Release, Debugかどうか調べるフォルダの前にフォルダがあるかどうか
		if (last3en) {
			if ((wcscmp(last2en + 1, L"debug") == 0) ||
				(wcscmp(last2en + 1, L"Debug") == 0) ||
				(wcscmp(last2en + 1, L"DEBUG") == 0) ||
				(wcscmp(last2en + 1, L"release") == 0) ||
				(wcscmp(last2en + 1, L"Release") == 0) ||
				(wcscmp(last2en + 1, L"RELEASE") == 0)
				) {

				*last3en = 0;
				last4en = wcsrchr(filename, TEXT('\\'));//x64かどうか調べるフォルダの前にフォルダがあるかどうか
				if (last4en) {
					if (wcscmp(last3en + 1, L"x64") != 0) {
						*last3en = TEXT('\\');
					}
				}
			}
			else {
				*last2en = TEXT('\\');
			}
		}
	}

	size_t leng;
	ZeroMemory(g_basedir, sizeof(WCHAR) * MAX_PATH);
	wcscpy_s(g_basedir, MAX_PATH, filename);
	g_basedir[MAX_PATH - 1] = 0L;
	leng = wcslen(g_basedir);
	if ((leng >= 1) && (leng <= (MAX_PATH - 2))) {//１文字追加分を考慮
		if (wcscmp(g_basedir + leng - 1, L"\\") != 0) {
			wcscat_s(g_basedir, MAX_PATH, L"\\");
		}
	}
	else {
		_ASSERT(0);
	}
	DbgOut(L"SetBaseDir : %s\r\n", g_basedir);

	return 0;
}


int OpenMNLFile()
{
	if (!s_model) {
		return 0;
	}

	if (g_tmpmqopath[0] == 0L) {
		return 0;
	}

	CMNLFile mnlfile;
	CallF(mnlfile.LoadMNLFile(g_tmpmqopath, s_model), return 1);

	CallF(OnAnimMenu(true, 0), return 1);

	return 0;
}


int OpenGcoFile()
{
	if (!s_bpWorld) {
		return 0;
	}
	if (!s_gplane) {
		return 0;
	}

	if (g_tmpmqopath[0] == 0L) {
		return 0;
	}

	CGColiFile gcofile;
	CallF(gcofile.LoadGColiFile(s_gplane, g_tmpmqopath, s_bpWorld), return 1);

	s_bpWorld->RemakeG();
	ChaVector3 tra(0.0f, 0.0f, 0.0f);
	ChaVector3 mult(s_bpWorld->m_gplanesize.x, 1.0f, s_bpWorld->m_gplanesize.y);
	CallF(s_gplane->MultDispObj(mult, tra), return 1);

	return 0;
}


int OpenImpFile()
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	if (g_tmpmqopath[0] == 0L) {
		return 0;
	}

	CImpFile impfile;
	CallF(impfile.LoadImpFile(g_tmpmqopath, s_model), return 1);

	int impnum = s_model->GetImpInfoSize();
	if (impnum > 0) {
		OnImpMenu(impnum - 1);
	}
	else {
		OnImpMenu(-1);
	}

	return 0;
}


int OpenREFile()
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	if (g_tmpmqopath[0] == 0L) {
		return 0;
	}

	if (s_model->GetRigidElemInfoSize() >= (MAXRENUM - 1)) {
		::DSMessageBox(s_3dwnd, L"Overflow Loading(Limit under 99 files)", L"warning!!!", MB_OK);
		return 0;
	}

	CRigidElemFile refile;
	CallF(refile.LoadRigidElemFile(g_tmpmqopath, s_model), return 1);


	int renum = s_model->GetRigidElemInfoSize();
	if (renum > 0) {

		//RgidElemFileのLoad時にしている
		//if (s_model && (renum == 1)) {//初回のref読み込み後にRigidElemを作成
		//	int chkret;
		//	chkret = s_model->CreateRigidElem();
		//	_ASSERT(!chkret);
		//}

		OnREMenu(renum - 1, 0);
		OnRgdMenu(renum - 1, 0);
	}
	else {
		OnREMenu(-1, 0);
		OnRgdMenu(-1, 0);
	}

	return 0;
}

int SaveGcoFile()
{
	if (!s_bpWorld) {
		return 0;
	}

	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SAVEGCODLG),
		s_3dwnd, (DLGPROC)SaveGcoDlgProc);
	if ((dlgret != IDOK) || !s_Gconame[0]) {
		return 0;
	}

	CGColiFile gcofile;
	CallF(gcofile.WriteGColiFile(s_Gconame, s_bpWorld), return 1);

	return 0;


}

int SaveImpFile()
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}
	if (s_rgdindexmap[s_model] < 0) {
		::DSMessageBox(s_3dwnd, L"Save Only RagdollImpulse.\nRetry after Setting of Ragdoll", L"error!!!", MB_OK);
		return 0;
	}


	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SAVEIMPDLG),
		s_3dwnd, (DLGPROC)SaveImpDlgProc);
	if ((dlgret != IDOK) || !s_Impname[0]) {
		return 0;
	}

	CImpFile impfile;
	CallF(impfile.WriteImpFile(s_Impname, s_model), return 1);

	int impnum = s_model->GetImpInfoSize();
	if (impnum > 0) {
		OnImpMenu(impnum - 1);
	}
	else {
		OnImpMenu(-1);
	}

	return 0;


}

int SaveREFile()
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SAVEREDLG),
		s_3dwnd, (DLGPROC)SaveREDlgProc);
	if ((dlgret != IDOK) || !s_REname[0]) {
		return 0;
	}

	CRigidElemFile refile;
	CallF(refile.WriteRigidElemFile(s_REname, s_model, s_model->GetCurReIndex()), return 1);

	return 0;
}


void FindF(std::vector<wstring>& out, const wstring& directory, const wstring& findext)
{
	HANDLE dir;
	WIN32_FIND_DATA fileData;

	if ((dir = FindFirstFile((directory + L"/*").c_str(), &fileData)) == INVALID_HANDLE_VALUE)
	{
		return; /* No files found */
	}

	do
	{
		const wstring fileName = fileData.cFileName;
		const wstring fullFileName = directory + L"\\" + fileName;
		const bool isDirectory = (fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

		if (fileName[0] == L'.')
			continue;

		if (!isDirectory)
		{
			//WCHAR pattern[20] = L".bvh";
			//WCHAR npattern[20] = L".bvh.";
			WCHAR pattern[20] = { 0L };
			WCHAR wpath[MAX_PATH] = { 0L };
			wcscpy_s(pattern, 20, findext.c_str());
			wcscpy_s(wpath, MAX_PATH, fullFileName.c_str());

			const WCHAR* pfind;
			pfind = wcsstr(wpath, pattern);
			if (pfind) {
				wpath[MAX_PATH - 1] = 0L;
				pattern[20 - 1] = 0L;
				size_t pathleng = wcslen(wpath);
				size_t patternleng = wcslen(pattern);
				if ((patternleng > 0) && (pathleng > 0) && (pathleng < MAX_PATH) && (pathleng > patternleng)) {
					WCHAR chkterm = *(pfind + patternleng);
					if (chkterm == 0L) {//patternの次の文字がNULLの場合
						out.push_back(fullFileName);
					}
				}
				else {
					_ASSERT(0);
				}
			}
		}
		else
		{
			FindF(out, fullFileName, findext);
		}

	} while (FindNextFile(dir, &fileData));

	FindClose(dir);

	return;
}


int CALLBACK BrowseCallbackProc(HWND   hWnd, UINT   uMsg, LPARAM lParam, LPARAM lpData)
{
	WCHAR firstdir[MAX_PATH] = { 0L };

	switch (uMsg) {

		// 初期ディレクトリの設定
	case BFFM_INITIALIZED:
		firstdir[0] = 0L;
		GetBatchHistoryDir(firstdir, MAX_PATH);
		if (firstdir[0] != 0L) {
			SendMessage(hWnd, BFFM_SETSELECTION, (WPARAM)TRUE, (LPARAM)firstdir);
			SendMessage(hWnd, BFFM_SETEXPANDED, (WPARAM)TRUE, (LPARAM)firstdir);
		}
		else {
			// ドキュメントが初期フォルダ
			if (lpData) {
				SendMessage(hWnd, BFFM_SETSELECTION, (WPARAM)TRUE, (LPARAM)lpData);
				SendMessage(hWnd, BFFM_SETEXPANDED, (WPARAM)TRUE, (LPARAM)lpData);
			}
		}
		//初期フォルダ（ドキュメント）を展開
		//SendMessage(hWnd, BFFM_SETEXPANDED, (WPARAM)TRUE, (LPARAM)lpData);
		break;

		// 無効なフォルダ名を入力された場合
	case BFFM_VALIDATEFAILED:
		MessageBox(NULL, L"無効なフォルダ名です", L"", MB_OK);
		return TRUE;
	}
	return FALSE;
}


//########### retarget batch　ここから

int RetargetFile(char* fbxpath)
{
	//RenderContext* pRenderContext = DXUTGetD3D11DeviceContext();

	char directorypath[MAX_PATH] = { 0 };
	ZeroMemory(directorypath, sizeof(char) * MAX_PATH);
	char* pfind;
	pfind = strrchr(fbxpath, '\\');
	if (pfind) {

		if (s_chascene && (s_chascene->GetModelNum() > 0)) {
			OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
		}

		unsigned int dirpathlen;
		dirpathlen = (unsigned int)(pfind - fbxpath + 1);
		strncpy_s(directorypath, MAX_PATH, fbxpath, dirpathlen);

		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, fbxpath, MAX_PATH, g_tmpmqopath, MAX_PATH);
		CModel* newmodel = 0;
		std::vector<std::string> ikstopname;
		ikstopname.clear();
		newmodel = OpenFBXFile(false, false, 0, 1, ikstopname);
		if (newmodel) {
			//s_model = s_convbone_model_batch;


			if(s_smoothBefRetarget && newmodel->GetCurMotInfo()){
				//##############################################################################
				//2023/10/12 retarget前にsmoothするオプション RetargetBatch()のダイアログで選択
				//ノイズによって　180度裏返り機能の閾値を越えないようにする
				//##############################################################################
				s_model = newmodel;
			
				int saveFilterState = s_filterState;
				double savestart = s_buttonselectstart;
				double saveend = s_buttonselectend;
			
				s_filterState = 1;
				s_buttonselectstart = 1.0;
				s_buttonselectend = newmodel->GetCurMotInfo()->frameleng - 1.0;
			
				FilterNoDlg(false);
			
				s_filterState = saveFilterState;
				s_buttonselectstart = savestart;
				s_buttonselectend = saveend;
			}


			OnModelMenu(false, s_convbone_model_batch_selindex, 1);
			s_model = s_convbone_model_batch;
			s_convbone_model = s_convbone_model_batch;
			s_convbone_bvh = newmodel;
			//s_maxboneno = s_convbone_bvh->GetBoneListSize();
			//s_maxboneno = s_convbone_bvh->GetBoneForMotionSize();
			s_maxboneno = s_convbone_bvh->GetMaxBoneNo();

			WCHAR wretargetfilename[MAX_PATH] = { 0L };
			char retargetfilename[MAX_PATH] = { 0 };
			sprintf_s(retargetfilename, MAX_PATH, "%sretarget.rtg", directorypath);
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, retargetfilename, MAX_PATH, wretargetfilename, MAX_PATH);

			int result1;
			result1 = LoadRetargetFile(wretargetfilename);
			if (result1 == 0) {
				int result2;
				result2 = RetargetMotion();
				if (result2 != 0) {
					_ASSERT(0);
				}
			}

			//if (s_convbone_model_batch && s_convbone_model_batch->GetCurMotInfo()) {
			//	int motid = s_convbone_model_batch->GetCurMotInfo()->motid;
			//	double startframe = 1.0;
			//	double endframe = s_convbone_model_batch->GetCurMotInfo()->frameleng - 1.0;
			//	s_convbone_model->ModifyEuler360Req(g_limitdegflag, s_convbone_model->GetTopBone(false),
			//		motid, startframe, endframe);
			//}

			//int modelindex = (int)s_modelindex.size() - 1;
			//OnDelModel(modelindex);
		}
	}
	return 0;
}


unsigned __stdcall ThreadFunc_Retarget(LPVOID lpThreadParam)
{

	int outnum = (int)s_retargetout.size();

	InterlockedExchange(&s_retargetnum, (LONG)outnum);
	InterlockedExchange(&s_retargetcnt, 0);
	InterlockedExchange(&s_befretargetnum, 0);
	InterlockedExchange(&s_befretargetcnt, 0);

	int outcnt;
	for (outcnt = 0; outcnt < outnum; outcnt++) {
		//FBXファイル
		char fbxpath[MAX_PATH] = { 0 };
		WideCharToMultiByte(CP_UTF8, 0, s_retargetout[outcnt].c_str(), -1, fbxpath, MAX_PATH, NULL, NULL);
		//strcat_s(fbxpath, MAX_PATH, ".fbx");

		int result;
		result = RetargetFile(fbxpath);
		if (result == 0) {
			InterlockedExchange(&s_retargetcnt, (LONG)outcnt);
		}
		else {
			//InterlockedExchange(&g_retargetbatchflag, 0);
			break;
		}

		//if (g_retargetbatchflag != 1) {
		if (InterlockedAdd(&g_retargetbatchflag, 0) != 1) {
			break;
		}
	}

	InterlockedExchange(&g_retargetbatchflag, (LONG)3);


	//#########################################
	//watch thread state at OnFrameBatchThread
	//#########################################


	return 0;
}


int RetargetBatch()
{
	if (!s_model) {
		_ASSERT(0);
		return 0;
	}


	if (InterlockedAdd(&g_retargetbatchflag, 0) != 0) {//if already under calc, return 0.
		return 0;
	}


	//2023/10/12
	int optionret;
	optionret = (int)::MessageBox(g_mainhwnd, L"リターゲット前にSmooth処理をしますか？\nDo you want to smooth before retargeting?\nN or Y.", L"Select Option", 
		MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2);
	if (optionret == IDYES) {
		s_smoothBefRetarget = true;
	}
	else {
		s_smoothBefRetarget = false;
	}



	s_savelimitdegflag = g_limitdegflag;
	//ChangeLimitDegFlag(false, true, true);//2023/10/23 1.2.0.27_RC2にて　コメントアウト
	
	
	//g_limitdegflag = false;
	//if (s_LimitDegCheckBox) {
	//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
	//}


	//if (!s_convbone_model || !s_convbone_bvh) {
	//}
	//if (s_model != s_convbone_model) {
	//}

	s_convbone_model_batch = s_model;
	s_convbone_model_batch_selindex = s_curmodelmenuindex;


	s_saveretargetmodel = s_curmodelmenuindex;//終了時にOnModelMenuを呼ぶために保存


	BROWSEINFO bi;
	ZeroMemory(&bi, sizeof(BROWSEINFO));
	LPITEMIDLIST curlpidl = 0;
	WCHAR dispname[MAX_PATH] = { 0L };
	WCHAR selectname[MAX_PATH] = { 0L };
	int iImage = 0;

	//GetBatchHistoryDir(dispname, MAX_PATH);
	//if (selectname[0] != 0) {
	//	LPITEMIDLIST pidl;
	//	IMalloc* pMalloc;
	//	SHGetMalloc(&pMalloc);
	//	if (SUCCEEDED(SHGetSpecialFolderLocation(s_3dwnd, CSIDL_DESKTOPDIRECTORY, &pidl)))
	//	{
	//		// パスに変換する
	//		SHGetPathFromIDList(pidl, selectname);
	//		// 取得したIDLを解放する (CoTaskMemFreeでも可)
	//		pMalloc->Free(pidl);
	//		//SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
	//	}
	//	pMalloc->Release();
	//}

	bi.hwndOwner = s_3dwnd;
	bi.pidlRoot = NULL;//!!!!!!!
	bi.pszDisplayName = dispname;
	//bi.lpszTitle = L"保存フォルダを選択してください。";
	bi.lpszTitle = L"SelectDirectoryForBatch";
	//bi.ulFlags = BIF_EDITBOX | BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
	bi.ulFlags = BIF_RETURNONLYFSDIRS;// | BIF_NEWDIALOGSTYLE;//BIF_NEWDIALOGSTYLEを指定すると固まる　謎
	bi.lpfn = BrowseCallbackProc;
	bi.lParam = 0;
	bi.iImage = iImage;

	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

	curlpidl = SHBrowseForFolder(&bi);

	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	////UnhookWinEvent(hhook);
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;

	if (curlpidl) {
		//::DSMessageBox( m_hWnd, dispname, "フォルダー名", MB_OK );

		BOOL bret;
		bret = SHGetPathFromIDList(curlpidl, selectname);
		if (bret == FALSE) {
			_ASSERT(0);
			if (curlpidl)
				CoTaskMemFree(curlpidl);

			//ChangeLimitDegFlag(s_savelimitdegflag, true, true);//2023/10/23 1.2.0.27_RC2にて　コメントアウト


			//g_limitdegflag = s_savelimitdegflag;
			//if (s_LimitDegCheckBox) {
			//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
			//}

			return 1;
		}

		if (curlpidl)
			CoTaskMemFree(curlpidl);


		//selectname
		wstring target;
		string filenamepattern;
		//vector<wstring> out;
		wstring findext;

		s_retargetout.clear();
		target = selectname;
		findext = L".fbx";

		SaveBatchHistory(selectname);

		FindF(s_retargetout, target, findext);
		int outnum = (int)s_retargetout.size();
		InterlockedExchange(&s_retargetnum, (LONG)outnum);
		InterlockedExchange(&s_retargetcnt, 0);
		InterlockedExchange(&s_befretargetnum, 0);
		InterlockedExchange(&s_befretargetcnt, 0);

		if (outnum > 0)
		{
			InterlockedExchange(&g_retargetbatchflag, (LONG)1);

			CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_DIALOG2), NULL, (DLGPROC)RetargetBatchDlgProc);
			RECT rect;
			GetWindowRect(s_LtimelineWnd->getHWnd(), &rect);
			SetWindowPos(s_retargetbatchwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);
			ShowWindow(s_retargetbatchwnd, SW_SHOW);
			UpdateWindow(s_retargetbatchwnd);

			unsigned int threadaddr1 = 0;
			s_retargethandle1 = (HANDLE)_beginthreadex(
				NULL, 0, &ThreadFunc_Retarget,
				(void*)0,
				0, &threadaddr1);


			//WiatForしない場合には先に閉じてもOK
			if ((s_retargethandle1 != 0) && (s_retargethandle1 != INVALID_HANDLE_VALUE)) {
				CloseHandle(s_retargethandle1);
			}

		}
	}

	//InterlockedExchange(&g_retargetbatchflag, 0);//スレッドを立ててすぐに出ていくのでここではフラグはそのまま


	//ChangeLimitDegFlag(s_savelimitdegflag, true, true);//OnFrameBatchThread()で行うので　ここでは呼ばない


	return 0;
}


//########## retarget batch ここまで


unsigned __stdcall ThreadFunc_Bvh2Fbx(LPVOID lpThreadParam)
{
	int outnum = (int)s_bvh2fbxout.size();
	int outcnt;

	InterlockedExchange(&s_progressnum, (LONG)outnum);
	InterlockedExchange(&s_progresscnt, (LONG)0);
	if (s_bvh2fbxbatchwnd) {
		HWND hProg;
		hProg = GetDlgItem(s_bvh2fbxbatchwnd, IDC_PROGRESS1);
		if (hProg) {
			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, 100));
			SendMessage(hProg, PBM_SETPOS, (WPARAM)0, 0);
			UpdateWindow(s_bvh2fbxbatchwnd);
		}
	}


	for (outcnt = 0; outcnt < outnum; outcnt++) {

		InterlockedExchange(&s_progresscnt, (LONG)outcnt);

		//bvhファイルを読み込む
		CBVHFile* bvhfile = new CBVHFile();
		if (!bvhfile) {
			//g_bvh2fbxbatchflag = 0;
			break;
		}
		int ret;
		ret = bvhfile->LoadBVHFile(s_LtimelineWnd->getHWnd(), (wchar_t*)(s_bvh2fbxout[outcnt].c_str()), g_tmpmqomult);
		if (ret) {
			_ASSERT(0);
			if (bvhfile) {
				delete bvhfile;
				bvhfile = 0;
			}
			break;
		}

		//FBXファイルに書き出す
		char fbxpath[MAX_PATH] = { 0 };
		WideCharToMultiByte(CP_UTF8, 0, s_bvh2fbxout[outcnt].c_str(), -1, fbxpath, MAX_PATH, NULL, NULL);
		strcat_s(fbxpath, MAX_PATH, ".fbx");
		SYSTEMTIME localtime;
		GetLocalTime(&localtime);
		char fbxdate[MAX_PATH] = { 0L };
		sprintf_s(fbxdate, MAX_PATH, "CommentForEGP_%04u%02u%02u%02u%02u%02u",
			localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);

		int result;
		result = BVH2FBXFile(s_psdk, bvhfile, fbxpath, fbxdate);
		if (result == 0) {
			s_bvh2fbxcnt = outcnt;
		}
		else {
			if (bvhfile) {
				delete bvhfile;
				bvhfile = 0;
			}
			break;
		}

		if (bvhfile) {
			delete bvhfile;
			bvhfile = 0;
		}

		//if (g_bvh2fbxbatchflag != 1) {
		if (InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 1) {
			break;
		}
	}

	InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)3);

	//#########################################
	//watch thread state at OnFrameBatchThread
	//#########################################

	return 0;
}

//unsigned __stdcall ThreadFunc_Bvh2FbxDisp(LPVOID lpThreadParam)
//{
//
//	if (s_bvh2fbxbatchwnd != 0) {
//		SetWindowTextW(s_bvh2fbxbatchwnd, L"bvh to FBX Batch");
//	}
//
//	while (g_bvh2fbxbatchflag == 1) {
//		if (s_bvh2fbxbatchwnd != 0) {
//			SendMessage(s_bvh2fbxbatchwnd, WM_USER_FOR_BATCH_PROGRESS, 0, 0);
//			InvalidateRect(s_bvh2fbxbatchwnd, NULL, TRUE);
//			UpdateWindow(s_bvh2fbxbatchwnd);
//		}
//		Sleep(20);
//	}
//
//	return 0;
//}


int BVH2FBXBatch()
{
	if (InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) {//if already under calc, return 0.
		return 0;
	}

	BROWSEINFO bi;
	ZeroMemory(&bi, sizeof(BROWSEINFO));
	LPITEMIDLIST curlpidl = 0;
	WCHAR dispname[MAX_PATH] = { 0L };
	WCHAR selectname[MAX_PATH] = { 0L };
	int iImage = 0;

	//GetBatchHistoryDir(dispname, MAX_PATH);
	//if (selectname[0] != 0) {
	//	LPITEMIDLIST pidl;
	//	IMalloc* pMalloc;
	//	SHGetMalloc(&pMalloc);
	//	if (SUCCEEDED(SHGetSpecialFolderLocation(s_3dwnd, CSIDL_DESKTOPDIRECTORY, &pidl)))
	//	{
	//		// パスに変換する
	//		SHGetPathFromIDList(pidl, selectname);
	//		// 取得したIDLを解放する (CoTaskMemFreeでも可)
	//		pMalloc->Free(pidl);
	//		//SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
	//	}
	//	pMalloc->Release();
	//}

	bi.hwndOwner = s_3dwnd;
	bi.pidlRoot = NULL;//!!!!!!!
	bi.pszDisplayName = dispname;
	//bi.lpszTitle = L"保存フォルダを選択してください。";
	bi.lpszTitle = L"SelectDirectoryForBatch";
	//bi.ulFlags = BIF_EDITBOX | BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
	bi.ulFlags = BIF_RETURNONLYFSDIRS;// | BIF_NEWDIALOGSTYLE;//BIF_NEWDIALOGSTYLEを指定すると固まる　謎
	bi.lpfn = BrowseCallbackProc;
	bi.lParam = 0;
	bi.iImage = iImage;

	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

	curlpidl = SHBrowseForFolder(&bi);

	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	//UnhookWinEvent(hhook);
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;

	if (curlpidl) {
		//::DSMessageBox( m_hWnd, dispname, "フォルダー名", MB_OK );

		BOOL bret;
		bret = SHGetPathFromIDList(curlpidl, selectname);
		if (bret == FALSE) {
			_ASSERT(0);
			if (curlpidl)
				CoTaskMemFree(curlpidl);
			return 1;
		}

		if (curlpidl)
			CoTaskMemFree(curlpidl);


		//selectname
		wstring target;
		string filenamepattern;
		//vector<wstring> out;
		wstring findext;

		s_bvh2fbxout.clear();
		target = selectname;
		findext = L".bvh";

		SaveBatchHistory(selectname);

		FindF(s_bvh2fbxout, target, findext);
		int outnum = (int)s_bvh2fbxout.size();
		InterlockedExchange(&s_bvh2fbxnum, (LONG)outnum);
		InterlockedExchange(&s_bvh2fbxcnt, 0);
		InterlockedExchange(&s_befbvh2fbxnum, 0);
		InterlockedExchange(&s_befbvh2fbxcnt, 0);

		if (outnum > 0)
		{

			InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)1);//start thread


			CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_DIALOG2), NULL, (DLGPROC)bvh2FbxBatchDlgProc);
			RECT rect;
			GetWindowRect(s_LtimelineWnd->getHWnd(), &rect);
			SetWindowPos(s_bvh2fbxbatchwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);
			ShowWindow(s_bvh2fbxbatchwnd, SW_SHOW);
			UpdateWindow(s_bvh2fbxbatchwnd);

			unsigned int threadaddr1 = 0;
			s_bvh2fbxhandle1 = (HANDLE)_beginthreadex(
				NULL, 0, &ThreadFunc_Bvh2Fbx,
				(void*)0,
				0, &threadaddr1);

			//WiatForしない場合には先に閉じてもOK
			if (s_bvh2fbxhandle1 && (s_bvh2fbxhandle1 != INVALID_HANDLE_VALUE)) {
				CloseHandle(s_bvh2fbxhandle1);
			}
		}
	}


	return 0;
}

int BVH2FBX()
{

	int dlgret;
	s_filterindex = 5;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_OPENMQODLG),
		s_3dwnd, (DLGPROC)OpenMqoDlgProc);
	if ((dlgret != IDOK) || (g_tmpmqopath[0] == 0L)) {
		return 0;
	}


	//WCHAR savepath[MULTIPATH];//stack size warning
	WCHAR* tmpsavepath = new WCHAR[MULTIPATH];
	if (!tmpsavepath) {
		_ASSERT(0);
		return 1;
	}
	ZeroMemory(tmpsavepath, sizeof(WCHAR) * MULTIPATH);
	MoveMemory(tmpsavepath, g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);


	//bvhファイルを読み込む
	CBVHFile bvhfile;
	int ret;
	ret = bvhfile.LoadBVHFile(s_3dwnd, g_tmpmqopath, g_tmpmqomult);
	if (ret) {
		_ASSERT(0);
		if(tmpsavepath)
			delete[] tmpsavepath;
		return 1;
	}

	Savebvh2FBXHistory(tmpsavepath);
	if (tmpsavepath)
		delete[] tmpsavepath;


	//FBXファイルに書き出す
	char fbxpath[MAX_PATH] = { 0 };
	WideCharToMultiByte(CP_UTF8, 0, g_tmpmqopath, -1, fbxpath, MAX_PATH, NULL, NULL);
	strcat_s(fbxpath, MAX_PATH, ".fbx");
	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	char fbxdate[MAX_PATH] = { 0L };
	sprintf_s(fbxdate, MAX_PATH, "CommentForEGP_%04u%02u%02u%02u%02u%02u",
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	CallF(BVH2FBXFile(s_psdk, &bvhfile, fbxpath, fbxdate), return 1);


	return 0;
}

int OpenFile()
{
	s_nowloading = true;


	//大きいフレーム一のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	InitTimelineSelection();



	////CurrentDirectoryがMameMediaになっていたときにはTestディレクトリに変える
	//WCHAR curdir[MAX_PATH] = { 0L };
	//ZeroMemory(curdir, sizeof(WCHAR) * MAX_PATH);
	//GetCurrentDirectory(MAX_PATH, curdir);
	//WCHAR* findpat = wcsstr(curdir, L"\\MameMedia");
	//if (findpat) {
	//	WCHAR initialdir[MAX_PATH] = { 0L };
	//	wcscpy_s(initialdir, MAX_PATH, g_basedir);
	//	wcscat_s(initialdir, MAX_PATH, L"..\\Test\\");
	//	SetCurrentDirectoryW(initialdir);
	//}
	SetCurrentDirectoryW(g_basedir);


	int dlgret;
	s_filterindex = 1;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_OPENMQODLG),
		s_3dwnd, (DLGPROC)OpenMqoDlgProc);
	if ((dlgret != IDOK) || (g_tmpmqopath[0] == 0L)) {
		s_nowloading = false;
		return 0;
	}

	//WCHAR savepath[MULTIPATH];//stack size warning
	WCHAR* tmpsavepath = new WCHAR[MULTIPATH];
	if (!tmpsavepath) {
		_ASSERT(0);
		s_nowloading = false;
		return 1;
	}
	ZeroMemory(tmpsavepath, sizeof(WCHAR) * MULTIPATH);
	MoveMemory(tmpsavepath, g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);

	size_t leng;
	int namecnt = 0;
	tmpsavepath[MULTIPATH - 1] = 0L;
	leng = wcslen(tmpsavepath);
	if ((leng <= 0) && (leng >= MULTIPATH)) {
		_ASSERT(0);
		s_nowloading = false;
		if (tmpsavepath)
			delete[] tmpsavepath;
		return 0;
	}

	WCHAR* topchar = tmpsavepath + leng;
	if (*topchar == TEXT('\0')) {
		WCHAR* extptr = 0;
		extptr = wcsrchr(g_tmpmqopath, TEXT('.'));
		if (!extptr) {
			s_nowloading = false;
			if (tmpsavepath)
				delete[] tmpsavepath;
			return 0;
		}
		int result = 0;
		CModel* newmodel = 0;
		int cmpcha, cmpfbx, cmpmqo, cmpref, cmpimp, cmpgco, cmpmnl;
		cmpcha = wcscmp(extptr, L".cha");
		cmpfbx = wcscmp(extptr, L".fbx");
		cmpmqo = wcscmp(extptr, L".mqo");
		cmpref = wcscmp(extptr, L".ref");
		cmpimp = wcscmp(extptr, L".imp");
		cmpgco = wcscmp(extptr, L".gco");
		cmpmnl = wcscmp(extptr, L".mnl");
		if (cmpcha == 0) {
			result = OpenChaFile();
			s_filterindex = 1;
		}
		else if (cmpfbx == 0) {
			if (s_chascene && (s_chascene->GetModelNum() > 0)) {
				OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
			}
			std::vector<std::string> ikstopname;
			ikstopname.clear();
			newmodel = OpenFBXFile(false, true, 0, 1, ikstopname);
			if (newmodel) {
				result = 0;
			}
			else {
				result = 1;
			}
			s_filterindex = 1;
		}
		else if (cmpmqo == 0) {
			if (s_chascene && (s_chascene->GetModelNum() > 0)) {
				OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
			}

			newmodel = OpenMQOFile();
			if (newmodel) {
				result = 0;
			}
			else {
				result = 1;
			}
			s_filterindex = 1;
		}
		else if (cmpref == 0) {
			result = OpenREFile();
			s_filterindex = 2;
		}
		else if (cmpimp == 0) {
			result = OpenImpFile();
			s_filterindex = 3;
		}
		else if (cmpgco == 0) {
			result = OpenGcoFile();
			s_filterindex = 4;
		}
		else if (cmpmnl == 0) {
			result = OpenMNLFile();
			s_filterindex = 6;
		}

		if (result != 0) {
			WCHAR strerror[MAX_PATH * 2] = { 0L };
			swprintf_s(strerror, MAX_PATH * 2, L"%s の\n読み込みに失敗しました。", g_tmpmqopath);
			MessageBox(g_mainhwnd, strerror, L"エラー", MB_OK);
			s_nowloading = false;

			if (tmpsavepath)
				delete[] tmpsavepath;
			return 1;
		}

	}
	else {
		size_t leng2;
		while (*topchar != TEXT('\0')) {
			tmpsavepath[MULTIPATH - 1] = 0L;
			//leng2 = wcslen(topchar);
			swprintf_s(g_tmpmqopath, MULTIPATH, L"%s\\%s", tmpsavepath, topchar);

			WCHAR* extptr = 0;
			extptr = wcsrchr(g_tmpmqopath, TEXT('.'));
			if (!extptr) {
				s_nowloading = false;
				if (tmpsavepath)
					delete[] tmpsavepath;
				return 0;
			}
			int result = 0;
			CModel* newmodel = 0;
			int cmpfbx, cmpmqo;
			cmpfbx = wcscmp(extptr, L".fbx");
			cmpmqo = wcscmp(extptr, L".mqo");
			if (cmpfbx == 0) {
				//WCHAR* nexttopchar = topchar + leng2 + 1;
				//if (*nexttopchar != TEXT('\0')) {
				if (s_chascene && (s_chascene->GetModelNum() > 0)) {
					OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
				}

				std::vector<std::string> ikstopname;
				ikstopname.clear();
				newmodel = OpenFBXFile(false, true, 0, 1, ikstopname);
				if (newmodel) {
					result = 0;
				}
				else {
					result = 1;
				}
				//}
				//else {
				//	//最終のFBXに対してのみinittimelineをする
				//	OpenFBXFile(0, 1);
				//}
				s_filterindex = 1;
			}
			else if (cmpmqo == 0) {
				if (s_chascene && (s_chascene->GetModelNum() > 0)) {
					OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
				}

				newmodel = OpenMQOFile();
				if (newmodel) {
					result = 0;
				}
				else {
					result = 1;
				}
				s_filterindex = 1;
			}

			if (result != 0) {
				WCHAR strerror[MAX_PATH * 2] = { 0L };
				swprintf_s(strerror, MAX_PATH * 2, L"%s の\n読み込みに失敗しました。", g_tmpmqopath);
				MessageBox(g_mainhwnd, strerror, L"エラー", MB_OK);
				s_nowloading = false;
				if (tmpsavepath)
					delete[] tmpsavepath;
				return 1;
			}

			tmpsavepath[MULTIPATH - 1] = 0L;
			leng2 = wcslen(topchar);
			if ((leng2 > 0) && (leng2 < MULTIPATH)) {
				topchar = topchar + leng2 + 1;
				namecnt++;
			}
			else {
				WCHAR strerror[MAX_PATH * 2] = { 0L };
				swprintf_s(strerror, MAX_PATH * 2, L"%s の\n読み込みに失敗しました。", g_tmpmqopath);
				MessageBox(g_mainhwnd, strerror, L"エラー", MB_OK);
				s_nowloading = false;
				if (tmpsavepath)
					delete[] tmpsavepath;
				return 1;
			}
		}
	}

	s_nowloading = false;

	//ChangeCurrentBone();

	if (tmpsavepath)
		delete[] tmpsavepath;


	s_camtargetOnceflag = 1;//set cameratarget to selected joint ONCE


	return 0;
}

CModel* OpenMQOFile()
{
	//RenderContext* pRenderContext = DXUTGetD3D11DeviceContext();


	//大きいフレーム一のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	InitTimelineSelection();


	static int modelcnt = 0;
	WCHAR modelname[MAX_PATH] = { 0L };
	WCHAR* lasten;
	lasten = wcsrchr(g_tmpmqopath, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return 0;
	}
	wcscpy_s(modelname, MAX_PATH, lasten + 1);
	WCHAR* extptr;
	extptr = wcsrchr(modelname, TEXT('.'));
	if (!extptr) {
		_ASSERT(0);
		return 0;
	}
	*extptr = 0L;
	WCHAR modelfolder[MAX_PATH] = { 0L };
	swprintf_s(modelfolder, MAX_PATH, L"%s_%d", modelname, modelcnt);
	modelcnt++;


	if (!g_texbank) {
		g_texbank = new CTexBank(s_pdev);
		if (!g_texbank) {
			_ASSERT(0);
			return 0;
		}
	}
	if (s_model && (s_curmodelmenuindex >= 0) && s_chascene && (s_chascene->GetModelNum() != 0)) {
		s_chascene->SetTimelineArray(s_curmodelmenuindex, s_tlarray);
		s_chascene->SetLineno2Boneno(s_curmodelmenuindex, s_lineno2boneno, s_boneno2lineno);
	}

	DestroyTimeLine(1);

	// Load the mesh
	CModel* newmodel;
	newmodel = new CModel();
	if (!newmodel) {
		_ASSERT(0);
		return 0;
	}
	newmodel->SetLoadingMotionCount(0);//2022/11/01

	int ret;
	ret = newmodel->LoadMQO(s_pdev, g_tmpmqopath, modelfolder, g_tmpmqomult, 0);
	if (ret) {
		delete newmodel;
		if (s_owpTimeline) {
			refreshTimeline(*s_owpTimeline);
		}
		return 0;
	}
	else {
		s_model = newmodel;
	}
	//CallF(s_model->MakeDispObj(), return 0);
	CallF(s_model->DbgDump(), return 0);

	int mindex;
	if (s_chascene) {
		mindex = s_chascene->GetModelNum();
	}
	else {
		mindex = 0;
	}
	MODELELEM modelelem;
	modelelem.modelptr = s_model;
	modelelem.motmenuindex = 0;
	if (s_chascene) {
		s_chascene->AddModelElem(modelelem);
	}


	//   CDXUTComboBox* pComboBox = g_SampleUI.GetComboBox( IDC_COMBO_BONE );
	   //pComboBox->RemoveAllItems();

	   //map<int, CBone*>::iterator itrbone;
	   //for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	   //	ULONG boneno = (ULONG)itrbone->first;
	   //	CBone* curbone = itrbone->second;
	   //	if( curbone && (boneno >= 0) ){
	   //		char* nameptr = (char*)curbone->GetBoneName();
	   //		WCHAR wname[256];
	   //		ZeroMemory( wname, sizeof( WCHAR ) * 256 );
	   //		MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, nameptr, 256, wname, 256 );
	   //		pComboBox->AddItem( wname, ULongToPtr( boneno ) );
	   //	}
	   //}

	   //s_totalmb.center = ChaVector3( 0.0f, 0.0f, 0.0f );
	   //s_totalmb.max = ChaVector3( 0.0f, 0.0f, 0.0f );
	   //s_totalmb.min = ChaVector3( 0.0f, 0.0f, 0.0f );
	   //s_totalmb.r = 0.0f;
	CalcTotalBound();


	CallF(AddMotion(0), return 0);

	if (s_chascene) {
		s_chascene->SetTimelineArray(mindex, s_tlarray);
		s_chascene->SetLineno2Boneno(mindex, s_lineno2boneno, s_boneno2lineno);
	}
	else {
		_ASSERT(0);
	}

	//	CallF( OnModelMenu( mindex, 0 ), return 0 );

	DispModelPanel();

	return newmodel;
}

int SetCameraModel()
{
	s_cameramodel = 0;

	if (s_chascene) {
		s_cameramodel = s_chascene->GetTheLastCameraModel();
	}



	//カメラモデルが無い場合には　スプライトスイッチもオフにしておく
	if (!s_cameramodel) {
		ChangeCameraMode(1);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2
	}


	//モデル読み込み中　かつ　カメラモデルがある場合　カメラアニメスイッチを強制オン
	if (s_nowloading && s_cameramodel) {
		ChangeCameraMode(2);
	}


	return 0;
}

void CalcTotalBound()
{

	//s_totalmb.center = ChaVector3(0.0f, 0.0f, 0.0f);
	//s_totalmb.max = ChaVector3(50.0f, 50.0f, 50.0f);
	//s_totalmb.min = ChaVector3(-50.0f, -50.0f, -50.0f);
	//s_totalmb.r = (float)ChaVector3LengthDbl(&s_totalmb.max);


	SetCameraModel();

	if (s_chascene) {
		s_chascene->CalcTotalModelBound();
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	FLOAT fObjectRadius;
	if (s_chascene) {
		g_vCenter = s_chascene->GetTotalModelBound().center;
		fObjectRadius = s_chascene->GetTotalModelBound().r;
	}
	else {
		_ASSERT(0);
		g_vCenter = ChaVector3(0.0f, 0.0f, 0.0f);
		fObjectRadius = 10.0f;
	}
	if (fObjectRadius < 0.1f) {
		fObjectRadius = 10.0f;
	}

	s_cammvstep = max(0.01f, min(500.0f, fObjectRadius));//2023/05/19

	//DbgOut(L"fbx : totalmb : r %f, center (%f, %f, %f)\r\n",
	//	s_totalmb.r, s_totalmb.center.x, s_totalmb.center.y, s_totalmb.center.z);

	//for (int i = 0; i < LIGHTNUMMAX; i++)
	//	g_LightControl[i].SetRadius(fObjectRadius);


	g_projnear = max(0.01f, min(10.0f, fObjectRadius * 0.01f));
	g_initcamdist = max(0.1f, min(1000.0f, fObjectRadius * 3.0f));
	g_projfar = g_initcamdist * 100.0f;
	//s_fAspectRatio = 1.0f;//ここでは更新しない
	g_fovy = (float)(PI / 4);
	g_camtargetpos = g_vCenter;
	ChaVector3 dirz = ChaVector3(0.0f, 0.0f, 1.0);
	g_camEye = g_vCenter + dirz * g_initcamdist;
	//ChangeCameraMode(1);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2.  この関数の上の方のSetCameraModel()で制御するので　ここはコメントアウト


	g_camdist = g_initcamdist;

	g_befcamEye = g_camEye;
	g_befcamtargetpos = g_camtargetpos;

	SetCamera3DFromEyePos();
}


CModel* OpenFBXFile(bool callfromcha, bool dorefreshtl, int skipdefref, int inittimelineflag, std::vector<std::string> ikstopname)
{
	static int s_dbgcnt = 0;
	s_dbgcnt++;

	//RenderContext* pRenderContext = DXUTGetD3D11DeviceContext();


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}


	//大きいフレーム一のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	InitTimelineSelection();


	//int dlgret;
	//dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_CHECKAXISTYPE),
	//	s_3dwnd, (DLGPROC)CheckAxisTypeProc);
	//if (dlgret != IDOK){
	//	return 0;
	//}

	g_camtargetpos = ChaVector3(0.0f, 0.0f, 0.0f);
	g_befcamtargetpos = g_camtargetpos;


	static int modelcnt = 0;

	WCHAR fbxpath0[MAX_PATH] = { 0L };
	wcscpy_s(fbxpath0, MAX_PATH, g_tmpmqopath);

	WCHAR modelname[MAX_PATH] = { 0L };
	WCHAR* lasten;
	lasten = wcsrchr(g_tmpmqopath, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return 0;
	}
	wcscpy_s(modelname, MAX_PATH, lasten + 1);
	WCHAR* extptr;
	extptr = wcsrchr(modelname, TEXT('.'));
	if (!extptr) {
		_ASSERT(0);
		return 0;
	}
	*extptr = 0L;
	WCHAR modelfolder[MAX_PATH] = { 0L };
	swprintf_s(modelfolder, MAX_PATH, L"%s_%d", modelname, modelcnt);
	modelcnt++;


	WCHAR tbofilename[MAX_PATH] = { 0L };
	swprintf_s(tbofilename, MAX_PATH, L"%s.tbo", g_tmpmqopath);


	if (!g_texbank) {
		g_texbank = new CTexBank(s_pdev);
		if (!g_texbank) {
			_ASSERT(0);
			return 0;
		}
	}
	if (s_model && (s_curmodelmenuindex >= 0) && s_chascene && (s_chascene->GetModelNum() != 0)) {
		s_chascene->SetTimelineArray(s_curmodelmenuindex, s_tlarray);
		s_chascene->SetLineno2Boneno(s_curmodelmenuindex, s_lineno2boneno, s_boneno2lineno);
	}



	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	DestroyTimeLine(1);

	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	// Load the mesh
	CModel* newmodel;
	newmodel = new CModel();
	if (!newmodel) {
		_ASSERT(0);
		return 0;
	}
	newmodel->SetLoadingMotionCount(0);//2022/11/01

	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	_ASSERT(s_btWorld);
	newmodel->SetBtWorld(s_btWorld);
	FbxScene* pScene = 0;
	FbxImporter* pImporter = 0;
	//skipdefref FBX単体読み込みの場合にはdefault_ref.refは存在しない。その場合skipdefrefには０が代入され、CModel::LoadFBX内でdefault_ref.refの中でメモリからデフォルト値が設定される
	int ret;
	BOOL motioncachebatchflag = FALSE;
	ret = newmodel->LoadFBX(skipdefref, s_pdev, g_tmpmqopath, modelfolder, g_tmpmqomult, s_psdk, &pImporter, &pScene, s_forcenewaxis, motioncachebatchflag);
	if (ret) {
		_ASSERT(0);
		delete newmodel;
		if (s_owpTimeline) {
			refreshTimeline(*s_owpTimeline);
		}
		return 0;
	}
	else {
		s_model = newmodel;
	}

	if (callfromcha == true) {
		//ChaFile.cppで　*.cha fileの記述から読み取る
		std::vector<std::string>::iterator itrname;
		for (itrname = ikstopname.begin(); itrname != ikstopname.end(); itrname++) {
			string curname = *itrname;
			newmodel->AddIKStopName(curname.c_str());
		}
	}
	else {
		//set default IKStopName
		newmodel->AddIKStopName("Shoulder");
		newmodel->AddIKStopName("UpperLeg");
	}
	newmodel->SetIKStopFlag();


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	//CallF(s_model->MakeDispObj(), return 0);

	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	int mindex;
	if (s_chascene) {
		mindex = s_chascene->GetModelNum();
	}
	else {
		mindex = 0;
	}
	MODELELEM modelelem;
	modelelem.modelptr = s_model;
	modelelem.motmenuindex = 0;
	if (s_chascene) {
		s_chascene->AddModelElem(modelelem);
	}

	//   CDXUTComboBox* pComboBox = g_SampleUI.GetComboBox( IDC_COMBO_BONE );
	   //pComboBox->RemoveAllItems();

	   //map<int, CBone*>::iterator itrbone;
	   //for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	   //	ULONG boneno = (ULONG)itrbone->first;
	   //	CBone* curbone = itrbone->second;
	   //	if( curbone && (boneno >= 0) ){
	   //		char* nameptr = (char*)curbone->GetBoneName();
	   //		WCHAR wname[256];
	   //		MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, nameptr, 256, wname, 256 );
	   //		pComboBox->AddItem( wname, ULongToPtr( boneno ) );
	   //	}
	   //}

	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}


	//CalcTotalBound();//下で呼んでる

	if (s_chascene) {
		s_chascene->SetTimelineArray(mindex, s_tlarray);
		s_chascene->SetLineno2Boneno(mindex, s_lineno2boneno, s_boneno2lineno);
	}
	else {
		_ASSERT(0);
	}



	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	CallF(OnModelMenu(dorefreshtl, mindex, 0), return 0);

	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}


	//FrameCopyDlgはOnModelMenu()にてまだ無いときに作成される
	//tboファイルのLoadはOnModelMenu()よりも後で
	CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg();
	if (curcpdlg) {
		bool result = curcpdlg->LoadWithProjectFile(tbofilename);//LoadTboFile
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	//CallF( s_model->LoadFBXAnim( s_psdk, pImporter, pScene, OnAddMotion ), return 0 );
	CallF(s_model->LoadFBXAnim(s_psdk, pImporter, pScene, NULL, motioncachebatchflag), return 0);
	//if( (int)s_modelindex.size() >= 2 )
	//	_ASSERT( 0 );




//::MessageBox(g_mainhwnd, L"check 1", L"check!!!", MB_OK);

	CalcTotalBound();

	if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
		int cameraindex = 0;
		OnCameraMenu(true, cameraindex, 1);
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	//if( s_model->GetMotInfoSize() >= 2 ){
	//	OnDelMotion( 0 );//初期状態のダミーモーションを削除
	//}

//::MessageBox(g_mainhwnd, L"check 2", L"check!!!", MB_OK);

	//OnAnimMenuでCreateRigidElemを呼ぶ前に、default_ref.refを読む
	if (skipdefref == 1) {//プロジェクトファイルから呼ばれて、かつ、default_ref.refが存在する場合
		if (s_model->GetMotInfoSize() > 0) {
			MOTINFO* firstmi = s_model->GetMotInfo(1);
			if (firstmi) {
				s_model->SetCurrentMotion(firstmi->motid);

				WCHAR savetmpmqopath[MAX_PATH];
				wcscpy_s(savetmpmqopath, MAX_PATH, g_tmpmqopath);
				WCHAR* lastenref;
				lastenref = wcsrchr(g_tmpmqopath, TEXT('\\'));
				if (lastenref) {
					*lastenref = 0L;
					wcscat_s(g_tmpmqopath, MAX_PATH, L"\\default_ref.ref");
					int chkret;
					chkret = OpenREFile();
					_ASSERT(chkret == 0);


					wcscpy_s(g_tmpmqopath, MAX_PATH, savetmpmqopath);
				}
			}
		}
	}

	//::MessageBox(g_mainhwnd, L"check 3", L"check!!!", MB_OK);


		//if (inittimelineflag == 1)//inittimelineflag は 最後のキャラの時に１
	{
		int lastmotid = -1;
		int motnum = s_model->GetMotInfoSize();
		int motno;
		for (motno = 0; motno < motnum; motno++) {

			//WCHAR strchk[256] = { 0L };
			//swprintf_s(strchk, 256, L"check 3 : %d / %d", motno, motnum);
			//::MessageBox(g_mainhwnd, strchk, L"check!!!", MB_OK);

			MOTINFO* curmi = s_model->GetMotInfo(motno + 1);
			if (curmi) {
				lastmotid = curmi->motid;
				s_model->SetCurrentMotion(lastmotid);
				//OnAddMotion(curmi->motid, (motno == 0));
				// 
				//Main.cppのOnAddMotion()は　メニューの追加のみ
				//
				OnAddMotion(curmi->motid, (motno == (motnum - 1)));//最後のモーション!!!!!! 2021/08/19

				if (s_nowloading && s_3dwnd) {
					OnRenderNowLoading();
				}

			}
		}
		//s_model->SetCurrentMotion(lastmotid);
	}
	//}

//::MessageBox(g_mainhwnd, L"check 4", L"check!!!", MB_OK);


	//2023/10/27
	// モーション無しのfbxを読み込んだ場合　motidは作成されるがモーションポイントは１つも無い
	// そのために　motnum == 0のときに　AddMotion()を呼んで　InitMPする
	// CModel::AddMotion()からInitMPが呼ばれるためには　GetLoadedFlag() == trueである必要
	// よってモデルとアニメ読み込み後　かつ motnum == 0処理よりも前に　SetLoadedFlag(true)する必要
	// 下方から移動
	s_model->SetLoadedFlag(true);


	//Handle a model not has motion.
	int motnum = s_model->GetMotInfoSize();
	if ((motnum == 0) && (s_model->GetNoBoneFlag() == false)) {
		CallF(AddMotion(0), return 0);//モーション無しfbxを読み込んだ場合のInitMP呼び出しでモーションポイント作成
		if (s_chascene) {
			s_chascene->SetTimelineArray(mindex, s_tlarray);
			s_chascene->SetLineno2Boneno(mindex, s_lineno2boneno, s_boneno2lineno);
		}
		else {
			_ASSERT(0);
			return 0;
		}
	}




	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	//::MessageBox(g_mainhwnd, L"check 5", L"check!!!", MB_OK);

	OnRgdMorphMenu(0);

	//	SetCapture( s_3dwnd );

	if (s_model && s_model->GetCurMotInfo()) {
		s_curmotid = s_model->GetCurMotInfo()->motid;
	}
	else {
		//_ASSERT(0);
		s_curmotid = 0;
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	if (s_model->GetOldAxisFlagAtLoading() == 0) {
		CLmtFile lmtfile;
		WCHAR lmtname[MAX_PATH];
		swprintf_s(lmtname, MAX_PATH, L"%s.lmt", g_tmpmqopath);
		char fbxcomment[MAX_PATH] = { 0 };
		int chkretcomment;
		chkretcomment = s_model->GetFbxComment(fbxcomment, MAX_PATH);
		if (chkretcomment == 0) {
			int chkret1;
			chkret1 = lmtfile.LoadLmtFile(lmtname, s_model, fbxcomment);
			//_ASSERT(chkret1 == 0);
		}
		WCHAR rigname[MAX_PATH] = { 0L };
		swprintf_s(rigname, MAX_PATH, L"%s.rig", g_tmpmqopath);
		CRigFile rigfile;
		int chkret2;
		chkret2 = rigfile.LoadRigFile(rigname, s_model);
		//_ASSERT(chkret2 == 0);
	}

	//::MessageBox(g_mainhwnd, L"check 6", L"check!!!", MB_OK);


	s_model->SetMotionSpeed(g_dspeed);

	DispModelPanel();


	//OnAnimMenuで呼ぶ
	//if (skipdefref == 0) {
	//	s_model->CreateBtObject(1);//初回
	//	s_model->CalcBoneEul(-1);
	//}

	CBone* hipsbone = nullptr;
	s_model->GetHipsBoneReq(s_model->GetTopBone(false), &hipsbone);
	if (hipsbone) {
		g_befcamtargetpos = g_camtargetpos;
		g_camtargetpos = hipsbone->GetChildWorld();
		s_curboneno = hipsbone->GetBoneNo();
	}

#ifndef NDEBUG
	CallF(s_model->DbgDump(), return 0);
#endif

	g_dbgloadcnt++;

	//s_model->DestroyScene();

	//2023/10/27
	// モーション無しのfbxを読み込んだ場合　motidは作成されるがモーションポイントは１つも無い
	// そのために　motnum == 0のときに　AddMotion()を呼んで　InitMPする
	// CModel::AddMotion()からInitMPが呼ばれるためには　GetLoadedFlag() == trueである必要
	// よってモデルとアニメ読み込み後　かつ motnum == 0処理よりも前に　SetLoadedFlag(true)する必要
	// 上方へ移動
	//s_model->SetLoadedFlag(true);

	//ShowRigidWnd(true);

//::MessageBox(g_mainhwnd, L"check 7", L"check!!!", MB_OK);



	//2022/11/23
	//VRoidの髪の毛ジョイントが多く　顔がみえなくなるので　読み込み時に自動的に　頭のジョイントマークをスキップ設定
	CBone* vroidheadjoint = s_model->FindBoneByName("J_Bip_C_Head");
	if (vroidheadjoint) {
		SkipJointMarkReq(1, vroidheadjoint, false);
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	OrgWindowListenMouse(true);

	//::MessageBox(g_mainhwnd, L"check 8", L"check!!!", MB_OK);


	SetTimelineHasRigFlag();


	//############################
	//############################

		//読み込み処理が成功してから履歴を保存する。fbxファイル。
	size_t savepathlen;
	fbxpath0[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(fbxpath0);
	if ((savepathlen > 4) && (savepathlen < MAX_PATH)) {
		WCHAR* pwext;
		pwext = fbxpath0 + ((size_t)savepathlen - 1) - 3;
		if (wcscmp(pwext, L".fbx") == 0) {
			SYSTEMTIME localtime;
			GetLocalTime(&localtime);
			WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
			swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProj_%04u%02u%02u%02u%02u%02u.txt",
				s_temppath,
				localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
			HANDLE hfile;
			hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				//int pathlen;
				//pathlen = (int)wcslen(saveprojpath);
				//if ((pathlen > 0) && (pathlen < MAX_PATH)) {
				if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
					DWORD writelen = 0;
					WriteFile(hfile, fbxpath0, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
					_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
				}
				CloseHandle(hfile);
			}
		}
	}

	return newmodel;
}

int InitCurMotion(int selectflag, double expandmotion)
{

	//モーション初期化はunlimitedに対して行う
	bool limitdegflag = false;


	if (s_model) {
		MOTINFO* curmi = s_model->GetCurMotInfo();
		if (curmi) {
			//CallF(s_model->FillUpEmptyMotion(curmi->motid), return 0);
			CBone* topbone = s_model->GetTopBone(false);
			if (topbone && (s_model->GetNoBoneFlag() == false)) {
				double motleng = curmi->frameleng;
				//_ASSERT(0);

				if (selectflag == 1) {//called from tool panel : init selected time range

					bool firstflag = true;
					double startframe = 0.0;
					double endframe = 0.0;
					list<KeyInfo>::iterator itrcp;
					for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
						if (firstflag) {
							startframe = itrcp->time;
							firstflag = false;
						}
						endframe = itrcp->time;
					}

					s_model->InitMpFrame(limitdegflag, curmi->motid, topbone, startframe, endframe);

				}
				else if (expandmotion > 0) {//モーション長を長くした際に、長くなった分の初期化をする
					double oldframeleng = expandmotion;

					//////if (topbone) {
					////	//topbone->ResizeIndexedMotionPointReq(curmi->motid, motleng);
					//////}

					//double frame;
					//for (frame = oldframeleng; frame < motleng; frame += 1.0) {
					//	if (topbone) {
					//		s_model->SetMotionFrame(frame);
					//		s_model->InitMPReq(limitdegflag, topbone, curmi->motid, frame);
					//	}
					//}

					s_model->InitMpFrame(limitdegflag, curmi->motid, topbone, oldframeleng, motleng - 1.0);


					int errorcount = 0;
					s_model->CreateIndexedMotionPointReq(s_model->GetTopBone(false),
						curmi->motid, motleng, &errorcount);
					if (errorcount != 0) {
						_ASSERT(0);
					}
				}
				else {
					//double frame;
					//for (frame = 0.0; frame < motleng; frame += 1.0) {
					//	if (topbone) {
					//		s_model->SetMotionFrame(frame);
					//		s_model->InitMPReq(limitdegflag, topbone, curmi->motid, frame);
					//	}
					//}

					s_model->InitMpFrame(limitdegflag, curmi->motid, topbone, 0.0, motleng - 1.0);

					int errorcount = 0;
					s_model->CreateIndexedMotionPointReq(s_model->GetTopBone(false),
						curmi->motid, motleng, &errorcount);
					if (errorcount != 0) {
						_ASSERT(0);
					}
				}


				////LimitEulを表示時には　worldへの変更をlimitedに反映させる
				//if (g_limitdegflag == true) {
				//	bool allframeflag = true;//全フレーム
				//	bool setcursorflag = false;
				//	bool onpasteflag = false;
				//	CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, s_editmotionflag, onpasteflag);
				//}

			}
		}
		else {
			_ASSERT(0);
		}
	}
	else {
		_ASSERT(0);
	}

	return 0;
};

int AddTimeLine(int newmotid, bool dorefreshtl)
{
	EnterCriticalSection(&s_CritSection_LTimeline);

	//EraseKeyList();
	//if (s_model && s_model->GetBoneListSize() > 0) {
	if (s_model && (s_model->GetBoneForMotionSize() > 0)) {

		if (!s_owpTimeline) {
			//OWP_Timeline* owpTimeline = 0;
			//タイムラインのGUIパーツを生成
			bool shortlabel = false;
			bool heightwheel = true;
			s_owpTimeline = new OWP_Timeline(heightwheel, shortlabel, L"testmotion", 100.0, 4.0);
			s_owpTimeline->setDispKeyFlag(false);//高速化のためkey表示無し

			// カーソル移動時のイベントリスナーに
			// カーソル移動フラグcursorFlagをオンにするラムダ関数を登録する
			s_owpTimeline->setCursorListener([]() {
				if (s_model) {
					s_cursorFlag = true;
				}
				});

			// キー選択時のイベントリスナーに
			// キー選択フラグselectFlagをオンにするラムダ関数を登録する
			//s_owpTimeline->setSelectListener([](){ s_selectFlag = true; });//LTimelineへ移動

			s_owpTimeline->setMouseRUpListener([]() {
				if (s_model) {
					s_timelineRUpFlag = true;
				}
				});

			//// キー移動時のイベントリスナーに
			//// キー移動フラグkeyShiftFlagをオンにして、キー移動量をコピーするラムダ関数を登録する
			//s_owpTimeline->setKeyShiftListener([]() {
			//	if (s_model) {
			//		s_keyShiftFlag = true;
			//		s_keyShiftTime = s_owpTimeline->getShiftKeyTime();
			//	}
			//});

			//// キー削除時のイベントリスナーに
			//// 削除されたキー情報をスタックするラムダ関数を登録する
			s_owpTimeline->setKeyDeleteListener([](const KeyInfo& keyInfo) {
				//s_deletedKeyInfoList.push_back(keyInfo);
				});


			//ウィンドウにタイムラインを関連付ける
			s_timelineWnd->addParts(*s_owpTimeline);


			//１クリック目問題対応
			s_timelineWnd->refreshPosAndSize();//2022/09/20


			//		s_owpTimeline->timeSize = 4.0;
			//		s_owpTimeline->callRewrite();						//再描画
			//		s_owpTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開
		}

		if (s_owpTimeline) {
			int nextindex;
			nextindex = (int)s_tlarray.size();

			TLELEM newtle;
			newtle.menuindex = nextindex;
			newtle.motionid = newmotid;
			s_tlarray.push_back(newtle);

			//2022/08/21
			int currentmodelindex = FindModelIndex(s_model);
			if (s_chascene && (currentmodelindex >= 0)) {
				s_chascene->SetTimelineArray(currentmodelindex, s_tlarray);
			}

			if (s_model) {
				s_model->SetCurrentMotion(newmotid);
			}
		}

		if (s_LtimelineWnd && s_owpPlayerButton) {
			if (!s_LTSeparator) {
				s_LTSeparator = new OWP_Separator(s_LtimelineWnd, false, 0.38, false);
				s_LtimelineWnd->addParts(*s_LTSeparator);

				if (s_owpLTimeline) {
					delete s_owpLTimeline;
					s_owpLTimeline = 0;
				}
				bool shortlabel = true;
				bool heightwheel = false;
				s_owpLTimeline = new OWP_Timeline(heightwheel, shortlabel, L"EditRangeTimeLine");
				if (s_owpLTimeline) {
					s_owpLTimeline->setDispKeyFlag(true);
					//s_LtimelineWnd->addParts(*s_owpLTimeline);//playerbuttonより後
					s_LTSeparator->addParts1(*s_owpLTimeline);
					s_owpLTimeline->setCursorListener([]() {
						if (s_model) {
							s_LcursorFlag = true;
						}
						});
					s_owpLTimeline->setSelectListener([]() {
						if (s_model && (s_selectFlag == false)) {
							s_selectFlag = true;
						}
						});
					s_owpLTimeline->setMouseMDownListener([]() {
						if (s_model) {
							s_timelinembuttonFlag = true;
							//if (s_mbuttoncnt == 0) {
							//	s_mbuttoncnt = 1;
							//}
							//else {
							//	s_mbuttoncnt = 0;
							//}
						}
						});
					s_owpLTimeline->setMouseWheelListener([]() {
						if (s_model) {
							if ((g_keybuf['S'] & 0x80) == 0) {//Scroll の S
								if (s_timelinewheelFlag == false) {
									s_timelinewheelFlag = true;
									s_timelineshowposFlag = false;
									s_LcursorFlag = true;
								}
							}
							else {
								if (s_timelineshowposFlag == false) {
									s_timelinewheelFlag = false;
									s_timelineshowposFlag = true;
								}
							}
						}
						});


					if (s_parentcheck) {
						delete s_parentcheck;
						s_parentcheck = 0;
					}
					s_parentcheck = new OWP_CheckBoxA(L"ParentEuler", 1);//parentcheck ON by default
					//s_LtimelineWnd->addParts(*s_parentcheck);
					//s_LTSeparator->addParts2(*s_parentcheck);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!parentwindow libfbxdll error 2021/03/04 comment out tmp
					//s_parentcheck->setButtonListener([]() { 
					//	if (s_model) {
					//		refreshEulerGraph();
					//	}
					//});


					if (s_owpEulerGraph) {
						delete s_owpEulerGraph;
						s_owpEulerGraph = 0;
					}
					s_owpEulerGraph = new OWP_EulerGraph(L"EulerGraph");
					if (s_owpEulerGraph) {
						//s_LtimelineWnd->addParts(*s_owpEulerGraph);
						s_LTSeparator->addParts2(*s_owpEulerGraph);
					}

					//OrgWinGUI::WindowSize graphsize = OrgWinGUI::WindowSize(s_LTSeparator->getSize().x - 8, 60);
					//s_owpEulerGraph->setSize(graphsize);
					//OrgWinGUI::WindowPos graphpos = OrgWinGUI::WindowPos(0, 16);
					//s_owpEulerGraph->setPos(graphpos);
					//s_owpEulerGraph->setCursorListener([]() { 
					//	if (s_model) {
					//		s_LcursorFlag = true;
					//	}
					//});

					//2022/09/20 １クリック目がおかしくなる不具合を解消
					s_LtimelineWnd->setPos(WindowPos(s_toolwidth, s_2ndposy));
					s_LtimelineWnd->setSizeMin(OrgWinGUI::WindowSize(100, 100));
					s_LtimelineWnd->setSize(WindowSize(s_longtimelinewidth, s_longtimelineheight));
					s_LtimelineWnd->refreshPosAndSize();//2022/09/20
				}
				
			}
		}

		//タイムラインのキーを設定
		if (s_owpTimeline) {
			if (dorefreshtl) {
				refreshTimeline(*s_owpTimeline);
			}
			s_owpLTimeline->selectClear();
		}

	}


	LeaveCriticalSection(&s_CritSection_LTimeline);

	return 0;
}


int UpdateEditedEuler()
{
	//オイラーグラフのキーを作成しなおす場合にはrefreshEulerGraph()


	//ツールボタンからも呼ぶ
	//if (s_pickinfo.buttonflag == 0) {
	//	return 0;
	//}


	if (s_owpEulerGraph) {
		s_owpEulerGraph->SetCurrentModel(s_model);
	}

	if (!s_model || !s_owpLTimeline || !s_owpEulerGraph) {
		return 0;
	}


	if (!s_model->GetCurMotInfo()) {
		return 0;
	}

	//if (s_model && (s_model->GetLoadedFlag() == false)) {
	//	return 0;
	//}


	//2023/10/13
	int eultiptime = (int)(s_owpEulerGraph->getCurrentTime() + 0.0001);


	//選択状態がない場合にはtopboneのオイラーグラフを表示する。
	if (s_curboneno < 0) {
		CBone* topbone = s_model->GetTopBone();
		if (topbone) {
			s_curboneno = topbone->GetBoneNo();
		}
	}


	CBone* opebone = s_model->GetBoneByID(s_curboneno);
	if (opebone) {
		CBone* parentbone = opebone->GetParent(false);
		if (s_ikkind == 0) {
			//ikkind がROT(0)の場合はIK　それ以外のMV, SCALEの場合にはFK
			if (parentbone && parentbone->IsSkeleton()) {
				opebone = parentbone;
			}
		}

		MOTINFO* curmi = s_model->GetCurMotInfo();
		if (curmi) {

			int curtime;
			float minval = 0.0f;
			float maxval = 0.0f;
			int minfirstflag, maxfirstflag;
			bool isset = false;

			//refreshEulerGraphは全範囲でminとmaxを設定。UpdateEditedEulerはstartframeからendframeまで。
			s_owpEulerGraph->getEulMinMax(&isset, &minval, &maxval);
			if (isset == true) {
				minfirstflag = 0;
				maxfirstflag = 0;
			}
			else {
				minfirstflag = 1;
				maxfirstflag = 1;
			}
			//minfirstflag = 1;
			//maxfirstflag = 1;


			//s_buttonselectstart = s_editrange.GetStartFrame();
			//s_buttonselectend = s_editrange.GetEndFrame();

			int startframe, endframe, frameleng;
			////if (g_previewFlag == 0) {
			////	startframe = s_buttonselectstart;
			////	endframe = s_buttonselectend;
			////}
			////else {
			//	if (s_model->GetCurMotInfo()) {
			//		double frameleng = s_model->GetCurMotInfo()->frameleng;
			//		double currenttime = s_owpEulerGraph->getCurrentTime();

			//		double startoffset;
			//		double endoffset;
			//		if (g_4kresolution) {
			//			startoffset = 150.0;
			//			endoffset = 260.0;
			//		}
			//		else {
			//			startoffset = 50.0;
			//			endoffset = 80.0;
			//		}

			//		startframe = max(0, (currenttime - startoffset));
			//		endframe = min(frameleng, (startframe + endoffset));
			//	}
			//	else {
			//		startframe = s_buttonselectstart;
			//		endframe = s_buttonselectend;
			//	}
			////}

			frameleng = IntTime(s_model->GetCurMotInfo()->frameleng);
			startframe = IntTime(s_owpLTimeline->getShowPosTime());
			endframe = (int)(min(frameleng, startframe + s_owpEulerGraph->getShowposWidth()));

			int firstframe;
			firstframe = max((startframe - 1), 0);

			ChaVector3 befeul = ChaVector3(0.0f, 0.0f, 0.0f);
			int ret;
			ret = s_owpEulerGraph->getEuler((double)firstframe, &befeul);
			if (ret) {
				befeul = ChaVector3(0.0f, 0.0f, 0.0f);
			}

			for (curtime = startframe; curtime <= endframe; curtime++) {
				const WCHAR* wbonename = opebone->GetWBoneName();
				ChaVector3 orgeul = ChaVector3(0.0f, 0.0f, 0.0f);
				ChaVector3 cureul = ChaVector3(0.0f, 0.0f, 0.0f);
				//cureul = opebone->CalcFBXEul(curmi->motid, (double)curtime, &befeul);
				//befeul = cureul;//!!!!!!!

				CMotionPoint* curmp = opebone->GetMotionPoint(curmi->motid, (double)curtime);
				if (curmp) {
					if (s_ikkind == 0) {//回転
						//opebone->GetWorldMat(curmi->motid, (double)curtime, 0, &cureul);
						cureul = opebone->GetLocalEul(g_limitdegflag, curmi->motid, (double)curtime, 0);
					}
					else if (s_ikkind == 1) {//移動
						cureul = opebone->CalcLocalTraAnim(g_limitdegflag, curmi->motid, (double)curtime);
					}
					else if (s_ikkind == 2) {//スケール
						cureul = opebone->CalcLocalScaleAnim(g_limitdegflag, curmi->motid, (double)curtime);
					}
				}
				else {
					cureul.x = 0.0;
					cureul.y = 0.0;
					cureul.z = 0.0;
					//befeul = cureul;//!!!!!!!
				}
				if ((curtime == 0.0) || (curtime == 1.0) || IsValidNewEul(cureul, befeul)) {
					befeul = cureul;
				}

				bool needCallRewrite = false;
				s_owpEulerGraph->setKey(needCallRewrite, _T("X"), (double)curtime, cureul.x);
				s_owpEulerGraph->setKey(needCallRewrite, _T("Y"), (double)curtime, cureul.y);
				s_owpEulerGraph->setKey(needCallRewrite, _T("Z"), (double)curtime, cureul.z);


				//2023/10/13
				if (curtime == eultiptime) {
					s_owpEulerGraph->setEulTip(cureul);
				}


				if (minfirstflag == 1) {
					minval = min(cureul.z, min(cureul.x, cureul.y));
					minfirstflag = 0;
				}
				if (minval > cureul.x) {
					minval = cureul.x;
				}
				if (minval > cureul.y) {
					minval = cureul.y;
				}
				if (minval > cureul.z) {
					minval = cureul.z;
				}

				if (maxfirstflag == 1) {
					maxval = max(cureul.z, max(cureul.x, cureul.y));
					maxfirstflag = 0;
				}
				if (maxval < cureul.x) {
					maxval = cureul.x;
				}
				if (maxval < cureul.y) {
					maxval = cureul.y;
				}
				if (maxval < cureul.z) {
					maxval = cureul.z;
				}

			}

			s_owpEulerGraph->setEulMinMax(s_ikkind, minval, maxval);

			if (g_motionbrush_value) {

				double scalemin, scalemax;
				if (minval != maxval) {
					scalemin = minval;
					scalemax = maxval;
				}
				else {
					//Eulerが全て０　例えば全フレームを選択してツールの姿勢初期化を実行した後など
					//仮のminとmaxを指定
					scalemin = minval;
					scalemax = maxval + 10.0;
				}

				unsigned int scaleindex;
				//for (scaleindex = 0; scaleindex < curmi->frameleng; scaleindex++) {
				for (scaleindex = (unsigned int)startframe; scaleindex <= (unsigned int)endframe; scaleindex++) {

					double curscalevalue;
					if ((scaleindex >= (unsigned int)g_motionbrush_startframe) && (scaleindex <= (unsigned int)g_motionbrush_endframe) && (scaleindex < (unsigned int)g_motionbrush_frameleng)) {
						curscalevalue = (double)(*(g_motionbrush_value + scaleindex));// *(scalemax - scalemin) + scalemin;
						curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
					}
					else {
						curscalevalue = 0.0;// *(scalemax - scalemin) + scalemin;
						curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
					}
					bool needCallRewrite = false;
					s_owpEulerGraph->setKey(needCallRewrite, _T("S"), (double)scaleindex, curscalevalue);//setkey
				}


			}

			//_ASSERT(0);
			s_owpEulerGraph->callRewrite();
			//s_owpEulerGraph->draw();

		}
	}

	return 0;
}

int refreshEulerGraph()
{
	//オイラーグラフのキーを作成しなおさない場合はUpdateEditedEuler()


	if (s_owpEulerGraph) {
		s_owpEulerGraph->SetCurrentModel(s_model);
	}

	if (!s_model || !s_owpLTimeline || !s_owpEulerGraph) {
		return 0;
	}

	//if (s_model && (s_model->GetLoadedFlag() == false)) {
	//	return;
	//}

	if (!s_model->GetCurMotInfo()) {
		return 0;
	}


	//2023/10/13
	int eultiptime = (int)(s_owpEulerGraph->getCurrentTime() + 0.0001);


	MOTINFO* curmotinfo = 0;
	if (s_model && ((curmotinfo = s_model->GetCurMotInfo()) != 0)) {

		int frameleng = (int)s_model->GetCurMotInfo()->frameleng;

		//if (!g_motionbrush_value || (g_motionbrush_frameleng != frameleng)) {
		int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
		if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
			_ASSERT(0);
			::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
			PostQuitMessage(result);
		}
		//}

		//int result = CreateMotionBrush(0, (double)(frameleng - 1), true);
		//_ASSERT(result == 0);

		s_owpEulerGraph->setDispScale(1.0);//倍率初期化
		s_owpEulerGraph->setDispOffset(0.0);//位置オフセット

		s_owpEulerGraph->deleteKey();
		s_owpEulerGraph->deleteLine();

		s_owpEulerGraph->newLine(0, 0, _T("X"));
		s_owpEulerGraph->newLine(0, 0, _T("Y"));
		s_owpEulerGraph->newLine(0, 0, _T("Z"));
		s_owpEulerGraph->newLine(0, 0, _T("S"));

		//s_owpLTimeline->setMaxTime( s_model->m_curmotinfo->frameleng - 1.0 );
		s_owpEulerGraph->setMaxTime(s_model->GetCurMotInfo()->frameleng);//左端の１マスを選んだ状態がフレーム０を選んだ状態だから　-1 しない。



		if (s_model && (s_curboneno >= 0)) {
			CBone* opebone = s_model->GetBoneByID(s_curboneno);
			if (opebone) {
				CBone* parentbone = opebone->GetParent(false);
				if (s_ikkind == 0) {
					//ikkind がROT(0)の場合はIK　それ以外のMV, SCALEの場合にはFK
					if (parentbone && parentbone->IsSkeleton()) {
						opebone = parentbone;
					}
				}

				MOTINFO* curmi = s_model->GetCurMotInfo();
				if (curmi) {
					int curtime;
					float minval = 0.0;
					float maxval = 0.0;
					int minfirstflag = 1;
					int maxfirstflag = 1;

					double firstframe = 0.0;
					ChaVector3 befeul = ChaVector3(0.0f, 0.0f, 0.0f);
					int ret;
					ret = s_owpEulerGraph->getEuler(firstframe, &befeul);
					if (ret) {
						befeul = ChaVector3(0.0f, 0.0f, 0.0f);
					}
					for (curtime = 0; curtime < frameleng; curtime++) {
						const WCHAR* wbonename = opebone->GetWBoneName();
						ChaVector3 orgeul = ChaVector3(0.0f, 0.0f, 0.0f);
						ChaVector3 cureul = ChaVector3(0.0f, 0.0f, 0.0f);
						//cureul = opebone->CalcFBXEul(curmi->motid, (double)curtime, &befeul);
						//befeul = cureul;//!!!!!!!

						CMotionPoint* curmp = opebone->GetMotionPoint(curmi->motid, (double)curtime);
						if (curmp) {
							if (s_ikkind == 0) {//回転
								//opebone->GetWorldMat(curmi->motid, (double)curtime, 0, &cureul);
								cureul = opebone->GetLocalEul(g_limitdegflag,
									curmi->motid, (double)curtime, 0);
							}
							else if (s_ikkind == 1) {//移動
								cureul = opebone->CalcLocalTraAnim(g_limitdegflag,
									curmi->motid, (double)curtime);
							}
							else if (s_ikkind == 2) {//スケール
								cureul = opebone->CalcLocalScaleAnim(g_limitdegflag,
									curmi->motid, (double)curtime);
							}
						}
						else {
							cureul.x = 0.0;
							cureul.y = 0.0;
							cureul.z = 0.0;
							//befeul = cureul;
						}
						if ((curtime == 0.0) || (curtime == 1.0) || IsValidNewEul(cureul, befeul)) {
							befeul = cureul;
						}

						bool needCallRewrite = false;
						s_owpEulerGraph->newKey(needCallRewrite, _T("X"), (double)curtime, cureul.x);
						s_owpEulerGraph->newKey(needCallRewrite, _T("Y"), (double)curtime, cureul.y);
						s_owpEulerGraph->newKey(needCallRewrite, _T("Z"), (double)curtime, cureul.z);
						//s_owpEulerGraph->newKey(_T("S"), (double)curtime, 0.0);


						//2023/10/13
						if (curtime == eultiptime) {
							s_owpEulerGraph->setEulTip(cureul);
						}


						if (minfirstflag == 1) {
							minval = min(cureul.z, min(cureul.x, cureul.y));
							minfirstflag = 0;
						}
						if (minval > cureul.x) {
							minval = cureul.x;
						}
						if (minval > cureul.y) {
							minval = cureul.y;
						}
						if (minval > cureul.z) {
							minval = cureul.z;
						}

						if (maxfirstflag == 1) {
							maxval = max(cureul.z, max(cureul.x, cureul.y));
							maxfirstflag = 0;
						}
						if (maxval < cureul.x) {
							maxval = cureul.x;
						}
						if (maxval < cureul.y) {
							maxval = cureul.y;
						}
						if (maxval < cureul.z) {
							maxval = cureul.z;
						}

					}

					s_owpEulerGraph->setEulMinMax(s_ikkind, minval, maxval);

					if (g_motionbrush_value) {

						double scalemin, scalemax;
						if (minval != maxval) {
							scalemin = minval;
							scalemax = maxval;
						}
						else {
							//Eulerが全て０　例えば全フレームを選択してツールの姿勢初期化を実行した後など
							//仮のminとmaxを指定
							scalemin = minval;
							scalemax = maxval + 10.0;
						}


						unsigned int scaleindex;
						for (scaleindex = 0; scaleindex < (unsigned int)frameleng; scaleindex++) {
							double curscalevalue;
							//if ((scaleindex >= (unsigned int)g_motionbrush_startframe) && (scaleindex <= (unsigned int)g_motionbrush_endframe) && (scaleindex < (unsigned int)g_motionbrush_frameleng)) {
							curscalevalue = (double)(*(g_motionbrush_value + scaleindex));// *(scalemax - scalemin) + scalemin;
							curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
							//}
							//else {
							//	curscalevalue = 0.0;// *(scalemax - scalemin) + scalemin;
							//	curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
							//}
							bool needCallRewrite = false;
							s_owpEulerGraph->newKey(needCallRewrite, _T("S"), (double)scaleindex, curscalevalue);//newkey
						}
					}
				}

				s_owpEulerGraph->callRewrite();
			}
		}

		//s_owpEulerGraph->setCurrentTime(0.0, false);

	}

	return 0;
}


//タイムラインにモーションデータのキーを設定する
void refreshTimeline(OWP_Timeline& timeline) 
{
	if (s_owpEulerGraph) {
		s_owpEulerGraph->SetCurrentModel(s_model);
	}

	if (!s_model || !s_owpLTimeline || !s_owpEulerGraph) {
		return;
	}

	//if (s_model && (s_model->GetLoadedFlag() == false)) {
	//	return;
	//}

	if (!s_model->GetCurMotInfo()) {
		return;
	}

	int saveshowposline = timeline.getShowPosLine();


	//時刻幅を設定
	if (s_model && (s_model->GetCurMotInfo())) {
		timeline.setMaxTime(s_model->GetCurMotInfo()->frameleng);

		s_owpLTimeline->deleteKey();
		s_owpLTimeline->deleteLine();

		s_owpLTimeline->newLine(0, 0, false, false, s_strcurrent);
		//s_owpLTimeline->newKey( s_strcurrent, 0.0, 0 );
		s_owpLTimeline->newLine(0, 0, false, false, s_streditrange);
		s_owpLTimeline->newLine(0, 0, false, false, s_strmark);
		//s_owpLTimeline->newKey( s_strmark, 0.0, 0 );

		//s_owpLTimeline->setMaxTime( s_model->m_curmotinfo->frameleng - 1.0 );
		s_owpLTimeline->setMaxTime(s_model->GetCurMotInfo()->frameleng);//左端の１マスを選んだ状態がフレーム０を選んだ状態だから　-1 しない。


		int itime;
		for (itime = 0; itime < (int)s_model->GetCurMotInfo()->frameleng; itime++) {
			s_owpLTimeline->newKey(s_streditrange, (double)itime, 0);
		}
	}

	//すべての行をクリア
	timeline.deleteKey();
	timeline.deleteLine();

	s_lineno2boneno.clear();
	s_boneno2lineno.clear();


	CBone* topbone = s_model->GetTopBone();

	if (s_model && s_model->GetTopBone()) {
		CallF(s_model->FillTimeLine(timeline, s_lineno2boneno, s_boneno2lineno), return);
	}
	else {
		WCHAR label[256];
		swprintf_s(label, 256, L"dummy%d", 0);
		timeline.newLine(0, 0, false, false, label);
	}

	//選択時刻を設定
	timeline.setCurrentLine(0);
	s_owpLTimeline->setCurrentTime(1.0, true);
	//timeline.setCurrentTime(0.0);


 //   CDXUTComboBox* pComboBox = g_SampleUI.GetComboBox( IDC_COMBO_BONE );
	//pComboBox->RemoveAllItems();
	//if( s_model ){
	//	map<int, CBone*>::iterator itrbone;
	//	for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	//		ULONG boneno = (ULONG)itrbone->first;
	//		CBone* opebone = itrbone->second;
	//		if( opebone && (boneno >= 0) ){
	//			char* nameptr = (char*)opebone->GetBoneName();
	//			WCHAR wname[256];
	//			MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, nameptr, 256, wname, 256 );
	//			pComboBox->AddItem( wname, ULongToPtr( boneno ) );
	//		}
	//	}
	//}

	timeline.setShowPosLine(saveshowposline);

	refreshEulerGraph();
	s_owpEulerGraph->setCurrentTime(1.0, false);
}



int AddBoneTra2(ChaVector3 diffvec)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		_ASSERT(0);
		return 0;
	}

	s_model->FKBoneTraUnderFK(g_limitdegflag, &s_editrange, s_curboneno, diffvec);

	s_editmotionflag = s_curboneno;

	return 0;
}

/*
int ImpulseBonePhysics(ChaVector3 diffvec)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()){
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone){
		_ASSERT(0);
		return 0;
	}

	s_model->ImpulseBoneRagdoll(0, &s_editrange, s_curboneno, diffvec);

	s_editmotionflag = s_curboneno;

	return 0;
}
*/

int AddBoneTra(int kind, float srctra)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		_ASSERT(0);
		return 0;
	}

	s_model->FKBoneTraAxisUnderFK(
		g_limitdegflag,
		&s_editrange, s_curboneno, kind, srctra, s_ikselectmat);
	s_editmotionflag = s_curboneno;

	return 0;
}

int AddBoneScale2(ChaVector3 diffvec)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		_ASSERT(0);
		return 0;
	}


	float scaleval;

	float upval = 1.1f;
	float downval = 0.9f;


	if (fabs(diffvec.x) >= fabs(diffvec.y)) {
		if (fabs(diffvec.x) >= fabs(diffvec.z)) {
			//x最大
			if (diffvec.x >= 0.0) {
				scaleval = upval;
			}
			else {
				scaleval = downval;
			}
		}
		else {
			//z最大
			if (diffvec.z >= 0.0) {
				scaleval = upval;
			}
			else {
				scaleval = downval;
			}
		}
	}
	else {
		if (fabs(diffvec.y) >= fabs(diffvec.z)) {
			//y最大
			if (diffvec.y >= 0.0) {
				scaleval = upval;
			}
			else {
				scaleval = downval;
			}
		}
		else {
			//z最大
			if (diffvec.z >= 0.0) {
				scaleval = upval;
			}
			else {
				scaleval = downval;
			}
		}
	}

	ChaVector3 scalevec;
	scalevec.x = scaleval;
	scalevec.y = scaleval;
	scalevec.z = scaleval;

	s_model->FKBoneScale(g_limitdegflag, 0, &s_editrange, s_curboneno, scalevec);

	s_editmotionflag = s_curboneno;

	return 0;
}

int AddBoneScale(int kind, float srcscale)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		_ASSERT(0);
		return 0;
	}

	float upval = 1.1f;
	float downval = 0.9f;


	float scaleval;
	if (srcscale >= 0.0) {
		scaleval = upval;
	}
	else {
		scaleval = downval;
	}

	s_model->FKBoneScaleAxis(g_limitdegflag,
		0, &s_editrange, s_curboneno, kind, scaleval);


	s_editmotionflag = s_curboneno;

	return 0;
}


int DispMotionWindow()
{
	if (!s_timelineWnd) {
		return 0;
	}

	if (s_dispmw) {
		s_timelineWnd->setVisible(false);
		s_LtimelineWnd->setVisible(false);
		s_dispmw = false;
	}
	else {
		s_timelineWnd->setVisible(true);
		s_LtimelineWnd->setVisible(true);
		s_dispmw = true;
	}

	return 0;
}
int DispToolWindow()
{
	if (!s_toolWnd) {
		return 0;
	}

	if (s_disptool) {
		s_toolWnd->setVisible(false);
		s_disptool = false;
	}
	else {
		s_toolWnd->setVisible(true);
		s_disptool = true;
	}

	return 0;
}
int DispObjPanel()
{
	//#########################
	// not toggle : 2021/10/19
	//#########################


	bool savedispobj = s_dispobj;
	CreateLayerWnd();
	if (!s_layerWnd) {
		return 0;
	}
	if (!(s_layerWnd->getHWnd())) {
		return 0;
	}

	refreshModelPanel();

	if (!savedispobj) {
		s_layerWnd->setListenMouse(false);
		s_layerWnd->setVisible(false);
		s_dispobj = false;
	}
	else {
		s_layerWnd->setListenMouse(true);
		s_layerWnd->setVisible(true);
		s_dispobj = true;

		//RECT dlgrect;
		//GetWindowRect(s_layerWnd->getHWnd(), &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
	}

	return 0;
}
int DispModelPanel()
{
	//#########################
	// not toggle : 2021/10/19
	//#########################


	bool savedispmodel = s_dispmodel;

	if (s_modelpanel.scroll) {
		s_savemodelpanelshowposline = s_modelpanel.scroll->getShowPosLine();
	}
	else {
		s_savemodelpanelshowposline = 0;
	}

	CreateModelPanel();
	if (!s_modelpanel.panel || !(s_modelpanel.panel->getHWnd())) {
		return 0;
	}

	if (!savedispmodel) {
		//s_modelpanel.panel->setListenMouse(false);
		s_modelpanel.panel->setVisible(false);
		s_dispmodel = false;
		s_modelpanel.panel->setListenMouse(false);
	}
	else {
		//s_modelpanel.panel->setListenMouse(true);
		s_modelpanel.panel->setVisible(true);
		s_dispmodel = true;
		s_modelpanel.panel->callRewrite();
		s_modelpanel.panel->setListenMouse(true);

		//RECT dlgrect;
		//GetWindowRect(s_modelpanel.panel->getHWnd(), &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
	}

	//DispMotionPanel();//!!!!!!!!!!!!!
	//DispObjPanel();//!!!!!!!!!!!!!!!!


	return 0;
}

int DispCameraPanel()
{
	bool savedispcamera = s_dispcamera;

	if (s_camerapanel.scroll) {
		s_savecamerapanelshowposline = s_camerapanel.scroll->getShowPosLine();
	}
	else {
		s_savecamerapanelshowposline = 0;
	}

	CreateCameraPanel();
	if (!s_camerapanel.panel || !(s_camerapanel.panel->getHWnd())) {
		return 0;
	}

	if (!savedispcamera) {
		//s_camerapanel.panel->setListenMouse(false);
		s_camerapanel.panel->setVisible(false);
		s_dispcamera = false;
		s_camerapanel.panel->setListenMouse(false);
	}
	else {
		//s_camerapanel.panel->setListenMouse(true);
		s_camerapanel.panel->setVisible(true);
		s_dispcamera = true;
		s_camerapanel.panel->callRewrite();
		s_camerapanel.panel->setListenMouse(true);

		//RECT dlgrect;
		//GetWindowRect(s_camerapanel.panel->getHWnd(), &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
	}


	return 0;
}

int DispMotionPanel()
{
	//#########################
	// not toggle : 2021/10/19
	//#########################


	bool savedispmotion = s_dispmotion;

	if (s_motionpanel.scroll) {
		s_savemotionpanelshowposline = s_motionpanel.scroll->getShowPosLine();
	}
	else {
		s_savemotionpanelshowposline = 0;
	}

	CreateMotionPanel();
	if (!s_motionpanel.panel || !(s_motionpanel.panel->getHWnd())) {
		return 0;
	}

	if (!savedispmotion) {
		//s_motionpanel.panel->setListenMouse(false);
		s_motionpanel.panel->setVisible(false);
		s_dispmotion = false;
		s_motionpanel.panel->setListenMouse(false);
	}
	else {
		//s_motionpanel.panel->setListenMouse(true);
		s_motionpanel.panel->setVisible(true);
		s_dispmotion = true;
		s_motionpanel.panel->callRewrite();
		s_motionpanel.panel->setListenMouse(true);

		//RECT dlgrect;
		//GetWindowRect(s_motionpanel.panel->getHWnd(), &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
	}

	return 0;
}


//int DispConvBoneWindow()
//{
//	if (!s_model){
//		return 0;
//	}
//
//	CreateConvBoneWnd();
//
//	if (!s_convboneWnd){
//		return 0;
//	}
//
//	if (s_dispconvbone){
//		s_convboneWnd->setVisible(false);
//		s_dispconvbone = false;
//	}
//	else{
//		s_convboneWnd->setVisible(true);
//		s_dispconvbone = true;
//	}
//	return 0;
//}


int EraseKeyList()
{
	s_copyKeyInfoList.clear();
	s_copymotvec.clear();
	s_selectKeyInfoList.clear();
	s_deletedKeyInfoList.clear();

	return 0;
}

int AddMotion(const WCHAR* wfilename, double srcmotleng)
{
	if (!s_model) {
		return 0;
	}
	if (s_model->GetNoBoneFlag() == true) {
		return 0;
	}


	int motnum = (int)s_tlarray.size();
	if (motnum >= MAXMOTIONNUM) {
		::DSMessageBox(s_3dwnd, L"Can't Load More.", L"error!!!", MB_OK);
		//DSMessageBox( s_3dwnd, L"これ以上モーションを読み込めません。", L"モーション数が多すぎます。", MB_OK );
		return 0;
	}

	char motionname[256];
	ZeroMemory(motionname, 256);
	SYSTEMTIME systime;
	GetLocalTime(&systime);
	sprintf_s(motionname, 256, "motion%u%u%u%u%u%u%u",
		systime.wYear,
		systime.wMonth,
		systime.wDay,
		systime.wHour,
		systime.wMinute,
		systime.wSecond,
		systime.wMilliseconds
	);

	int newmotid = -1;
	double motleng;
	if (srcmotleng == 0.0) {
		motleng = 100.0;
	}
	else {
		motleng = srcmotleng;
	}

	s_model->WaitUpdateMatrixFinished();//2022/08/18
	const WCHAR* addwfilename;
	if (wfilename) {
		addwfilename = wfilename;
	}
	else {
		addwfilename = L"ForEmpty";
	}
	//CallF( s_model->AddMotion( motionname, wfilename, motleng, &newmotid ), return 1 );
	CallF(s_model->AddMotion(motionname, addwfilename, motleng, &newmotid), return 1);
	//_ASSERT(0);



	CallF(AddTimeLine(newmotid, true), return 1);


	//2023/02/11
	//OnAnimMenuよりも前 : OnAnimMenu()-->CalcBoneEulよりも前
	//InitCurMotion(0, 0);//2023/10/23 大分前からInitMPReq()はCModel::AddMotionから呼ばれるようになったので不要　2023/10/27 ただしGetLoadedFlag() == trueの必要

	int selindex = (int)s_tlarray.size() - 1;
	CallF(OnAnimMenu(true, selindex), return 1);


	return 0;
}

int OnRgdMorphMenu(int selindex)
{
	s_model->SetRgdMorphIndex(selindex);

	if (selindex < 0) {
		return 0;//!!!!!!!!!
	}

	_ASSERT(s_morphmenu);

	int iAnimSet, cAnimSets;
	cAnimSets = GetMenuItemCount(s_morphmenu);
	for (iAnimSet = 0; iAnimSet < cAnimSets; iAnimSet++)
	{
		RemoveMenu(s_morphmenu, 0, MF_BYPOSITION);
	}

	if (!s_model || !s_owpTimeline) {
		return 0;//!!!!!!!!!!!!!!!!!!
	}


	cAnimSets = (int)s_tlarray.size();

	if (cAnimSets <= 0) {
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	char* szName;
	WCHAR wname[256];
	for (iAnimSet = 0; iAnimSet < cAnimSets; iAnimSet++)
	{
		int motid;
		motid = s_tlarray[iAnimSet].motionid;

		szName = s_model->GetMotInfo(motid)->motname;
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szName, 256, wname, 256);

		if (szName != NULL)
			AppendMenu(s_morphmenu, MF_STRING, 64000 + iAnimSet, wname);
		else
			AppendMenu(s_morphmenu, MF_STRING, 64000 + iAnimSet, L"<No Animation Name>");
	}

	if (cAnimSets > 0) {
		CheckMenuItem(s_mainmenu, 64000 + selindex, MF_CHECKED);
	}

	return 0;
}

int OnCameraMenu(bool dorefreshflag, int selindex, int saveundoflag)
{
	if (!s_cameramodel) {
		return 0;
	}


	s_underselectcamera = true;


	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	//大きいフレーム位置のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	//InitTimelineSelection();

	if (!s_model) {
		_ASSERT(0);
		SetMainWindowTitle();
		s_underselectcamera = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;
	}

	s_cameramenuindexmap[s_model] = selindex;

	if (selindex < 0) {
		SetMainWindowTitle();
		s_underselectcamera = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!
	}


	//if (!s_model || !s_owpTimeline) {//LoadFbxAnimの後に呼び出した場合　まだtimelineはNULL
	//	s_curmotid = -1;
	//	SetMainWindowTitle();
	//	s_underselectcamera = false;
	//	if (oldcursor) {
	//		SetCursor(oldcursor);
	//	}
	//	return 0;//!!!!!!!!!!!!!!!!!!
	//}


	MOTINFO* camerami = s_cameramodel->GetCameraMotInfoByCameraIndex(selindex);
	if (!camerami) {
		//s_curmotid = -1;
		SetMainWindowTitle();
		s_underselectcamera = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!!!!!!!!!!
	}


	int cameramotid = camerami->motid;
	s_cameramodel->SetCameraMotionId(cameramotid);


	if (s_cameramodel->IsCameraLoaded()) {
		//fbxにカメラが在る場合
		ChaVector3 camdir = ChaVector3(0.0f, 0.0f, 1.0f);
		s_cameramodel->GetCameraProjParams(cameramotid, &g_projnear, &g_projfar, &g_fovy, &g_camEye, &camdir, &g_cameraupdir);

		g_initcamdist = max(0.1f, min(1000.0f, g_projfar));
		g_camtargetpos = g_camEye + camdir * g_initcamdist;

		ChangeCameraMode(2);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2

		g_camdist = g_initcamdist;

		g_befcamEye = g_camEye;
		g_befcamtargetpos = g_camtargetpos;

		////#replacing comment out#g_Camera->SetProjParams(g_fovy, s_fAspectRatio, g_projnear, g_projfar);
		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		//////#replacing comment out#g_Camera->SetRadius(fObjectRadius * 3.0f, fObjectRadius * 0.5f, fObjectRadius * 6.0f);

		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		SetCamera3DFromEyePos();
	}


	//if (saveundoflag == 1) {
	//	//if( s_model ){
	//	//	s_model->SaveUndoMotion(s_curboneno, s_curbaseno, &s_editrange, (double)g_applyrate);
	//	//}
	//	if (s_model) {
	//		PrepairUndo();
	//	}
	//}
	//else {
	//	if (s_model && s_owpLTimeline && s_owpEulerGraph) {
	//		//double curframe = s_model->GetCurMotInfo()->curframe;
	//		double curframe = 1.0;
	//		s_owpLTimeline->setCurrentTime(curframe, true);
	//		s_owpEulerGraph->setCurrentTime(curframe, false);
	//	}
	//}

	//if (s_owpLTimeline) {
	//	s_owpLTimeline->selectClear();
	//}


	//DispModelPanel();
	//refreshModelPanel();
	//DispMotionPanel();
	DispCameraPanel();

	SetMainWindowTitle();


	//InitTimelineSelection();


	if (oldcursor) {
		SetCursor(oldcursor);
	}


	s_underselectcamera = false;

	return 0;
}



int OnAnimMenu(bool dorefreshflag, int selindex, int saveundoflag)
{

	s_underselectmotion = true;

	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	//大きいフレーム位置のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	InitTimelineSelection();

	if (!s_model) {
		_ASSERT(0);
		SetMainWindowTitle();
		s_underselectmotion = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;
	}

	s_motmenuindexmap[s_model] = selindex;

	if (selindex < 0) {
		SetMainWindowTitle();
		s_underselectmotion = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!
	}

	_ASSERT(s_animmenu);

	int iAnimSet, cAnimSets;
	cAnimSets = GetMenuItemCount(s_animmenu);
	for (iAnimSet = 0; iAnimSet < cAnimSets; iAnimSet++)
	{
		RemoveMenu(s_animmenu, 0, MF_BYPOSITION);
	}


	if (!s_model || !s_owpTimeline) {
		s_curmotid = -1;
		SetMainWindowTitle();
		s_underselectmotion = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!!!!!!!!!!
	}

	cAnimSets = (int)s_tlarray.size();

	if (cAnimSets <= 0) {
		if (s_owpTimeline && dorefreshflag) {
			refreshTimeline(*s_owpTimeline);
		}
		s_curmotid = -1;
		SetMainWindowTitle();
		s_underselectmotion = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	char* szName;
	WCHAR wname[256];
	for (iAnimSet = 0; iAnimSet < cAnimSets; iAnimSet++)
	{
		int motid;
		motid = s_tlarray[iAnimSet].motionid;
		szName = s_model->GetMotInfo(motid)->motname;
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szName, 256, wname, 256);

		if (szName != NULL)
			AppendMenu(s_animmenu, MF_STRING, 59900 + iAnimSet, wname);
		else
			AppendMenu(s_animmenu, MF_STRING, 59900 + iAnimSet, L"<No Animation Name>");
	}

	if (cAnimSets > 0) {
		CheckMenuItem(s_mainmenu, 59900 + selindex, MF_CHECKED);

		int selmotid;
		selmotid = s_tlarray[selindex].motionid;
		if (selmotid > 0) {
			int chkresult;
			chkresult = s_model->SetCurrentMotion(selmotid);
			if (chkresult != 0) {
				_ASSERT(0);
				if (oldcursor) {
					SetCursor(oldcursor);
				}
				return 1;
			}
			//EraseKeyList();
			if (s_owpTimeline) {
				s_owpTimeline->setCurrentLine(0);
				//s_owpTimeline->setCurrentTime( 0.0 );
				s_owpTimeline->setCurrentTime(1.0);
			}
			s_curmotid = selmotid;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			if (dorefreshflag) {
				s_model->CreateBtObject(g_limitdegflag, 1);
				//s_model->CalcBoneEul(-1);

				//2023/10/26　コメントアウト
				//s_model->CalcBoneEul(g_limitdegflag, selmotid);//2021/08/25
			}


			//2023/01/29 初回物理再生のために必要
			//s_savelimitdegflag = g_limitdegflag;
			//g_limitdegflag = true;
			//ClearLimitedWM(s_model);
			//ApplyNewLimitsToWM(s_model);
			//g_limitdegflag = s_savelimitdegflag;


			//2023/02/08
			if (g_limitdegflag == true) {
				ClearLimitedWM(s_model);
				CopyWorldToLimitedWorld(s_model);
				ApplyNewLimitsToWM(s_model);
			}


		}
	}

	if (s_owpTimeline && dorefreshflag) {
		//タイムラインのキーを設定
		refreshTimeline(*s_owpTimeline);
		//s_owpTimeline->setCurrentTime( 0.0 );
		s_owpTimeline->setCurrentTime(1.0);
	}

	OnSetMotSpeed();//2022/09/16

	//MOTINFO* curmi = s_model->GetCurMotInfo();
	//if (curmi) {
	//	OnAddMotion(curmi->motid);
	//}

	if (saveundoflag == 1) {
		//if( s_model ){
		//	s_model->SaveUndoMotion(s_curboneno, s_curbaseno, &s_editrange, (double)g_applyrate);
		//}
		if ((InterlockedAdd(&g_retargetbatchflag, 0) == 0) && s_model) {
			PrepairUndo();
		}
	}
	else {
		if (s_model && s_owpLTimeline && s_owpEulerGraph) {
			//double curframe = s_model->GetCurMotInfo()->curframe;
			double curframe = 1.0;
			s_owpLTimeline->setCurrentTime(curframe, true);
			s_owpEulerGraph->setCurrentTime(curframe, false);
		}
	}

	if (s_owpLTimeline) {
		s_owpLTimeline->selectClear();
	}

	DispModelPanel();
	//refreshModelPanel();
	DispMotionPanel();
	DispCameraPanel();

	SetMainWindowTitle();


	InitTimelineSelection();


	s_underselectmotion = false;


	if (s_model->GetInitAxisMatX() == 0) {//OnAnimMenuに移動
		if (s_owpLTimeline) {
			s_owpLTimeline->setCurrentTime(0.0, true);
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->setCurrentTime(0.0, false);
		}
		s_model->SetMotionFrame(0.0);
		ChaMatrix tmpwm = s_model->GetWorldMat();
		s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
		//ここでAxisMatXの初期化
		s_model->CreateBtObject(g_limitdegflag, 1);
		s_model->CalcBtAxismat(2);//2
		s_model->SetInitAxisMatX(1);
	}

	if (oldcursor) {
		SetCursor(oldcursor);
	}

	return 0;
}

int OnModelMenu(bool dorefreshtl, int selindex, int callbymenu)
{
	s_underselectmodel = true;

	s_customrigbone = 0;

	if (s_anglelimitdlg) {
		s_underanglelimithscroll = 0;
		DestroyWindow(s_anglelimitdlg);
		s_anglelimitdlg = 0;
	}
	if (s_rotaxisdlg) {
		DestroyWindow(s_rotaxisdlg);
		s_rotaxisdlg = 0;
	}
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}
	s_oprigflag = 0;

	if (callbymenu == 1) {
		if (s_model && (s_curmodelmenuindex >= 0) && s_chascene && (s_chascene->GetModelNum() != 0)) {
			s_chascene->SetTimelineArray(s_curmodelmenuindex, s_tlarray);
			s_chascene->SetLineno2Boneno(s_curmodelmenuindex, s_lineno2boneno, s_boneno2lineno);
		}
	}

	s_curmodelmenuindex = selindex;

	_ASSERT(s_modelmenu);
	int iMdlSet, cMdlSets;
	cMdlSets = GetMenuItemCount(s_modelmenu);
	for (iMdlSet = 0; iMdlSet < cMdlSets; iMdlSet++)
	{
		RemoveMenu(s_modelmenu, 0, MF_BYPOSITION);
	}

	if ((selindex < 0) || !s_model) {
		OrgWindowListenMouse(false);

		s_model = 0;
		s_curboneno = -1;

		if (s_owpTimeline && dorefreshtl) {
			refreshTimeline(*s_owpTimeline);
		}
		//refreshModelPanel();
		s_dispobj = false;
		DispObjPanel();
		refreshModelPanel();
		DispModelPanel();
		DispMotionPanel();
		DispCameraPanel();

		SetMainWindowTitle();
		ShowDispGroupWnd(s_spdispsw[SPDISPSW_DISPGROUP].state);
		ShowLaterTransparentWnd(s_spdispsw[SPDISPSW_LATERTRANSPARENT].state);
		ShowShaderTypeWnd(s_spdispsw[SPDISPSW_SHADERTYPE].state);
		ShowShadowParamsWnd(s_spdispsw[SPDISPSW_SHADOWPARAMS].state);


		s_underselectmodel = false;
		return 0;//!!!!!!!!!
	}

	if (s_chascene) {
		cMdlSets = s_chascene->GetModelNum();
	}
	else {
		cMdlSets = 0;
	}

	if (cMdlSets <= 0) {
		OrgWindowListenMouse(false);

		s_model = 0;
		if (s_owpTimeline && dorefreshtl) {
			refreshTimeline(*s_owpTimeline);
		}
		s_dispobj = false;
		DispObjPanel();
		refreshModelPanel();
		DispModelPanel();
		DispMotionPanel();
		DispCameraPanel();

		SetMainWindowTitle();
		ShowDispGroupWnd(s_spdispsw[SPDISPSW_DISPGROUP].state);
		ShowLaterTransparentWnd(s_spdispsw[SPDISPSW_LATERTRANSPARENT].state);
		ShowShaderTypeWnd(s_spdispsw[SPDISPSW_SHADERTYPE].state);
		ShowShadowParamsWnd(s_spdispsw[SPDISPSW_SHADOWPARAMS].state);


		s_underselectmodel = false;
		return 0;//!!!!!!!!!!!!!!!!!!!
	}
	else {
		const WCHAR* wname;
		for (iMdlSet = 0; iMdlSet < cMdlSets; iMdlSet++)
		{
			if (s_chascene) {
				wname = s_chascene->GetModelFileName(iMdlSet);
				if (*wname != 0)
					AppendMenu(s_modelmenu, MF_STRING, 61000 + iMdlSet, wname);
				else
					AppendMenu(s_modelmenu, MF_STRING, 61000 + iMdlSet, L"<No Model Name>");
			}
			else {
				AppendMenu(s_modelmenu, MF_STRING, 61000 + iMdlSet, L"<No Model Name>");
			}
		}

		CheckMenuItem(s_mainmenu, 61000 + selindex, MF_CHECKED);

		if (s_chascene) {
			s_model = s_chascene->GetModel(selindex);
		}
		else {
			_ASSERT(0);
			s_model = 0;
		}
		if (s_model && s_chascene) {
			s_chascene->GetTimelineArray(selindex, s_tlarray);
			s_motmenuindexmap[s_model] = s_chascene->GetMotMenuIndex(selindex);
			s_chascene->GetLineno2Boneno(selindex, s_lineno2boneno, s_boneno2lineno);

			//s_dispobj = false;
			DispObjPanel();
			refreshModelPanel();
			ShowDispGroupWnd(s_spdispsw[SPDISPSW_DISPGROUP].state);
			ShowLaterTransparentWnd(s_spdispsw[SPDISPSW_LATERTRANSPARENT].state);
			ShowShaderTypeWnd(s_spdispsw[SPDISPSW_SHADERTYPE].state);
			ShowShadowParamsWnd(s_spdispsw[SPDISPSW_SHADOWPARAMS].state);

			OnAnimMenu(dorefreshtl, s_motmenuindexmap[s_model]);
		}


		//大きいフレーム位置のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
		InitTimelineSelection();


		CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg();
		if (!curcpdlg) {
			curcpdlg = new CFrameCopyDlg();
			if (!curcpdlg) {
				_ASSERT(0);
				s_underselectmodel = false;
				return 1;//!!!!!!!!!
			}
			s_selbonedlgmap[s_model] = curcpdlg;
			curcpdlg->SetModel(s_model);
		}

		if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
			{
				if (s_copyhistorydlg.GetCreatedFlag() == false) {
					int result = CreateCopyHistoryDlg();
					if (result != 0) {
						_ASSERT(0);
						return 1;
					}
				}

				GetCPTFileName(s_cptfilename);
				s_copyhistorydlg.SetNames(s_model, s_cptfilename);
			}
		}

		{
			if (s_materialratedlgwnd) {
				if (s_model) {
					SetModel2MaterialRateDlg(s_model);
				}
			}
		}

		{
			if (s_modelworldmatdlgwnd) {
				if (s_model) {
					SetModel2ModelWorldMatDlg(s_model);
				}
			}
		}

		{
			if (s_shadertypeparamsdlgwnd) {
				if (s_model) {
					SetMaterial2ShaderTypeParamsDlg(nullptr);
				}
			}
		}

		if (s_model) {
			if (s_model->GetRigidElemInfoSize() > 0) {
				int result1 = OnREMenu(0, 0);
				if (result1) {
					s_underselectmodel = false;
					return 0;
				}
				int result2 = OnRgdMenu(0, 0);
				if (result2) {
					s_underselectmodel = false;
					return 0;
				}
				int result3 = OnImpMenu(0);
				if (result3) {
					s_underselectmodel = false;
					return 0;
				}
			}
			else {
				int result1 = OnREMenu(-1, 0);
				if (result1) {
					s_underselectmodel = false;
					return 0;
				}
				int result2 = OnRgdMenu(-1, 0);
				if (result2) {
					s_underselectmodel = false;
					return 0;
				}
				int result3 = OnImpMenu(-1);
				if (result3) {
					s_underselectmodel = false;
					return 0;
				}
			}
		}
		else {
			int result1 = OnREMenu(-1, 0);
			if (result1) {
				s_underselectmodel = false;
				return 0;
			}
			int result2 = OnRgdMenu(-1, 0);
			if (result2) {
				s_underselectmodel = false;
				return 0;
			}
			int result3 = OnImpMenu(-1);
			if (result3) {
				s_underselectmodel = false;
				return 0;
			}
		}


		//g_SampleUI.GetSlider(IDC_SPEED)->SetValue((int)(g_dspeed * 100.0f));
		//WCHAR sz[100];
		//swprintf_s(sz, 100, L"Speed: %0.4f", g_dspeed);
		//g_SampleUI.GetStatic(IDC_SPEED_STATIC)->SetText(sz);

		//if (!g_bvh2fbxbatchflag && !g_motioncachebatchflag && !g_retargetbatchflag) {
		//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 0) && (InterlockedAdd(&g_motioncachebatchflag, 0) == 0) && (InterlockedAdd(&g_retargetbatchflag, 0) == 0)) {
		if ((s_dispconvbone == true) &&
			(InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 0) && (InterlockedAdd(&g_retargetbatchflag, 0) == 0)) {
			CreateConvBoneWnd();//!!!!!!!!!!!!! モデル選択変更によりリターゲットウインドウ作り直し
		}

		SetTimelineHasRigFlag();

		SetMainWindowTitle();

		
	}

	s_underselectmodel = false;

	return 0;
}

int OnREMenu(int selindex, int callbymenu)
{
	if (!s_model) {
		_ASSERT(0);
		SetMainWindowTitle();
		return 0;
	}
	s_reindexmap[s_model] = selindex;

	_ASSERT(s_remenu);
	int iReSet, cReSets;
	cReSets = GetMenuItemCount(s_remenu);
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		RemoveMenu(s_remenu, 0, MF_BYPOSITION);
	}

	if ((selindex < 0) || !s_model) {
		AppendMenu(s_remenu, MF_STRING, 62000, L"NotLoaded");
		SetMainWindowTitle();
		return 0;//!!!!!!!!!
	}

	cReSets = s_model->GetRigidElemInfoSize();
	if (cReSets <= 0) {
		if (s_model) {
			s_reindexmap[s_model] = -1;
		}
		AppendMenu(s_remenu, MF_STRING, 62000, L"NotLoaded");
		SetMainWindowTitle();
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	WCHAR wname[MAX_PATH];
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		ZeroMemory(wname, sizeof(WCHAR) * MAX_PATH);
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s_model->GetRigidElemInfo(iReSet).filename, MAX_PATH, wname, MAX_PATH);
		AppendMenu(s_remenu, MF_STRING, 62000 + iReSet, wname);
		DbgOut(L"OnREMenu : addmenu %s\r\n", wname);
	}

	if (cReSets > 0) {
		CheckMenuItem(s_mainmenu, 62000 + selindex, MF_CHECKED);
	}

	CallF(s_model->SetCurrentRigidElem(s_reindexmap[s_model]), return 1);

	RigidElem2WndParam();

	SetMainWindowTitle();

	return 0;
}

int OnRgdMenu(int selindex, int callbymenu)
{
	if (s_model) {
		s_model->SetRgdIndex(selindex);
	}
	else {
		_ASSERT(0);
		return 0;
	}
	s_rgdindexmap[s_model] = selindex;

	_ASSERT(s_rgdmenu);
	int iReSet, cReSets;
	cReSets = GetMenuItemCount(s_rgdmenu);
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		RemoveMenu(s_rgdmenu, 0, MF_BYPOSITION);
	}

	if ((selindex < 0) || !s_model) {
		AppendMenu(s_rgdmenu, MF_STRING, 63000, L"NotLoaded");
		return 0;//!!!!!!!!!
	}

	cReSets = s_model->GetRigidElemInfoSize();
	if (cReSets <= 0) {
		s_rgdindexmap[s_model] = -1;
		AppendMenu(s_rgdmenu, MF_STRING, 63000, L"NotLoaded");
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	WCHAR wname[MAX_PATH];
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		ZeroMemory(wname, sizeof(WCHAR) * MAX_PATH);
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s_model->GetRigidElemInfo(iReSet).filename, MAX_PATH, wname, MAX_PATH);
		AppendMenu(s_rgdmenu, MF_STRING, 63000 + iReSet, wname);
	}

	if (cReSets > 0) {
		CheckMenuItem(s_mainmenu, 63000 + selindex, MF_CHECKED);
	}

	//	CallF( s_model->SetCurrentRigidElem( s_curreindex ), return 1 );

	return 0;
}
int OnImpMenu(int selindex)
{
	if (s_model) {
		s_model->SetCurImpIndex(selindex);
	}

	_ASSERT(s_impmenu);
	int iReSet, cReSets;
	cReSets = GetMenuItemCount(s_impmenu);
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		RemoveMenu(s_impmenu, 0, MF_BYPOSITION);
	}

	if ((selindex < 0) || !s_model) {
		AppendMenu(s_impmenu, MF_STRING, 64500, L"NotLoaded");
		return 0;//!!!!!!!!!
	}

	cReSets = s_model->GetImpInfoSize();
	if (cReSets <= 0) {
		s_model->SetCurImpIndex(0);
		AppendMenu(s_impmenu, MF_STRING, 64500, L"NotLoaded");
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	WCHAR wname[MAX_PATH];
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		ZeroMemory(wname, sizeof(WCHAR) * MAX_PATH);
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s_model->GetImpInfo(iReSet).c_str(), -1, wname, MAX_PATH);
		AppendMenu(s_impmenu, MF_STRING, 64500 + iReSet, wname);
	}

	if (cReSets > 0) {
		CheckMenuItem(s_mainmenu, 64500 + selindex, MF_CHECKED);
	}

	return 0;
}

int OnDelMotion(int delmenuindex, bool ondelbutton)//default : ondelbutton = false
{
	//if (s_underdelmotion == true) {
	//	//再入防止
	//	return 0;
	//}

	//s_underdelmotion = true;

	int tlnum = (int)s_tlarray.size();
	if ((tlnum <= 0) || (delmenuindex < 0) || (delmenuindex >= tlnum)) {
		//s_underdelmotion = false;
		return 0;
	}
	if ((ondelbutton == true) && (tlnum <= 1)) {
		//s_underdelmotion = false;
		return 0;
	}

	int delmotid = s_tlarray[delmenuindex].motionid;
	int result;
	s_model->WaitUpdateMatrixFinished();//2022/08/18
	result = s_model->DeleteMotion(delmotid);
	//if (result) {
	//	//s_underdelmotion = false;
	//	return 1;
	//}
	SetCameraModel();


	//vector<TLELEM> tmptlarray;
	//tmptlarray = s_tlarray;
	//s_tlarray.clear();
	//int tlno;
	//int settlcount = 0;
	//for (tlno = 0; tlno < tlnum; tlno++) {
	//	if (tlno != delmenuindex) {
	//		s_tlarray[settlcount] = tmptlarray[tlno];
	//		settlcount++;
	//	}
	//}
	int tlno;
	//for (tlno = delmenuindex; tlno < (tlnum - 1); tlno++) {
	//	s_tlarray[tlno] = s_tlarray[tlno + 1];
	//}
	std::vector<TLELEM>::iterator itrtl = s_tlarray.begin();
	for (tlno = 0; tlno < delmenuindex; tlno++) {
		itrtl++;
	}
	s_tlarray.erase(itrtl);
	//s_tlarray.pop_back();


	//2022/09/13
	int currentmodelindex = FindModelIndex(s_model);
	if (s_chascene && (currentmodelindex >= 0)) {
		s_chascene->SetTimelineArray(currentmodelindex, s_tlarray);
	}


	int newtlnum = (int)s_tlarray.size();
	if (newtlnum == 0) {
		AddMotion(L"forempty", 100.0);
	}
	OnAnimMenu(true, 0);

	DispMotionPanel();
	DispCameraPanel();

	//s_underdelmotion = false;

	return 0;
}

int OnDispModel(int modelcnt)
{
	int mdlnum;
	if (s_chascene) {
		mdlnum = s_chascene->GetModelNum();
	}
	else {
		mdlnum = 0;
	}
	if ((mdlnum <= 0) || (modelcnt < 0) || (modelcnt >= mdlnum)) {
		return 0;
	}

	CModel* dispmodel;
	if (s_chascene) {
		dispmodel = s_chascene->GetModel(modelcnt);
	}
	else {
		dispmodel = 0;
	}
	if (dispmodel && s_modelpanel.checkvec[modelcnt] && s_modelpanel.panel) {
		dispmodel->SetModelDisp(s_modelpanel.checkvec[modelcnt]->getValue());
		s_modelpanel.panel->callRewrite();
	}

	return 0;
}

int OnDelModel(int delmenuindex, bool ondelbutton)//default : ondelbutton == false
{
	//s_underdelmodel = true;
	if (!s_chascene) {
		_ASSERT(0);
		return 0;
	}

	StopBt();//2023/11/03

	int mdlnum;
	mdlnum = s_chascene->GetModelNum();
	if ((mdlnum <= 0) || (delmenuindex < 0) || (delmenuindex >= mdlnum)) {
		//s_underdelmodel = false;
		return 0;
	}

	if (mdlnum == 1) {
		OnDelAllModel();//psdk rootnode初期化
		//s_underdelmodel = false;
		return 0;
	}


	s_chascene->DelModel(delmenuindex);

	SetCameraModel();

	if (s_chascene->ModelEmpty()) {
		s_curboneno = -1;
		s_model = 0;
		s_curmodelmenuindex = -1;
		s_tlarray.clear();
		s_motmenuindexmap.clear();
		s_cameramenuindexmap.clear();
		s_lineno2boneno.clear();
		s_boneno2lineno.clear();
	}
	else {
		s_curboneno = -1;
		s_model = s_chascene->GetModel(0);
		if (s_model) {
			s_motmenuindexmap[s_model] = s_chascene->GetMotMenuIndex(0);
		}
		s_chascene->GetTimelineArray(0, s_tlarray);
		s_chascene->GetLineno2Boneno(0, s_lineno2boneno, s_boneno2lineno);
	}

	OnModelMenu(true, 0, 0);

	DispModelPanel();

	if (!s_model) {
		OrgWindowListenMouse(false);
	}

	//s_underdelmodel = false;

	return 0;
}

int OnDelAllModel()
{
	if (!s_chascene) {
		_ASSERT(0);
		return 0;
	}

	StopBt();//2023/11/03

	OrgWindowListenMouse(false);

	s_chascene->DelAllModel();

	//SetCameraModel();
	s_cameramodel = 0;//2023/06/02

	s_curboneno = -1;
	s_model = 0;
	s_curmodelmenuindex = -1;
	s_tlarray.clear();
	s_motmenuindexmap.clear();
	s_cameramenuindexmap.clear();
	s_lineno2boneno.clear();
	s_boneno2lineno.clear();

	OnModelMenu(true, -1, 0);

	DispModelPanel();

	return 0;
}






int refreshModelPanel()
{
	if (!s_layerWnd || !s_owpLayerTable) {
		return 0;
	}

	//すべての行をクリア
	s_owpLayerTable->deleteLine();

	WCHAR label[256];
	int objnum = 0;

	if (s_model) {
		objnum = s_model->GetMqoObjectSize();
	}
	else {
		objnum = 0;
	}

	if (objnum > 0) {
		map<int, CMQOObject*>::iterator itrobj;
		for (itrobj = s_model->GetMqoObjectBegin(); itrobj != s_model->GetMqoObjectEnd(); itrobj++) {
			CMQOObject* curobj = itrobj->second;
			WCHAR wname[256];
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (char*)curobj->GetName(), 256, wname, 256);
			s_owpLayerTable->newLine(wname, (void*)curobj);
			s_owpLayerTable->setVisible(wname, (curobj->GetDispFlag() > 0), true);
		}
	}
	else {
		wcscpy_s(label, 256, L"dummy name");
		s_owpLayerTable->newLine(label, 0);
	}

	//if (s_modelpanel.radiobutton && ((int)s_modelindex.size() > 0) && (s_curmodelmenuindex >= 0)) {
	//	//if( s_curmodelmenuindex >= 0 ){
	//	s_modelpanel.modelindex = s_curmodelmenuindex;
	//	s_modelpanel.radiobutton->setSelectIndex(s_modelpanel.modelindex);
	//	//}
	//}

	return 0;
}

//int refreshMotionPanel()
//{
//	if (s_motionpanel.radiobutton && ((int)s_modelindex.size() > 0) && (s_curmodelmenuindex >= 0)) {
//		if (s_model && (s_model->GetMotInfoSize() > 0) && s_motmenuindexmap[s_model] >= 0) {
//			s_motionpanel.radiobutton->setSelectIndex(s_motmenuindexmap[s_model]);
//		}
//	}
//
//	return 0;
//}


float CalcSelectScale(CBone* curboneptr)
{
	if (!s_model) {
		return 0.0f;
	}

	MODELBOUND mb;
	s_model->GetModelBound(&mb);
	double modelr = (double)mb.r;

	s_selectscale = max(0.01f, min(2.0f, (float)(modelr * 0.0020)));//2023/05/19
	if (s_oprigflag == 1) {
		s_selectscale *= 0.125f;
		//s_selectscale *= 0.50f;
	}

	s_selectscale *= ((float)s_selectuserscale * 0.01f);//2023/09/07


	//if (g_4kresolution) {
	//	s_selectscale *= 0.5f;
	//}


	//ChaMatrix selm;
	//selm = s_selm;
	//ChaMatrixNormalizeRot(&selm);
	//ChaVector3 orgcenterpos = curboneptr->GetJointFPos();
	//ChaVector3 orgedgepos = ChaVector3(orgcenterpos.x, orgcenterpos.y + 100.0f, orgcenterpos.z);
	//ChaVector3 dispcenterpos, dispedgepos;
	//ChaVector3TransformCoord(&dispcenterpos, &orgcenterpos, &selm);
	//ChaVector3TransformCoord(&dispedgepos, &orgedgepos, &selm);
	//double lineleng = (dispedgepos.x - dispcenterpos.x) * (dispedgepos.x - dispcenterpos.x) + (dispedgepos.y - dispcenterpos.y) * (dispedgepos.y - dispcenterpos.y);
	//if (lineleng > 0.00001) {
	//	lineleng = sqrt(lineleng);
	//	//s_selectscale = 0.0020f / lineleng;
	//	//s_selectscale = (modelr * 0.015f * 0.75f) / (lineleng * 100.0f);
	//	s_selectscale = (float)((modelr * 0.40) / lineleng);// *(g_camdist / g_initcamdist);
	//	if (s_oprigflag == 1) {
	//		s_selectscale *= 0.25f;
	//		//s_selectscale *= 0.50f;
	//	}
	//	if (g_4kresolution) {
	//		s_selectscale *= 0.5f;
	//	}
	//}
	//else {
	//	//s_selectscaleの計算はしない。s_selectscaleは前回の計算値を使用。
	//}

	return s_selectscale;
}


int RenderSelectMark(myRenderer::RenderingEngine* re, RenderContext* pRenderContext, int renderflag)
{
	if (!re || !pRenderContext) {
		_ASSERT(0);
		return 1;
	}

	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	MOTINFO* curmi = s_model->GetCurMotInfo();
	if (!curmi) {
		return 0;
	}

	CBone* curboneptr = s_model->GetBoneByID(s_curboneno);
	if (curboneptr) {
		if (s_onragdollik == 0) {
			int multworld = 1;
			//s_selm = curboneptr->CalcManipulatorMatrix(1, multworld, curmi->motid, curmi->curframe);
			int calccapsuleflag = 0;
			//s_selm_posture = s_selm;
			//s_selm_posture = curboneptr->CalcManipulatorPostureMatrix(calccapsuleflag, 0, multworld, 0);

			if (curboneptr && curboneptr->GetParent(false) && curboneptr->GetParent(false)->IsSkeleton()) {
				curboneptr->GetParent(false)->CalcAxisMatX_Manipulator(g_limitdegflag, g_boneaxis, 0, curboneptr, &s_selm, 0);
			}
			else {
				s_selm.SetIdentity();
			}
			s_selm_posture = s_selm;
		}


		CalcSelectScale(curboneptr);//s_selectscaleにセット

		ChaMatrix scalemat;
		ChaMatrixIdentity(&scalemat);
		ChaMatrixScaling(&scalemat, s_selectscale, s_selectscale, s_selectscale);

		ChaVector3 bonepos = curboneptr->GetWorldPos(g_limitdegflag, curmi->motid, curmi->curframe);

		//s_selectmat = scalemat * s_selm;
		//s_selectmat = s_selm;
		s_selectmat = s_selm * s_model->GetWorldMat();//2023/03/34
		ChaMatrixNormalizeRot(&s_selectmat);
		s_selectmat = scalemat * s_selectmat;

		s_selectmat.SetTranslation(bonepos);

		//s_selectmat_posture = scalemat * s_selm_posture;
		s_selectmat_posture = s_selm_posture;
		ChaMatrixNormalizeRot(&s_selectmat_posture);
		s_selectmat_posture = scalemat * s_selectmat_posture;

		s_selectmat_posture.SetTranslation(bonepos);

		if (renderflag) {
			//g_hmVP->SetMatrix(s_matVP.GetDataPtr());

			//g_hmWorld->SetMatrix(s_selectmat.GetDataPtr());
			RenderSelectFunc(re);


			//g_hmWorld->SetMatrix(s_selectmat_posture.GetDataPtr());
			if (s_oprigflag == 0) {
				RenderSelectPostureFunc(re);
			}
			else {
				if (curboneptr == s_customrigbone) {
				}
				else {
					RenderSelectPostureFunc(re);
				}
			}


			//s_pdev->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
			//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmp, 1);

		}
	}

	return 0;
}

int RenderSelectFunc(myRenderer::RenderingEngine* re)
{
	if (!s_select || !s_chascene) {
		return 0;
	}

	s_chascene->UpdateMatrixOneModel(s_select, g_limitdegflag, &s_selectmat, &s_matVP, 0.0);
	if (s_dispselect) {
		int lightflag = 1;
		//ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, 0.7f);
		//ChaVector4 diffusemult = ChaVector4(0.6f, 0.6f, 0.6f, 0.3f);
		ChaVector4 diffusemult = ChaVector4(0.6f, 0.6f, 0.6f, 1.0f);
		bool forcewithalpha = true;
		int btflag = 0;
		bool zcmpalways = true;
		s_chascene->RenderOneModel(s_select, forcewithalpha, re, lightflag, diffusemult, btflag, zcmpalways);
		//s_select->OnRender(withalpha, pRenderContext, lightflag, diffusemult);
	}
	//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmp, 1);

	return 0;

}

int RenderSelectPostureFunc(myRenderer::RenderingEngine* re)
{
	if (!s_select_posture || !s_chascene) {
		return 0;
	}

	s_chascene->UpdateMatrixOneModel(s_select_posture, g_limitdegflag, &s_selectmat_posture, &s_matVP, 0.0);
	if (s_dispselect) {
		int lightflag = 1;
		//ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, 1.0f);
		//ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, 0.7f);
		ChaVector4 diffusemult = ChaVector4(0.6f, 0.6f, 0.6f, 0.3f);
		bool forcewithalpha = true;
		int btflag = 0;
		bool zcmpalways = true;
		s_chascene->RenderOneModel(s_select_posture, forcewithalpha, re, lightflag, diffusemult, btflag, zcmpalways);
		//s_select_posture->OnRender(withalpha, pRenderContext, lightflag, diffusemult);
	}
	//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmp, 1);

	return 0;

}

CFrameCopyDlg* GetCurrentFrameCopyDlg()
{
	if (!s_model) {
		_ASSERT(0);
		return 0;
	}

	CFrameCopyDlg* curcpdlg = 0;
	map<CModel*, CFrameCopyDlg*>::iterator itrfinddlg;
	itrfinddlg = s_selbonedlgmap.find(s_model);
	if (itrfinddlg == s_selbonedlgmap.end()) {
		return 0;
	}
	else {
		return itrfinddlg->second;
	}
}


void ResetRigModelNum()
{
	s_rigsphere_num = 0;
	s_rigringX_num = 0;
	s_rigringY_num = 0;
	s_rigringZ_num = 0;
}
CModel* GetCurRigModel(CUSTOMRIG currig, int* pinstanceno, ChaVector4* prigmat)
{
	if (!pinstanceno || !prigmat) {
		_ASSERT(0);
		return nullptr;
	}

	*pinstanceno = -1;//error値で初期化
	*prigmat = ChaVector4(1.0f, 1.0f, 1.0f, 1.0f);//error値で初期化


	//int rigopemarkno = currig.shapemult;
	int rigshapekind = currig.shapekind;
	int rigaxis = currig.dispaxis;
	int rigcolor = currig.rigcolor;

	//if ((rigopemarkno >= 0) && (rigopemarkno <= RIGMULTINDEXMAX) &&
	if((rigshapekind >= RIGSHAPE_SPHERE) && (rigshapekind < RIGSHAPE_MAX) &&
		(rigaxis >= 0) && (rigaxis <= 2) && 
		(rigcolor >= 0) && (rigcolor < RIGCOLOR_MAX)) {

		float alpha;
		if (rigshapekind == RIGSHAPE_SPHERE) {
			alpha = 0.79f;//ZCmpAlways
		}
		else {
			alpha = 1.0f;//ZCmp
		}

		if (rigcolor == RIGCOLOR_RED) {
			s_matrigmat = ChaVector4(1.0f, 0.5f, 0.5f, alpha);
		}
		else if (rigcolor == RIGCOLOR_GREEN) {
			s_matrigmat = ChaVector4(0.0f, 1.0f, 0.0f, alpha);
		}
		else if (rigcolor == RIGCOLOR_BLUE) {
			s_matrigmat = ChaVector4(15.0f / 255.0f, 200.0f / 255.0f, 1.0f, alpha);
		}
		else {
			_ASSERT(0);
			s_matrigmat = ChaVector4(1.0f, 0.5f, 0.5f, alpha);
		}

		CModel* currigmodel;
		if (rigshapekind == RIGSHAPE_SPHERE) {
			if (s_rigsphere_num >= RIGMULTINDEXMAX) {
				_ASSERT(0);
				return nullptr;
			}

			currigmodel = s_rigopemark_sphere;
			*pinstanceno = s_rigsphere_num;
			*prigmat = s_matrigmat;

			////s_rigmaterial_sphere[s_rigsphere_num]->SetDif4F(s_matrigmat);
			//s_rigmaterial_sphere[s_rigsphere_num]->SetTempDiffuseMult(s_matrigmat);
			//s_rigmaterial_sphere[s_rigsphere_num]->SetTempDiffuseMultFlag(true);

			s_rigsphere_num++;
		}
		else if (rigshapekind == RIGSHAPE_RINGX) {
			if (s_rigringX_num >= RIGMULTINDEXMAX) {
				_ASSERT(0);
				return nullptr;
			}

			currigmodel = s_rigopemark_ringX;
			*pinstanceno = s_rigringX_num;
			*prigmat = s_matrigmat;

			////s_rigmaterial_ringX[s_rigringX_num]->SetDif4F(s_matrigmat);
			//s_rigmaterial_ringX[s_rigringX_num]->SetTempDiffuseMult(s_matrigmat);
			//s_rigmaterial_ringX[s_rigringX_num]->SetTempDiffuseMultFlag(true);

			s_rigringX_num++;
		}
		else if (rigshapekind == RIGSHAPE_RINGY) {
			if (s_rigringY_num >= RIGMULTINDEXMAX) {
				_ASSERT(0);
				return nullptr;
			}

			currigmodel = s_rigopemark_ringY;
			*pinstanceno = s_rigringY_num;
			*prigmat = s_matrigmat;

			////s_rigmaterial_ringY[s_rigringY_num]->SetDif4F(s_matrigmat);
			//s_rigmaterial_ringY[s_rigringY_num]->SetTempDiffuseMult(s_matrigmat);
			//s_rigmaterial_ringY[s_rigringY_num]->SetTempDiffuseMultFlag(true);

			s_rigringY_num++;
		}
		else if (rigshapekind == RIGSHAPE_RINGZ) {
			if (s_rigringZ_num >= RIGMULTINDEXMAX) {
				_ASSERT(0);
				return nullptr;
			}

			currigmodel = s_rigopemark_ringZ;
			*pinstanceno = s_rigringZ_num;
			*prigmat = s_matrigmat;

			////s_rigmaterial_ringZ[s_rigringZ_num]->SetDif4F(s_matrigmat);
			//s_rigmaterial_ringZ[s_rigringZ_num]->SetTempDiffuseMult(s_matrigmat);
			//s_rigmaterial_ringZ[s_rigringZ_num]->SetTempDiffuseMultFlag(true);

			s_rigringZ_num++;
		}
		else {
			_ASSERT(0);
			return 0;
		}

		return currigmodel;
	}
	else {
		return 0;
	}

}

int RenderRigMarkFunc(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!pRenderContext) {
		_ASSERT(0);
		return 1;
	}


	if (!s_model) {
		return 0;
	}

	//g_hmVP->SetMatrix(s_matVP.GetDataPtr());

	ResetRigModelNum();
	s_rigopemark_sphere->ResetInstancingParams();
	s_rigopemark_ringX->ResetInstancingParams();
	s_rigopemark_ringY->ResetInstancingParams();
	s_rigopemark_ringZ->ResetInstancingParams();

	int rendercount = 0;
	MOTINFO* curmi = s_model->GetCurMotInfo();
	if (curmi) {
		int curmotid = curmi->motid;
		double curframe = curmi->curframe;

		std::map<int, CBone*>::iterator itrbone;
		for (itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++) {
			CBone* curbone = (CBone*)itrbone->second;
			if (curbone && (curbone->IsSkeleton())) {
				int rigno;
				for (rigno = 0; rigno < MAXRIGNUM; rigno++) {
					CUSTOMRIG currig = curbone->GetCustomRig(rigno);
					if (currig.useflag == 2) {//0: free, 1: allocated, 2: valid
					//if (currig.rigboneno > 0) {
						CModel* currigmodel;
						int instancingno;
						ChaVector4 rigmaterial;
						currigmodel = GetCurRigModel(currig, &instancingno, &rigmaterial);
						if (currigmodel && (instancingno >= 0) && (instancingno < RIGMULTINDEXMAX)) {
							ChaMatrix rigmat;
							ChaMatrixIdentity(&rigmat);
							rigmat = CalcRigMat(&currig, curbone, curmotid, curframe, currig.dispaxis, currig.disporder, currig.posinverse);

							//currigmodel->UpdateMatrix(g_limitdegflag, &rigmat, &s_matVP);
							currigmodel->SetInstancingParams(instancingno, rigmat, s_matVP, rigmaterial);

							rendercount++;
						}
					}
				}
			}
		}

		//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmp, 1);
	}

	{
		int lightflag = 0;
		ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, g_rigmark_alpha);//2024/01/12 alpha
		bool forcewithalpha = true;
		int btflag = 0;
		bool zcmpalways = false;

		if (s_rigsphere_num > 0) {
			s_chascene->RenderInstancingModel(s_rigopemark_sphere, forcewithalpha, re, lightflag, diffusemult, btflag, zcmpalways);
		}
		if (s_rigringX_num > 0) {
			s_chascene->RenderInstancingModel(s_rigopemark_ringX, forcewithalpha, re, lightflag, diffusemult, btflag, zcmpalways);
		}
		if (s_rigringY_num > 0) {
			s_chascene->RenderInstancingModel(s_rigopemark_ringY, forcewithalpha, re, lightflag, diffusemult, btflag, zcmpalways);
		}
		if (s_rigringZ_num > 0) {
			s_chascene->RenderInstancingModel(s_rigopemark_ringZ, forcewithalpha, re, lightflag, diffusemult, btflag, zcmpalways);
		}
	}


	return 0;
}
int CalcTargetPos(ChaVector3* dstpos)
{
	ChaVector3 start3d, end3d;
	CalcPickRay(&start3d, &end3d);

	//カメラの面とレイとの交点(targetpos)を求める。
	ChaVector3 sb, se, n;
	sb = s_pickinfo.objworld - start3d;
	se = end3d - start3d;
	n = g_camtargetpos - g_camEye;

	float t;
	t = ChaVector3Dot(&sb, &n) / ChaVector3Dot(&se, &n);

	ChaVector3 targetwm = start3d * (1.0f - t) + end3d * t;
	ChaVector3 targetlocal; 
	ChaMatrix invmodelwm;
	if (s_model) {
		//########################################################
		//2023/03/24
		//model座標系で計算：modelのWorldMatの影響を無くして計算
		//########################################################

		invmodelwm = ChaMatrixInv(s_model->GetWorldMat());
		ChaVector3TransformCoord(&targetlocal, &targetwm, &invmodelwm);
	}
	else {
		targetlocal = targetwm;
	}

	*dstpos = targetlocal;

	return 0;
}

int CalcPickRay(ChaVector3* startptr, ChaVector3* endptr)
{
	s_pickinfo.diffmouse.x = (float)(s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x);
	s_pickinfo.diffmouse.y = (float)(s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y);

	ChaVector3 mousesc;
	//以下2行。相対位置で動かすことができるが、マウスが可動でボーンが可動でないような位置への操作があると、その後の操作と結果の関係が不自然にみえる。
	mousesc.x = s_pickinfo.objscreen.x + s_pickinfo.diffmouse.x;
	mousesc.y = s_pickinfo.objscreen.y + s_pickinfo.diffmouse.y;

	//以下２行。常にマウス位置を目標にする。
	//mousesc.x = s_pickinfo.mousepos.x;
	//mousesc.y = s_pickinfo.mousepos.y;
	mousesc.z = s_pickinfo.objscreen.z;

	ChaVector3 startsc, endsc;
	float rayx, rayy;
	rayx = mousesc.x / (s_pickinfo.winx / 2.0f) - 1.0f;
	rayy = 1.0f - mousesc.y / (s_pickinfo.winy / 2.0f);

	startsc = ChaVector3(rayx, rayy, 0.0f);
	endsc = ChaVector3(rayx, rayy, 1.0f);

	ChaMatrix mView;
	ChaMatrix mProj;
	
	mProj = ChaMatrix(g_camera3D->GetProjectionMatrix());
	mView = ChaMatrix(g_camera3D->GetViewMatrix(false));
	ChaMatrix mVP, invmVP;
	mVP = mView * mProj;
	ChaMatrixInverse(&invmVP, NULL, &mVP);//2023/03/24 model座標系　model->GetWorldMat()の効果は打ち消しておく

	ChaVector3TransformCoord(startptr, &startsc, &invmVP);
	ChaVector3TransformCoord(endptr, &endsc, &invmVP);

	return 0;
}

////s_openfilehwnd
////UINT CALLBACK OFNHookProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
////UINT CALLBACK GetFileNameHook(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
////UINT_PTR CALLBACK GetFileNameHook(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
////{
////
////	static int s_getfilenametimer = 338;
////
////	WORD loword;
////	WORD hiword;
////
////	switch (msg) {
////	case WM_INITDIALOG:
////		SetTimer(hDlgWnd, s_getfilenametimer, 20, NULL);
////		s_openfilehwnd = hDlgWnd;
////		return FALSE;
////	case WM_COMMAND:
////		switch (LOWORD(wp)) {
////		case IDOK:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDOK);
////			return TRUE;
////			break;
////		case IDCANCEL:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDCANCEL);
////			return TRUE;
////			break;
////		default:
////			return FALSE;
////		}
////	case WM_LBUTTONDOWN:
////		loword = LOWORD(wp);
////		hiword = HIWORD(wp);
////		break;
////	case WM_LBUTTONUP:
////		loword = LOWORD(wp);
////		hiword = HIWORD(wp);
////
////		switch (LOWORD(wp)) {
////		case IDOK:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDOK);
////			return TRUE;
////			break;
////		case IDCANCEL:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDCANCEL);
////			return TRUE;
////			break;
////		default:
////			return FALSE;
////		}
////		break;
////	case WM_NOTIFY:
/////*
////WM_NOTIFYメッセージは、標準のコントロールやユーザーの操作によるさまざまな通知メッセージが送られたときに送られてきます。
////lParamにはOFNOTIFY構造体のアドレスが入っていてこれを調べると通知メッセージの種類がわかります。
////この構造体の説明はここでは省略します。通知メッセージとしては、
////CDN_INITDONE          ダイアログ配置が終わったことを知らせます。
////CDN_FILEOK            ＯＫボタンが押されたことを知らせます。
////CDN_FOLDERCHANGE      開いているフォルダが変わったことを知らせます。
////CDN_HELP              ＨＥＬＰボタンが押されたことを知らせます。
////CDN_SELCHANGE         別のファイルが選ばれたことを知らせます。
////CDN_SHAREVIOLATION    共有違反が発生したことを知らせます。
////CDN_TYPECHANGE        ファイルの種類が変更されたことを知らせます。
////また、ダイアログの状態を知るためには次のようなメッセージを送ります。
////それぞれのメッセージについては各自で調べてください（今回こればっか、手抜きだというのがばれてしまう）。
////CDM_GETFILEPATH       選択されているファイルのパス（フォルダ名＋ファイル名）を取得します。
////CDM_GETSPEC           選択されているファイルのファイル名だけを取得します。
////CDM_GETFOLDERPATH     現在のフォルダのパスを取得します。
////CDM_GETFOLDERIDLIST   現在のフォルダのItem-ID-Listを取得します。
////CDM_HIDECONTROL       指定したコントロールを隠します。
////CDM_SETCONTROLTEXT    指定したコントロールにテキストを設定します。
////CDM_SETDEFEXT         表示するファイルの拡張子を設定します。*/
////		loword = LOWORD(wp);
////		hiword = HIWORD(wp);
////
////		switch (LOWORD(wp)) {
////		case IDOK:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDOK);
////			return TRUE;
////			break;
////		case IDCANCEL:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDCANCEL);
////			return TRUE;
////			break;
////		default:
////			return FALSE;
////		}
////		break;
////	case WM_TIMER:
////		OnDSUpdate();
////		return FALSE;
////		break;
////	default:
////		DefWindowProc(hDlgWnd, msg, wp, lp);
////		return FALSE;
////	}
////	return TRUE;
////
////
////}


void SetDlgHistory(HWND hDlgWnd, std::vector<wstring> vecopenfilename, int pagenum, int currentpage)
{

	int radionum = 0;
	int startno = 0;


	//ページングはここで行う
	int numhistory2 = (int)vecopenfilename.size();
	int fullpagenum = numhistory2 / OPENHISTORYMAXNUM;//満たされているページの数
	int pagenum2 = fullpagenum;//端数込みのページ数
	if ((numhistory2 - fullpagenum * OPENHISTORYMAXNUM) > 0) {
		pagenum2++;
	}


	if (pagenum2 != pagenum) {
		_ASSERT(0);
		return;//!!!!!!!!!!!!!!!!!
	}


	if (pagenum > 0) {
		int setpage;
		if (currentpage < 0) {
			setpage = 0;
		}
		else if ((currentpage + 1) <= pagenum) {
			setpage = currentpage;
		}
		else {
			setpage = currentpage % pagenum;
		}

		int restnum;

		startno = setpage * OPENHISTORYMAXNUM;//!!!!!!!!!!!!!!!!!!!
		restnum = numhistory2 - startno;
		//dispnum2 = min(restnum, OPENHISTORYMAXNUM);
		//endno = startno + dispnum2 - 1;
		radionum = min(restnum, OPENHISTORYMAXNUM);//!!!!!!!!!!!!!!!!!!!

	}
	else {
		startno = 0;
		radionum = 0;
	}


	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI51), L"");
	if (radionum != 0) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI51), vecopenfilename[startno + 0].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI51), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI52), L"");
	if (radionum >= 2) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI52), vecopenfilename[startno + 1].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI52), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI53), L"");
	if (radionum >= 3) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI53), vecopenfilename[startno + 2].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI53), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI54), L"");
	if (radionum >= 4) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI54), vecopenfilename[startno + 3].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI54), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI55), L"");
	if (radionum >= 5) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI55), vecopenfilename[startno + 4].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI55), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI56), L"");
	if (radionum >= 6) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI56), vecopenfilename[startno + 5].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI56), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI57), L"");
	if (radionum >= 7) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI57), vecopenfilename[startno + 6].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI57), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI58), L"");
	if (radionum >= 8) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI58), vecopenfilename[startno + 7].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI58), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI59), L"");
	if (radionum >= 9) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI59), vecopenfilename[startno + 8].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI59), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI60), L"");
	if (radionum >= 10) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI60), vecopenfilename[startno + 9].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI60), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI61), L"");
	if (radionum >= 11) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI61), vecopenfilename[startno + 10].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI61), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI62), L"");
	if (radionum >= 12) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI62), vecopenfilename[startno + 11].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI62), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI63), L"");
	if (radionum >= 13) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI63), vecopenfilename[startno + 12].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI63), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI64), L"");
	if (radionum >= 14) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI64), vecopenfilename[startno + 13].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI64), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI65), L"");
	if (radionum >= 15) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI65), vecopenfilename[startno + 14].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI65), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI66), L"");
	if (radionum >= 16) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI66), vecopenfilename[startno + 15].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI66), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI67), L"");
	if (radionum >= 17) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI67), vecopenfilename[startno + 16].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI67), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI68), L"");
	if (radionum >= 18) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI68), vecopenfilename[startno + 17].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI68), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI69), L"");
	if (radionum >= 19) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI69), vecopenfilename[startno + 18].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI69), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI70), L"");
	if (radionum >= 20) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI70), vecopenfilename[startno + 19].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI70), L"Loading History not Exist.");
	}


	if (pagenum > 0) {
		int disppage;
		disppage = currentpage % pagenum + 1;
		WCHAR strpages[256] = { 0L };
		swprintf_s(strpages, 256, L"%03d / %03d Pages", disppage, pagenum);
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_PAGES), strpages);
	}
	else {
		WCHAR strpages[256] = { 0L };
		swprintf_s(strpages, 256, L"0 / 0 NoPages");
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_PAGES), strpages);
	}

}




LRESULT CALLBACK OpenMqoDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hDlgWnd;//2024/01/03
	//ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"project(*.cha)chara(*.fbx)\0*.cha;*.fbx\0Rigid(*.ref)\0*.ref\0Impulse(*.imp)\0*.imp\0Ground(*.gco)\0*.gco\0BVH(*.bvh)\0*.bvh\0MNL(*.mnl)\0*.mnl\0Retarget(*.rtg)\0*.rtg\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = s_filterindex;
	//ofn.lpstrFile = g_tmpmqopath;
	ofn.lpstrFile = NULL;
	ofn.nMaxFile = MULTIPATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	//ofn.lpstrTitle = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT | OFN_ENABLEHOOK;
	//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT | OFN_EXPLORER;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = NULL;
	ofn.lCustData = NULL;
	//ofn.lpfnHook = GetFileNameHook;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	WCHAR strmult[256];
	wcscpy_s(strmult, 256, L"1.000");
	WCHAR wfilename[MAX_PATH] = { 0L };

	static int s_openmqoproctimer = 336;
	static bool s_refokflag = false;
	static int s_filter_cha = 1;
	static WCHAR s_beffolder[MAX_PATH] = { 0L };
	static bool s_underrefflag = false;//参照中に参照ボタンを押さないように

	static int pagenum = 1;//2023/07/22
	static int currentpage = 0;//2023/07/22
	static int testcurrentpage = 0;//2023/07/22
	



	switch (msg) {
	case WM_INITDIALOG:
	{
		pagenum = 1;
		currentpage = 0;
		testcurrentpage = 0;


		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		s_refokflag = false;
		g_tmpmqomult = 1.0f;
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);
		ZeroMemory(wfilename, sizeof(WCHAR) * MAX_PATH);
		SetDlgItemText(hDlgWnd, IDC_MULT, strmult);
		SetDlgItemText(hDlgWnd, IDC_FILEPATH, L"PushRefButtonToSelectFile.");

		if (s_filterindex != 7) {
			if (s_filter_cha == 1) {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, TRUE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, FALSE, 0);
			}
			else {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, TRUE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, FALSE, 0);
			}
		}
		else {
			SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, FALSE, 0);
			SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, FALSE, 0);
			SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, TRUE, 0);
		}


		if (s_filterindex == 5) {
			//bvh2FBXの単体ファイル履歴

			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), FALSE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), FALSE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), FALSE);

			std::vector<wstring> vecopenfilename;
			pagenum = GetbvhHistoryDir(vecopenfilename);

			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
		}
		else if (s_filterindex == 7) {
			//retarget fileの単体ファイル履歴

			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), FALSE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), FALSE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), TRUE);

			std::vector<wstring> vecopenfilename;
			pagenum = GetRtgHistoryDir(vecopenfilename);

			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
		}
		else {
			//cha, fbxファイル履歴

			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), TRUE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), TRUE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), FALSE);

			std::vector<wstring> vecopenfilename;
			pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);

			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
		}

		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		SetTimer(hDlgWnd, s_openmqoproctimer, 20, NULL);
		s_mqodlghwnd = hDlgWnd;
	}
	return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			GetDlgItemText(hDlgWnd, IDC_MULT, strmult, 256);
			g_tmpmqomult = (float)_wtof(strmult);
			if (s_refokflag == false) {
				UINT ischecked1 = 0;
				UINT ischecked2 = 0;
				UINT ischecked3 = 0;
				UINT ischecked4 = 0;
				UINT ischecked5 = 0;
				UINT ischecked6 = 0;
				UINT ischecked7 = 0;
				UINT ischecked8 = 0;
				UINT ischecked9 = 0;
				UINT ischecked10 = 0;
				UINT ischecked11 = 0;
				UINT ischecked12 = 0;
				UINT ischecked13 = 0;
				UINT ischecked14 = 0;
				UINT ischecked15 = 0;
				UINT ischecked16 = 0;
				UINT ischecked17 = 0;
				UINT ischecked18 = 0;
				UINT ischecked19 = 0;
				UINT ischecked20 = 0;
				ischecked1 = IsDlgButtonChecked(hDlgWnd, IDC_RADI51);
				ischecked2 = IsDlgButtonChecked(hDlgWnd, IDC_RADI52);
				ischecked3 = IsDlgButtonChecked(hDlgWnd, IDC_RADI53);
				ischecked4 = IsDlgButtonChecked(hDlgWnd, IDC_RADI54);
				ischecked5 = IsDlgButtonChecked(hDlgWnd, IDC_RADI55);
				ischecked6 = IsDlgButtonChecked(hDlgWnd, IDC_RADI56);
				ischecked7 = IsDlgButtonChecked(hDlgWnd, IDC_RADI57);
				ischecked8 = IsDlgButtonChecked(hDlgWnd, IDC_RADI58);
				ischecked9 = IsDlgButtonChecked(hDlgWnd, IDC_RADI59);
				ischecked10 = IsDlgButtonChecked(hDlgWnd, IDC_RADI60);
				ischecked11 = IsDlgButtonChecked(hDlgWnd, IDC_RADI61);
				ischecked12 = IsDlgButtonChecked(hDlgWnd, IDC_RADI62);
				ischecked13 = IsDlgButtonChecked(hDlgWnd, IDC_RADI63);
				ischecked14 = IsDlgButtonChecked(hDlgWnd, IDC_RADI64);
				ischecked15 = IsDlgButtonChecked(hDlgWnd, IDC_RADI65);
				ischecked16 = IsDlgButtonChecked(hDlgWnd, IDC_RADI66);
				ischecked17 = IsDlgButtonChecked(hDlgWnd, IDC_RADI67);
				ischecked18 = IsDlgButtonChecked(hDlgWnd, IDC_RADI68);
				ischecked19 = IsDlgButtonChecked(hDlgWnd, IDC_RADI69);
				ischecked20 = IsDlgButtonChecked(hDlgWnd, IDC_RADI70);
				if (ischecked1 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI51, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked2 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI52, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked3 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI53, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked4 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI54, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked5 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI55, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked6 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI56, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked7 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI57, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked8 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI58, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked9 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI59, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked10 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI60, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked11 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI61, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked12 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI62, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked13 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI63, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked14 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI64, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked15 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI65, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked16 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI66, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked17 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI67, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked18 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI68, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked19 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI69, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked20 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI70, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else {
					g_tmpmqopath[0] = 0L;
				}
			}
			if (g_tmpmqopath[0]) {
				//GetDlgItemText( hDlgWnd, IDC_FILEPATH, g_tmpmqopath, MULTIPATH );
				s_mqodlghwnd = 0;
				KillTimer(hDlgWnd, s_openmqoproctimer);
				EndDialog(hDlgWnd, IDOK);
			}
			return TRUE;
			break;
		case IDCANCEL:
			s_mqodlghwnd = 0;
			g_tmpmqopath[0] = 0L;
			wfilename[0] = 0L;
			KillTimer(hDlgWnd, s_openmqoproctimer);
			EndDialog(hDlgWnd, IDCANCEL);
			return TRUE;
			break;



		case IDC_REFMQO:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

				//###############################
				//前回の場所を初期ディレクトリに
				//###############################
				//ofn.lpstrInitialDir = g_tmpmqopath;
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				wcscpy_s(wfilename, MAX_PATH, s_beffolder);
				ofn.lpstrInitialDir = s_beffolder;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}

				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;
		case IDC_REFDESKTOP:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;


				//###############################
				//デスクトップを初期ディレクトリに
				//###############################
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				WCHAR waFolderPath[MAX_PATH];
				SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_DESKTOP, 0);
				ofn.lpstrInitialDir = waFolderPath;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}

				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;
		case IDC_REFMYDOC:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;


				//#########################################
				//ドキュメントフォルダを初期ディレクトリに
				//#########################################
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				WCHAR waFolderPath[MAX_PATH];
				SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PERSONAL, 0);
				ofn.lpstrInitialDir = waFolderPath;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}


				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;
		case IDC_REFTEST:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;


				//#################################
				//Testフォルダを初期ディレクトリに
				//#################################
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				WCHAR waFolderPath[MAX_PATH];
				//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PROGRAMS, 0);//これではAppDataのパスになってしまう
				swprintf_s(waFolderPath, MAX_PATH, L"C:\\Program Files\\OchakkoLAB\\AdditiveIK1.0.0.5\\Test\\");
				ofn.lpstrInitialDir = waFolderPath;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}


				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;
		case IDC_REFPG:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;


				//#####################################
				//プログラムの場所を初期ディレクトリに
				//#####################################
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				//ofn.lpstrInitialDir = g_basedir;

				//2023/10/02 １つ上のディレクトリに
				WCHAR waFolderPath[MAX_PATH];
				wcscpy_s(waFolderPath, MAX_PATH, g_basedir);
				WCHAR* lasten = wcsrchr(waFolderPath, TEXT('\\'));
				if (lasten) {
					*lasten = 0L;//pathの最終文字としての'\\'
					WCHAR* lasten2 = wcsrchr(waFolderPath, TEXT('\\'));
					if (lasten2) {
						*(lasten2 + 1) = 0L;//pathの最終文字は'\\'なので　+1
					}
				}
				ofn.lpstrInitialDir = waFolderPath;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}


				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;



		case IDC_FILTER_CHA:
			currentpage = 0;

			if (s_filterindex != 7) {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, TRUE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, FALSE, 0);
				s_filter_cha = 1;

				if (s_filterindex == 5) {
					//bvh2FBXの単体ファイル履歴
					std::vector<wstring> vecopenfilename;
					pagenum = GetbvhHistoryDir(vecopenfilename);
					SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
				}
				else {
					//cha, fbxファイル履歴
					std::vector<wstring> vecopenfilename;
					pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);
					SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
				}
			}
			break;


		case IDC_FILTER_FBX:
			currentpage = 0;

			if (s_filterindex != 7) {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, TRUE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, FALSE, 0);
				s_filter_cha = 2;

				if (s_filterindex == 5) {
					//bvh2FBXの単体ファイル履歴
					std::vector<wstring> vecopenfilename;
					pagenum = GetbvhHistoryDir(vecopenfilename);
					SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
				}
				else {
					//cha, fbxファイル履歴
					std::vector<wstring> vecopenfilename;
					pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);
					SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
				}
			}
			break;

		case IDC_FILTER_RTG:
			currentpage = 0;

			if (s_filterindex == 7) {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, TRUE, 0);

				//Retarget fileの単体ファイル履歴
				std::vector<wstring> vecopenfilename;
				pagenum = GetRtgHistoryDir(vecopenfilename);
				SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
			}
			break;
		case IDC_PREVPAGE:
		{
			//##############
			//get history
			//##############

			std::vector<wstring> vecopenfilename;
			if (s_filterindex == 5) {
				//bvh2FBXの単体ファイル履歴
				pagenum = GetbvhHistoryDir(vecopenfilename);
			}
			else if (s_filterindex == 7) {
				//Retarget fileの単体ファイル履歴
				pagenum = GetRtgHistoryDir(vecopenfilename);
			}
			else {
				//cha, fbxファイル履歴
				pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);
			}

			//###################
			//change currentpage
			//###################
			if (pagenum >= 1) {
				if (currentpage >= 1) {
					currentpage--;
				}
				else {
					currentpage = pagenum - 1;
				}
			}
			else {
				currentpage = 0;
			}

			//##################
			//set paged history
			//##################
			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
		}
		break;

		case IDC_NEXTPAGE:
		{
			//##############
			//get history
			//##############

			std::vector<wstring> vecopenfilename;
			if (s_filterindex == 5) {
				//bvh2FBXの単体ファイル履歴
				pagenum = GetbvhHistoryDir(vecopenfilename);
			}
			else if (s_filterindex == 7) {
				//Retarget fileの単体ファイル履歴
				pagenum = GetRtgHistoryDir(vecopenfilename);
			}
			else {
				//cha, fbxファイル履歴
				pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);
			}

			//###################
			//change currentpage
			//###################
			if (pagenum >= 1) {
				if (currentpage < (pagenum - 1)) {
					currentpage++;
				}
				else {
					currentpage = 0;
				}
			}
			else {
				currentpage = 0;
			}

			//##################
			//set paged history
			//##################
			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);

		}
		break;

		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_mqodlghwnd = 0;
		g_tmpmqopath[0] = 0L;
		KillTimer(hDlgWnd, s_openmqoproctimer);
		EndDialog(hDlgWnd, IDCANCEL);
		return TRUE;
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;
}


LRESULT CALLBACK OpenBvhDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = hDlgWnd;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"BVH(*.bvh)\0*.bvh\0chara(*.fbx)\0*.fbx\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 0;
	ofn.lpstrFile = g_tmpmqopath;
	ofn.nMaxFile = MULTIPATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = NULL;
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	WCHAR strmult[256];
	wcscpy_s(strmult, 256, L"1.000");
	WCHAR strfilter[256];
	wcscpy_s(strfilter, 256, L"100.0");

	static int s_openbvhproctimer = 352;


	switch (msg) {
	case WM_INITDIALOG:

		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		g_tmpmqomult = 1.0f;
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);
		SetDlgItemText(hDlgWnd, IDC_MULT, strmult);
		SetDlgItemText(hDlgWnd, IDC_EDITFILTER, strfilter);
		SetDlgItemText(hDlgWnd, IDC_FILEPATH, L"PushRefButtonToSelectFile.");

		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		SetTimer(hDlgWnd, s_openbvhproctimer, 20, NULL);
		s_bvhdlghwnd = hDlgWnd;

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_bvhdlghwnd = 0;
			KillTimer(hDlgWnd, s_openbvhproctimer);

			GetDlgItemText(hDlgWnd, IDC_MULT, strmult, 256);
			g_tmpmqomult = (float)_wtof(strmult);
			//GetDlgItemText( hDlgWnd, IDC_FILEPATH, g_tmpmqopath, MULTIPATH );
			GetDlgItemText(hDlgWnd, IDC_EDITFILTER, strfilter, 256);
			g_tmpbvhfilter = (float)_wtof(strfilter);

			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_bvhdlghwnd = 0;
			KillTimer(hDlgWnd, s_openbvhproctimer);

			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFMQO:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);

			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_bvhdlghwnd = 0;
		KillTimer(hDlgWnd, s_openbvhproctimer);

		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}

LRESULT CALLBACK CheckAxisTypeProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
		SetDlgItemText(hDlgWnd, IDC_FILENAME, g_tmpmqopath);
		SendMessage(GetDlgItem(hDlgWnd, IDC_AXISCHECK1), BM_SETCHECK, (WPARAM)0, 0L);
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			if (IsDlgButtonChecked(hDlgWnd, IDC_AXISCHECK1) == BST_CHECKED) {
				s_forcenewaxis = 1;
			}
			else {
				s_forcenewaxis = 0;
			}

			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
		}
		break;
	case WM_CLOSE:
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		return FALSE;
	}
	return TRUE;

}


LRESULT CALLBACK MotPropDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	//static WCHAR s_tmpmotname[256] = {0L};
	//static double s_tmpmotframeleng = 100.0f;
	//static int s_tmpmotloop = 0;

	WCHAR strframeleng[256];

	static int s_motproptimerid = 345;


	switch (msg) {
	case WM_INITDIALOG:
	{
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model && s_model->GetCurMotInfo()) {
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
				s_model->GetCurMotInfo()->motname, 256, s_tmpmotname, 256);
			SetDlgItemText(hDlgWnd, IDC_MOTNAME, s_tmpmotname);

			s_tmpmotframeleng = s_model->GetCurMotInfo()->frameleng;
			swprintf_s(strframeleng, 256, L"%f", s_tmpmotframeleng);
			SetDlgItemText(hDlgWnd, IDC_FRAMELENG, strframeleng);

			s_tmpmotloop = s_model->GetCurMotInfo()->loopflag;
			SendMessage(GetDlgItem(hDlgWnd, IDC_LOOP), BM_SETCHECK, (WPARAM)s_tmpmotloop, 0L);
		}


		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		s_motpropdlghwnd = hDlgWnd;
		SetTimer(hDlgWnd, s_motproptimerid, 20, NULL);
	}
	//SetDlgItemText( hDlgWnd, IDC_MULT, strmult );
	return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			GetDlgItemText(hDlgWnd, IDC_MOTNAME, s_tmpmotname, 256);

			GetDlgItemText(hDlgWnd, IDC_FRAMELENG, strframeleng, 256);
			s_tmpmotframeleng = (float)_wtof(strframeleng);

			if (IsDlgButtonChecked(hDlgWnd, IDC_LOOP) == BST_CHECKED) {
				s_tmpmotloop = 1;
			}
			else {
				s_tmpmotloop = 0;
			}

			KillTimer(hDlgWnd, s_motproptimerid);
			s_motpropdlghwnd = 0;
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			KillTimer(hDlgWnd, s_motproptimerid);
			s_motpropdlghwnd = 0;
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		break;
	case WM_CLOSE:
		KillTimer(hDlgWnd, s_motproptimerid);
		s_motpropdlghwnd = 0;
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}

//########################################################
//2023/08/23 DollyHistoryDlg.h, DollyHistoryDlg.cppに移行
//########################################################
//LRESULT CALLBACK CameraDollyDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
//{
//	float posvalue = 0.0f;
//	WCHAR strpos[256] = { 0L };
//
//	switch (msg) {
//	case WM_INITDIALOG:
//	{
//		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);
//
//		swprintf_s(strpos, 256, L"%.3f", g_camEye.x);
//		SetDlgItemTextW(hDlgWnd, IDC_DOLLYX, strpos);
//		swprintf_s(strpos, 256, L"%.3f", g_camEye.y);
//		SetDlgItemTextW(hDlgWnd, IDC_DOLLYY, strpos);
//		swprintf_s(strpos, 256, L"%.3f", g_camEye.z);
//		SetDlgItemTextW(hDlgWnd, IDC_DOLLYZ, strpos);
//
//		swprintf_s(strpos, 256, L"%.3f", g_camtargetpos.x);
//		SetDlgItemTextW(hDlgWnd, IDC_DOLLYX2, strpos);
//		swprintf_s(strpos, 256, L"%.3f", g_camtargetpos.y);
//		SetDlgItemTextW(hDlgWnd, IDC_DOLLYY2, strpos);
//		swprintf_s(strpos, 256, L"%.3f", g_camtargetpos.z);
//		SetDlgItemTextW(hDlgWnd, IDC_DOLLYZ2, strpos);
//
//
//		//RECT dlgrect;
//		//GetWindowRect(hDlgWnd, &dlgrect);
//		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
//
//		s_cameradollydlgwnd = hDlgWnd;
//	}
//	//SetDlgItemText( hDlgWnd, IDC_MULT, strmult );
//	return FALSE;
//
//	case WM_COMMAND:
//		switch (LOWORD(wp)) {
//		case IDOK:
//			ShowWindow(hDlgWnd, SW_HIDE);
//			break;
//		case IDCANCEL:
//			ShowWindow(hDlgWnd, SW_HIDE);
//			break;
//		case IDC_GETDOLLY:
//		{
//			swprintf_s(strpos, 256, L"%.3f", g_camEye.x);
//			SetDlgItemTextW(hDlgWnd, IDC_DOLLYX, strpos);
//			swprintf_s(strpos, 256, L"%.3f", g_camEye.y);
//			SetDlgItemTextW(hDlgWnd, IDC_DOLLYY, strpos);
//			swprintf_s(strpos, 256, L"%.3f", g_camEye.z);
//			SetDlgItemTextW(hDlgWnd, IDC_DOLLYZ, strpos);
//
//			swprintf_s(strpos, 256, L"%.3f", g_camtargetpos.x);
//			SetDlgItemTextW(hDlgWnd, IDC_DOLLYX2, strpos);
//			swprintf_s(strpos, 256, L"%.3f", g_camtargetpos.y);
//			SetDlgItemTextW(hDlgWnd, IDC_DOLLYY2, strpos);
//			swprintf_s(strpos, 256, L"%.3f", g_camtargetpos.z);
//			SetDlgItemTextW(hDlgWnd, IDC_DOLLYZ2, strpos);
//		}
//			break;
//
//		case IDC_APPLYDOLLY:
//		{
//			ChaVector3 savecameye = g_camEye;
//			ChaVector3 savetarget = g_camtargetpos;
//			g_befcamtargetpos = g_camtargetpos;
//
//			GetDlgItemTextW(hDlgWnd, IDC_DOLLYX, strpos, 256);
//			posvalue = (float)_wtof(strpos);
//			if ((posvalue >= -FLT_MAX) && (posvalue <= FLT_MAX)) {
//				g_camEye.x = posvalue;
//			}
//			GetDlgItemTextW(hDlgWnd, IDC_DOLLYY, strpos, 256);
//			posvalue = (float)_wtof(strpos);
//			if ((posvalue >= -FLT_MAX) && (posvalue <= FLT_MAX)) {
//				g_camEye.y = posvalue;
//			}
//			GetDlgItemTextW(hDlgWnd, IDC_DOLLYZ, strpos, 256);
//			posvalue = (float)_wtof(strpos);
//			if ((posvalue >= -FLT_MAX) && (posvalue <= FLT_MAX)) {
//				g_camEye.z = posvalue;
//			}
//
//
//			GetDlgItemTextW(hDlgWnd, IDC_DOLLYX2, strpos, 256);
//			posvalue = (float)_wtof(strpos);
//			if ((posvalue >= -FLT_MAX) && (posvalue <= FLT_MAX)) {
//				g_camtargetpos.x = posvalue;
//			}
//			GetDlgItemTextW(hDlgWnd, IDC_DOLLYY2, strpos, 256);
//			posvalue = (float)_wtof(strpos);
//			if ((posvalue >= -FLT_MAX) && (posvalue <= FLT_MAX)) {
//				g_camtargetpos.y = posvalue;
//			}
//			GetDlgItemTextW(hDlgWnd, IDC_DOLLYZ2, strpos, 256);
//			posvalue = (float)_wtof(strpos);
//			if ((posvalue >= -FLT_MAX) && (posvalue <= FLT_MAX)) {
//				g_camtargetpos.z = posvalue;
//			}
//
//			
//			ChaVector3 diffv;
//			diffv = g_camEye - g_camtargetpos;
//			g_camdist = (float)ChaVector3LengthDbl(&diffv);
//			if (g_camdist <= 1e-4) {
//				//rollback
//
//				g_camEye = savecameye;
//				g_camtargetpos = savetarget;
//				ChaVector3 diffv2;
//				diffv2 = g_camEye - g_camtargetpos;
//				g_camdist = (float)ChaVector3LengthDbl(&diffv2);
//
//				swprintf_s(strpos, 256, L"%.3f", g_camEye.x);
//				SetDlgItemTextW(hDlgWnd, IDC_DOLLYX, strpos);
//				swprintf_s(strpos, 256, L"%.3f", g_camEye.y);
//				SetDlgItemTextW(hDlgWnd, IDC_DOLLYY, strpos);
//				swprintf_s(strpos, 256, L"%.3f", g_camEye.z);
//				SetDlgItemTextW(hDlgWnd, IDC_DOLLYZ, strpos);
//
//				swprintf_s(strpos, 256, L"%.3f", g_camtargetpos.x);
//				SetDlgItemTextW(hDlgWnd, IDC_DOLLYX2, strpos);
//				swprintf_s(strpos, 256, L"%.3f", g_camtargetpos.y);
//				SetDlgItemTextW(hDlgWnd, IDC_DOLLYY2, strpos);
//				swprintf_s(strpos, 256, L"%.3f", g_camtargetpos.z);
//				SetDlgItemTextW(hDlgWnd, IDC_DOLLYZ2, strpos);
//			}
//
//			//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
//			//#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
//			//#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();
//
//		}
//			break;
//		default:
//			return FALSE;
//		}
//		break;
//	case WM_CLOSE:
//		ShowWindow(hDlgWnd, SW_HIDE);
//		break;
//	default:
//		DefWindowProc(hDlgWnd, msg, wp, lp);
//		return FALSE;
//	}
//	return TRUE;
//
//}



LRESULT CALLBACK RetargetBatchDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR strnumcnt[1024] = { 0L };
	HWND hProg;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		s_retargetbatchwnd = hDlgWnd;

		swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (s_retargetcnt + 1), s_retargetnum);
		SetDlgItemTextW(s_retargetbatchwnd, IDC_STRBVH2FBXBATCH, strnumcnt);
		hProg = GetDlgItem(s_retargetbatchwnd, IDC_PROGRESS1);
		if (hProg) {
			//プログレスバーの範囲         
			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, 100));
			//ステップの範囲を設定 
			SendMessage(hProg, PBM_SETSTEP, 1, 0);
			//現在位置を設定  
			SendMessage(hProg, PBM_SETPOS, 0, 0);
		}

		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			if (s_retargetbatchwnd) {
				DestroyWindow(s_retargetbatchwnd);
				s_retargetbatchwnd = 0;
			}
			InterlockedExchange(&g_retargetbatchflag, 2);
			//EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			if (s_retargetbatchwnd) {
				DestroyWindow(s_retargetbatchwnd);
				s_retargetbatchwnd = 0;
			}
			InterlockedExchange(&g_retargetbatchflag, 2);
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			break;
		}
		break;
	case WM_USER_FOR_BATCH_PROGRESS:
		break;
	case WM_CLOSE:
		if (s_retargetbatchwnd) {
			DestroyWindow(s_retargetbatchwnd);
			s_retargetbatchwnd = 0;
		}
		InterlockedExchange(&g_retargetbatchflag, 2);
		//EndDialog(hDlgWnd, IDOK);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}



LRESULT CALLBACK ProgressDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	//static int s_timerid = 371;

	WCHAR strnumcnt[1024] = { 0L };
	HWND hProg;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		s_progresswnd = hDlgWnd;

		swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (s_progresscnt + 1), s_progressnum);
		SetDlgItemTextW(s_progresswnd, IDC_STRBVH2FBXBATCH, strnumcnt);
		hProg = GetDlgItem(s_progresswnd, IDC_PROGRESS1);
		if (hProg) {
			//プログレスバーの範囲         
			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, 100));
			//ステップの範囲を設定 
			SendMessage(hProg, PBM_SETSTEP, 1, 0);
			//現在位置を設定  
			SendMessage(hProg, PBM_SETPOS, 0, 0);
		}

		//SetTimer(hDlgWnd, s_timerid, 100, NULL);
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			//if (s_progresswnd) {
			//	if (s_timerid != 0) {
			//		KillTimer(s_progresswnd, s_timerid);
			//		s_timerid = 0;
			//	}
			//	DestroyWindow(s_progresswnd);
			//	s_progresswnd = 0;
			//}
			//InterlockedExchange(&g_progressflag, 2);
			////EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			//if (s_progresswnd) {
			//	if (s_timerid != 0) {
			//		KillTimer(s_progresswnd, s_timerid);
			//		s_timerid = 0;
			//	}
			//	DestroyWindow(s_progresswnd);
			//	s_progresswnd = 0;
			//}
			//InterlockedExchange(&g_progressflag, 2);
			////EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			break;
		}
		break;
	case WM_USER_FOR_BATCH_PROGRESS:
		//case WM_TIMER:
		//	swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (s_progresscnt + 1), s_progressnum);
		//	SetDlgItemTextW(s_progresswnd, IDC_STRBVH2FBXBATCH, strnumcnt);

		//	if (s_progresswnd) {
		//		//HWND hProg;
		//		hProg = GetDlgItem(s_progresswnd, IDC_PROGRESS1);
		//		if (hProg) {
		//			//プログレスバーの範囲を0-300にする           
		//			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, s_progressnum));
		//			//現在位置を設定  
		//			SendMessage(hProg, PBM_SETPOS, (s_progresscnt + 1), 0);
		//			//ステップの範囲を設定 
		//			//SendMessage(hProg, PBM_SETSTEP, 1, 0);
		//		}
		//		UpdateWindow(s_progresswnd);
		//	}
		break;
	case WM_CLOSE:
		if (s_progresswnd) {
			//if (s_timerid != 0) {
			//	KillTimer(s_progresswnd, s_timerid);
			//	s_timerid = 0;
			//}
			DestroyWindow(s_progresswnd);
			s_progresswnd = 0;
		}
		//InterlockedExchange(&g_progressflag, 2);
		//EndDialog(hDlgWnd, IDOK);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}




LRESULT CALLBACK bvh2FbxBatchDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	WCHAR strnumcnt[1024] = { 0L };
	HWND hProg;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		s_bvh2fbxbatchwnd = hDlgWnd;

		swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (s_bvh2fbxcnt + 1), s_bvh2fbxnum);
		SetDlgItemTextW(s_bvh2fbxbatchwnd, IDC_STRBVH2FBXBATCH, strnumcnt);
		hProg = GetDlgItem(s_bvh2fbxbatchwnd, IDC_PROGRESS1);
		if (hProg) {
			//プログレスバーの範囲         
			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, s_bvh2fbxnum));
			//ステップの範囲を設定 
			SendMessage(hProg, PBM_SETSTEP, 1, 0);
			//現在位置を設定  
			SendMessage(hProg, PBM_SETPOS, 0, 0);
		}

		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			if (s_bvh2fbxbatchwnd) {
				DestroyWindow(s_bvh2fbxbatchwnd);
				s_bvh2fbxbatchwnd = 0;
			}
			InterlockedExchange(&g_bvh2fbxbatchflag, 2);
			//EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			if (s_bvh2fbxbatchwnd) {
				DestroyWindow(s_bvh2fbxbatchwnd);
				s_bvh2fbxbatchwnd = 0;
			}
			InterlockedExchange(&g_bvh2fbxbatchflag, 2);
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			break;
		}
		break;
	case WM_CLOSE:
		if (s_bvh2fbxbatchwnd) {
			DestroyWindow(s_bvh2fbxbatchwnd);
			s_bvh2fbxbatchwnd = 0;
		}
		InterlockedExchange(&g_bvh2fbxbatchflag, 2);
		//EndDialog(hDlgWnd, IDOK);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}


LRESULT CALLBACK SaveGcoDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR buf[MAX_PATH];
	ZeroMemory(buf, sizeof(WCHAR) * MAX_PATH);
	if (s_Gconame[0] != 0) {
		wcscpy_s(buf, MAX_PATH, s_Gconame);
	}

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	//buf[0] = 0L;
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = NULL;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"Ground File(*.gco)\0*.gco\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	//ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = L"gco";
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;


	static int s_savegcoproctimer = 356;

	switch (msg) {
	case WM_INITDIALOG:

		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model && s_model->GetTopBone()) {
			SetDlgItemText(hDlgWnd, IDC_FILENAME, s_Gconame);
		}

		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		SetTimer(hDlgWnd, s_savegcoproctimer, 20, NULL);
		s_savegcodlghwnd = hDlgWnd;

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_savegcodlghwnd = 0;
			KillTimer(hDlgWnd, s_savegcoproctimer);

			GetDlgItemText(hDlgWnd, IDC_FILENAME, s_Gconame, MAX_PATH);
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_savegcodlghwnd = 0;
			KillTimer(hDlgWnd, s_savegcoproctimer);

			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFFILE:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				buf[0] = 0;
				SetDlgItemText(hDlgWnd, IDC_FILENAME, buf);
				buf[MAX_PATH - 1] = 0;
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);

			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_savegcodlghwnd = 0;
		KillTimer(hDlgWnd, s_savegcoproctimer);

		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;

}

LRESULT CALLBACK SaveImpDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR buf[MAX_PATH];
	ZeroMemory(buf, sizeof(WCHAR) * MAX_PATH);
	if (s_Impname[0] != 0) {
		wcscpy_s(buf, MAX_PATH, s_Impname);
	}

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	//buf[0] = 0L;
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = NULL;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"Impulse File(*.imp)\0*.imp\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	//ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = L"imp";
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	static int s_saveimpproctimer = 355;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model && s_model->GetTopBone()) {
			SetDlgItemText(hDlgWnd, IDC_FILENAME, s_Impname);
		}
		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		SetTimer(hDlgWnd, s_saveimpproctimer, 20, NULL);
		s_saveimpdlghwnd = hDlgWnd;

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_saveimpdlghwnd = 0;
			KillTimer(hDlgWnd, s_saveimpproctimer);

			GetDlgItemText(hDlgWnd, IDC_FILENAME, s_Impname, MAX_PATH);
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_saveimpdlghwnd = 0;
			KillTimer(hDlgWnd, s_saveimpproctimer);

			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFFILE:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				buf[0] = 0;
				SetDlgItemText(hDlgWnd, IDC_FILENAME, buf);
				buf[MAX_PATH - 1] = 0;
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);

			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_saveimpdlghwnd = 0;
		KillTimer(hDlgWnd, s_saveimpproctimer);

		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;

}


LRESULT CALLBACK SaveREDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR buf[MAX_PATH];
	ZeroMemory(buf, sizeof(WCHAR) * MAX_PATH);
	if (s_REname[0] != 0) {
		wcscpy_s(buf, MAX_PATH, s_REname);
	}

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	//buf[0] = 0L;
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = NULL;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"RigidElem File(*.ref)\0*.ref\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	//ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = L"ref";
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	static int s_savereproctimer = 354;

	switch (msg) {
	case WM_INITDIALOG:

		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model && s_model->GetTopBone()) {
			SetDlgItemText(hDlgWnd, IDC_FILENAME, s_REname);
		}
		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		SetTimer(hDlgWnd, s_savereproctimer, 20, NULL);
		s_saveredlghwnd = hDlgWnd;

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_saveredlghwnd = 0;
			KillTimer(hDlgWnd, s_savereproctimer);

			GetDlgItemText(hDlgWnd, IDC_FILENAME, s_REname, MAX_PATH);
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_saveredlghwnd = 0;
			KillTimer(hDlgWnd, s_savereproctimer);

			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFFILE:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				buf[0] = 0;
				SetDlgItemText(hDlgWnd, IDC_FILENAME, buf);
				buf[MAX_PATH - 1] = 0;
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);


			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}

		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_saveredlghwnd = 0;
		KillTimer(hDlgWnd, s_savereproctimer);

		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;

}


LRESULT CALLBACK ExportXDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR buf[MAX_PATH];
	ZeroMemory(buf, sizeof(WCHAR) * MAX_PATH);
	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	//buf[0] = 0L;
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = NULL;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"x File (*.x)\0*.x\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	//ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = NULL;
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	WCHAR strmult[256];
	wcscpy_s(strmult, 256, L"1.000");

	static int s_exportxproctimer = 360;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		g_tmpmqomult = 1.0f;
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);
		SetDlgItemText(hDlgWnd, IDC_MULT, strmult);
		SetDlgItemText(hDlgWnd, IDC_FILEPATH, L"PushRefButtonToSelectFile.");

		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		SetTimer(hDlgWnd, s_exportxproctimer, 20, NULL);
		s_exportxdlghwnd = hDlgWnd;
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_exportxdlghwnd = 0;
			KillTimer(hDlgWnd, s_exportxproctimer);
			GetDlgItemText(hDlgWnd, IDC_MULT, strmult, 256);
			g_tmpmqomult = (float)_wtof(strmult);
			GetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath, MULTIPATH);
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_exportxdlghwnd = 0;
			KillTimer(hDlgWnd, s_exportxproctimer);
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFX:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				buf[0] = 0;
				SetDlgItemText(hDlgWnd, IDC_FILEPATH, buf);
				buf[MAX_PATH - 1] = 0;
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);

			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_exportxdlghwnd = 0;
		KillTimer(hDlgWnd, s_exportxproctimer);
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;

	}
	return TRUE;
}



void ActivatePanel(int state)
{
	if (!s_timelineWnd || !s_toolWnd || !s_layerWnd || !s_modelpanel.panel || !s_motionpanel.panel || !s_camerapanel.panel)
		return;


	if (state == 1) {
		if (s_dispmw && s_timelineWnd) {
			s_timelineWnd->setVisible(false);
			s_timelineWnd->setVisible(true);
		}
		if (s_disptool && s_toolWnd) {
			s_toolWnd->setVisible(true);
		}
		if (s_dispobj && s_layerWnd) {
			s_layerWnd->setVisible(true);
		}

	}
	else if (state == 0) {
		if (s_timelineWnd) {
			s_timelineWnd->setVisible(false);
		}
		if (s_toolWnd) {
			s_toolWnd->setVisible(false);
		}

		if (s_layerWnd) {
			s_layerWnd->setVisible(false);
		}
		s_dispobj = false;
	}

	DispModelPanel();
}


int DestroyModelPanel()
{
	if (s_modelpanel.panel) {
		s_modelpanel.panel->setVisible(false);
		delete s_modelpanel.panel;
		s_modelpanel.panel = 0;
	}
	if (s_modelpanel.scroll) {
		delete s_modelpanel.scroll;
		s_modelpanel.scroll = 0;
	}
	if (s_modelpanel.radiobutton) {
		delete s_modelpanel.radiobutton;
		s_modelpanel.radiobutton = 0;
	}
	if (s_modelpanel.separator) {
		delete s_modelpanel.separator;
		s_modelpanel.separator = 0;
	}
	if (s_modelpanel.separator2) {
		delete s_modelpanel.separator2;
		s_modelpanel.separator2 = 0;
	}
	if (!(s_modelpanel.checkvec.empty())) {
		int checknum = (int)s_modelpanel.checkvec.size();
		int checkno;
		for (checkno = 0; checkno < checknum; checkno++) {
			delete s_modelpanel.checkvec[checkno];
		}
	}
	s_modelpanel.checkvec.clear();
	if (!(s_modelpanel.delbutton.empty())) {
		int buttonnum = (int)s_modelpanel.delbutton.size();
		int buttonno;
		for (buttonno = 0; buttonno < buttonnum; buttonno++) {
			delete s_modelpanel.delbutton[buttonno];
		}
	}
	s_modelpanel.delbutton.clear();

	s_modelpanel.modelindex = -1;

	return 0;
}

int CreateModelPanel()
{

	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	if (s_modelpanel.panel) {
		s_firstmodelpanelpos = false;
		s_modelpanelpos = s_modelpanel.panel->getPos();
	}
	DestroyModelPanel();


	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}

	int modelnum = s_chascene->GetModelNum();
	//if (modelnum <= 0) {
	//	return 0;
	//}

	int classcnt = 0;
	WCHAR clsname[256];
	swprintf_s(clsname, 256, L"ModelPanel%d", classcnt);

	HWND parentwnd;
	int istopmost;
	if (g_4kresolution) {
		parentwnd = g_mainhwnd;
		istopmost = 0;
		//istopmost = 1;
	}
	else {
		parentwnd = NULL;
		istopmost = 1;
	}

	if (g_4kresolution) {
		//4Kの場合には　位置固定フレームに埋め込み
		s_modelpanelpos = WindowPos(s_timelinewidth, MAINMENUAIMBARH);
	}
	else if (s_firstmodelpanelpos) {
		RECT wnd3drect;
		if (g_mainhwnd) {
			GetWindowRect(g_mainhwnd, &wnd3drect);
			s_modelpanelpos = WindowPos(wnd3drect.left + 100, wnd3drect.top + 500);
		}
		else {
			s_modelpanelpos = WindowPos(200, s_2ndposy);
		}
	}
	s_firstmodelpanelpos = false;


	s_modelpanel.panel = new OrgWindow(
		istopmost,
		clsname,		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		//WindowPos(s_toolwidth, MAINMENUAIMBARH),		//位置
		s_modelpanelpos,
		WindowSize(s_modelwindowwidth, s_modelwindowheight),	//サイズ
		L"ModelPanel",	//タイトル
		//g_mainhwnd,					//親ウィンドウハンドル
		//false,
		parentwnd,
		true,					//表示・非表示状態
		//70,50,70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否

	if (s_modelpanel.panel) {
		s_modelpanel.panel->setVisible(false);//作成中
		s_modelpanel.panel->setSizeMin(WindowSize(150, 150));		// 最小サイズを設定


		//スクロールウインドウ
		s_modelpanel.scroll = new OWP_ScrollWnd(L"ModelPanelScroll", true);
		if (!s_modelpanel.scroll) {
			_ASSERT(0);
			return 1;
		}
		//要素数が変わったときには指定し忘れないように！！！
		s_modelpanel.scroll->setLineDataSize(modelnum + 3);
		s_modelpanel.scroll->setSize(WindowSize(s_modelwindowwidth, s_modelwindowheight - 30));
		s_modelpanel.panel->addParts(*(s_modelpanel.scroll));
		s_modelpanel.panel->setPos(s_modelpanelpos);
		s_modelpanel.scroll->setPos(WindowPos(0, 30));

		int modelcnt;

		if (modelnum > 0) {

			for (modelcnt = 0; modelcnt < modelnum; modelcnt++) {
				CModel* curmodel = s_chascene->GetModel(modelcnt);
				if (curmodel) {
					if (modelcnt == 0) {
						bool limitnamelen = true;
						s_modelpanel.radiobutton = new OWP_RadioButton(curmodel->GetFileName(), limitnamelen);
						if (!s_modelpanel.radiobutton) {
							_ASSERT(0);
							return 1;
						}
					}
					else {
						if (s_modelpanel.radiobutton) {
							s_modelpanel.radiobutton->addLine(curmodel->GetFileName());
						}
					}
				}
				else {
					_ASSERT(0);
				}
			}

			//s_modelpanel.separator =  new OWP_Separator(s_modelpanel.panel, false);// セパレータ1（境界線による横方向2分割）
			s_modelpanel.separator = new OWP_Separator(s_modelpanel.panel, true, 0.5, true, s_modelpanel.scroll);// セパレータ1（境界線による横方向2分割）
			if (!s_modelpanel.separator) {
				_ASSERT(0);
				return 1;
			}
			s_modelpanel.separator->setSize(WindowSize(s_modelwindowwidth, s_modelwindowheight));
			s_modelpanel.separator->setPos(OrgWinGUI::WindowPos(0, 0));

			// セパレータ2（境界線による横方向2分割）
			s_modelpanel.separator2 = new OWP_Separator(s_modelpanel.panel, true, 0.5, true, s_modelpanel.scroll);// セパレータ2（境界線による横方向2分割）
			if (!s_modelpanel.separator2) {
				_ASSERT(0);
				return 1;
			}
			s_modelpanel.separator2->setSize(WindowSize(s_modelwindowwidth / 2, s_modelwindowheight));
			s_modelpanel.separator2->setPos(OrgWinGUI::WindowPos(0, 0));


			for (modelcnt = 0; modelcnt < modelnum; modelcnt++) {
				CModel* curmodel = s_chascene->GetModel(modelcnt);
				if (curmodel) {
					OWP_CheckBoxA* owpCheckBox = new OWP_CheckBoxA(L"Show/Hide", curmodel->GetModelDisp());
					if (owpCheckBox) {
						s_modelpanel.checkvec.push_back(owpCheckBox);
						OWP_Button* owpButton = new OWP_Button(L"delete");
						if (owpButton) {
							s_modelpanel.delbutton.push_back(owpButton);
						}
						else {
							_ASSERT(0);
							return 1;
						}
					}
					else {
						_ASSERT(0);
						return 1;
					}
				}
			}


			//s_modelpanel.panel->addParts(*(s_modelpanel.separator));
			if (s_modelpanel.scroll) {
				s_modelpanel.scroll->addParts(*(s_modelpanel.separator));
			}
			if (s_modelpanel.separator) {
				if (s_modelpanel.radiobutton) {
					s_modelpanel.separator->addParts1(*(s_modelpanel.radiobutton));
				}
				if (s_modelpanel.separator2) {
					s_modelpanel.separator->addParts2(*(s_modelpanel.separator2));
				}
			}


			for (modelcnt = 0; modelcnt < modelnum; modelcnt++) {
				if (s_modelpanel.separator2) {
					OWP_CheckBoxA* curcb = s_modelpanel.checkvec[modelcnt];
					if (curcb) {
						s_modelpanel.separator2->addParts1(*curcb);
					}
					OWP_Button* curbutton = s_modelpanel.delbutton[modelcnt];
					if (curbutton) {
						s_modelpanel.separator2->addParts2(*curbutton);
					}
				}
			}

			s_modelpanel.modelindex = s_curmodelmenuindex;
			if (s_modelpanel.radiobutton) {
				s_modelpanel.radiobutton->setSelectIndex(s_modelpanel.modelindex);
			}

			//s_modelpanel.scroll->inView(s_modelpanel.modelindex);
			if (s_modelpanel.scroll) {
				s_modelpanel.scroll->setShowPosLine(s_savemodelpanelshowposline);
			}


			//s_modelpanel.scroll->addParts(*(s_modelpanel.separator));
			//s_modelpanel.panel->addParts(*(s_modelpanel.scroll));


			s_modelpanel.scroll->autoResize();
			s_modelpanel.separator->autoResize();
			s_modelpanel.separator2->autoResize();

		}


		//if (s_modelpanel.panel && s_modelpanel.scroll) {
		//	if (s_modelpanel.separator) {
		//		s_modelpanel.scroll->addParts(*(s_modelpanel.separator));
		//	}
		//	s_modelpanel.panel->addParts(*(s_modelpanel.scroll));
		//	s_modelpanel.scroll->setPos(OrgWinGUI::WindowPos(0, 30));
		//}


		//s_modelpanel.panel->setVisible(0);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	////////////
		if (s_modelpanel.panel) {
			s_modelpanel.panel->setCloseListener([]() {
				if (s_model) {
					s_closemodelFlag = true;
				}
				});
		}

		for (modelcnt = 0; modelcnt < modelnum; modelcnt++) {
			if (s_modelpanel.checkvec[modelcnt]) {
				s_modelpanel.checkvec[modelcnt]->setButtonListener([modelcnt]() {
					if (s_model && s_chascene) {
						if (modelcnt < s_chascene->GetModelNum()) {
							CModel* curmodel = s_chascene->GetModel(modelcnt);
							if ((s_underdelmotion == false) && (s_opedelmotioncnt < 0) && //Motion削除と同時は禁止 
								!s_underdelmodel && (s_opedelmodelcnt < 0) && 
								curmodel && !s_underdispmodel) {

								//ここでOnDelModelを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
								s_underdispmodel = true;
								s_opedispmodelcnt = modelcnt;
							}
						}
					}
				});
			}


			if (s_modelpanel.delbutton[modelcnt]) {
				s_modelpanel.delbutton[modelcnt]->setButtonListener([modelcnt]() {
					if (s_model && s_chascene) {
						if ((modelcnt < s_chascene->GetModelNum()) && (s_chascene->GetModelNum() >= 2)) {//全部消すときはメインメニューから
							CModel* curmodel = s_chascene->GetModel(modelcnt);
							if ((s_underdelmotion == false) && (s_opedelmotioncnt < 0) && //Motion削除と同時は禁止 
								(s_opedelmodelcnt < 0) && curmodel && !s_underdelmodel) {
								s_underdelmodel = true;
								//bool ondelbutton = true;
								//OnDelModel(modelcnt, ondelbutton);//s_modelpanel.modelindexはs_modelのindexなので違う

								//ここでOnDelModelを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
								s_opedelmodelcnt = modelcnt;

								s_model = 0;//カレントモデルに影響しないように

								Sleep(100);//ボタン連打でメニューのモーション数が実際より減ることがあったので
							}
						}
					}
				});
			}
		}

		if (s_modelpanel.radiobutton) {
			s_modelpanel.radiobutton->setSelectListener([]() {
				if (s_model && s_chascene) {
					int curindex = s_modelpanel.radiobutton->getSelectIndex();
					if ((s_opeselectmodelcnt < 0) && !s_underselectmodel && 
						(s_underdelmotion == false) && (s_opedelmotioncnt < 0) &&
						(curindex >= 0) && (curindex < s_chascene->GetModelNum())) {

						//s_modelpanel.modelindex = curindex;
						//OnModelMenu(true, s_modelpanel.modelindex, 1);
						//s_modelpanel.panel->callRewrite();

						//ここでOnModelMenuを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
						s_underselectmodel = true;
						s_opeselectmodelcnt = curindex;
					}
				}
			});
		}

		//if (s_firstmodelpanelpos) {
		//	if (g_4kresolution) {
		//		s_modelpanelpos = WindowPos(s_toolwidth, MAINMENUAIMBARH);
		//	}
		//	else {
		//		RECT wnd3drect;
		//		if (g_mainhwnd) {
		//			GetWindowRect(g_mainhwnd, &wnd3drect);
		//			s_modelpanelpos = WindowPos(wnd3drect.left + 100, wnd3drect.top + 500);
		//		}
		//		else {
		//			s_modelpanelpos = WindowPos(200, s_2ndposy);
		//		}
		//	}
		//	s_firstmodelpanelpos = false;
		//}
		//s_modelpanel.panel->setPos(s_modelpanelpos);

		////s_modelpanel.panel->setSize(WindowSize(200, 100));//880
		//s_modelpanel.panel->setSize(WindowSize(s_modelwindowwidth, s_modelwindowheight));


		s_rcmodelpanel.top = s_modelpanelpos.y;
		s_rcmodelpanel.bottom = s_modelpanelpos.y + s_modelwindowheight;
		s_rcmodelpanel.left = s_modelpanelpos.x;
		s_rcmodelpanel.right = s_modelpanelpos.x + s_modelwindowwidth;

		//if (g_4kresolution) {
		//	//4K時は　フレーム組み込み表示
		//	s_modelpanel.panel->setVisible(true);
		//	s_dispmodel = true;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
		//}
		//else {
		if (s_modelpanel.panel) {
			s_modelpanel.panel->setVisible(false);
		}
	}
	else {
		_ASSERT(0);
		return 1;
	}
	s_dispmodel = false;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
	//}

	return 0;
}

int DestroyCameraPanel()
{
	if (s_camerapanel.panel) {
		s_camerapanel.panel->setVisible(false);
		delete s_camerapanel.panel;
		s_camerapanel.panel = 0;
	}
	if (s_camerapanel.scroll) {
		delete s_camerapanel.scroll;
		s_camerapanel.scroll = 0;
	}
	if (s_camerapanel.radiobutton) {
		delete s_camerapanel.radiobutton;
		s_camerapanel.radiobutton = 0;
	}
	if (s_camerapanel.separator) {
		delete s_camerapanel.separator;
		s_camerapanel.separator = 0;
	}
	if (!(s_camerapanel.delbutton.empty())) {
		int buttonnum = (int)s_camerapanel.delbutton.size();
		int buttonno;
		for (buttonno = 0; buttonno < buttonnum; buttonno++) {
			delete s_camerapanel.delbutton[buttonno];
		}
	}
	s_camerapanel.delbutton.clear();

	s_camerapanel.modelindex = -1;

	return 0;
}

int CreateCameraPanel()
{
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	if (s_camerapanel.panel) {
		s_firstcamerapanelpos = false;
		s_camerapanelpos = s_camerapanel.panel->getPos();
	}
	DestroyCameraPanel();

	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}

	int modelnum = s_chascene->GetModelNum();
	//if (modelnum <= 0) {
	//	return 0;
	//}
	//if (!s_model) {
	//	return 0;
	//}
	int cameranum;
	if (s_model) {
		cameranum = s_model->GetCameraMotInfoSize();
	}
	else {
		cameranum = 0;
	}

	//if (motionnum <= 0) {
	//	return 0;
	//}

	int classcnt = 0;
	WCHAR clsname[256];
	swprintf_s(clsname, 256, L"CameraPanel%d", classcnt);

	HWND parentwnd;
	int istopmost;
	if (g_4kresolution) {
		parentwnd = g_mainhwnd;
		istopmost = 0;
		//istopmost = 1;
	}
	else {
		parentwnd = NULL;
		istopmost = 1;
	}


	if (g_4kresolution) {
		//4Kの場合には　位置固定フレームに埋め込み
		s_camerapanelpos = WindowPos(s_timelinewidth, MAINMENUAIMBARH + s_modelwindowheight + s_motionwindowheight);
	}
	else if (s_firstcamerapanelpos) {
		RECT wnd3drect;
		if (g_mainhwnd) {
			GetWindowRect(g_mainhwnd, &wnd3drect);
			s_camerapanelpos = WindowPos(wnd3drect.left + 500 + 500, wnd3drect.top + 500);
		}
		else {
			s_motionpanelpos = WindowPos(700, s_2ndposy);
		}
	}
	s_firstcamerapanelpos = false;


	s_camerapanel.panel = new OrgWindow(
		istopmost,
		clsname,		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		s_camerapanelpos,		//位置
		WindowSize(s_camerawindowwidth, s_camerawindowheight),	//サイズ
		L"CameraPanel",	//タイトル
		//g_mainhwnd,					//親ウィンドウハンドル
		//false,
		parentwnd,
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否
	if (s_camerapanel.panel) {
		s_camerapanel.panel->setSizeMin(WindowSize(150, 150));		// 最小サイズを設定



		if (s_model) {
			int cameracnt = 0;
			std::map<int, MOTINFO*>::iterator itrmi;
			for (itrmi = s_model->GetMotInfoBegin(); itrmi != s_model->GetMotInfoEnd(); itrmi++) {
				MOTINFO* curmi = (MOTINFO*)(itrmi->second);
				if (curmi && curmi->cameramotion) {
					WCHAR wmotname[MAX_PATH] = { 0L };
					MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, curmi->motname, 256, wmotname, MAX_PATH);
					if (cameracnt == 0) {
						bool limitnamelen = true;
						s_camerapanel.radiobutton = new OWP_RadioButton(wmotname, limitnamelen);
						if (!s_camerapanel.radiobutton) {
							_ASSERT(0);
							return 1;
						}
					}
					else {
						if (s_camerapanel.radiobutton) {
							if (wmotname[0] != 0L) {
								s_camerapanel.radiobutton->addLine(wmotname);
							}
							else {
								s_camerapanel.radiobutton->addLine(L"NoName");
							}
						}
					}

					cameracnt++;
				}
			}

			//スクロールウインドウ
			s_camerapanel.scroll = new OWP_ScrollWnd(L"CameraPanelScroll", true);
			if (!s_camerapanel.scroll) {
				_ASSERT(0);
				return 1;
			}
			//要素数が変わったときには指定し忘れないように！！！
			s_camerapanel.scroll->setLineDataSize(cameranum + 3);
			s_camerapanel.scroll->setSize(WindowSize(s_camerawindowwidth, s_camerawindowheight - 30));
			s_camerapanel.panel->addParts(*(s_camerapanel.scroll));
			s_camerapanel.panel->setPos(s_camerapanelpos);
			s_camerapanel.scroll->setPos(WindowPos(0, 30));

			s_camerapanel.separator = new OWP_Separator(s_camerapanel.panel, false, 0.8, true, s_camerapanel.scroll);									// セパレータ1（境界線による横方向2分割）
			if (!s_camerapanel.separator) {
				_ASSERT(0);
				return 1;
			}
			//s_camerapanel.separator->setSize(WindowSize(s_camerawindowwidth, s_camerawindowheight));
			//s_camerapanel.scroll->addParts(*(s_camerapanel.separator));
			if (s_camerapanel.separator) {
				s_camerapanel.scroll->addParts(*(s_camerapanel.separator));
				if (s_camerapanel.radiobutton) {
					s_camerapanel.separator->addParts1(*(s_camerapanel.radiobutton));//add once
				}
			}

			if (s_model) {
				std::map<int, MOTINFO*>::iterator itrmi2;
				for (itrmi2 = s_model->GetMotInfoBegin(); itrmi2 != s_model->GetMotInfoEnd(); itrmi2++) {
					MOTINFO* curmi = (MOTINFO*)(itrmi2->second);
					if (curmi && curmi->cameramotion) {
						OWP_Button* owpButton = new OWP_Button(L"delete");
						if (owpButton) {
							s_camerapanel.delbutton.push_back(owpButton);
							s_camerapanel.separator->addParts2(*owpButton);
						}
						else {
							_ASSERT(0);
							return 1;
						}
					}
				}
			}


			s_camerapanel.modelindex = s_curmodelmenuindex;
			//s_camerapanel.radiobutton->setSelectIndex(0);
			if (s_model) {
				if (s_camerapanel.radiobutton) {
					int cameramotid = s_model->GetCameraMotionId();
					if (cameramotid > 0) {
						int cameramotindex = s_model->MotionID2CameraIndex(cameramotid);
						if (cameramotindex >= 0) {
							s_cameramenuindexmap[s_model] = cameramotindex;
							s_camerapanel.radiobutton->setSelectIndex(cameramotindex);//!!!!
						}
					}
				}
				//s_camerapanel.scroll->inView(s_motmenuindexmap[s_model]);
				if (s_camerapanel.scroll) {
					s_camerapanel.scroll->setShowPosLine(s_savecamerapanelshowposline);
				}
			}
			else {
				_ASSERT(0);
				return 1;
			}

		}
		else {
			//_ASSERT(0);
			return 0;//s_model == NULL : 0 return
		}


		if (s_camerapanel.panel) {
			s_camerapanel.panel->setVisible(false);//作成中非表示

			s_camerapanel.panel->setCloseListener([]() {
				if (s_model) {
					s_closecameraFlag = true;
				}
				});

		}

		if (s_model) {
			int delmenuindex = 0;
			for (delmenuindex = 0; delmenuindex < s_model->GetCameraMotInfoSize(); delmenuindex++) {
				if (s_camerapanel.delbutton[delmenuindex]) {
					s_camerapanel.delbutton[delmenuindex]->setButtonListener([delmenuindex]() {
						if ((s_underdelmodel == false) && (s_opedelmodelcnt < 0) && //Model削除と同時は禁止
							!s_underdelmotion && s_model && (s_model->GetCameraMotInfoSize() >= 2)) {//全部消すときはメインメニューから

							MOTINFO* camerami = s_model->GetCameraMotInfoByCameraIndex(delmenuindex);
							if (camerami) {
								int delmotid = camerami->motid;
								int deleteindex = s_model->MotionID2Index(delmotid);
								if (deleteindex >= 0) {
									s_opedelmotioncnt = deleteindex;
									s_underdelmotion = true;
									Sleep(100);//ボタン連打でメニューのモーション数が実際より減ることがあったので
								}
							}

							//ここでOnDelMotionを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ

						}
						});
				}
				else {
					_ASSERT(0);
					return 1;
				}
			}
		}

		if (s_camerapanel.radiobutton) {
			s_camerapanel.radiobutton->setSelectListener([]() {
				if (s_model) {
					int curindex = s_camerapanel.radiobutton->getSelectIndex();
					if ((s_opeselectcameracnt < 0) && !s_underselectcamera && (curindex >= 0) && (curindex < s_model->GetCameraMotInfoSize())) {
						s_opeselectcameracnt = curindex;
						s_underselectcamera = true;
						//int cameraindex = curindex;
						//OnAnimMenu(true, cameraindex, 1);
						//s_camerapanel.panel->callRewrite();

						//ここでOnAnimMenuを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
					}
				}
				});
		}

		//s_motionpanel.panel->setPos(s_motionpanelpos);
		//s_motionpanel.panel->setSize(WindowSize(s_motionwindowwidth, s_motionwindowheight));

		s_rccamerapanel.top = s_camerapanelpos.y;
		s_rccamerapanel.bottom = s_camerapanelpos.y + s_camerawindowheight;
		s_rccamerapanel.left = s_camerapanelpos.x;
		s_rccamerapanel.right = s_camerapanelpos.x + s_camerawindowwidth;

		if (g_4kresolution) {
			//4K時は　フレーム組み込み表示
			if (s_camerapanel.panel) {
				s_camerapanel.panel->setVisible(true);
			}
			s_dispcamera = true;//!!!!!!!!!!!!!!!!! camerapanelのdispflag
		}
		else {
			if (s_camerapanel.panel) {
				s_camerapanel.panel->setVisible(false);
			}
			s_dispcamera = false;//!!!!!!!!!!!!!!!!! camerapanelのdispflag
		}
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;
}


int DestroyMotionPanel()
{
	if (s_motionpanel.panel) {
		s_motionpanel.panel->setVisible(false);
		delete s_motionpanel.panel;
		s_motionpanel.panel = 0;
	}
	if (s_motionpanel.scroll) {
		delete s_motionpanel.scroll;
		s_motionpanel.scroll = 0;
	}
	if (s_motionpanel.radiobutton) {
		delete s_motionpanel.radiobutton;
		s_motionpanel.radiobutton = 0;
	}
	if (s_motionpanel.separator) {
		delete s_motionpanel.separator;
		s_motionpanel.separator = 0;
	}
	if (!(s_motionpanel.delbutton.empty())) {
		int buttonnum = (int)s_motionpanel.delbutton.size();
		int buttonno;
		for (buttonno = 0; buttonno < buttonnum; buttonno++) {
			delete s_motionpanel.delbutton[buttonno];
		}
	}
	s_motionpanel.delbutton.clear();

	s_motionpanel.modelindex = -1;

	return 0;
}

int CreateMotionPanel()
{
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	if (s_motionpanel.panel) {
		s_firstmotionpanelpos = false;
		s_motionpanelpos = s_motionpanel.panel->getPos();
	}
	DestroyMotionPanel();


	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}

	int modelnum = s_chascene->GetModelNum();
	//if (modelnum <= 0) {
	//	return 0;
	//}
	//if (!s_model) {
	//	return 0;
	//}
	int motionnum;
	if (s_model) {
		motionnum = s_model->GetMotInfoSize();
	}
	else {
		motionnum = 0;
	}
	
	//if (motionnum <= 0) {
	//	return 0;
	//}

	int classcnt = 0;
	WCHAR clsname[256];
	swprintf_s(clsname, 256, L"MotionPanel%d", classcnt);

	HWND parentwnd;
	int istopmost;
	if (g_4kresolution) {
		parentwnd = g_mainhwnd;
		istopmost = 0;
		//istopmost = 1;
	}
	else {
		parentwnd = NULL;
		istopmost = 1;
	}


	if (g_4kresolution) {
		//4Kの場合には　位置固定フレームに埋め込み
		s_motionpanelpos = WindowPos(s_timelinewidth, MAINMENUAIMBARH + s_modelwindowheight);
	}
	else if (s_firstmotionpanelpos) {
		RECT wnd3drect;
		if (g_mainhwnd) {
			GetWindowRect(g_mainhwnd, &wnd3drect);
			s_motionpanelpos = WindowPos(wnd3drect.left + 500, wnd3drect.top + 500);
		}
		else {
			s_motionpanelpos = WindowPos(600, s_2ndposy);
		}
	}
	s_firstmotionpanelpos = false;


	s_motionpanel.panel = new OrgWindow(
		istopmost,
		clsname,		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		s_motionpanelpos,		//位置
		WindowSize(s_motionwindowwidth, s_motionwindowheight),	//サイズ
		L"MotionPanel",	//タイトル
		//g_mainhwnd,					//親ウィンドウハンドル
		//false,
		parentwnd,
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否
	if (s_motionpanel.panel) {
		s_motionpanel.panel->setSizeMin(WindowSize(150, 150));		// 最小サイズを設定

		//スクロールウインドウ
		//2023/10/15 Separatorに渡すので　Separatorよりも先に作成
		s_motionpanel.scroll = new OWP_ScrollWnd(L"MotionPanelScroll", true);
		if (!s_motionpanel.scroll) {
			_ASSERT(0);
			return 1;
		}
		//要素数が変わったときには指定し忘れないように！！！
		s_motionpanel.scroll->setLineDataSize(motionnum + 3);
		s_motionpanel.scroll->setSize(WindowSize(s_motionwindowwidth, s_motionwindowheight - 30));
		s_motionpanel.panel->addParts(*(s_motionpanel.scroll));
		s_motionpanel.panel->setPos(s_motionpanelpos);
		s_motionpanel.scroll->setPos(WindowPos(0, 30));



		if (s_model) {
			s_motionpanel.separator = new OWP_Separator(s_motionpanel.panel, false, 0.8, true, s_motionpanel.scroll);// セパレータ1（境界線による横方向2分割）
			if (!s_motionpanel.separator) {
				_ASSERT(0);
				return 1;
			}


			int motioncnt = 0;
			std::map<int, MOTINFO*>::iterator itrmi;
			for (itrmi = s_model->GetMotInfoBegin(); itrmi != s_model->GetMotInfoEnd(); itrmi++) {
				MOTINFO* curmi = (MOTINFO*)(itrmi->second);
				if (curmi) {
					WCHAR wmotname[MAX_PATH] = { 0L };
					MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, curmi->motname, 256, wmotname, MAX_PATH);
					if (motioncnt == 0) {
						bool limitnamelen = true;
						s_motionpanel.radiobutton = new OWP_RadioButton(wmotname, limitnamelen);
						if (!s_motionpanel.radiobutton) {
							_ASSERT(0);
							return 1;
						}
					}
					else {
						if (s_motionpanel.radiobutton) {
							if (wmotname[0] != 0L) {
								s_motionpanel.radiobutton->addLine(wmotname);
							}
							else {
								s_motionpanel.radiobutton->addLine(L"NoName");
							}
						}
					}

					motioncnt++;
				}
			}

			s_motionpanel.separator->setSize(WindowSize(s_motionwindowwidth, s_motionwindowheight));
			s_motionpanel.scroll->addParts(*(s_motionpanel.separator));
			if (s_motionpanel.radiobutton) {
				s_motionpanel.separator->addParts1(*(s_motionpanel.radiobutton));//add once
			}

			if (s_model) {
				std::map<int, MOTINFO*>::iterator itrmi2;
				for (itrmi2 = s_model->GetMotInfoBegin(); itrmi2 != s_model->GetMotInfoEnd(); itrmi2++) {
					MOTINFO* curmi = (MOTINFO*)(itrmi2->second);
					if (curmi) {
						OWP_Button* owpButton = new OWP_Button(L"delete");
						if (owpButton) {
							s_motionpanel.delbutton.push_back(owpButton);
							s_motionpanel.separator->addParts2(*owpButton);
						}
						else {
							_ASSERT(0);
							return 1;
						}
					}
				}
			}


			s_motionpanel.modelindex = s_curmodelmenuindex;
			//s_motionpanel.radiobutton->setSelectIndex(0);
			if (s_model) {
				if (s_motionpanel.radiobutton) {
					s_motionpanel.radiobutton->setSelectIndex(s_motmenuindexmap[s_model]);//!!!!
				}
				//s_motionpanel.scroll->inView(s_motmenuindexmap[s_model]);
				if (s_motionpanel.scroll) {
					s_motionpanel.scroll->setShowPosLine(s_savemotionpanelshowposline);
				}
			}
			else {
				_ASSERT(0);
				return 1;
			}

		}
		else {
			//_ASSERT(0);
			return 0;//s_model == NULL : 0 return
		}


		if (s_motionpanel.panel) {
			s_motionpanel.panel->setVisible(false);//作成中非表示

			s_motionpanel.panel->setCloseListener([]() {
				if (s_model) {
					s_closemotionFlag = true;
				}
				});

		}

		if (s_model) {
			int delmenuindex = 0;
			for (delmenuindex = 0; delmenuindex < s_model->GetMotInfoSize(); delmenuindex++) {
				if (s_motionpanel.delbutton[delmenuindex]) {
					s_motionpanel.delbutton[delmenuindex]->setButtonListener([delmenuindex]() {
						if ((s_underdelmodel == false) && (s_opedelmodelcnt < 0) && //Model削除と同時は禁止
							(s_opedelmotioncnt < 0) && !s_underdelmotion && 
							s_model && (s_model->GetMotInfoSize() >= 2)) {//全部消すときはメインメニューから
							s_opedelmotioncnt = delmenuindex;
							s_underdelmotion = true;
							//bool ondelbutton = true;
							//OnDelMotion(delmenuindex, ondelbutton);

							//ここでOnDelMotionを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ

							Sleep(100);//ボタン連打でメニューのモーション数が実際より減ることがあったので
						}
						});
				}
				else {
					_ASSERT(0);
					return 1;
				}
			}
		}

		if (s_motionpanel.radiobutton) {
			s_motionpanel.radiobutton->setSelectListener([]() {
				if (s_model) {
					int curindex = s_motionpanel.radiobutton->getSelectIndex();
					if ((s_opeselectmotioncnt < 0) && !s_underselectmotion && (curindex >= 0) && (curindex < s_model->GetMotInfoSize())) {
						s_opeselectmotioncnt = curindex;
						s_underselectmotion = true;
						//int motionindex = curindex;
						//OnAnimMenu(true, motionindex, 1);
						//s_motionpanel.panel->callRewrite();

						//ここでOnAnimMenuを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
					}
				}
				});
		}

		//s_motionpanel.panel->setPos(s_motionpanelpos);
		//s_motionpanel.panel->setSize(WindowSize(s_motionwindowwidth, s_motionwindowheight));

		s_rcmotionpanel.top = s_motionpanelpos.y;
		s_rcmotionpanel.bottom = s_motionpanelpos.y + s_motionwindowheight;
		s_rcmotionpanel.left = s_motionpanelpos.x;
		s_rcmotionpanel.right = s_motionpanelpos.x + s_motionwindowwidth;

		if (g_4kresolution) {
			//4K時は　フレーム組み込み表示
			if (s_motionpanel.panel) {
				s_motionpanel.panel->setVisible(true);
			}
			s_dispmotion = true;//!!!!!!!!!!!!!!!!! motionpanelのdispflag
		}
		else {
			if (s_motionpanel.panel) {
				s_motionpanel.panel->setVisible(false);
			}
			s_dispmotion = false;//!!!!!!!!!!!!!!!!! motionpanelのdispflag
		}
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;
}


int DestroyConvBoneWnd()
{
	s_convbone_model = 0;
	s_convbone_bvh = 0;
	s_convbonemap.clear();

	if (s_convboneWnd) {
		s_convboneWnd->setListenMouse(false);
		s_convboneWnd->setVisible(false);
		delete s_convboneWnd;
		s_convboneWnd = 0;
	}
	if (s_convboneSCWnd) {
		delete s_convboneSCWnd;
		s_convboneSCWnd = 0;
	}

	int cbno;
	for (cbno = 0; cbno < MAXBONENUM; cbno++) {
		if (s_modelbone[cbno]) {
			delete s_modelbone[cbno];
			s_modelbone[cbno] = 0;
		}
		if (s_bvhbone[cbno]) {
			delete s_bvhbone[cbno];
			s_bvhbone[cbno] = 0;
		}
		s_modelbone_bone[cbno] = 0;
		s_bvhbone_bone[cbno] = 0;
	}

	if (s_cbselmodel) {
		delete s_cbselmodel;
		s_cbselmodel = 0;
	}
	if (s_cbselbvh) {
		delete s_cbselbvh;
		s_cbselbvh = 0;
	}

	if (s_convboneconvert) {
		delete s_convboneconvert;
		s_convboneconvert = 0;
	}
	if (s_convbonespace1) {
		delete s_convbonespace1;
		s_convbonespace1 = 0;
	}
	if (s_convbonespace2) {
		delete s_convbonespace2;
		s_convbonespace2 = 0;
	}
	if (s_convbonespace3) {
		delete s_convbonespace3;
		s_convbonespace3 = 0;
	}
	if (s_convbonespace4) {
		delete s_convbonespace4;
		s_convbonespace4 = 0;
	}
	if (s_convbonespace5) {
		delete s_convbonespace5;
		s_convbonespace5 = 0;
	}
	if (s_rtgfilesave) {
		delete s_rtgfilesave;
		s_rtgfilesave = 0;
	}
	if (s_rtgfileload) {
		delete s_rtgfileload;
		s_rtgfileload = 0;
	}

	if (s_convbonesp) {
		delete s_convbonesp;
		s_convbonesp = 0;
	}

	if (s_convbonemidashi[0]) {
		delete s_convbonemidashi[0];
		s_convbonemidashi[0] = 0;
	}
	if (s_convbonemidashi[1]) {
		delete s_convbonemidashi[1];
		s_convbonemidashi[1] = 0;
	}

	s_convbonenum = 0;

	return 0;
}


int CreateConvBoneWnd()
{
	DestroyConvBoneWnd();

	s_dsretargetctrls.clear();

	if (!s_model) {
		_ASSERT(0);
		::MessageBox(g_mainhwnd, L"modelメニューでmodelを選択して下さい", L"model not selected !!!", MB_OK);
		return 0;
	}
	//if (s_model->GetBoneListSize() <= 1) {
	if (s_model->GetBoneForMotionSize() <= 1) {
		return 0;
	}


	s_convbone_model = s_model;

	//s_convbonenum = s_model->GetBoneListSize();
	s_convbonenum = s_model->GetBoneForMotionSize();
	if (s_convbonenum >= MAXBONENUM) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	s_convboneWnd = new OrgWindow(
		0,
		L"convbone0",		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),		//位置
		WindowSize(s_sidewidth, s_sideheight),	//サイズ
		L"ConvBoneWnd",	//タイトル
		g_mainhwnd,					//親ウィンドウハンドル
		false,					//表示・非表示状態
		//true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否
	if (s_convboneWnd) {
		s_convboneWnd->setSizeMin(WindowSize(150, 150));		// 最小サイズを設定

		//スクロールウインドウ
		s_convboneSCWnd = new OWP_ScrollWnd(L"ConvBoneScWnd", true);
		if (!s_convboneSCWnd) {
			_ASSERT(0);
			return 1;
		}

		//s_convboneSCWnd->setLineDataSize(s_convbonenum + 4);
		//2023/02/14
		//要素数が変わったときには指定し忘れないように！！！
		s_convboneSCWnd->setLineDataSize(s_convbonenum + 8);
		s_convboneWnd->addParts(*s_convboneSCWnd);


		WCHAR bvhbonename[MAX_PATH];
		int listno = 0;
		int cbno = 0;
		map<int, CBone*>::iterator itrbone;
		for (itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++) {
			CBone* curbone = itrbone->second;
			if (curbone && (curbone->IsSkeleton())) {
				const WCHAR* wbonename = curbone->GetWBoneName();
				_ASSERT(wbonename);
				s_modelbone[cbno] = new OWP_Label(wbonename);
				if (s_modelbone[cbno]) {
					s_modelbone_bone[cbno] = curbone;

					swprintf_s(bvhbonename, MAX_PATH, L"NotSet_%03d", cbno);
					s_bvhbone[cbno] = new OWP_Button(bvhbonename);
					if (s_bvhbone[cbno]) {
						s_bvhbone_bone[cbno] = 0;
						s_convbonemap[curbone] = 0;
#ifndef NDEBUG
						DbgOut(L"convbone %d : (%s,  %s)\n", cbno, wbonename, bvhbonename);
#endif
					}
					else {
						_ASSERT(0);
						return 1;
					}
				}
				else {
					_ASSERT(0);
					return 1;
				}

				cbno++;
			}
			listno++;
		}
#ifndef NDEBUG
		DbgOut(L"\n\n");
#endif
		if (cbno != s_convbonenum) {
			_ASSERT(0);
			return 1;
		}

		s_convbonesp = new OWP_Separator(s_convboneWnd, false, 0.5, true, s_convboneSCWnd);									// セパレータ1（境界線による横方向2分割）
		if (!s_convbonesp) {
			_ASSERT(0);
			return 1;
		}

		//s_cbselmodel = new OWP_Button(L"SelectShapeModel");
		WCHAR strtext[256] = { 0L };
		swprintf_s(strtext, 256, L"Model: %s", s_model->GetFileName());
		s_cbselmodel = new OWP_Label(strtext);
		if (!s_cbselmodel) {
			_ASSERT(0);
			return 1;
		}

		s_cbselbvh = new OWP_Button(L"SelectMotionModel");
		if (!s_cbselbvh) {
			_ASSERT(0);
			return 1;
		}
		s_convboneconvert = new OWP_Button(L"ConvertButton");
		if (!s_convboneconvert) {
			_ASSERT(0);
			return 1;
		}
		s_convbonespace1 = new OWP_Label(L"--------------");
		if (!s_convbonespace1) {
			_ASSERT(0);
			return 1;
		}
		s_convbonespace2 = new OWP_Label(L"--------------");
		if (!s_convbonespace2) {
			_ASSERT(0);
			return 1;
		}
		s_convbonespace3 = new OWP_Label(L"--------------");
		if (!s_convbonespace3) {
			_ASSERT(0);
			return 1;
		}
		s_convbonespace4 = new OWP_Label(L"--------------");
		if (!s_convbonespace4) {
			_ASSERT(0);
			return 1;
		}
		s_convbonespace5 = new OWP_Label(L"              ");
		if (!s_convbonespace5) {
			_ASSERT(0);
			return 1;
		}
		s_rtgfilesave = new OWP_Button(L"Save RtgFile");
		if (!s_rtgfilesave) {
			_ASSERT(0);
			return 1;
		}
		s_rtgfileload = new OWP_Button(L"Load RtgFile");
		if (!s_rtgfileload) {
			_ASSERT(0);
			return 1;
		}
		s_convbonemidashi[0] = new OWP_Label(L"ShapeSide");
		if (!s_convbonemidashi) {
			_ASSERT(0);
			return 1;
		}
		s_convbonemidashi[1] = new OWP_Label(L"MotionSide");
		if (!s_convbonemidashi) {
			_ASSERT(0);
			return 1;
		}

		COLORREF importantcolR = RGB(168, 129, 129);
		COLORREF importantcolG = RGB(0, 240, 0);
		COLORREF importantcolW = RGB(240, 240, 240);
		if (s_convboneconvert) {
			s_convboneconvert->setTextColor(importantcolG);
		}
		if (s_rtgfilesave) {
			s_rtgfilesave->setTextColor(importantcolG);
		}
		if (s_rtgfileload) {
			s_rtgfileload->setTextColor(importantcolG);
		}
		if (s_cbselbvh) {
			s_cbselbvh->setTextColor(importantcolR);
		}
		if (s_cbselmodel) {
			s_cbselmodel->setTextColor(importantcolR);
		}
		if (s_convbonespace1) {
			s_convbonespace1->setTextColor(importantcolW);
		}
		if (s_convbonespace2) {
			s_convbonespace2->setTextColor(importantcolW);
		}
		if (s_convbonespace3) {
			s_convbonespace3->setTextColor(importantcolW);
		}

		if (s_convboneSCWnd && s_convbonesp) {
			s_convboneSCWnd->addParts(*s_convbonesp);
		}
		if (s_convbonesp && s_convbonemidashi[0]) {
			s_convbonesp->addParts1(*s_convbonemidashi[0]);
		}
		if (s_convbonesp && s_cbselmodel) {
			s_convbonesp->addParts1(*s_cbselmodel);
		}
		if (s_convbonesp && s_convbonemidashi[1]) {
			s_convbonesp->addParts2(*s_convbonemidashi[1]);
		}
		if (s_convbonesp && s_cbselbvh) {
			s_convbonesp->addParts2(*s_cbselbvh);
		}
		if (s_cbselmodel) {
			s_dsretargetctrls.push_back(s_cbselmodel);
		}
		if (s_cbselbvh) {
			s_dsretargetctrls.push_back(s_cbselbvh);
		}


		//2023/02/14
		//convert実行、rtgファイル読み込みボタンは
		//ボーン名対応表よりも　上に配置
		//一番下までスクロールしなくても　操作できることが多くなるように
		if (s_convbonesp && s_convboneconvert) {
			s_convbonesp->addParts1(*s_convboneconvert);
		}
		if (s_convboneconvert) {
			s_dsretargetctrls.push_back(s_convboneconvert);
		}
		if (s_convbonesp && s_rtgfileload) {
			s_convbonesp->addParts2(*s_rtgfileload);
		}
		if (s_rtgfileload) {
			s_dsretargetctrls.push_back(s_rtgfileload);
		}

		//2023/02/14
		//境目に　空白
		if (s_convbonesp && s_convbonespace1) {
			s_convbonesp->addParts1(*s_convbonespace1);
		}
		if (s_convbonesp && s_convbonespace2) {
			s_convbonesp->addParts2(*s_convbonespace2);
		}

		for (cbno = 0; cbno < s_convbonenum; cbno++) {
			if (s_convbonesp && s_modelbone[cbno]) {
				s_convbonesp->addParts1(*s_modelbone[cbno]);
			}
			if (s_convbonesp && s_bvhbone[cbno]) {
				s_convbonesp->addParts2(*s_bvhbone[cbno]);
			}

			//s_dsretargetctrls.push_back(s_modelbone[cbno]);
			if (s_bvhbone[cbno]) {
				s_dsretargetctrls.push_back(s_bvhbone[cbno]);
			}
		}

		//2023/02/14
		//境目に　空白
		if (s_convbonesp && s_convbonespace3) {
			s_convbonesp->addParts1(*s_convbonespace3);
		}
		if (s_convbonesp && s_convbonespace4) {
			s_convbonesp->addParts2(*s_convbonespace4);
		}

		//Rtgファイル保存ボタンは　設定し終わってから押すので　一番下のまま
		if (s_convbonesp && s_rtgfilesave) {
			s_convbonesp->addParts1(*s_rtgfilesave);
			s_dsretargetctrls.push_back(s_rtgfilesave);
		}
		if (s_convbonesp && s_convbonespace5) {
			s_convbonesp->addParts2(*s_convbonespace5);
		}

		if (s_convboneWnd) {
			s_convboneWnd->setListenMouse(false);
			s_convboneWnd->setVisible(0);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		}

		////////////
		if (s_convboneWnd) {
			s_convboneWnd->setCloseListener([]() {
				if (s_model) {
					s_closeconvboneFlag = true;
				}
				});
		}

		//s_cbselmodel->setButtonListener([](){
		//	if (s_model) {
		//		SetConvBoneModel();
		//		s_convboneWnd->callRewrite();
		//	}
		//});
		if (s_cbselbvh) {
			s_cbselbvh->setButtonListener([]() {
				if (s_model) {
					if (!s_convbone_model || (s_convbone_model != s_model)) {
						::DSMessageBox(g_mainhwnd, L"Retry after selecting ShapeModel using ModelMenu Of MainWindow.", L"error!!!", MB_OK);
					}
					else {
						SetConvBoneBvh();
					}
					s_convboneWnd->callRewrite();
				}
				});
		}

		for (cbno = 0; cbno < s_convbonenum; cbno++) {
			if (s_bvhbone[cbno]) {
				s_bvhbone[cbno]->setButtonListener([cbno]() {
					if (s_model) {
						SetConvBone(cbno);
						//CModel* curmodel = s_modelindex[modelcnt].modelptr;
						//curmodel->SetModelDisp(s_modelpanel.checkvec[modelcnt]->getValue());
						s_convboneWnd->callRewrite();
					}
				});
			}
		}

		if (s_convboneconvert) {
			s_convboneconvert->setButtonListener([]() {
				if (s_model) {
					if (s_retargetguiFlag == false) {
						s_retargetguiFlag = true;
					}
				}
				});
		}

		if (s_rtgfilesave) {
			s_rtgfilesave->setButtonListener([]() {
				if (s_model) {
					SaveRetargetFile();
				}
				});
		}
		if (s_rtgfileload) {
			s_rtgfileload->setButtonListener([]() {
				if (s_model) {
					LoadRetargetFile(0);
				}
				});
		}
		if (s_convboneWnd) {
			s_convboneWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
			s_convboneWnd->setPos(WindowPos(windowposx, s_sidemenuheight));
			//１クリック目問題対応
			s_convboneWnd->refreshPosAndSize();//2022/09/20

			s_convboneWnd->setVisible(false);
		}
	}
	else{
		_ASSERT(0);
		return 1;
	}

	return 0;
}

//int SetConvBoneModel()
//{
//	int modelnum = (int)s_modelindex.size();
//	if (modelnum <= 0){
//		return 0;
//	}
//
//	HWND parwnd;
//	//parwnd = s_convboneWnd->getHWnd();
//	parwnd = s_3dwnd;
//
//	CRMenuMain* rmenu;
//	rmenu = new CRMenuMain(IDR_RMENU);
//	if (!rmenu){
//		return 1;
//	}
//	int ret;
//	ret = rmenu->Create(parwnd, MENUOFFSET_SETCONVBONEMODEL);
//	if (ret){
//		return 1;
//	}
//
//	HMENU submenu = rmenu->GetSubMenu();
//
//	int menunum;
//	menunum = GetMenuItemCount(submenu);
//	int menuno;
//	for (menuno = 0; menuno < menunum; menuno++)
//	{
//		RemoveMenu(submenu, 0, MF_BYPOSITION);
//	}
//
//	int modelno;
//	for (modelno = 0; modelno < modelnum; modelno++){
//		CModel* curmodel = s_modelindex[modelno].modelptr;
//		if (curmodel){
//			const WCHAR* modelname = curmodel->GetFileName();
//			if (modelname){
//				int setmenuid = ID_RMENU_0 + modelno + MENUOFFSET_SETCONVBONEMODEL;
//				AppendMenu(submenu, MF_STRING, setmenuid, modelname);
//			}
//		}
//	}
//
//
//	POINT pt;
//	GetCursorPos(&pt);
//	//::ScreenToClient(parwnd, &pt);
//
//	s_cursubmenu = rmenu->GetSubMenu();
//
//	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
//	int menuid;
//	menuid = rmenu->TrackPopupMenu(pt);
//	//if ((menuid >= ID_RMENU_0) && (menuid < (ID_RMENU_0 + modelnum))) {
//	//	int modelindex = menuid - ID_RMENU_0;
//	//	s_convbone_model = s_modelindex[modelindex].modelptr;
//
//	//	WCHAR strmes[1024];
//	//	if (!s_convbone_model) {
//	//		swprintf_s(strmes, 1024, L"convbone : sel model : modelptr NULL !!!");
//	//		::DSMessageBox(NULL, strmes, L"check", MB_OK);
//	//	}
//	//	else {
//	//		swprintf_s(strmes, 1024, L"%s", s_convbone_model->GetFileName());
//	//		s_cbselmodel->setName(strmes);
//	//	}
//	//}
//
//
//	rmenu->Destroy();
//	delete rmenu;
//	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
//
//	return 0;
//}

int SetConvBoneBvh()
{

	if (!s_chascene) {
		_ASSERT(0);
		return 0;
	}

	int modelnum = s_chascene->GetModelNum();

	if (modelnum <= 0) {
		return 0;
	}

	HWND parwnd;
	//parwnd = s_convboneWnd->getHWnd();
	parwnd = s_3dwnd;


	//###############################
	//joint対応表リセット 2022/09/13
	//###############################
	InitJointPair2ConvBoneWnd();


	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_SETCONVBONEBVH);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}

	int modelno;
	for (modelno = 0; modelno < modelnum; modelno++) {
		CModel* curmodel = s_chascene->GetModel(modelno);
		if (curmodel) {
			const WCHAR* modelname = curmodel->GetFileName();
			if (modelname) {
				int setmenuid = ID_RMENU_0 + modelno + MENUOFFSET_SETCONVBONEBVH;
				AppendMenu(submenu, MF_STRING, setmenuid, modelname);
			}
		}
	}


	POINT pt;
	GetCursorPos(&pt);
	//::ScreenToClient(parwnd, &pt);

	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);
	//if ((menuid >= ID_RMENU_0) && (menuid < (ID_RMENU_0 + modelnum))){
	//	int modelindex = menuid - ID_RMENU_0;
	//	s_convbone_bvh = s_modelindex[modelindex].modelptr;

	//	WCHAR strmes[1024];
	//	if (!s_convbone_bvh){
	//		swprintf_s(strmes, 1024, L"convbone : sel model : modelptr NULL !!!");
	//		::DSMessageBox(NULL, strmes, L"check", MB_OK);
	//	}
	//	else{
	//		swprintf_s(strmes, 1024, L"%s", s_convbone_bvh->GetFileName());
	//		s_cbselbvh->setName(strmes);
	//	}
	//}


	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	if (s_convboneWnd) {
		//2023/10/15
		//OrgWindowのLisner関数でコンテクストメニューを出した場合　メニュー終了時にLBUTTONUPを呼び出す必要有り
		//呼び出さなかった場合　SetCaptureとReleaseCaptureのバランスが崩れて　スクロールバーを画面外でBUTTONUPしたときに処理されない
		::SendMessage(s_convboneWnd->getHWnd(), WM_LBUTTONUP, 0, 0);
	}


	return 0;
}
int SetConvBone(int cbno)
{
	s_bvhbone_cbno = cbno;

	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}

	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}

	if (!s_convbone_model || !s_convbone_bvh) {
		return 0;
	}

	HWND parwnd;
	//parwnd = s_convboneWnd->getHWnd();
	parwnd = s_3dwnd;
	//parwnd = NULL;


	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_SETCONVBONE);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}

	int setmenuid0 = ID_RMENU_0 + 0 + MENUOFFSET_SETCONVBONE;
	AppendMenu(submenu, MF_STRING, setmenuid0, L"NotSet");

	int maxboneno = 0;
	map<int, CBone*>::iterator itrbone;
	for (itrbone = s_convbone_bvh->GetBoneListBegin(); itrbone != s_convbone_bvh->GetBoneListEnd(); itrbone++) {
		CBone* curbone = itrbone->second;
		if (curbone && (curbone->IsSkeleton())) {
			int boneno = curbone->GetBoneNo();
			int setmenuid = ID_RMENU_0 + boneno + 1 + MENUOFFSET_SETCONVBONE;
			AppendMenu(submenu, MF_STRING, setmenuid, curbone->GetWBoneName());
			if (boneno > maxboneno) {
				maxboneno = boneno;
			}
		}
	}
	//s_maxboneno = s_convbone_bvh->GetBoneListSize();
	//s_maxboneno = s_convbone_bvh->GetBoneForMotionSize();
	s_maxboneno = s_convbone_bvh->GetMaxBoneNo();

	POINT pt;
	GetCursorPos(&pt);
	//::ScreenToClient(parwnd, &pt);

	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);
	//if ((menuid >= ID_RMENU_0) && (menuid <= (ID_RMENU_0 + maxboneno + 1))){
	//	if (menuid == (ID_RMENU_0 + 0)){
	//		//未設定
	//		s_bvhbone_bone[cbno] = 0;
	//		CBone* modelbone = s_modelbone_bone[cbno];
	//		_ASSERT(modelbone);
	//		if (modelbone){
	//			s_convbonemap[modelbone] = 0;
	//		}
	//		s_bvhbone[cbno]->setName(L"NotSet");
	//	}
	//	else{
	//		int boneno = menuid - ID_RMENU_0 - 1;
	//		CBone* curbone = s_convbone_bvh->GetBoneByID(boneno);
	//		WCHAR strmes[1024];
	//		if (!curbone){
	//			s_bvhbone_bone[cbno] = 0;
	//			CBone* modelbone = s_modelbone_bone[cbno];
	//			_ASSERT(modelbone);
	//			if (modelbone){
	//				s_convbonemap[modelbone] = 0;
	//			}
	//			s_bvhbone[cbno]->setName(L"NotSet");
	//
	//			swprintf_s(strmes, 1024, L"convbone : sel bvh bone : curbone NULL !!!");
	//			::DSMessageBox(NULL, strmes, L"check", MB_OK);
	//		}
	//		else{
	//			swprintf_s(strmes, 1024, L"%s", curbone->GetWBoneName());
	//			s_bvhbone[cbno]->setName(strmes);
	//			s_bvhbone_bone[cbno] = curbone;
	//
	//			CBone* modelbone = s_modelbone_bone[cbno];
	//			if (modelbone){
	//				s_convbonemap[modelbone] = curbone;
	//			}
	//		}
	//	}
	//}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	if (s_convboneWnd) {
		//2023/10/15
		//OrgWindowのLisner関数でコンテクストメニューを出した場合　メニュー終了時にLBUTTONUPを呼び出す必要有り
		//呼び出さなかった場合　SetCaptureとReleaseCaptureのバランスが崩れて　スクロールバーを画面外でBUTTONUPしたときに処理されない
		::SendMessage(s_convboneWnd->getHWnd(), WM_LBUTTONUP, 0, 0);
	}


	return 0;
}

int InitJointPair2ConvBoneWnd()
{
	if (!s_model) {
		return 0;
	}

	s_convbonemap.clear();


	WCHAR bvhbonename[MAX_PATH];
	int cbno = 0;
	map<int, CBone*>::iterator itrbone;
	for (itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++) {
		CBone* curbone = itrbone->second;
		if (curbone && (curbone->IsSkeleton())) {
			swprintf_s(bvhbonename, MAX_PATH, L"NotSet_%03d", cbno);
			(s_bvhbone[cbno])->setName(bvhbonename);
			s_bvhbone_bone[cbno] = 0;

			cbno++;
		}
	}

	return 0;
}

int SetJointPair2ConvBoneWnd()
{
	if (s_convbonemap.empty()) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_convbone_bvh) {
		return 0;
	}

	WCHAR bvhbonename[MAX_PATH];
	int cbno = 0;
	map<int, CBone*>::iterator itrbone;
	for (itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++) {
		CBone* curbone = itrbone->second;
		if (curbone && (curbone->IsSkeleton())) {
			CBone* bvhbone = s_convbonemap[curbone];
			if (bvhbone) {
				swprintf_s(bvhbonename, MAX_PATH, bvhbone->GetWBoneName());
				(s_bvhbone[cbno])->setName(bvhbonename);
				s_bvhbone_bone[cbno] = bvhbone;
			}
			else {
				swprintf_s(bvhbonename, MAX_PATH, L"NotSet_%03d", cbno);
				(s_bvhbone[cbno])->setName(bvhbonename);
				s_bvhbone_bone[cbno] = 0;
			}

			cbno++;
		}
	}

	_ASSERT(cbno == s_convbonenum);

	return 0;
}


int SaveMotionNameListFile()
{

	ChangeCurDirFromMameMediaToTest();

	//OPENFILENAME ofn;//stack size warning (MULTIPATH)
	OPENFILENAME* ofn = (OPENFILENAME*)malloc(sizeof(OPENFILENAME));
	if (!ofn) {
		_ASSERT(0);
		return 1;
	}
	ZeroMemory(ofn, sizeof(OPENFILENAME));

	ofn->lStructSize = sizeof(OPENFILENAME);
	//ofn->hwndOwner = hDlgWnd;
	ofn->hwndOwner = s_3dwnd;
	ofn->hInstance = 0;
	ofn->lpstrFilter = L"Retarget(*.mnl)\0*.mnl\0";
	ofn->lpstrCustomFilter = NULL;
	ofn->nMaxCustFilter = 0;
	ofn->nFilterIndex = 0;
	ofn->lpstrFile = g_tmpmqopath;
	ofn->nMaxFile = MULTIPATH;
	ofn->lpstrFileTitle = NULL;
	ofn->nMaxFileTitle = 0;
	ofn->lpstrInitialDir = NULL;
	ofn->lpstrTitle = L"GetFileNameDlg";
	//ofn->Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	ofn->Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn->nFileOffset = 0;
	ofn->nFileExtension = 0;
	ofn->lpstrDefExt = NULL;
	ofn->lCustData = NULL;
	ofn->lpfnHook = NULL;
	ofn->lpTemplateName = NULL;

	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);


	WCHAR* pext;
	pext = wcsstr(g_tmpmqopath, L".mnl");
	if (!pext) {
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MAX_PATH);//異なる拡張子のファイル名が残っている場合があるから
	}

	if (GetOpenFileNameW(ofn) == IDOK) {
		CMNLFile mnlfile;
		int result;
		result = mnlfile.WriteMNLFile(g_tmpmqopath, s_model);
	}

	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	//UnhookWinEvent(hhook);
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;


	if (ofn) {
		free(ofn);
		ofn = 0;
	}

	return 0;
}



int SaveRetargetFile()
{

	ChangeCurDirFromMameMediaToTest();

	int result = 0;
	WCHAR savepath[MULTIPATH];
	ZeroMemory(savepath, sizeof(WCHAR) * MULTIPATH);


	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = hDlgWnd;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"Retarget(*.rtg)\0*.rtg\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 0;
	ofn.lpstrFile = g_tmpmqopath;
	ofn.nMaxFile = MULTIPATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = NULL;
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);


	WCHAR* pext;
	pext = wcsstr(g_tmpmqopath, L".rtg");
	if (!pext) {
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MAX_PATH);//異なる拡張子のファイル名が残っている場合があるから
	}

	if (GetOpenFileNameW(&ofn) == IDOK) {

		MoveMemory(savepath, g_tmpmqopath, sizeof(WCHAR) * MAX_PATH);//MULTIPATHではない

		CRetargetFile rtgfile;
		result = rtgfile.WriteRetargetFile(g_tmpmqopath, s_convbone_model, s_convbone_bvh, s_convbonemap);
		if (result != 0) {
			::MessageBox(NULL, L"保存に失敗しました。\n書き込み禁止ディレクトリの可能性があります。\n保存場所を変えて再試行してみてください。", L"エラー", MB_OK);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
			_ASSERT(0);
			return 1;
		}
	}


	//履歴を保存
	if ((result == 0) && (savepath[0] != 0L)) {
		SaveRtgHistory(savepath);
	}


	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	//UnhookWinEvent(hhook);
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;

	return 0;
}
int LoadRetargetFile(WCHAR* srcfilename)
{
	if (!s_convbone_model || !s_convbone_bvh) {
		_ASSERT(0);
		return 1;
	}

	ChangeCurDirFromMameMediaToTest();

	s_convbonemap.clear();


	//OPENFILENAME ofn;
	//ofn.lStructSize = sizeof(OPENFILENAME);
	////ofn.hwndOwner = hDlgWnd;
	//ofn.hwndOwner = s_3dwnd;
	//ofn.hInstance = 0;
	//ofn.lpstrFilter = L"Retarget(*.rtg)\0*.rtg\0";
	//ofn.lpstrCustomFilter = NULL;
	//ofn.nMaxCustFilter = 0;
	//ofn.nFilterIndex = 0;
	//ofn.lpstrFile = g_tmpmqopath;
	//ofn.nMaxFile = MULTIPATH;
	//ofn.lpstrFileTitle = NULL;
	//ofn.nMaxFileTitle = 0;
	//ofn.lpstrInitialDir = NULL;
	//ofn.lpstrTitle = L"GetFileNameDlg";
	////ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	//ofn.nFileOffset = 0;
	//ofn.nFileExtension = 0;
	//ofn.lpstrDefExt = NULL;
	//ofn.lCustData = NULL;
	//ofn.lpfnHook = NULL;
	//ofn.lpTemplateName = NULL;

	int result = 0;

	if (srcfilename == 0) {
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
		//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
		InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

		int dlgret;
		s_filterindex = 7;
		dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_OPENMQODLG),
			s_3dwnd, (DLGPROC)OpenMqoDlgProc);
		if ((dlgret != IDOK) || (g_tmpmqopath[0] == 0L)) {

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			return 0;
		}


		//WCHAR savepath[MULTIPATH];//stack size warning
		WCHAR* tmpsavepath = new WCHAR[MULTIPATH];
		if (!tmpsavepath) {
			_ASSERT(0);
			return 1;
		}
		ZeroMemory(tmpsavepath, sizeof(WCHAR) * MULTIPATH);
		MoveMemory(tmpsavepath, g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);


		//rtgファイルを読み込む
		CRetargetFile rtgfile;
		result = rtgfile.LoadRetargetFile(g_tmpmqopath, s_convbone_model, s_convbone_bvh, s_convbonemap);
		if (result == 0) {
			//if (g_retargetbatchflag == 0) {
			if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
				SetJointPair2ConvBoneWnd();
			}
		}

		SaveRtgHistory(tmpsavepath);
		if (tmpsavepath)
			delete[] tmpsavepath;


		//if (GetOpenFileNameW(&ofn) == IDOK) {
		//	CRetargetFile rtgfile;
		//	result = rtgfile.LoadRetargetFile(g_tmpmqopath, s_convbone_model, s_convbone_bvh, s_convbonemap);
		//	if (result == 0) {
		//		//if (g_retargetbatchflag == 0) {
		//		if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
		//			SetJointPair2ConvBoneWnd();
		//		}
		//	}
		//}

		InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
		//UnhookWinEvent(hhook);
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;

	}
	else {
		//s_getfilenamehwnd = 0;
		//s_getfilenametreeview = 0;
		//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
		//InterlockedExchange(&g_undertrackingRMenu, (LONG)1);


		//ファイル名指定時はそのまま開く
		//バッチからも呼ばれる

		CRetargetFile rtgfile;
		result = rtgfile.LoadRetargetFile(srcfilename, s_convbone_model, s_convbone_bvh, s_convbonemap);
		if (result == 0) {
			//if (g_retargetbatchflag == 0) {
			if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
				SetJointPair2ConvBoneWnd();
			}
		}

		//InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
		////UnhookWinEvent(hhook);
		//s_getfilenamehwnd = 0;
		//s_getfilenametreeview = 0;
	}
	return result;
}


int RetargetMotion()
{
	//static CModel* s_convbone_model = 0;
	//static CModel* s_convbone_model_batch = 0;
	//static CModel* s_convbone_bvh = 0;

	if (!s_convbone_model || !s_convbone_bvh) {
		return 0;
	}

	if (s_model != s_convbone_model) {
		::DSMessageBox(NULL, L"Retry After Selectiong ShapeModel using ModelMenu Of MainWindow.", L"error!!!", MB_OK);
		s_convbone_model->SetUnderRetarget(false);
		return 1;
	}

	int result = s_convbone_model->Retarget(s_convbone_bvh, s_matVP, s_convbonemap, AddMotion);
	if (result) {
		_ASSERT(0);
		//g_underRetargetFlag = false;
		s_convbone_model->SetUnderRetarget(false);
		return 1;
	}
	//g_underRetargetFlag = false;
	s_convbone_model->SetUnderRetarget(false);


	if (g_limitdegflag == true) {
		CopyWorldToLimitedWorld(s_model);
		ApplyNewLimitsToWM(s_model);
	}


	return 0;

}


int SetCamera6Angle()
{

	ChaVector3 weye, wdiff;
	weye = g_camEye;
	wdiff = g_camtargetpos - weye;
	float camdist = (float)ChaVector3LengthDbl(&wdiff);

	ChaVector3 neweye;
	float delta = 0.10f;

	if (g_keybuf[VK_F1] & 0x80) {
		neweye.x = g_camtargetpos.x;
		neweye.y = g_camtargetpos.y;
		neweye.z = g_camtargetpos.z - camdist;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);

	}
	else if (g_keybuf[VK_F2] & 0x80) {
		neweye.x = g_camtargetpos.x;
		neweye.y = g_camtargetpos.y;
		neweye.z = g_camtargetpos.z + camdist;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}
	else if (g_keybuf[VK_F3] & 0x80) {
		neweye.x = g_camtargetpos.x - camdist;
		neweye.y = g_camtargetpos.y;
		neweye.z = g_camtargetpos.z;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}
	else if (g_keybuf[VK_F4] & 0x80) {
		neweye.x = g_camtargetpos.x + camdist;
		neweye.y = g_camtargetpos.y;
		neweye.z = g_camtargetpos.z;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}
	else if (g_keybuf[VK_F5] & 0x80) {
		neweye.x = g_camtargetpos.x;
		neweye.y = g_camtargetpos.y + camdist;
		neweye.z = g_camtargetpos.z + delta;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}
	else if (g_keybuf[VK_F6] & 0x80) {
		neweye.x = g_camtargetpos.x;
		neweye.y = g_camtargetpos.y - camdist;
		neweye.z = g_camtargetpos.z - delta;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}

	ChaVector3 diffv;
	diffv = g_camEye - g_camtargetpos;
	g_camdist = (float)ChaVector3LengthDbl(&diffv);

	SetCamera3DFromEyePos();

	return 0;
}

int OnAddMotion(int srcmotid, bool dorefreshtl)
{
	static int s_dbgcnt = 0;
	s_dbgcnt++;

	//MOTINFO* newmotinfo = s_model->GetMotInfo( srcmotid );

//WCHAR strchk[256] = { 0L };
//swprintf_s(strchk, 256, L"check OnAddMotion : 1 : %d, %d", srcmotid, (int)dorefreshtl);
//::MessageBox(g_mainhwnd, strchk, L"check!!!", MB_OK);

	CallF(AddTimeLine(srcmotid, dorefreshtl), return 1);

	//swprintf_s(strchk, 256, L"check OnAddMotion : 2 : %d, %d", srcmotid, (int)dorefreshtl);
	//::MessageBox(g_mainhwnd, strchk, L"check!!!", MB_OK);

	int selindex = (int)s_tlarray.size() - 1;
	CallF(OnAnimMenu(dorefreshtl, selindex), return 1);

	//swprintf_s(strchk, 256, L"check OnAddMotion : 3 : %d, %d", srcmotid, (int)dorefreshtl);
	//::MessageBox(g_mainhwnd, strchk, L"check!!!", MB_OK);


	return 0;

}

int StopBt()
{
	if (!s_chascene) {
		_ASSERT(0);
		return 0;
	}

	s_chascene->StopBt();


	//g_previewFlag = 0;

	//2022/11/07 btrec終了時にも　timeline表示を正常にするために　playerbuttonのpreviewstopと同じ処理をする
	s_LstopFlag = true; s_LcursorFlag = true; g_previewFlag = 0;



	////g_limitdegflag = s_savelimitdegflag;
	////if (s_LimitDegCheckBox) {
	////	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
	////}

	return 0;
}


int StartBt(CModel* curmodel, BOOL isfirstmodel, int flag, int btcntzero)
{
	if (!s_model || !curmodel || !s_chascene) {
		return 0;
	}

	if (s_model->GetNoBoneFlag()) {
		return 0;
	}
	if (!s_owpTimeline || !s_owpLTimeline || !s_owpEulerGraph) {
		return 0;
	}

	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//previewmodeがglobalなのでmodelごとにモードを設定するようにはなっていない。
	//ひとまず、全モデルへの適用という形をとってエラーにならないようにする。
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


	double curframe = 1.0;//初期値、start時の揺れに影響？

	if (flag == 1) {
		//まず物理IKを停止する。
		//プレビューを止めないとtimelineはスタートフレームになるが姿勢がスタートフレームにならない。
		//flag == 0で呼ぶとシミュが動かない。

		s_chascene->StopBt();

		g_previewFlag = 0;//!!!!!!!!!!!!!!!!!!!!!!!!!!!

		s_previewrange = s_editrange;
		//double rangestart;
		if (s_previewrange.IsSameStartAndEnd()) {
			//rangestart = 1.0;
			curframe = 1.0;
		}
		else {
			if (g_previewFlag == 5) {
				int tmpleng;
				double tmpstart, tmpend;
				s_previewrange.GetRange(&tmpleng, &tmpstart, &tmpend);
				curframe = s_previewrange.GetApplyFrame();
			}
			else {
				//rangestart = s_previewrange.GetStartFrame();
				curframe = s_previewrange.GetStartFrame();
			}
		}

		s_owpLTimeline->setCurrentTime(curframe, true);
		s_owpEulerGraph->setCurrentTime(curframe, false);

		OnFramePreviewStop();
	}

	static int resetflag = 0;//!!!!!!!!!!!!!!!!!!!! static 
	static int createflag = 0;//!!!!!!!!!!!!!!!!!!!! static 

	if (isfirstmodel == TRUE) {
		if ((flag == 0) && (g_previewFlag != 4)) {
			//F9キー
			g_previewFlag = 4;
			createflag = 1;
			resetflag = 0;//2021/06/18
		}
		else if (flag == 1) {
			//F10キー
			g_previewFlag = 5;
			createflag = 1;
			resetflag = 0;//2021/06/18
		}
		else if (flag == 2) {
			//spaceキー
			if (g_previewFlag == 4) {
				createflag = 1;//2021/06/18
				resetflag = 1;
			}
			else if (g_previewFlag == 5) {
				createflag = 1;//2021/06/18
				resetflag = 0;
			}
		}
		else {
			g_previewFlag = 0;
		}
	}


	int modelnum = s_chascene->GetModelNum();
	int modelcount;
	for (modelcount = 0; modelcount < modelnum; modelcount++) {
		CModel* pmodel = s_chascene->GetModel(modelcount);

		if (pmodel) {

			//if ((flag == 0) && (g_previewFlag != 4)){
				//F9キー
			if (btcntzero == 1) {
				pmodel->ZeroBtCnt();
				pmodel->SetCreateBtFlag(false);
			}
			//}
			//else if (flag == 1){
			//	//F10キー
			//	if (btcntzero == 1){
			//		curmodel->ZeroBtCnt();
			//		curmodel->SetCreateBtFlag(false);
			//	}
			//}


			//double curframe;
			if (flag == 0) {// bt simu
				if (resetflag == 1) {
					curframe = s_owpTimeline->getCurrentTime();
					//curmodel->GetMotionFrame(&curframe);
				}
				else {
					s_previewrange = s_editrange;
					//double rangestart;
					if (s_previewrange.IsSameStartAndEnd()) {
						//rangestart = 1.0;
						curframe = 1.0;
					}
					else {
						if (g_previewFlag == 5) {
							int tmpleng;
							double tmpstart, tmpend;
							s_previewrange.GetRange(&tmpleng, &tmpstart, &tmpend);
							curframe = s_previewrange.GetApplyFrame();
						}
						else {
							//rangestart = s_previewrange.GetStartFrame();
							curframe = s_previewrange.GetStartFrame();
						}
					}
					//curframe = 1.0;//!!!!!!!!!!

					//curframe = s_editrange.GetStartFrame();
					//curframe = s_buttonselectstart;

					s_owpLTimeline->setCurrentTime(curframe, false);
					s_owpEulerGraph->setCurrentTime(curframe, false);
				}
			}
			else if (flag == 2) {//2021/06/18
				if (resetflag == 1) {
					//curframe = s_owpTimeline->getCurrentTime();
					pmodel->GetMotionFrame(&curframe);
					s_owpLTimeline->setCurrentTime(curframe, false);
					s_owpEulerGraph->setCurrentTime(curframe, false);
				}
			}

			if ((g_previewFlag == 4) || (g_previewFlag == 5)) {

				if (g_previewFlag == 4) {
					//curmodel->SetCurrentRigidElem(s_curreindex);//s_curreindexをmodelごとに持つ必要あり！！！
					pmodel->SetCurrentRigidElem(s_reindexmap[pmodel]);//s_curreindexをmodelごとに持つ必要あり！！！

					//決め打ち
					s_btWorld->setGravity(btVector3(0.0f, -9.8f, 0.0f)); // 重力加速度の設定　//SetBtKinFlagReqにて剛体ごとにも設定



					//s_btWorld->setGravity(btVector3(0.0, 0.0, 0.0)); // 重力加速度の設定
					s_bpWorld->setGlobalERP(btScalar(g_erp));// ERP



					//s_model->SetAllKData(-1, s_curreindex, 3, 3, 800.0, 20.0);
					//curmodel->SetAllKData(-1, s_curreindex, 3, 3, 1000.0, 30.0);


					//決め打ち
					//curmodel->SetAllMassDataByBoneLeng(-1, s_curreindex, 30.0);//!!!!!!!! Mass自動設定中 !!!!!


					pmodel->SetMotionFrame(curframe);

					//vector<MODELELEM>::iterator itrmodel2;
					//for (itrmodel2 = s_modelindex.begin(); itrmodel2 != s_modelindex.end(); itrmodel2++) {
					//	CModel* updatemodel = itrmodel2->modelptr;
					//	if (updatemodel) {
					//		ChaMatrix tmpwm = updatemodel->GetWorldMat();
					//		updatemodel->UpdateMatrix(&tmpwm, &s_matVP);
					//	}
					//}
					ChaMatrix tmpwm = pmodel->GetWorldMat();
					pmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);

					//curmodel->SetCurrentRigidElem(s_curreindex);//s_curreindexをmodelごとに持つ必要あり！！！reの内容を変えてから呼ぶ
					//s_curreindex = 1;
					pmodel->SetMotionSpeed(g_dspeed);
				}
				else if (g_previewFlag == 5) {
					s_rectime = 0.0;
					s_reccnt = 0;

					pmodel->SetCurrentRigidElem(s_rgdindexmap[pmodel]);//s_rgdindexをmodelごとに持つ必要あり！！！

					s_btWorld->setGravity(btVector3(0.0, 0.0, 0.0)); // 重力加速度の設定

					//s_bpWorld->setGlobalERP(btScalar(g_erp));// ERP

				//ラグドールの時のERPは決め打ち
					s_bpWorld->setGlobalERP(0.0);// ERP
					//s_bpWorld->setGlobalERP(1.0);// ERP
					//s_bpWorld->setGlobalERP(0.2);// ERP
					//s_bpWorld->setGlobalERP(0.001);// ERP
					//s_bpWorld->setGlobalERP(1.0e-8);// ERP


					//s_bpWorld->setGlobalERP(0.00020);// ERP
					//s_bpWorld->setGlobalERP(0.00030);// ERP
					//s_bpWorld->setGlobalERP(g_erp);// ERP
					//s_bpWorld->setGlobalERP(0.00040);// ERP
					//s_bpWorld->setGlobalERP(0.0010);// ERP
					//s_bpWorld->setGlobalERP(0.80);// ERP


					//s_bpWorld->setGlobalERP(0.0010);// ERP
					//s_bpWorld->setGlobalERP(0.0020);// ERP
					//s_bpWorld->setGlobalERP(0.0040);// ERP !!!!

					//s_bpWorld->setGlobalERP(0.0100);// ERP
					//s_bpWorld->setGlobalERP(0.0200);// ERP
					//s_bpWorld->setGlobalERP(0.0400);// ERP

					//s_bpWorld->setGlobalERP(g_erp);// ERP



					pmodel->SetMotionFrame(curframe);

					//vector<MODELELEM>::iterator itrmodel3;
					//for (itrmodel3 = s_modelindex.begin(); itrmodel3 != s_modelindex.end(); itrmodel3++) {
					//	CModel* updatemodel = itrmodel3->modelptr;
					//	if (updatemodel) {
					//		ChaMatrix tmpwm = updatemodel->GetWorldMat();
					//		updatemodel->UpdateMatrix(&tmpwm, &s_matVP);
					//	}
					//}
					ChaMatrix tmpwm = pmodel->GetWorldMat();
					pmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);


					//curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 1000.0, 0.1);

					//決め打ち
					pmodel->SetAllKData(-1, s_rgdindexmap[pmodel], 3, 3, 1500.0, 30.0);

					//curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 800.0, 30.0);

/*
					curmodel->SetColTypeAll(s_rgdindex, COL_CONE_INDEX);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					//curmodel->SetColTypeAll(s_rgdindex, COL_CAPSULE_INDEX);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!



				//ラグドールの時のバネは決め打ち
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 1e4, 10.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 230.0, 30.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 600.0, 60.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 600.0, 30.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 600.0, 10.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 400.0, 10.0);

					//s_model->SetAllMassData(-1, s_rgdindex, 1e-9);
					//s_model->SetAllMassData(-1, s_rgdindex, 0.5);
					//s_model->SetAllMassData(-1, s_rgdindex, 1.0);
					//s_model->SetAllMassData(-1, s_rgdindex, 10.0);


					//if (s_physicskind == 0) {
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 800.0, 30.0);
						curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 800.0, 20.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 1600.0, 20.0);
					//}
					//else {
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 1000.0, 60.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 2000.0, 60.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 10000.0, 60.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 13000.0, 200.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 40000.0, 100.0);
					//	curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 1000.0, 30.0);
					//}

					//curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 0.0, 20.0);

					//s_model->SetAllMassData(-1, s_rgdindex, 100.0);
					//s_model->SetAllMassData(-1, s_rgdindex, 30.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 800.0, 30.0);
*/
//決め打ち
					pmodel->SetAllMassDataByBoneLeng(-1, s_rgdindexmap[pmodel], 30.0);

					//curmodel->SetAllMassData(-1, s_rgdindex, 1.0);


					pmodel->SetMotionSpeed(g_dspeed);
				}

				s_btstartframe = curframe;

				//CallF(curmodel->CreateBtObject(s_coldisp, 0), return 1);
				CallF(pmodel->CreateBtObject(g_limitdegflag, 1), return 1);


				//if( g_previewFlag == 4 ){

				//pmodel->BulletSimulationStart();





				//s_bpWorld->clientResetScene();
				//if( s_model ){
				//	s_model->ResetBt();
				//}
				//int firstflag = 1;
				//s_model->Motion2Bt(firstflag, s_coldisp, s_btstartframe, &s_matW, &s_matVP);
				//int rgdollflag = 0;
				//double difftime = 0.0;
				//s_model->SetBtMotion(rgdollflag, s_btstartframe, &s_matW, &s_matVP);
				//s_model->ResetBt();



				//UpdateBtSimu(curframe, curmodel);




				//}

				//if( g_previewFlag == 5 ){
				//	s_model->SetBtImpulse();
				//}


				if (pmodel->GetRgdMorphIndex() >= 0) {
					MOTINFO* morphmi = pmodel->GetRgdMorphInfo();
					if (morphmi) {
						//morphmi->curframe = 0.0;
						morphmi->curframe = s_btstartframe;
					}
				}

			}
		}
	}

	//curmodel : 引数で渡されたmodel
	if (s_model && (curmodel == s_model)) {
		PrepairUndo();//物理REC様に保存
	}


	//全モデルシミュ開始
	s_chascene->StartBt();


	return 0;
}

int RigidElem2WndParam()
{
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}


	//ダイアログの数値はメニューで選択中のもの
	s_model->SetCurrentRigidElem(s_reindexmap[s_model]);


	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (curbone) {
		//int kinflag = curbone->m_btforce;

		CBone* parentbone = curbone->GetParent(false);
		if (parentbone && parentbone->IsSkeleton()) {
			int kinflag = parentbone->GetBtForce();
			s_btforce->setValue((bool)kinflag);

			CRigidElem* curre = parentbone->GetRigidElem(curbone);
			if (curre) {
				float rate = (float)curre->GetSphrate();
				float boxz = (float)curre->GetBoxzrate();
				float mass = (float)curre->GetMass();
				bool skipflag = !((bool)curre->GetSkipflag());
				int colindex = curre->GetColtype();
				int lkindex = curre->GetLKindex();
				int akindex = curre->GetAKindex();
				float ldmp = curre->GetLDamping();
				float admp = curre->GetADamping();
				float cuslk = curre->GetCusLk();
				float cusak = curre->GetCusAk();
				float rest = curre->GetRestitution();
				float fric = curre->GetFriction();
				float btg = curre->GetBtg();
				int forbidrot = curre->GetForbidRotFlag();

				s_sphrateSlider->setValue(rate);
				s_boxzSlider->setValue(boxz);
				s_massSlider->setValue(mass);
				s_rigidskip->setValue(skipflag);
				s_forbidrot->setValue(forbidrot);
				s_colradio->setSelectIndex(colindex);
				s_lkradio->setSelectIndex(lkindex);
				s_akradio->setSelectIndex(akindex);
				s_ldmpSlider->setValue(ldmp);
				s_admpSlider->setValue(admp);
				s_lkSlider->setValue(cuslk);
				s_akSlider->setValue(cusak);
				s_restSlider->setValue(rest);
				s_fricSlider->setValue(fric);
				s_btgSlider->setValue(btg);
			}
			else {
				//rigid elemが作成されていないとき
				s_sphrateSlider->setValue(1.0);
				s_boxzSlider->setValue(1.0);
				s_massSlider->setValue(1.0);
				s_rigidskip->setValue(0);
				s_forbidrot->setValue(0);
				s_colradio->setSelectIndex(0);
				s_lkradio->setSelectIndex(0);
				s_akradio->setSelectIndex(0);
				s_ldmpSlider->setValue(g_l_dmp);
				s_admpSlider->setValue(g_a_dmp);
				s_lkSlider->setValue(g_initcuslk);
				s_akSlider->setValue(g_initcusak);
				s_restSlider->setValue(0.0);
				s_fricSlider->setValue(0.0);
				s_btgSlider->setValue(9.0);
			}
		}
		else {
			//rigid elemが作成されていないとき
			s_sphrateSlider->setValue(1.0);
			s_boxzSlider->setValue(1.0);
			s_massSlider->setValue(1.0);
			s_rigidskip->setValue(0);
			s_forbidrot->setValue(0);
			s_colradio->setSelectIndex(0);
			s_lkradio->setSelectIndex(0);
			s_akradio->setSelectIndex(0);
			s_ldmpSlider->setValue(g_l_dmp);
			s_admpSlider->setValue(g_a_dmp);
			s_lkSlider->setValue(g_initcuslk);
			s_akSlider->setValue(g_initcusak);
			s_restSlider->setValue(0.0);
			s_fricSlider->setValue(0.0);
			s_btgSlider->setValue(9.0);
		}
		s_namelabel->setName((WCHAR*)curbone->GetWBoneName());
	}
	else {
		WCHAR noname[256];
		wcscpy_s(noname, 256, L"BoneName：not selected");
		s_namelabel->setName(noname);
	}
	if (s_model && (s_model->GetNoBoneFlag() == false)) {
		s_btgscSlider->setValue(s_model->GetBtGScale(s_model->GetCurReIndex()));
	}

	s_rigidWnd->callRewrite();



	//再生中、シミュレーション中への対応。元の状態に戻す。
	if (g_previewFlag != 5) {
		s_model->SetCurrentRigidElem(s_reindexmap[s_model]);
	}
	else {
		s_model->SetCurrentRigidElem(s_rgdindexmap[s_model]);
	}



	return 0;
}

int SetRigidLeng()
{
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBt()) {
		return 0;
	}

	CBtObject* curbto = s_model->FindBtObject(s_curboneno);
	if (curbto) {
		WCHAR curlabel[512];
		swprintf_s(curlabel, 512, L"BonaName：%s", curbto->GetEndBone()->GetWBoneName());
		if (s_namelabel) {
			s_namelabel->setName(curlabel);
		}

		WCHAR curlabel2[256];
		swprintf_s(curlabel2, 256, L"BoneLength:%.3f[m]", curbto->GetBoneLeng());
		if (s_lenglabel) {
			s_lenglabel->setName(curlabel2);
		}
	}
	else {
		WCHAR curlabel[512];
		wcscpy_s(curlabel, 512, L"BoneName：not selected");
		if (s_namelabel) {
			s_namelabel->setName(curlabel);
		}

		WCHAR curlabel2[256];
		wcscpy_s(curlabel2, 256, L"BoneLength：not selected");
		if (s_lenglabel) {
			s_lenglabel->setName(curlabel2);
		}
	}
	return 0;
}

int SetImpWndParams()
{
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (s_rgdindexmap[s_model] < 0) {
		return 0;
	}


	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (curbone) {
		CBone* parentbone = curbone->GetParent(false);
		if (parentbone && parentbone->IsSkeleton()) {
			ChaVector3 setimp(0.0f, 0.0f, 0.0f);


			int impnum = parentbone->GetImpMapSize();
			if ((s_model->GetCurImpIndex() >= 0) && (s_model->GetCurImpIndex() < impnum)) {
				string curimpname = s_model->GetImpInfo(s_model->GetCurImpIndex());
				setimp = parentbone->GetImpMap(curimpname, curbone);
			}
			else {
				//_ASSERT(0);
			}

			if (s_impzSlider) {
				s_impzSlider->setValue(setimp.z);
			}
			if (s_impySlider) {
				s_impySlider->setValue(setimp.y);
			}
			if (s_impxSlider) {
				s_impxSlider->setValue(setimp.x);
			}
			if (s_impscaleSlider) {
				s_impscaleSlider->setValue(g_impscale);
			}
		}
	}

	s_impWnd->callRewrite();

	return 0;
}

int SetDmpWndParams()
{
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (s_rgdindexmap[s_model] < 0) {
		return 0;
	}


	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (curbone) {
		CBone* parentbone = curbone->GetParent(false);
		if (parentbone && parentbone->IsSkeleton()) {
			char* filename = s_model->GetRigidElemInfo(s_rgdindexmap[s_model]).filename;
			CRigidElem* curre = parentbone->GetRigidElemOfMap(filename, curbone);
			if (curre) {
				if (s_dmpanimLSlider) {
					s_dmpanimLSlider->setValue(curre->GetDampanimL());
				}
				if (s_dmpanimASlider) {
					s_dmpanimASlider->setValue(curre->GetDampanimA());
				}
			}
		}
	}

	s_dmpanimWnd->callRewrite();

	return 0;
}


int SetGpWndParams()
{
	if (!s_bpWorld) {
		return 0;
	}

	if (s_ghSlider) {
		s_ghSlider->setValue(s_bpWorld->m_gplaneh);
	}
	if (s_gsizexSlider) {
		s_gsizexSlider->setValue(s_bpWorld->m_gplanesize.x);
	}
	if (s_gsizezSlider) {
		s_gsizezSlider->setValue(s_bpWorld->m_gplanesize.y);
	}
	if (s_gpdisp) {
		s_gpdisp->setValue((bool)s_bpWorld->m_gplanedisp);
	}

	if (s_grestSlider) {
		s_grestSlider->setValue(s_bpWorld->m_restitution);
	}
	if (s_gfricSlider) {
		s_gfricSlider->setValue(s_bpWorld->m_friction);
	}

	s_gpWnd->callRewrite();

	return 0;
}

int SaveProject()
{
	if (!s_bpWorld || !s_chascene) {
		return 0;
	}

	if (s_chascene->ModelEmpty()) {
		return 0;
	}

	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SAVECHADLG),
		s_3dwnd, (DLGPROC)SaveChaDlgProc);
	if ((dlgret != IDOK) || !s_projectname[0] || !s_projectdir[0] || !s_chasavename[0]) {
		return 0;
	}

	//###################################################################
	//limitdegflagは　ダイアログで指定した　g_bakelimiteulonsave　を使う
	//###################################################################

	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));


	int modelnum = s_chascene->GetModelNum();
	int modelcount;
	for (modelcount = 0; modelcount < modelnum; modelcount++) {
		CModel* curmodel = s_chascene->GetModel(modelcount);

		if (curmodel && s_owpLTimeline && s_owpEulerGraph) {
			s_owpLTimeline->setCurrentTime(0.0, true);
			s_owpEulerGraph->setCurrentTime(0.0, false);
			curmodel->SetMotionFrame(0.0);
			ChaMatrix tmpwm = curmodel->GetWorldMat();
			curmodel->UpdateMatrix(g_bakelimiteulonsave, &tmpwm, &s_matVP);

			//ここでAxisMatXの初期化
			curmodel->CreateBtObject(g_bakelimiteulonsave, 1);
			curmodel->CalcBtAxismat(2);//2
			curmodel->SetInitAxisMatX(1);
		}
	}


	WCHAR saveprojpath[MAX_PATH] = { 0L };
	swprintf_s(saveprojpath, MAX_PATH, L"%s\\%s\\%s.cha", s_projectdir, s_projectname, s_projectname);

	vector<MODELELEM> writemodelindex;
	s_chascene->GetModelIndex(writemodelindex);
	CChaFile chafile;
	int result = chafile.WriteChaFile(g_bakelimiteulonsave, s_bpWorld, s_projectdir, s_projectname,
		writemodelindex, (float)g_dspeed, s_selbonedlgmap);
	if (result) {
		::MessageBox(g_mainhwnd, L"保存に失敗しました。", L"Error", MB_OK);
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 1;
	}


	//書き込み処理が成功してから履歴を保存する。chaファイルだけ。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	if ((savepathlen > 4) && (savepathlen < MAX_PATH)) {
		WCHAR* pwext;
		pwext = saveprojpath + ((size_t)savepathlen - 1) - 3;
		if (wcscmp(pwext, L".cha") == 0) {
			SYSTEMTIME localtime;
			GetLocalTime(&localtime);
			WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
			swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProj_%04u%02u%02u%02u%02u%02u.txt",
				s_temppath,
				localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
			HANDLE hfile;
			hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				//int pathlen;
				//pathlen = (int)wcslen(saveprojpath);
				//if ((pathlen > 0) && (pathlen < MAX_PATH)) {
				if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
					DWORD writelen = 0;
					WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
					_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
				}
				CloseHandle(hfile);
			}
		}
	}


	if (oldcursor) {
		SetCursor(oldcursor);
	}


	return 0;
}


LRESULT CALLBACK SaveChaDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	//	static WCHAR s_projectname[64] = {0L};
	//	static WCHAR s_projectdir[MAX_PATH] = {0L};

	BROWSEINFO bi;
	ZeroMemory(&bi, sizeof(BROWSEINFO));
	LPITEMIDLIST curlpidl = 0;
	WCHAR dispname[MAX_PATH] = { 0L };
	WCHAR selectname[MAX_PATH] = { 0L };
	int iImage = 0;

	static int s_savechaproctimer = 351;


	switch (msg) {
	case WM_INITDIALOG:

		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model && s_model->GetCurMotInfo()) {
			if (s_chasavename[0]) {
				SetDlgItemText(hDlgWnd, IDC_PROJNAME, s_chasavename);
			}
			if (s_chasavedir[0]) {
				SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_chasavedir);
			}
			else {
				if (s_projectdir[0]) {
					SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
				}
				else {
					LPITEMIDLIST pidl;

					HWND hWnd = NULL;

					IMalloc* pMalloc;
					if (SUCCEEDED(SHGetMalloc(&pMalloc))) {
						if (SUCCEEDED(SHGetSpecialFolderLocation(s_3dwnd, CSIDL_DESKTOPDIRECTORY, &pidl)))
						{
							// パスに変換する
							SHGetPathFromIDList(pidl, s_projectdir);
							// 取得したIDLを解放する (CoTaskMemFreeでも可)
							pMalloc->Free(pidl);
							SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
						}
						pMalloc->Release();
					}
				}
			}

			if (g_bakelimiteulonsave) {
				CheckDlgButton(hDlgWnd, IDC_CHECK1, BST_CHECKED);
			}
			else {
				CheckDlgButton(hDlgWnd, IDC_CHECK1, BST_UNCHECKED);
			}


			RECT dlgrect;
			GetWindowRect(hDlgWnd, &dlgrect);
			SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

			s_savechadlghwnd = hDlgWnd;
			SetTimer(hDlgWnd, s_savechaproctimer, 20, NULL);

		}
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
		{


			s_savechadlghwnd = 0;
			KillTimer(hDlgWnd, s_savechaproctimer);

			GetDlgItemText(hDlgWnd, IDC_PROJNAME, s_projectname, 64);
			GetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir, MAX_PATH);
			wcscpy_s(s_chasavename, 64, s_projectname);
			wcscpy_s(s_chasavedir, MAX_PATH, s_projectdir);


			UINT ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK1);
			if (ischecked == BST_CHECKED) {
				g_bakelimiteulonsave = true;
			}
			else {
				g_bakelimiteulonsave = false;
			}

			EndDialog(hDlgWnd, IDOK);
		}
		break;
		case IDCANCEL:
			s_savechadlghwnd = 0;
			KillTimer(hDlgWnd, s_savechaproctimer);

			s_projectname[0] = 0L;
			s_projectdir[0] = 0L;
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFDIR:
		{
			bi.hwndOwner = hDlgWnd;
			bi.pidlRoot = NULL;//!!!!!!!
			bi.pszDisplayName = dispname;
			//bi.lpszTitle = L"保存フォルダを選択してください。";
			bi.lpszTitle = L"SelectDirectoryForSave";
			//bi.ulFlags = BIF_EDITBOX | BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
			bi.ulFlags = BIF_RETURNONLYFSDIRS;// | BIF_NEWDIALOGSTYLE;//BIF_NEWDIALOGSTYLEを指定すると固まる　謎
			bi.lpfn = NULL;
			bi.lParam = 0;
			bi.iImage = iImage;


			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			curlpidl = SHBrowseForFolder(&bi);

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			if (curlpidl) {
				//::DSMessageBox( m_hWnd, dispname, "フォルダー名", MB_OK );

				BOOL bret;
				bret = SHGetPathFromIDList(curlpidl, selectname);
				if (bret == FALSE) {
					_ASSERT(0);
					if (curlpidl)
						CoTaskMemFree(curlpidl);
					return 1;
				}

				if (curlpidl)
					CoTaskMemFree(curlpidl);

				wcscpy_s(s_projectdir, MAX_PATH, selectname);
				SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
			}
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_savechadlghwnd = 0;
		KillTimer(hDlgWnd, s_savechaproctimer);

		s_projectname[0] = 0L;
		s_projectdir[0] = 0L;
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}

int OpenChaFile()
{

	//g_tmpmqopathはプロジェクト読み込み時にプロジェクトファイル内に記述されているファイル名に変わっていくので先に保存しておく。
	WCHAR saveprojpath[MAX_PATH] = { 0L };
	wcscpy_s(saveprojpath, MAX_PATH, g_tmpmqopath);

	//先に履歴を保存する。chaファイルだけ。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	if ((savepathlen > 4) && (savepathlen < MAX_PATH)) {
		WCHAR* pwext;
		pwext = saveprojpath + ((size_t)savepathlen - 1) - 3;
		if (wcscmp(pwext, L".cha") == 0) {
			SYSTEMTIME localtime;
			GetLocalTime(&localtime);
			WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
			swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProj_%04u%02u%02u%02u%02u%02u.txt",
				s_temppath,
				localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
			HANDLE hfile;
			hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				//int pathlen;
				//pathlen = (int)wcslen(saveprojpath);
				if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
					DWORD writelen = 0;
					WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
					_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
				}
				CloseHandle(hfile);
			}
		}
	}


	WCHAR* lasten = 0;
	g_tmpmqopath[MAX_PATH - 1] = 0L;
	lasten = wcsrchr(g_tmpmqopath, TEXT('\\'));
	if (lasten && (*(lasten + 1) != 0L)) {
		size_t leng = wcslen(lasten + 1);
		if ((leng > 0) && (leng < 64)) {
			wcscpy_s(s_chasavename, 64, lasten + 1);
			WCHAR* peri = wcsrchr(s_chasavename, TEXT('.'));
			if (peri) {
				*peri = 0L;
			}
		}
	}
	else {
		//s_chasavenameは更新しない
	}
	//念のために終端
	s_chasavename[64 - 1] = 0L;


	WCHAR tmpdir[MAX_PATH];
	wcscpy_s(tmpdir, MAX_PATH, g_tmpmqopath);
	WCHAR* lastend = 0;
	lastend = wcsrchr(tmpdir, TEXT('\\'));
	if (lastend) {
		*lastend = 0L;
		WCHAR* lastend2 = 0;
		lastend2 = wcsrchr(tmpdir, TEXT('\\'));
		if (lastend2) {
			*lastend2 = 0L;
			int dirleng = (int)(lastend2 - tmpdir);
			if (dirleng < MAX_PATH) {
				wcscpy_s(s_chasavedir, MAX_PATH, tmpdir);
			}
		}
	}

	if (!s_bpWorld) {
		//ChaMatrix inimat;
		//ChaMatrixIdentity( &inimat );
		//s_bpWorld = new BPWorld(NULL, inimat, "BtPiyo", // ウィンドウのタイトル
		//				460, 460,         // ウィンドウの幅と高さ [pixels]
		//				NULL);    // モニタリング用関数へのポインタ  
		//_ASSERT( s_bpWorld );
		char strtitle[256];
		strcpy_s(strtitle, 256, "BpPiyo");
		s_bpWorld = new BPWorld(NULL, s_matWorld, strtitle, // ウィンドウのタイトル
			460, 460,         // ウィンドウの幅と高さ [pixels]
			NULL);    // モニタリング用関数へのポインタ  
		_ASSERT(s_bpWorld);


		s_bpWorld->enableFixedTimeStep(false);
		//s_bpWorld->enableFixedTimeStep(false);
		//s_bpWorld->setTimeStep(0.015);// seconds
		s_bpWorld->setGlobalERP(btScalar(g_erp));// ERP
									   //s_bpWorld->start();// ウィンドウを表示して，シミュレーションを開始する
		s_btWorld = s_bpWorld->getDynamicsWorld();
		s_bpWorld->setNumThread(g_numthread);

	}

	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));




	CChaFile chafile;
	int ret = chafile.LoadChaFile(g_limitdegflag, g_tmpmqopath,
		OpenFBXFile, OpenREFile, OpenImpFile, OpenGcoFile,
		OnREMenu, OnRgdMenu, OnRgdMorphMenu, OnImpMenu);
	if (ret == 1) {
		_ASSERT(0);
		SetCursor(oldcursor);
		return 1;
	}
	//OnAddMotion(s_model->GetCurMotInfo()->motid);

	SetCursor(oldcursor);


	//ChangeCurrentBone();

	return 0;
}

int OnSetMotSpeed()
{
	//s_model->GetCurMotInfo()->speed = s_model->GetTmpMotSpeed();//!!!!!!!!!!!!!!!!!!!
	//g_dspeed = s_model->GetTmpMotSpeed();

	if (!s_model || !s_chascene) {
		return 0;
	}
	if (!s_model->GetCurMotInfo()) {
		return 0;
	}
	//if (!g_SampleUI.GetSlider(IDC_SPEED)) {
	//	return 0;
	//}
	//if (!g_SampleUI.GetStatic(IDC_SPEED_STATIC)) {
	//	return 0;
	//}


	//スライダーからspeedの値を取得
	if (s_guidlg[GUIDLG_DISP_AND_LIMITS]) {
		HWND speedwnd = GetDlgItem(s_guidlg[GUIDLG_DISP_AND_LIMITS], IDC_SLIDER_SPEED);
		if (speedwnd && IsWindow(speedwnd)) {
			int cursliderpos = (int)SendMessage(speedwnd, TBM_GETPOS, 0, 0);
			g_dspeed = (float)((double)cursliderpos / 100.0);
		}
	}


	////SetMotionSpeed() : モーションごとのスピード
	////SetTmpMotSpeed() : モーションが変わってもスライダー指定のスピード
	////モーションが変わってもスライダー指定のスピードを維持するようにする
	////g_dspeed = s_model->GetCurMotInfo()->speed;
	//g_dspeed = s_model->GetTmpMotSpeed();
	s_chascene->SetMotionSpeed(-1, g_dspeed);


	//g_SampleUI.GetSlider(IDC_SPEED)->SetValue((int)(g_dspeed * 100.0f));
	//WCHAR sz[100];
	//swprintf_s(sz, 100, L"Motion Speed: %0.4f", g_dspeed);
	//g_SampleUI.GetStatic(IDC_SPEED_STATIC)->SetText(sz);

	return 0;
}


int SetSpParams()
{
	SetSpSel3DParams();
	SetSpAimBarParams();
	SetSpMenuAimBarParams();//CreateMainMenuAimBarWndよりも後
	SetSpAxisParams();
	SetSpUndoParams();
	SetSpGUISWParams();
	SetSpIkModeSWParams();
	SetSpLODSWParams();
	SetSpDispSWParams();
	SetSpRigidSWParams();
	SetSpRetargetSWParams();
	SetSpCamParams();
	SetSpRigParams();
	SetSpCpLW2WParams();
	SetSpSmoothParams();
	SetSpLimitEulSWParams();
	SetSpScrapingSWParams();
	SetSpConstExeParams();
	SetSpConstRefreshParams();
	//SetSpBtParams();
	SetSpMouseHereParams();
	SetSpMouseCenterParams();//SetSpCamParamsよりも後で呼ぶ　位置を参照しているから
	SetSpCameraModeSWParams();
	SetSpCameraInheritSWParams();
	
	SetSpRet2PrevParams();
	
	SetSpCopyParams();//SetSpCameraInheritSWParams()よりも後で呼ぶ
	SetSpSymCopyParams();
	SetSpPasteParams();
	SetSpCopyHistoryParams();
	
	SetSpInterpolateParams();
	SetSpInitParams();
	SetSpScaleInitParams();
	SetSpPropertyParams();
	
	SetSpZeroFrameParams();
	SetSpCameraDollyParams();
	SetSpModelPosDirParams();
	SetSpMaterialRateParams();

	return 0;
}
int SetSpUndoParams()
{


	int spashift = 6;
	//s_spundo[0].dispcenter.x = (int)( s_mainwidth * 0.57f );
	//s_spundo[0].dispcenter.y = (int)( 30.0f * ( (float)s_mainheight / 620.0 ) );
	//s_spundo[0].dispcenter.x = s_mainwidth - 50 - 10 - (32 + 12) * 4;
	//s_spundo[0].dispcenter.y = 16 + 10;
	s_spundo[0].dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_spundo[0].dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 3;
	//spashift = (int)( (float)spashift * ( (float)s_mainwidth / 600.0 ) );

	s_spundo[1].dispcenter.x = s_spundo[0].dispcenter.x;
	s_spundo[1].dispcenter.y = s_spundo[0].dispcenter.y + (int)s_spsize + spashift;

	//{
	//	s_spaxis[0].dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	//	s_spaxis[0].dispcenter.y = (int)s_sptopmargin;
	//	//spashift = (int)( (float)spashift * ( (float)s_mainwidth / 600.0 ) );
	//
	//	s_spaxis[1].dispcenter.x = s_spaxis[0].dispcenter.x;
	//	s_spaxis[1].dispcenter.y = s_spaxis[0].dispcenter.y + (int)s_spsize + spashift;
	//
	//	s_spaxis[2].dispcenter.x = s_spaxis[0].dispcenter.x;
	//	s_spaxis[2].dispcenter.y = s_spaxis[1].dispcenter.y + (int)s_spsize + spashift;;
	//}


	int spacnt;
	for (spacnt = 0; spacnt < 2; spacnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spundo[spacnt].dispcenter.x);
		disppos.y = (float)(s_spundo[spacnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);
		//CallF(s_spundo[spacnt].sprite->SetPos(disppos), return 1);
		//CallF(s_spundo[spacnt].sprite->SetSize(dispsize), return 1);
		s_spundo[spacnt].sprite.UpdateScreen(disppos, dispsize);
	}

	return 0;

}


int SetSpAxisParams()
{

	int spashift = 6;
	//s_spaxis[0].dispcenter.x = (int)( s_mainwidth * 0.57f );
	//s_spaxis[0].dispcenter.y = (int)( 30.0f * ( (float)s_mainheight / 620.0 ) );
	//s_spaxis[0].dispcenter.x = s_mainwidth - 50 - 10 - (32 + 12) * 4;
	//s_spaxis[0].dispcenter.y = 16 + 10;
	s_spaxis[0].dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_spaxis[0].dispcenter.y = (int)s_sptopmargin;
	//spashift = (int)( (float)spashift * ( (float)s_mainwidth / 600.0 ) );

	s_spaxis[1].dispcenter.x = s_spaxis[0].dispcenter.x;
	s_spaxis[1].dispcenter.y = s_spaxis[0].dispcenter.y + (int)s_spsize + spashift;

	s_spaxis[2].dispcenter.x = s_spaxis[0].dispcenter.x;
	s_spaxis[2].dispcenter.y = s_spaxis[1].dispcenter.y + (int)s_spsize + spashift;;

	int spacnt;
	for (spacnt = 0; spacnt < SPAXISNUM; spacnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spaxis[spacnt].dispcenter.x);
		disppos.y = (float)(s_spaxis[spacnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);
		//CallF(s_spaxis[spacnt].sprite->SetPos(disppos), return 1);
		//CallF(s_spaxis[spacnt].sprite->SetSize(dispsize), return 1);
		s_spaxis[spacnt].sprite.UpdateScreen(disppos, dispsize);
	}

	return 0;

}

int SetSpDispSWParams()
{


	//float spgwidth = 140.0f;
	float spgwidth = 124.0f;
	float spgheight = 28.0f;
	int spgshift = 6;
	s_spdispsw[SPDISPSW_LIGHTS].dispcenter.x = s_guibarX0;
	//s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y = 486;


	//s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y = 486 - MAINMENUAIMBARH;
	if (g_4kresolution) {
		s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y = 486 * 2 - MAINMENUAIMBARH + 32;
	}
	else {
		s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y = 486 - MAINMENUAIMBARH;
	}


	s_spdispsw[SPDISPSW_DISPGROUP].dispcenter.x = s_spdispsw[SPDISPSW_LIGHTS].dispcenter.x + (int)spgwidth + spgshift;
	s_spdispsw[SPDISPSW_DISPGROUP].dispcenter.y = s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y;

	s_spdispsw[SPDISPSW_LATERTRANSPARENT].dispcenter.x = s_spdispsw[SPDISPSW_DISPGROUP].dispcenter.x + (int)spgwidth + spgshift;
	s_spdispsw[SPDISPSW_LATERTRANSPARENT].dispcenter.y = s_spdispsw[SPDISPSW_DISPGROUP].dispcenter.y;

	s_spdispsw[SPDISPSW_SHADERTYPE].dispcenter.x = s_spdispsw[SPDISPSW_LATERTRANSPARENT].dispcenter.x + (int)spgwidth + spgshift;
	s_spdispsw[SPDISPSW_SHADERTYPE].dispcenter.y = s_spdispsw[SPDISPSW_LATERTRANSPARENT].dispcenter.y;

	s_spdispsw[SPDISPSW_SHADOWPARAMS].dispcenter.x = s_spdispsw[SPDISPSW_SHADERTYPE].dispcenter.x + (int)spgwidth + spgshift;
	s_spdispsw[SPDISPSW_SHADOWPARAMS].dispcenter.y = s_spdispsw[SPDISPSW_SHADERTYPE].dispcenter.y;

	int spgcnt;
	for (spgcnt = 0; spgcnt < SPDISPSWNUM; spgcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spdispsw[spgcnt].dispcenter.x);
		disppos.y = (float)(s_spdispsw[spgcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(spgwidth, spgheight);

		//CallF(s_spdispsw[spgcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_spdispsw[spgcnt].spriteON->SetSize(dispsize), return 1);
		s_spdispsw[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

		//CallF(s_spdispsw[spgcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_spdispsw[spgcnt].spriteOFF->SetSize(dispsize), return 1);
		s_spdispsw[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	}

	return 0;

}


int SetSpRigidSWParams()
{

	//float spgwidth = 140.0f;
	float spgwidth = 124.0f;
	float spgheight = 28.0f;
	int spgshift = 6;
	s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.x = s_guibarX0;
	//s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y = 486;


	//s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y = 486 - MAINMENUAIMBARH;
	if (g_4kresolution) {
		s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y = 486 * 2 - MAINMENUAIMBARH + 32;
	}
	else {
		s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y = 486 - MAINMENUAIMBARH;
	}


	s_sprigidsw[SPRIGIDSW_IMPULSE].dispcenter.x = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.x + (int)spgwidth + spgshift;
	s_sprigidsw[SPRIGIDSW_IMPULSE].dispcenter.y = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y;

	s_sprigidsw[SPRIGIDSW_GROUNDPLANE].dispcenter.x = s_sprigidsw[SPRIGIDSW_IMPULSE].dispcenter.x + (int)spgwidth + spgshift;
	s_sprigidsw[SPRIGIDSW_GROUNDPLANE].dispcenter.y = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y;

	s_sprigidsw[SPRIGIDSW_DAMPANIM].dispcenter.x = s_sprigidsw[SPRIGIDSW_GROUNDPLANE].dispcenter.x + (int)spgwidth + spgshift;
	s_sprigidsw[SPRIGIDSW_DAMPANIM].dispcenter.y = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y;

	int spgcnt;
	for (spgcnt = 0; spgcnt < SPRIGIDSWNUM; spgcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_sprigidsw[spgcnt].dispcenter.x);
		disppos.y = (float)(s_sprigidsw[spgcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(spgwidth, spgheight);

		//CallF(s_sprigidsw[spgcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_sprigidsw[spgcnt].spriteON->SetSize(dispsize), return 1);
		s_sprigidsw[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

		//CallF(s_sprigidsw[spgcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_sprigidsw[spgcnt].spriteOFF->SetSize(dispsize), return 1);
		s_sprigidsw[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	}

	return 0;

}

int SetSpRetargetSWParams()
{


	//float spgwidth = 140.0f;
	float spgwidth = 124.0f;
	float spgheight = 28.0f;
	int spgshift = 6;
	s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.x = s_guibarX0;


	//s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y = 486 - MAINMENUAIMBARH;
	if (g_4kresolution) {
		s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y = 486 * 2 - MAINMENUAIMBARH + 32;
	}
	else {
		s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y = 486 - MAINMENUAIMBARH;
	}


	s_spretargetsw[SPRETARGETSW_LIMITEULER].dispcenter.x = s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.x + (int)spgwidth + spgshift;
	s_spretargetsw[SPRETARGETSW_LIMITEULER].dispcenter.y = s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y;


	int sprcnt;
	for (sprcnt = 0; sprcnt < SPRETARGETSWNUM; sprcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spretargetsw[sprcnt].dispcenter.x);
		disppos.y = (float)(s_spretargetsw[sprcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(spgwidth, spgheight);

		//CallF(s_spretargetsw[sprcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_spretargetsw[sprcnt].spriteON->SetSize(dispsize), return 1);
		s_spretargetsw[sprcnt].spriteON.UpdateScreen(disppos, dispsize);
		//CallF(s_spretargetsw[sprcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_spretargetsw[sprcnt].spriteOFF->SetSize(dispsize), return 1);
		s_spretargetsw[sprcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	}

	return 0;

}

int SetSpMenuAimBarParams()
{


	////float spgwidth = 140.0f;
	////float spgheight = 6.0f;
	////int spgshift = 6;

	//HMENU mainmenu;
	//mainmenu = GetMenu(g_mainhwnd);
	//int menuno;
	//for (menuno = 0; menuno < SPMENU_MAX; menuno++) {
	//	HMENU submenu = GetSubMenu(mainmenu, menuno);
	//	if (submenu) {
	//		int curmenuitemid;
	//		curmenuitemid = ::GetMenuItemID(submenu, 0);
	//		if (curmenuitemid >= 0) {
	//			RECT rc;
	//			GetMenuItemRect(g_mainhwnd, mainmenu, menuno, &rc);
	//			int spritewidth = rc.right - rc.left;//org:140
	//			int spriteheight = 6;//org:6

	//			POINT point1;
	//			POINT point2;
	//			point1.x = rc.left;
	//			point1.y = rc.top;
	//			point2.x = rc.right;
	//			point2.y = rc.bottom;
	//			::ClientToScreen(g_mainhwnd, &point1);
	//			::ClientToScreen(g_mainhwnd, &point2);
	//			//::ScreenToClient(s_mainmenuaimbarWnd->getHWnd(), &point1);
	//			//::ScreenToClient(s_mainmenuaimbarWnd->getHWnd(), &point2);

	//			s_spmenuaimbar[menuno].dispcenter.x = point1.x;//screen pos!!!!!!!!!!!
	//			s_spmenuaimbar[menuno].dispcenter.y = 16;

	//			//ChaVector3 disppos;
	//			//disppos.x = (float)(s_spmenuaimbar[menuno].dispcenter.x);
	//			//disppos.y = (float)(s_spmenuaimbar[menuno].dispcenter.y);
	//			//disppos.z = 0.0f;
	//			//ChaVector2 dispsize = ChaVector2(spritewidth / (float)s_mainwidth * 2.0f, spriteheight / (float)s_mainheight * 2.0f);

	//			//if (s_spmenuaimbar[menuno].spriteON) {
	//			//	CallF(s_spmenuaimbar[menuno].spriteON->SetPos(disppos), return 1);
	//			//	CallF(s_spmenuaimbar[menuno].spriteON->SetSize(dispsize), return 1);
	//			//}
	//			//else {
	//			//	_ASSERT(0);
	//			//}
	//			//if (s_spmenuaimbar[menuno].spriteOFF) {
	//			//	CallF(s_spmenuaimbar[menuno].spriteOFF->SetPos(disppos), return 1);
	//			//	CallF(s_spmenuaimbar[menuno].spriteOFF->SetSize(dispsize), return 1);
	//			//}
	//			//else {
	//			//	_ASSERT(0);
	//			//}

	//		}
	//	}

	//}

	return 0;

}


int SetSpAimBarParams()
{
	////float spgwidth = 140.0f;
	//float spgwidth = 124.0f;
	//float spgheight = 6.0f;
	//int spgshift = 6;
	//s_spaimbar[SPAIMBAR_1].dispcenter.x = s_guibarX0;
	////s_spaimbar[SPAIMBAR_1].dispcenter.y = 486 + (28 / 2) + (6 / 2);


	////s_spaimbar[SPAIMBAR_1].dispcenter.y = 486 + (28 / 2) + (6 / 2) - MAINMENUAIMBARH;
	//if (g_4kresolution) {
	//	s_spaimbar[SPAIMBAR_1].dispcenter.y = 486 * 2 - MAINMENUAIMBARH + 32 + 16 + 4;
	//}
	//else {
	//	s_spaimbar[SPAIMBAR_1].dispcenter.y = 486 + (28 / 2) + (6 / 2) - MAINMENUAIMBARH;
	//}


	//s_spaimbar[SPAIMBAR_2].dispcenter.x = s_spaimbar[SPAIMBAR_1].dispcenter.x + (int)spgwidth + spgshift;
	//s_spaimbar[SPAIMBAR_2].dispcenter.y = s_spaimbar[SPAIMBAR_1].dispcenter.y;

	//s_spaimbar[SPAIMBAR_3].dispcenter.x = s_spaimbar[SPAIMBAR_2].dispcenter.x + (int)spgwidth + spgshift;
	//s_spaimbar[SPAIMBAR_3].dispcenter.y = s_spaimbar[SPAIMBAR_1].dispcenter.y;

	//s_spaimbar[SPAIMBAR_4].dispcenter.x = s_spaimbar[SPAIMBAR_3].dispcenter.x + (int)spgwidth + spgshift;
	//s_spaimbar[SPAIMBAR_4].dispcenter.y = s_spaimbar[SPAIMBAR_1].dispcenter.y;

	//s_spaimbar[SPAIMBAR_5].dispcenter.x = s_spaimbar[SPAIMBAR_4].dispcenter.x + (int)spgwidth + spgshift;
	//s_spaimbar[SPAIMBAR_5].dispcenter.y = s_spaimbar[SPAIMBAR_1].dispcenter.y;

	//int spgcnt;
	//for (spgcnt = 0; spgcnt < SPAIMBARNUM; spgcnt++) {
	//	ChaVector3 disppos;
	//	disppos.x = (float)(s_spaimbar[spgcnt].dispcenter.x);
	//	disppos.y = (float)(s_spaimbar[spgcnt].dispcenter.y);
	//	disppos.z = 0.0f;
	//	ChaVector2 dispsize = ChaVector2(spgwidth, spgheight);

	//	//CallF(s_spaimbar[spgcnt].spriteON->SetPos(disppos), return 1);
	//	//CallF(s_spaimbar[spgcnt].spriteON->SetSize(dispsize), return 1);
	//	s_spaimbar[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

	//	//CallF(s_spaimbar[spgcnt].spriteOFF->SetPos(disppos), return 1);
	//	//CallF(s_spaimbar[spgcnt].spriteOFF->SetSize(dispsize), return 1);
	//	s_spaimbar[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	//}

	return 0;

}

int SetSpMouseCenterParams()
{
	//float spgwidth = 91.0f;
	//float spgheight = 145.0f;
	//float spgwidth = 50;
	//float spgheight = 67;
	//float spgwidth = 50.0f * 0.6f;
	//float spgheight = 67.0f * 0.6f;
	int spgshift = 6;

	_ASSERT(s_3dwnd);
	RECT clientrect;
	::GetClientRect(s_3dwnd, &clientrect);

	//s_spsel3d.dispcenter.x = (LONG)(clientrect.right - spgwidth / 2 - 20);
	//s_spsel3d.dispcenter.y = (LONG)(clientrect.top + spgheight / 2 + 20);
	//s_mousecenteron.dispcenter.x = s_mainwidth - 50 - 10 - 50 - 6 - (50 + 6) * 6;
	//s_mousecenteron.dispcenter.y = (LONG)(clientrect.top + spgheight / 2 + 20);


	s_mousecenteron.dispcenter.x = s_spcam[2].dispcenter.x + (int)s_spsize + spgshift;// +(int)s_spsize / 2;
	s_mousecenteron.dispcenter.y = s_spcam[2].dispcenter.y;
	//s_spcam[2].dispcenter.x = s_spcam[1].dispcenter.x + (int)(spawidth)+spashift;
	//s_spcam[2].dispcenter.y = s_spcam[0].dispcenter.y;

	ChaVector3 disppos;
	disppos.x = (float)(s_mousecenteron.dispcenter.x);
	disppos.y = (float)(s_mousecenteron.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

	//CallF(s_mousecenteron.sprite->SetPos(disppos), return 1);
	//CallF(s_mousecenteron.sprite->SetSize(dispsize), return 1);
	s_mousecenteron.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpSel3DParams()
{

	/*
		float spawidth = 50.0f;
		int spashift = 6;
		//s_spcam[0].dispcenter.x = (int)(s_mainwidth * 0.57f);
		//s_spcam[0].dispcenter.y = (int)(30.0f * ((float)s_mainheight / 620.0)) + (int(spawidth * 1.5f));
		//s_spcam[0].dispcenter.x = s_mainwidth - 50 - 10 - (32 + 12) * 3;
		//s_spcam[0].dispcenter.y = 16 + 10 + (int(spawidth * 1.5f));
		s_spcam[0].dispcenter.x = s_mainwidth - 50 - 10 - 50 - 6 - (50 + 6) * 4;
		s_spcam[0].dispcenter.y = 25 + 10;
	*/


	//float spgwidth = 91.0f;
	//float spgheight = 145.0f;
	//float spgwidth = 91.0f * 0.25f;
	//float spgheight = 145.0f * 0.25f;
	int spgshift = 6;

	_ASSERT(s_3dwnd);
	RECT clientrect;
	::GetClientRect(s_3dwnd, &clientrect);

	//s_spsel3d.dispcenter.x = (LONG)(clientrect.right - spgwidth / 2 - 20);
	//s_spsel3d.dispcenter.y = (LONG)(clientrect.top + spgheight / 2 + 20);
	s_spsel3d.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 7;
	s_spsel3d.dispcenter.y = (LONG)(clientrect.top + (int)s_spsize / 2 + 20);

	ChaVector3 disppos;
	disppos.x = (float)(s_spsel3d.dispcenter.x);
	disppos.y = (float)(s_spsel3d.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

	//CallF(s_spsel3d.spriteON->SetPos(disppos), return 1);
	//CallF(s_spsel3d.spriteON->SetSize(dispsize), return 1);
	s_spsel3d.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_spsel3d.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_spsel3d.spriteOFF->SetSize(dispsize), return 1);
	s_spsel3d.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpIkModeSWParams()
{

	int spgshift = 6;
	s_spikmodesw[0].dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_spikmodesw[0].dispcenter.y = (int)s_sptopmargin;

	s_spikmodesw[1].dispcenter.x = s_spikmodesw[0].dispcenter.x;
	s_spikmodesw[1].dispcenter.y = s_spikmodesw[0].dispcenter.y + (int)s_spsize + spgshift;

	s_spikmodesw[2].dispcenter.x = s_spikmodesw[1].dispcenter.x;
	s_spikmodesw[2].dispcenter.y = s_spikmodesw[1].dispcenter.y + (int)s_spsize + spgshift;

	int spgcnt;
	for (spgcnt = 0; spgcnt < 3; spgcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spikmodesw[spgcnt].dispcenter.x);
		disppos.y = (float)(s_spikmodesw[spgcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

		//CallF(s_spikmodesw[spgcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_spikmodesw[spgcnt].spriteON->SetSize(dispsize), return 1);
		s_spikmodesw[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

		//CallF(s_spikmodesw[spgcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_spikmodesw[spgcnt].spriteOFF->SetSize(dispsize), return 1);
		s_spikmodesw[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	}

	return 0;
}


int SetSpLODSWParams()
{
	int spgshift = 6;
	s_splod.dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_splod.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spgshift) * 3;

	ChaVector3 disppos;
	disppos.x = (float)(s_splod.dispcenter.x);
	disppos.y = (float)(s_splod.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);


	//CallF(s_splod.spriteON->SetPos(disppos), return 1);
	//CallF(s_splod.spriteON->SetSize(dispsize), return 1);
	s_splod.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_splod.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_splod.spriteOFF->SetSize(dispsize), return 1);
	s_splod.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpLimitEulSWParams()
{
	int spgshift = 6;
	s_splimiteul.dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_splimiteul.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spgshift) * 6 + spgshift;

	ChaVector3 disppos;
	disppos.x = (float)(s_splimiteul.dispcenter.x);
	disppos.y = (float)(s_splimiteul.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

	//CallF(s_splimiteul.spriteON->SetPos(disppos), return 1);
	//CallF(s_splimiteul.spriteON->SetSize(dispsize), return 1);
	s_splimiteul.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_splimiteul.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_splimiteul.spriteOFF->SetSize(dispsize), return 1);
	s_splimiteul.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpScrapingSWParams()
{
	int spgshift = 6;
	s_spscraping.dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_spscraping.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spgshift) * 6 + spgshift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spscraping.dispcenter.x);
	disppos.y = (float)(s_spscraping.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

	//CallF(s_spscraping.spriteON->SetPos(disppos), return 1);
	//CallF(s_spscraping.spriteON->SetSize(dispsize), return 1);
	s_spscraping.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_spscraping.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_spscraping.spriteOFF->SetSize(dispsize), return 1);
	s_spscraping.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpRet2PrevParams()
{
	
	float spretwidth1;
	float spretheight1;
	float spretwidth2;
	float spretheight2;
	int spretshift = 0;

	//プレートメニュー横のカエルボタンの大きさは4K時にも同じ
	spretwidth1 = 32.0;
	spretheight1 = 32.0;

	//ショートカットボタン横のカエルボタンの大きさは4K時は大きく
	if (g_4kresolution) {
		spretwidth2 = 32.0;
		spretheight2 = 32.0;
	}
	else {
		spretwidth2 = 18.0;
		spretheight2 = 18.0;
	}


	{
		//s_spret2prev.dispcenter.x = (LONG)(16.0f + 8.0f);
		s_spret2prev.dispcenter.x = s_guibarX0 - 70 - (LONG)(16.0f + 8.0f);
		//s_spret2prev.dispcenter.y = 486;
		if (g_4kresolution) {
			s_spret2prev.dispcenter.y = 486 * 2 - MAINMENUAIMBARH + 32;
		}
		else {
			s_spret2prev.dispcenter.y = 486 - MAINMENUAIMBARH;
		}

		ChaVector3 disppos;
		disppos.x = (float)(s_spret2prev.dispcenter.x);
		disppos.y = (float)(s_spret2prev.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(spretwidth1, spretheight1);

		//CallF(s_spret2prev.sprite->SetPos(disppos), return 1);
		//CallF(s_spret2prev.sprite->SetSize(dispsize), return 1);
		s_spret2prev.sprite.UpdateScreen(disppos, dispsize);
	}

	{

		int spgshift = 6;
		s_spret2prev2.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 4;
		s_spret2prev2.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


		ChaVector3 disppos;
		disppos.x = (float)(s_spret2prev2.dispcenter.x);
		disppos.y = (float)(s_spret2prev2.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(spretwidth2, spretheight2);

		//CallF(s_spret2prev2.sprite->SetPos(disppos), return 1);
		//CallF(s_spret2prev2.sprite->SetSize(dispsize), return 1);
		s_spret2prev2.sprite.UpdateScreen(disppos, dispsize);
	}

	return 0;
}


int SetSpGUISWParams()
{
	//float spgwidth = 140.0f;
	float spgwidth = 124.0f;
	float spgheight = 28.0f;
	int spgshift = 6;
	s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.x = s_guibarX0;
	//s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y = 486;

	//s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y = 486 * s_winsizemult - MAINMENUAIMBARH;
	if (g_4kresolution) {
		s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y = 486 * 2 - MAINMENUAIMBARH + 32 - Float2Int(spgheight) - spgshift;
	}
	else {
		s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y = 486 - MAINMENUAIMBARH - Float2Int(spgheight) - spgshift;
	}

	s_spguisw[SPGUISW_DISP_AND_LIMITS].dispcenter.x = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.x + (int)spgwidth + spgshift;
	s_spguisw[SPGUISW_DISP_AND_LIMITS].dispcenter.y = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y;

	s_spguisw[SPGUISW_BRUSHPARAMS].dispcenter.x = s_spguisw[SPGUISW_DISP_AND_LIMITS].dispcenter.x + (int)spgwidth + spgshift;
	s_spguisw[SPGUISW_BRUSHPARAMS].dispcenter.y = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y;

	s_spguisw[SPGUISW_BULLETPHYSICS].dispcenter.x = s_spguisw[SPGUISW_BRUSHPARAMS].dispcenter.x + (int)spgwidth + spgshift;
	s_spguisw[SPGUISW_BULLETPHYSICS].dispcenter.y = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y;

	s_spguisw[SPGUISW_PROJ_AND_LOD].dispcenter.x = s_spguisw[SPGUISW_BULLETPHYSICS].dispcenter.x + (int)spgwidth + spgshift;
	s_spguisw[SPGUISW_PROJ_AND_LOD].dispcenter.y = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y;

	int spgcnt;
	for (spgcnt = 0; spgcnt < SPGUISWNUM; spgcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spguisw[spgcnt].dispcenter.x);
		disppos.y = (float)(s_spguisw[spgcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(spgwidth, spgheight);

		//CallF(s_spguisw[spgcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_spguisw[spgcnt].spriteON->SetSize(dispsize), return 1);
		s_spguisw[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

		//CallF(s_spguisw[spgcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_spguisw[spgcnt].spriteOFF->SetSize(dispsize), return 1);
		s_spguisw[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);

	}

	return 0;

}



int SetSpCamParams()
{
	int spashift = 6;
	//s_spcam[0].dispcenter.x = (int)(s_mainwidth * 0.57f);
	//s_spcam[0].dispcenter.y = (int)(30.0f * ((float)s_mainheight / 620.0)) + (int(spawidth * 1.5f));
	//s_spcam[0].dispcenter.x = s_mainwidth - 50 - 10 - (32 + 12) * 3;
	//s_spcam[0].dispcenter.y = 16 + 10 + (int(spawidth * 1.5f));
	s_spcam[0].dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 4;
	s_spcam[0].dispcenter.y = (int)s_spsize / 2 + 10;

	//spashift = (int)((float)spashift * ((float)s_mainwidth / 600.0));

	s_spcam[1].dispcenter.x = s_spcam[0].dispcenter.x + (int)s_spsize + spashift;
	s_spcam[1].dispcenter.y = s_spcam[0].dispcenter.y;

	s_spcam[2].dispcenter.x = s_spcam[1].dispcenter.x + (int)s_spsize + spashift;
	s_spcam[2].dispcenter.y = s_spcam[0].dispcenter.y;

	int spacnt;
	for (spacnt = 0; spacnt < SPR_CAM_MAX; spacnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spcam[spacnt].dispcenter.x);
		disppos.y = (float)(s_spcam[spacnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

		//CallF(s_spcam[spacnt].sprite->SetPos(disppos), return 1);
		//CallF(s_spcam[spacnt].sprite->SetSize(dispsize), return 1);
		s_spcam[spacnt].sprite.UpdateScreen(disppos, dispsize);

	}

	return 0;

}

int SetSpCameraModeSWParams()
{
	int spgshift = 6;
	s_spcameramode.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5;
	s_spcameramode.dispcenter.y = (int)s_spsize / 2 + 10;

	ChaVector3 disppos;
	disppos.x = (float)(s_spcameramode.dispcenter.x);
	disppos.y = (float)(s_spcameramode.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);


	dispsize *= 0.70f;//大きくみえるデザインなので　少し小さくして表示　当たり判定は元の大きさ

	//CallF(s_spcameramode.spriteON->SetPos(disppos), return 1);
	//CallF(s_spcameramode.spriteON->SetSize(dispsize), return 1);
	s_spcameramode.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_spcameramode.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_spcameramode.spriteOFF->SetSize(dispsize), return 1);
	s_spcameramode.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpCameraInheritSWParams()
{
	int spgshift = 6;
	s_spcamerainherit.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5 - (int)s_spsize / 2;
	s_spcamerainherit.dispcenter.y = (int)s_spsize / 2 + 10;

	ChaVector3 disppos;
	disppos.x = (float)(s_spcamerainherit.dispcenter.x);
	disppos.y = (float)(s_spcamerainherit.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);


	dispsize *= 0.80f;//大きくみえるデザインなので　少し小さくして表示　当たり判定は元の大きさ


	//CallF(s_spcamerainherit.sprite1->SetPos(disppos), return 1);
	//CallF(s_spcamerainherit.sprite1->SetSize(dispsize), return 1);
	s_spcamerainherit.sprite1.UpdateScreen(disppos, dispsize);

	//CallF(s_spcamerainherit.sprite2->SetPos(disppos), return 1);
	//CallF(s_spcamerainherit.sprite2->SetSize(dispsize), return 1);
	s_spcamerainherit.sprite2.UpdateScreen(disppos, dispsize);
	//CallF(s_spcamerainherit.sprite3->SetPos(disppos), return 1);
	//CallF(s_spcamerainherit.sprite3->SetSize(dispsize), return 1);
	s_spcamerainherit.sprite3.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpCopyParams()
{

	int spgshift = 6;
	//s_spcopy.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5;
	s_spcopy.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 3;
	//s_spcopy.dispcenter.y = s_spcamerainherit.dispcenter.y + (int)s_spsize + 6;
	s_spcopy.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;

	ChaVector3 disppos;
	disppos.x = (float)(s_spcopy.dispcenter.x);
	disppos.y = (float)(s_spcopy.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spcopy.sprite->SetPos(disppos), return 1);
	//CallF(s_spcopy.sprite->SetSize(dispsize), return 1);
	s_spcopy.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpSymCopyParams()
{
	int spgshift = 6;
	//s_spsymcopy.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5 + (int)s_spsizeSmall + 6;
	s_spsymcopy.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 2;
	//s_spsymcopy.dispcenter.y = s_spcamerainherit.dispcenter.y + (int)s_spsize + 6;
	s_spsymcopy.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


	ChaVector3 disppos;
	disppos.x = (float)(s_spsymcopy.dispcenter.x);
	disppos.y = (float)(s_spsymcopy.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spsymcopy.sprite->SetPos(disppos), return 1);
	//CallF(s_spsymcopy.sprite->SetSize(dispsize), return 1);
	s_spsymcopy.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpPasteParams()
{

	int spgshift = 6;
	//s_sppaste.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5 + (int)(s_spsizeSmall + 6) * 2;
	s_sppaste.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 1;
	//s_sppaste.dispcenter.y = s_spcamerainherit.dispcenter.y + (int)s_spsize + 6;
	s_sppaste.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


	ChaVector3 disppos;
	disppos.x = (float)(s_sppaste.dispcenter.x);
	disppos.y = (float)(s_sppaste.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_sppaste.sprite->SetPos(disppos), return 1);
	//CallF(s_sppaste.sprite->SetSize(dispsize), return 1);
	s_sppaste.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpCopyHistoryParams()
{
	int spgshift = 6;
	//s_spcopyhistory.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5 + (int)(s_spsizeSmall + 6) * 3;
	s_spcopyhistory.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 0;
	//s_spcopyhistory.dispcenter.y = s_spcamerainherit.dispcenter.y + (int)s_spsize + 6;
	s_spcopyhistory.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


	ChaVector3 disppos;
	disppos.x = (float)(s_spcopyhistory.dispcenter.x);
	disppos.y = (float)(s_spcopyhistory.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spcopyhistory.sprite->SetPos(disppos), return 1);
	//CallF(s_spcopyhistory.sprite->SetSize(dispsize), return 1);
	s_spcopyhistory.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpInterpolateParams()
{
	int spgshift = 6;
	s_spinterpolate.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 3;
	s_spinterpolate.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;

	ChaVector3 disppos;
	disppos.x = (float)(s_spinterpolate.dispcenter.x);
	disppos.y = (float)(s_spinterpolate.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spinterpolate.sprite->SetPos(disppos), return 1);
	//CallF(s_spinterpolate.sprite->SetSize(dispsize), return 1);
	s_spinterpolate.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpInitParams()
{
	int spgshift = 6;
	s_spinit.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 2;
	s_spinit.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


	ChaVector3 disppos;
	disppos.x = (float)(s_spinit.dispcenter.x);
	disppos.y = (float)(s_spinit.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spinit.sprite->SetPos(disppos), return 1);
	//CallF(s_spinit.sprite->SetSize(dispsize), return 1);
	s_spinit.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpScaleInitParams()
{

	int spgshift = 6;
	s_spscaleinit.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 1;
	s_spscaleinit.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


	ChaVector3 disppos;
	disppos.x = (float)(s_spscaleinit.dispcenter.x);
	disppos.y = (float)(s_spscaleinit.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spscaleinit.sprite->SetPos(disppos), return 1);
	//CallF(s_spscaleinit.sprite->SetSize(dispsize), return 1);
	s_spscaleinit.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpPropertyParams()
{
	int spgshift = 6;
	s_spproperty.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 0;
	s_spproperty.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


	ChaVector3 disppos;
	disppos.x = (float)(s_spproperty.dispcenter.x);
	disppos.y = (float)(s_spproperty.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spproperty.sprite->SetPos(disppos), return 1);
	//CallF(s_spproperty.sprite->SetSize(dispsize), return 1);
	s_spproperty.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}


int SetSpZeroFrameParams()
{

	int spgshift = 6;
	s_spzeroframe.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 3;
	s_spzeroframe.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;

	ChaVector3 disppos;
	disppos.x = (float)(s_spzeroframe.dispcenter.x);
	disppos.y = (float)(s_spzeroframe.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spzeroframe.sprite->SetPos(disppos), return 1);
	//CallF(s_spzeroframe.sprite->SetSize(dispsize), return 1);
	s_spzeroframe.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpCameraDollyParams()
{
	int spgshift = 6;
	s_spcameradolly.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 2;
	s_spcameradolly.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


	ChaVector3 disppos;
	disppos.x = (float)(s_spcameradolly.dispcenter.x);
	disppos.y = (float)(s_spcameradolly.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spcameradolly.sprite->SetPos(disppos), return 1);
	//CallF(s_spcameradolly.sprite->SetSize(dispsize), return 1);
	s_spcameradolly.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpModelPosDirParams()
{
	int spgshift = 6;
	s_spmodelposdir.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 1;
	s_spmodelposdir.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


	ChaVector3 disppos;
	disppos.x = (float)(s_spmodelposdir.dispcenter.x);
	disppos.y = (float)(s_spmodelposdir.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spmodelposdir.sprite->SetPos(disppos), return 1);
	//CallF(s_spmodelposdir.sprite->SetSize(dispsize), return 1);
	s_spmodelposdir.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpMaterialRateParams()
{
	int spgshift = 6;
	s_spmaterialrate.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 0;
	s_spmaterialrate.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


	ChaVector3 disppos;
	disppos.x = (float)(s_spmaterialrate.dispcenter.x);
	disppos.y = (float)(s_spmaterialrate.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spmaterialrate.sprite->SetPos(disppos), return 1);
	//CallF(s_spmaterialrate.sprite->SetSize(dispsize), return 1);
	s_spmaterialrate.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}


int SetSpRigParams()
{
	/*
		//sprefpos
		float spgwidth = 50.0f;
		float spgheight = 50.0f;
		int spgshift = 6;
		s_splod.dispcenter.x = s_mainwidth - 35;
		s_splod.dispcenter.y = 35 + ((int)spgheight + spgshift) * 3;
	*/

	int spashift = 6;
	//spashift = (int)((float)spashift * ((float)s_mainwidth / s_2ndposy));
	//s_sprig[SPRIG_INACTIVE].dispcenter.x = (int)(s_mainwidth * 0.57f) + ((int)(spawidth)+spashift) * 3;
	//s_sprig[SPRIG_INACTIVE].dispcenter.y = (int)(30.0f * ((float)s_mainheight / 620.0));// +(int(spawidth * 1.5f) * 2);
	//s_sprig[SPRIG_INACTIVE].dispcenter.x = s_mainwidth - 50 - 10 - 50 - 6 - 50 - 6;
	//s_sprig[SPRIG_INACTIVE].dispcenter.y = 25 + 10;
	s_sprig[SPRIG_INACTIVE].dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_sprig[SPRIG_INACTIVE].dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 4 + spashift;

	//s_spcam[0].dispcenter.x = s_mainwidth - 50 - 10 - 50 - 6 - (50 + 6) * 4;
	//s_spcam[0].dispcenter.y = 25 + 10;

	s_sprig[SPRIG_ACTIVE].dispcenter.x = s_sprig[SPRIG_INACTIVE].dispcenter.x;
	s_sprig[SPRIG_ACTIVE].dispcenter.y = s_sprig[SPRIG_INACTIVE].dispcenter.y;


	ChaVector3 disppos;
	disppos.x = (float)(s_sprig[0].dispcenter.x);
	disppos.y = (float)(s_sprig[0].dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

	//CallF(s_sprig[SPRIG_INACTIVE].sprite->SetPos(disppos), return 1);
	//CallF(s_sprig[SPRIG_INACTIVE].sprite->SetSize(dispsize), return 1);
	s_sprig[SPRIG_INACTIVE].sprite.UpdateScreen(disppos, dispsize);

	//CallF(s_sprig[SPRIG_ACTIVE].sprite->SetPos(disppos), return 1);
	//CallF(s_sprig[SPRIG_ACTIVE].sprite->SetSize(dispsize), return 1);
	s_sprig[SPRIG_ACTIVE].sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpCpLW2WParams()
{
	int spashift = 6;
	s_spcplw2w.dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_spcplw2w.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 5 + spashift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spcplw2w.dispcenter.x);
	disppos.y = (float)(s_spcplw2w.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

	//CallF(s_spcplw2w.sprite->SetPos(disppos), return 1);
	//CallF(s_spcplw2w.sprite->SetSize(dispsize), return 1);
	s_spcplw2w.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpSmoothParams()
{
	int spashift = 6;
	s_spsmooth.dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_spsmooth.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 5 + spashift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spsmooth.dispcenter.x);
	disppos.y = (float)(s_spsmooth.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

	//CallF(s_spsmooth.sprite->SetPos(disppos), return 1);
	//CallF(s_spsmooth.sprite->SetSize(dispsize), return 1);
	s_spsmooth.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpConstExeParams()
{
	int spashift = 6;
	s_spconstexe.dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_spconstexe.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 7 + spashift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spconstexe.dispcenter.x);
	disppos.y = (float)(s_spconstexe.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

	//CallF(s_spconstexe.sprite->SetPos(disppos), return 1);
	//CallF(s_spconstexe.sprite->SetSize(dispsize), return 1);
	s_spconstexe.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpConstRefreshParams()
{
	int spashift = 6;
	s_spconstrefresh.dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_spconstrefresh.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 7 + spashift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spconstrefresh.dispcenter.x);
	disppos.y = (float)(s_spconstrefresh.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(s_spsize, s_spsize);

	//CallF(s_spconstrefresh.sprite->SetPos(disppos), return 1);
	//CallF(s_spconstrefresh.sprite->SetSize(dispsize), return 1);
	s_spconstrefresh.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpMouseHereParams()
{
	float spawidth = 52.0f;
	int spashift = 50;
	s_spmousehere.dispcenter.x = 0;
	s_spmousehere.dispcenter.y = 0;


	ChaVector3 disppos;
	disppos.x = (float)(s_spmousehere.dispcenter.x);
	disppos.y = (float)(s_spmousehere.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize = ChaVector2(spawidth / (float)s_mainwidth * 2.0f, spawidth / (float)s_mainheight * 2.0f);

	//CallF(s_spmousehere.sprite->SetPos(disppos), return 1);
	//CallF(s_spmousehere.sprite->SetSize(dispsize), return 1);
	s_spmousehere.sprite.UpdateScreen(disppos, dispsize);

	return 0;
}

//int SetSpBtParams()
//{
//	if (!s_spbt.sprite){
//		return 0;
//	}
//
//	float spawidth = 32.0f;
//	int spashift = 12;
//	spashift = (int)((float)spashift * ((float)s_mainwidth / 600.0));
//	s_spbt.dispcenter.x = (int)(s_mainwidth * 0.57f) + ((int)(spawidth)+spashift) * 3;
//	s_spbt.dispcenter.y = (int)(30.0f * ((float)s_mainheight / 620.0)) + (int(spawidth * 1.5f));// *2);
//
//
//	ChaVector3 disppos;
//	disppos.x = (float)(s_spbt.dispcenter.x);
//	disppos.y = (float)(s_spbt.dispcenter.y);
//	disppos.z = 0.0f;
//	ChaVector2 dispsize = ChaVector2(spawidth / (float)s_mainwidth * 2.0f, spawidth / (float)s_mainheight * 2.0f);
//	if (s_spbt.sprite) {
//		CallF(s_spbt.sprite->SetPos(disppos), return 1);
//		CallF(s_spbt.sprite->SetSize(dispsize), return 1);
//	}
//	else {
//		_ASSERT(0);
//	}
//
//	return 0;
//
//}

int PickSpUndo(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	if (!s_model) {
		return 0;
	}
	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	int startx = s_spundo[0].dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int spacnt;
		for (spacnt = 0; spacnt < 2; spacnt++) {
			int starty = s_spundo[spacnt].dispcenter.y - (int)s_spsize / 2;
			int endy = starty + (int)s_spsize;

			if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
				switch (spacnt) {
				case 0:
					kind = PICK_UNDO;
					break;
				case 1:
					kind = PICK_REDO;
					break;
				default:
					break;
				}
				break;
			}
		}
	}


	//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
	//	kind, srcpos.x, srcpos.y, starty, endy );
	//int spacnt;
	//for( spacnt = 0; spacnt < 3; spacnt++ ){
	//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spundo[spacnt].dispcenter.x, s_spundo[spacnt].dispcenter.x + 32 );
	//}

	return kind;
}


int PickSpAxis(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	int startx = s_spaxis[0].dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int spacnt;
		for (spacnt = 0; spacnt < SPAXISNUM; spacnt++) {
			int starty = s_spaxis[spacnt].dispcenter.y - (int)s_spsize / 2;
			int endy = starty + (int)s_spsize;

			if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
				switch (spacnt) {
				case 0:
					kind = PICK_SPA_X;
					break;
				case 1:
					kind = PICK_SPA_Y;
					break;
				case 2:
					kind = PICK_SPA_Z;
					break;
				}
				break;
			}
		}
	}


	//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
	//	kind, srcpos.x, srcpos.y, starty, endy );
	//int spacnt;
	//for( spacnt = 0; spacnt < 3; spacnt++ ){
	//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
	//}

	return kind;
}

int PickSpDispSW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}


	//ret2prev
	bool pickfrog = PickSpFrog(srcpos);
	if (pickfrog == true) {
		kind = -2;
	}


	//spguisw
	if (kind == 0) {//カエルボタンを押していないとき
		int starty = s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y - 14;
		int endy = starty + 28;


		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPDISPSWNUM; spgcnt++) {
				int startx = s_spdispsw[spgcnt].dispcenter.x - 70;
				int endx = startx + 124 + 6;

				if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
					switch (spgcnt) {
					case 0:
						kind = 1;
						break;
					case 1:
						kind = 2;
						break;
					case 2:
						kind = 3;
						break;
					case 3:
						kind = 4;
						break;
					case 4:
						kind = 5;
						break;
					default:
						kind = 0;
						break;
					}
					break;
				}
			}
		}


		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}


int PickSpRigidSW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}


	//ret2prev
	bool pickfrog = PickSpFrog(srcpos);
	if (pickfrog == true) {
		kind = -2;
	}


	//spguisw
	if (kind == 0) {//カエルボタンを押していないとき
		int starty = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y - 14;
		int endy = starty + 28;


		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPRIGIDSWNUM; spgcnt++) {
				int startx = s_sprigidsw[spgcnt].dispcenter.x - 70;
				int endx = startx + 124 + 6;

				if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
					switch (spgcnt) {
					case 0:
						kind = 1;
						break;
					case 1:
						kind = 2;
						break;
					case 2:
						kind = 3;
						break;
					case 3:
						kind = 4;
						break;
					default:
						kind = 0;
						break;
					}
					break;
				}
			}
		}


		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}

int PickSpRetargetSW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}


	//ret2prev
	bool pickfrog = PickSpFrog(srcpos);
	if (pickfrog == true) {
		kind = -2;
	}


	//spretargetsw
	if (kind == 0) {
		int starty = s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y - 14;
		int endy = starty + 28;


		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int sprcnt;
			for (sprcnt = 0; sprcnt < SPRETARGETSWNUM; sprcnt++) {

				int startx = s_spretargetsw[sprcnt].dispcenter.x - 70;
				int endx = startx + 124 + 6;

				if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
					kind = sprcnt + 1;
					return kind;
				}
			}
		}
		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}

int PickSpIkModeSW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}



	//spikmodesw
	if (kind == 0) {
		int startx = s_spikmodesw[0].dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;


		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			int spgcnt;
			for (spgcnt = 0; spgcnt < 3; spgcnt++) {
				int starty = s_spikmodesw[spgcnt].dispcenter.y - (int)s_spsize / 2;
				int endy = starty + (int)s_spsize + 6;

				if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
					switch (spgcnt) {
					case 0:
						kind = 1;
						break;
					case 1:
						kind = 2;
						break;
					case 2:
						kind = 3;
						break;
					default:
						kind = 1;
						break;
					}
					break;
				}
			}
		}


		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}

int PickSpLODSW(POINT srcpos)
{
	int ispick = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	//splod
	int startx = s_splod.dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_splod.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}

int PickSpLimitEulSW(POINT srcpos)
{
	int ispick = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	//splod
	int startx = s_splimiteul.dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_splimiteul.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}

int PickSpScrapingSW(POINT srcpos)
{
	int ispick = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	//sprefpos
	int startx = s_spscraping.dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_spscraping.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}

bool PickSpFrog(POINT srcpos)
{

	int spretwidth = 32;//プレートメニュー横のカエルボタンの大きさは４K時にも同じ

	int starty0 = s_spret2prev.dispcenter.y - spretwidth / 2;
	int endy0 = starty0 + spretwidth;
	if ((srcpos.y >= starty0) && (srcpos.y <= endy0)) {
		int startx0 = s_spret2prev.dispcenter.x - spretwidth / 2;
		int endx0 = startx0 + spretwidth;
		if ((srcpos.x >= startx0) && (srcpos.x <= endx0)) {
			return true;
		}
	}

	return false;
}

bool PickSpFrog2(POINT srcpos)
{

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	int spretwidth;
	if (g_4kresolution) {//ショートカットボタン横のカエルボタンは４K時には大きく
		spretwidth = 32;
	}
	else {
		spretwidth = 18;
	}


	int starty0 = s_spret2prev2.dispcenter.y - spretwidth / 2;
	int endy0 = starty0 + spretwidth;
	if ((srcpos.y >= starty0) && (srcpos.y <= endy0)) {
		int startx0 = s_spret2prev2.dispcenter.x - spretwidth / 2;
		int endx0 = startx0 + spretwidth;
		if ((srcpos.x >= startx0) && (srcpos.x <= endx0)) {
			return true;
		}
	}

	return false;
}


int PickSpGUISW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}


	//ret2prev
	bool pickfrog = PickSpFrog(srcpos);
	if (pickfrog == true) {
		kind = -2;
	}


	//spguisw
	if (kind == 0) {
		int starty = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y - 14;
		int endy = starty + 28;


		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPGUISWNUM; spgcnt++) {
				//int startx = s_spguisw[spgcnt].dispcenter.x - 70;
				//int endx = startx + 140 + 6;
				int startx = s_spguisw[spgcnt].dispcenter.x - 62;
				int endx = startx + 124 + 6;

				if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
					switch (spgcnt) {
					case 0:
						kind = (SPGUISW_CAMERA_AND_IK + 2);
						break;
					case 1:
						kind = (SPGUISW_DISP_AND_LIMITS + 2);
						break;
					case 2:
						kind = (SPGUISW_BRUSHPARAMS + 2);
						break;
					case 3:
						kind = (SPGUISW_BULLETPHYSICS + 2);
						break;
					case 4:
						kind = (SPGUISW_PROJ_AND_LOD + 2);
						break;
					default:
						kind = 1;
						break;
					}
					break;
				}
			}
		}


		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}

int PickSpCam(POINT srcpos)
{
	int kind = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}

	//if (g_previewFlag == 5){
	//	return 0;
	//}



	int starty = s_spcam[SPR_CAM_I].dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int spacnt;
		for (spacnt = 0; spacnt < SPR_CAM_MAX; spacnt++) {
			int startx = s_spcam[spacnt].dispcenter.x - (int)s_spsize / 2;
			int endx = startx + (int)s_spsize;

			if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
				switch (spacnt) {
				case 0:
					kind = PICK_CAMROT;
					break;
				case 1:
					kind = PICK_CAMMOVE;
					break;
				case 2:
					kind = PICK_CAMDIST;
					break;
				default:
					kind = 0;
					break;
				}
				break;
			}
		}
	}

	//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
	//	kind, srcpos.x, srcpos.y, starty, endy );
	//int spacnt;
	//for( spacnt = 0; spacnt < 3; spacnt++ ){
	//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
	//}

	return kind;
}

int PickSpCameraModeSW(POINT srcpos)
{
	int ispick = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		return 0;
	}

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	//sprefpos
	int startx = s_spcameramode.dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_spcameramode.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}

int PickSpCameraInheritSW(POINT srcpos)
{
	int ispick = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}

	//if (g_previewFlag != 0) {
	//	return 0;
	//}

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	//sprefpos
	int startx = s_spcamerainherit.dispcenter.x - (int)s_spsize / 2;

	//int endx = startx + (int)s_spsize;
	int endx = startx + (int)s_spsize / 2;//inheritスプライトは半分重ねて表示する　当たり判定をその分狭くする


	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_spcamerainherit.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}



int PickSpRig(POINT srcpos)
{
	int pickflag = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}
	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	int starty = s_sprig[SPRIG_INACTIVE].dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_sprig[SPRIG_INACTIVE].dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpCpLW2W(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spcplw2w.dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spcplw2w.dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpSmooth(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	int starty = s_spsmooth.dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spsmooth.dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpConstExe(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spconstexe.dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spconstexe.dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpConstRefresh(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spconstrefresh.dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spconstrefresh.dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpCopy(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 0) {
		return 0;
	}

	int starty = s_spcopy.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spcopy.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpSymCopy(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 0) {
		return 0;
	}

	int starty = s_spsymcopy.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spsymcopy.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpPaste(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 0) {
		return 0;
	}

	int starty = s_sppaste.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_sppaste.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpCopyHistory(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 0) {
		return 0;
	}

	int starty = s_spcopyhistory.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spcopyhistory.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}


int PickSpInterpolate(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 1) {
		return 0;
	}

	int starty = s_spinterpolate.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spinterpolate.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpInit(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 1) {
		return 0;
	}

	int starty = s_spinit.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spinit.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpScaleInit(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 1) {
		return 0;
	}

	int starty = s_spscaleinit.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spscaleinit.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpProperty(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 1) {
		return 0;
	}

	int starty = s_spproperty.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spproperty.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}



int PickSpZeroFrame(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 2) {
		return 0;
	}

	int starty = s_spzeroframe.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spzeroframe.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpCameraDolly(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 2) {
		return 0;
	}

	int starty = s_spcameradolly.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spcameradolly.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpModelPosDir(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 2) {
		return 0;
	}

	int starty = s_spmodelposdir.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spmodelposdir.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpMaterialRate(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 2) {
		return 0;
	}

	int starty = s_spmaterialrate.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spmaterialrate.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}


//int PickSpBt(POINT srcpos)
//{
//	int pickflag = 0;
//
//	//if (g_previewFlag == 5){
//	//	return 0;
//	//}
//
//
//	if (s_spbt.sprite == 0){
//		return 0;
//	}
//
//	int starty = s_spbt.dispcenter.y - 16;
//	int endy = starty + 32;
//
//	if ((srcpos.y >= starty) && (srcpos.y <= endy)){
//		int startx = s_spbt.dispcenter.x - 16;
//		int endx = startx + 32;
//
//		if ((srcpos.x >= startx) && (srcpos.x <= endx)){
//			pickflag = 1;
//		}
//	}
//
//	return pickflag;
//}

int SetSelectState()
{

	if ((g_previewFlag != 0) && (g_previewFlag != 5)) {
		return 0;
	}

	//if( !s_select || !s_model || g_previewFlag ){
	if (!s_select || !s_model || (g_previewFlag == 5)) {
		return 0;
	}

	if (!s_selectobj_objx || !s_selectobj_objy || !s_selectobj_objz || !s_selectobj_center ||
		!s_selectobj_ringx || !s_selectobj_ringy || !s_selectobj_ringz) {
		return 0;
	}
	if (!s_matred || !s_ringred || !s_matblue || !s_ringblue || !s_matgreen || !s_ringgreen || !s_matyellow || !s_matyellow) {
		return 0;
	}



	if (s_ikkind == 0) {
		s_select->SetDispFlag("ringX", 1);
		s_select->SetDispFlag("ringY", 1);
		s_select->SetDispFlag("ringZ", 1);
	}
	else if ((s_ikkind == 1) || (s_ikkind == 2)) {
		s_select->SetDispFlag("ringX", 0);
		s_select->SetDispFlag("ringY", 0);
		s_select->SetDispFlag("ringZ", 0);
	}
	////////
	UIPICKINFO pickinfo;
	ZeroMemory(&pickinfo, sizeof(UIPICKINFO));
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	pickinfo.clickpos = ptCursor;
	pickinfo.mousepos = ptCursor;
	pickinfo.mousebefpos = ptCursor;
	pickinfo.diffmouse = ChaVector2(0.0f, 0.0f);

	//pickinfo.winx = (int)DXUTGetWindowWidth();
	//pickinfo.winy = (int)DXUTGetWindowHeight();
	pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	pickinfo.pickrange = PICKRANGE;
	pickinfo.buttonflag = 0;

	//pickinfo.pickobjno = s_curboneno;
	pickinfo.pickobjno = -1;

	int spakind = 0;
	int spckind = 0;
	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
		spakind = PickSpAxis(ptCursor);
		spckind = PickSpCam(ptCursor);
	}
	if (spakind != 0) {
		pickinfo.pickobjno = s_curboneno;
		pickinfo.buttonflag = spakind;
	}
	else if (spckind != 0) {
		pickinfo.pickobjno = s_curboneno;
		pickinfo.buttonflag = spckind;
	}
	else {

		if (g_shiftkey == false) {
			CallF(s_model->PickBone(&pickinfo), return 1);
		}

		if (pickinfo.pickobjno >= 0) {
			pickinfo.buttonflag = PICK_CENTER;//!!!!!!!!!!!!!
		}
		else {
			if (s_dispselect) {
				bool excludeinvface = false;
				int colliobjx, colliobjy, colliobjz, colliringx, colliringy, colliringz;
				colliobjx = 0;
				colliobjy = 0;
				colliobjz = 0;
				colliringx = 0;
				colliringy = 0;
				colliringz = 0;

				colliobjx = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "objX", excludeinvface);
				colliobjy = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "objY", excludeinvface);
				colliobjz = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "objZ", excludeinvface);
				if (s_ikkind == 0) {
					colliringx = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "ringX", excludeinvface);
					colliringy = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "ringY", excludeinvface);
					colliringz = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "ringZ", excludeinvface);
				}
				else {
					colliringx = 0;
					colliringy = 0;
					colliringz = 0;
				}
				if (colliobjx || colliringx || colliobjy || colliringy || colliobjz || colliringz) {
					pickinfo.pickobjno = s_curboneno;
				}

				if (colliobjx || colliringx) {
					pickinfo.buttonflag = PICK_X;
				}
				else if (colliobjy || colliringy) {
					pickinfo.buttonflag = PICK_Y;
				}
				else if (colliobjz || colliringz) {
					pickinfo.buttonflag = PICK_Z;
				}
				else {
					ZeroMemory(&pickinfo, sizeof(UIPICKINFO));
					pickinfo.pickobjno = -1;
				}
			}
			else {
				ZeroMemory(&pickinfo, sizeof(UIPICKINFO));
				pickinfo.pickobjno = -1;
			}
		}
	}

	if (s_pickinfo.buttonflag != 0) {
		return 0;//!!!!!!!!!!!!!!!!!!!!!!!
	}

	//float hirate = 1.0f;
	//float hirate = 1.25f;
	float hirate = 1.0f;//2023/12/21
	float lowrate = 0.6f;

	//float hia = 0.3f;
	//float hia = 0.7f;
	float hia = 0.50f;//2023/12/21
	//float hia = 0.3f;
	//float lowa = 0.3f;
	float lowa = 0.45f;//23023/12/21

	ChaVector4 hidiffusemult = ChaVector4(hirate, hirate, hirate, hia);
	ChaVector4 lowdiffusemult = ChaVector4(lowrate, lowrate, lowrate, lowa);
	//ChaVector4 hidiffusemult = ChaVector4(hirate, hirate, hirate, hia);
	//ChaVector4 lowdiffusemult = ChaVector4(hirate, hirate, hirate, lowa);


	if (s_matred && s_ringred && s_matblue && s_ringblue && s_matgreen && s_ringgreen && s_matyellow) {
		if ((pickinfo.pickobjno >= 0) && (s_curboneno == pickinfo.pickobjno)) {

			if ((pickinfo.buttonflag == PICK_X) || (pickinfo.buttonflag == PICK_SPA_X)) {//red
				//s_matred->SetDif4F(s_matredmat * hirate);
				//s_ringred->SetDif4F(s_ringredmat * hirate);
				//s_matred->SetDif4FW(hia);
				//s_ringred->SetDif4FW(hia);

				//s_matblue->SetDif4F(s_matbluemat * lowrate);
				//s_ringblue->SetDif4F(s_ringbluemat * lowrate);
				//s_matblue->SetDif4FW(lowa);
				//s_ringblue->SetDif4FW(lowa);

				//s_matgreen->SetDif4F(s_matgreenmat * lowrate);
				//s_ringgreen->SetDif4F(s_ringgreenmat * lowrate);
				//s_matgreen->SetDif4FW(lowa);
				//s_ringgreen->SetDif4FW(lowa);

				//s_matyellow->SetDif4F(s_matyellowmat * lowrate);
				//s_matyellow->SetDif4FW(lowa);


				s_matred->SetTempDiffuseMult(hidiffusemult);
				s_ringred->SetTempDiffuseMult(hidiffusemult);
				s_matblue->SetTempDiffuseMult(lowdiffusemult);
				s_ringblue->SetTempDiffuseMult(lowdiffusemult);
				s_matgreen->SetTempDiffuseMult(lowdiffusemult);
				s_ringgreen->SetTempDiffuseMult(lowdiffusemult);
				s_matyellow->SetTempDiffuseMult(lowdiffusemult);

				s_matred->SetTempDiffuseMultFlag(true);
				s_ringred->SetTempDiffuseMultFlag(true);
				s_matblue->SetTempDiffuseMultFlag(true);
				s_ringblue->SetTempDiffuseMultFlag(true);
				s_matgreen->SetTempDiffuseMultFlag(true);
				s_ringgreen->SetTempDiffuseMultFlag(true);
				s_matyellow->SetTempDiffuseMultFlag(true);

			}
			else if ((pickinfo.buttonflag == PICK_Y) || (pickinfo.buttonflag == PICK_SPA_Y)) {//green
				//s_matred->SetDif4F(s_matredmat * lowrate);
				//s_ringred->SetDif4F(s_ringredmat * lowrate);
				//s_matred->SetDif4FW(lowa);
				//s_ringred->SetDif4FW(lowa);

				//s_matblue->SetDif4F(s_matbluemat * lowrate);
				//s_ringblue->SetDif4F(s_ringbluemat * lowrate);
				//s_matblue->SetDif4FW(lowa);
				//s_ringblue->SetDif4FW(lowa);

				//s_matgreen->SetDif4F(s_matgreenmat * hirate);
				//s_ringgreen->SetDif4F(s_ringgreenmat * hirate);
				//s_matgreen->SetDif4FW(hia);
				//s_ringgreen->SetDif4FW(hia);

				//s_matyellow->SetDif4F(s_matyellowmat * lowrate);
				//s_matyellow->SetDif4FW(lowa);

				s_matred->SetTempDiffuseMult(lowdiffusemult);
				s_ringred->SetTempDiffuseMult(lowdiffusemult);
				s_matblue->SetTempDiffuseMult(lowdiffusemult);
				s_ringblue->SetTempDiffuseMult(lowdiffusemult);
				s_matgreen->SetTempDiffuseMult(hidiffusemult);
				s_ringgreen->SetTempDiffuseMult(hidiffusemult);
				s_matyellow->SetTempDiffuseMult(lowdiffusemult);

				s_matred->SetTempDiffuseMultFlag(true);
				s_ringred->SetTempDiffuseMultFlag(true);
				s_matblue->SetTempDiffuseMultFlag(true);
				s_ringblue->SetTempDiffuseMultFlag(true);
				s_matgreen->SetTempDiffuseMultFlag(true);
				s_ringgreen->SetTempDiffuseMultFlag(true);
				s_matyellow->SetTempDiffuseMultFlag(true);
			}
			else if ((pickinfo.buttonflag == PICK_Z) || (pickinfo.buttonflag == PICK_SPA_Z)) {//blue
				//s_matred->SetDif4F(s_matredmat * lowrate);
				//s_ringred->SetDif4F(s_ringredmat * lowrate);
				//s_matred->SetDif4FW(lowa);
				//s_ringred->SetDif4FW(lowa);

				//s_matblue->SetDif4F(s_matbluemat * hirate);
				//s_ringblue->SetDif4F(s_ringbluemat * hirate);
				//s_matblue->SetDif4FW(hia);
				//s_ringblue->SetDif4FW(hia);

				//s_matgreen->SetDif4F(s_matgreenmat * lowrate);
				//s_ringgreen->SetDif4F(s_ringgreenmat * lowrate);
				//s_matgreen->SetDif4FW(lowa);
				//s_ringgreen->SetDif4FW(lowa);

				//s_matyellow->SetDif4F(s_matyellowmat * lowrate);
				//s_matyellow->SetDif4FW(lowa);


				s_matred->SetTempDiffuseMult(lowdiffusemult);
				s_ringred->SetTempDiffuseMult(lowdiffusemult);
				s_matblue->SetTempDiffuseMult(hidiffusemult);
				s_ringblue->SetTempDiffuseMult(hidiffusemult);
				s_matgreen->SetTempDiffuseMult(lowdiffusemult);
				s_ringgreen->SetTempDiffuseMult(lowdiffusemult);
				s_matyellow->SetTempDiffuseMult(lowdiffusemult);

				s_matred->SetTempDiffuseMultFlag(true);
				s_ringred->SetTempDiffuseMultFlag(true);
				s_matblue->SetTempDiffuseMultFlag(true);
				s_ringblue->SetTempDiffuseMultFlag(true);
				s_matgreen->SetTempDiffuseMultFlag(true);
				s_ringgreen->SetTempDiffuseMultFlag(true);
				s_matyellow->SetTempDiffuseMultFlag(true);
			}
			else if (pickinfo.buttonflag == PICK_CENTER) {//yellow
				//s_matred->SetDif4F(s_matredmat * lowrate);
				//s_ringred->SetDif4F(s_ringredmat * lowrate);
				//s_matred->SetDif4FW(lowa);
				//s_ringred->SetDif4FW(lowa);

				//s_matblue->SetDif4F(s_matbluemat * lowrate);
				//s_ringblue->SetDif4F(s_ringbluemat * lowrate);
				//s_matblue->SetDif4FW(lowa);
				//s_ringblue->SetDif4FW(lowa);

				//s_matgreen->SetDif4F(s_matgreenmat * lowrate);
				//s_ringgreen->SetDif4F(s_ringgreenmat * lowrate);
				//s_matgreen->SetDif4FW(lowa);
				//s_ringgreen->SetDif4FW(lowa);

				//s_matyellow->SetDif4F(s_matyellowmat * hirate);
				//s_matyellow->SetDif4FW(hia);

				s_matred->SetTempDiffuseMult(lowdiffusemult);
				s_ringred->SetTempDiffuseMult(lowdiffusemult);
				s_matblue->SetTempDiffuseMult(lowdiffusemult);
				s_ringblue->SetTempDiffuseMult(lowdiffusemult);
				s_matgreen->SetTempDiffuseMult(lowdiffusemult);
				s_ringgreen->SetTempDiffuseMult(lowdiffusemult);
				s_matyellow->SetTempDiffuseMult(hidiffusemult);

				s_matred->SetTempDiffuseMultFlag(true);
				s_ringred->SetTempDiffuseMultFlag(true);
				s_matblue->SetTempDiffuseMultFlag(true);
				s_ringblue->SetTempDiffuseMultFlag(true);
				s_matgreen->SetTempDiffuseMultFlag(true);
				s_ringgreen->SetTempDiffuseMultFlag(true);
				s_matyellow->SetTempDiffuseMultFlag(true);
			}
		}
		else {
			//s_matred->SetDif4F(s_matredmat * lowrate);
			//s_ringred->SetDif4F(s_ringredmat * lowrate);
			//s_matred->SetDif4FW(lowa);
			//s_ringred->SetDif4FW(lowa);

			//s_matblue->SetDif4F(s_matbluemat * lowrate);
			//s_ringblue->SetDif4F(s_ringbluemat * lowrate);
			//s_matblue->SetDif4FW(lowa);
			//s_ringblue->SetDif4FW(lowa);

			//s_matgreen->SetDif4F(s_matgreenmat * lowrate);
			//s_ringgreen->SetDif4F(s_ringgreenmat * lowrate);
			//s_matgreen->SetDif4FW(lowa);
			//s_ringgreen->SetDif4FW(lowa);

			//s_matyellow->SetDif4F(s_matyellowmat * lowrate);
			//s_matyellow->SetDif4FW(lowa);

			s_matred->SetTempDiffuseMult(lowdiffusemult);
			s_ringred->SetTempDiffuseMult(lowdiffusemult);
			s_matblue->SetTempDiffuseMult(lowdiffusemult);
			s_ringblue->SetTempDiffuseMult(lowdiffusemult);
			s_matgreen->SetTempDiffuseMult(lowdiffusemult);
			s_ringgreen->SetTempDiffuseMult(lowdiffusemult);
			s_matyellow->SetTempDiffuseMult(lowdiffusemult);

			s_matred->SetTempDiffuseMultFlag(true);
			s_ringred->SetTempDiffuseMultFlag(true);
			s_matblue->SetTempDiffuseMultFlag(true);
			s_ringblue->SetTempDiffuseMultFlag(true);
			s_matgreen->SetTempDiffuseMultFlag(true);
			s_ringgreen->SetTempDiffuseMultFlag(true);
			s_matyellow->SetTempDiffuseMultFlag(true);

		}
	}

	return 0;
}

int CreateTimeLineMark(int topboneno)
{
	if (g_previewFlag != 0) {
		return 0;
	}

	if (s_model && s_owpTimeline && s_owpLTimeline) {
		if (topboneno < 0) {
			CreateMarkReq(s_editmotionflag, 0);
		}
		else {
			CreateMarkReq(topboneno, 0);
		}

		SetTimelineMark();

		s_owpTimeline->callRewrite();
		s_owpTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開

		s_owpLTimeline->callRewrite();
		s_owpLTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開
	}
	return 0;
}

int CreateMotionBrush(double srcstart, double srcend, bool onrefreshflag)
{
	//int keynum;
	double startframe, endframe;
	//s_editrange.GetRange(&keynum, &startframe, &endframe);

	if (!s_model) {
		//return -1;
		return 2;//2023/10/05 
	}
	if (!s_model->GetCurMotInfo()) {
		//return -1;
		return 2;//2023/10/05 
	}


	if ((srcstart < 0.0) || (srcend < 0.0)) {
		//_ASSERT(0);
		return 2;//フレーム,フレーム長範囲外は 2 を返す
	}
	if (srcstart > srcend) {
		double tmp = srcstart;
		srcstart = srcend;
		srcend = tmp;
	}


	startframe = srcstart;
	endframe = srcend;


	if (g_motionbrush_value) {
		free(g_motionbrush_value);
		g_motionbrush_value = 0;
	}

	int frameleng = (int)s_model->GetCurMotInfo()->frameleng;
	if ((frameleng <= 0) || (frameleng > 100000)) {
		//_ASSERT(0);
		return 2;//フレーム,フレーム長範囲外は 2 を返す
	}

	g_motionbrush_startframe = startframe;
	g_motionbrush_endframe = endframe;
	g_motionbrush_numframe = endframe - startframe + 1;
	g_motionbrush_frameleng = frameleng;

	//g_motionbrush_applyframe = startframe + (endframe - startframe) * g_applyrate * 0.01;
	if (g_applyrate == 0.0) {
		g_motionbrush_applyframe = startframe;
	}
	else if (g_applyrate == 100.0) {
		g_motionbrush_applyframe = endframe;
	}
	else {
		g_motionbrush_applyframe = (double)((int)(startframe + (endframe - startframe) * (g_applyrate / 100.0)));//editrangeと同じ式
	}


	if ((g_motionbrush_applyframe < 0) || (g_motionbrush_applyframe > endframe)) {
		//_ASSERT(0);
		return 2;//フレーム,フレーム長範囲外は 2 を返す
	}

	g_motionbrush_value = (float*)malloc(sizeof(float) * (g_motionbrush_frameleng + 1));
	if (!g_motionbrush_value) {
		_ASSERT(0);
		return -1;
	}
	::memset(g_motionbrush_value, 0, sizeof(float) * (g_motionbrush_frameleng + 1));

	float* tempvalue;
	tempvalue = (float*)malloc(sizeof(float) * (g_motionbrush_frameleng + 1));
	if (!tempvalue) {
		_ASSERT(0);
		return -1;
	}
	::memset(tempvalue, 0, sizeof(float) * (g_motionbrush_frameleng + 1));


	int ret = 0;

	if (s_plugin && (g_motionbrush_method >= 0) && (g_motionbrush_method <= MAXPLUGIN)) {
		s_onselectplugin = 1;


		//このif文はプラグイン内にも推奨
		if ((g_motionbrush_startframe >= 0.0) && (g_motionbrush_startframe < 1e5) &&
			(g_motionbrush_endframe >= g_motionbrush_startframe) && (g_motionbrush_endframe < 1e5) &&
			(g_motionbrush_applyframe >= g_motionbrush_startframe) && (g_motionbrush_applyframe <= g_motionbrush_endframe) &&
			(g_motionbrush_frameleng > g_motionbrush_endframe) && (g_motionbrush_frameleng < 1e5) &&
			(g_brushrepeats >= 1) && (g_brushrepeats <= 10) &&
			tempvalue) {

			int pluginno;
			for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
				if ((s_plugin + pluginno)->menuid == g_motionbrush_method) {
					//DbgOut( "viewer : OnSelectPlugin : pluginno %d, menuid %d\r\n", pluginno, menuid );
					ret = (s_plugin + pluginno)->CreateMotionBrush(g_motionbrush_startframe, g_motionbrush_endframe, g_motionbrush_applyframe, g_motionbrush_frameleng, g_brushrepeats, g_brushmirrorUflag, g_brushmirrorVflag, g_ifmirrorVDiv2flag, tempvalue);
					if ((ret != 0) && (ret != 2)) {
						_ASSERT(0);
						::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
						PostQuitMessage(ret);
					}
				}
			}

			//ZeroMemory(g_motionbrush_value, sizeof(float) * (unsigned int)g_motionbrush_frameleng);//2022/09/12

			int cpframe;
			for (cpframe = 0; cpframe < (int)g_motionbrush_frameleng; cpframe++) {
				//for (cpframe = (int)g_motionbrush_startframe; cpframe <= (int)g_motionbrush_endframe; cpframe++) {//2022/09/12
				float cpvalue;

				//if ((cpframe >= (int)g_motionbrush_startframe) && (cpframe <= (int)g_motionbrush_endframe)) {
				cpvalue = *(tempvalue + cpframe);
				cpvalue = min(1.0f, cpvalue);
				cpvalue = max(-1.0f, cpvalue);
				//}
				//else {
				//	cpvalue = 0.0f;
				//}

				*(g_motionbrush_value + cpframe) = cpvalue;
			}

		}
		else {
			//後処理のためにreturnせずにretにセットする
			ret = 2;//フレーム,フレーム長範囲外は 2 を返す
		}

		s_onselectplugin = 0;
	}


	if (tempvalue) {
		free(tempvalue);
		tempvalue = 0;
	}


	//2024/01/19
	//BrushParamsプレートメニューでTopPosを移動した直後のIK中に　3dwndのポーズが変わらない不具合解消のため
	//s_editrangeを更新
	s_buttonselectstart = g_motionbrush_startframe;
	s_buttonselectend = g_motionbrush_endframe;
	CEditRange::SetApplyRate((double)g_applyrate);
	OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);


	if (onrefreshflag == false) {//Refresh関数以外から呼び出したとき

		if (s_owpTimeline)
			s_owpTimeline->setMaxTime(frameleng);//!!!!!!!!!!!!!!!!!!!!!
		if (s_owpLTimeline)
			s_owpLTimeline->setMaxTime(frameleng);//!!!!!!!!!!!!!!!!!!!!!

		if (s_owpTimeline)
			s_owpTimeline->setCurrentTime(g_motionbrush_applyframe, false);//!!!!!!!!!!!!!!!!!!!!!
		if (s_owpLTimeline)
			s_owpLTimeline->setCurrentTime(g_motionbrush_applyframe, false);//!!!!!!!!!!!!!!!!!!!!!
		if (s_owpEulerGraph)
			s_owpEulerGraph->setCurrentTime(g_motionbrush_applyframe, false);//!!!!!!!!!!!!!!!!!!!!!

		UpdateEditedEuler();
	}


	UpdateTopPosText();

	SavePlayingStartEnd();


	return ret;
}


int SetTimelineMark()
{
	if (!s_model || !s_owpTimeline || !s_owpLTimeline) {
		_ASSERT(0);
		return 0;
	}

	if (g_previewFlag != 0) {
		return 0;
	}


	s_owpTimeline->setRewriteOnChangeFlag(false);		//再描画要求を再開


//	s_owpTimeline->deleteKey();

	//map<int,CBone*>::iterator itrbone;
	//for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	//	CBone* curbone = itrbone->second;
	//	if( curbone ){
	//		int curlineno = s_boneno2lineno[ curbone->GetBoneNo() ];
	//		if( curlineno >= 0 ){
	//			double curframe;
	//			for( curframe = 0.0; curframe < s_model->GetCurMotInfo()->frameleng; curframe += 1.0 ){
	//				KeyInfo chkki = s_owpTimeline->ExistKey( curlineno, curframe );
	//				if( chkki.lineIndex >= 0 ){
	//					s_owpTimeline->deleteKey( curlineno, curframe );
	//				}
	//			}
	//		}
	//	}
	//}

	//map<int, CBone*>::iterator itrbone;
	//for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	//	CBone* curbone = itrbone->second;
	//	if( curbone ){
	//		int curlineno = s_boneno2lineno[ curbone->GetBoneNo() ];
	//		if( curlineno >= 0 ){
	//			map<int, map<double, int>>::iterator itrcur;
	//			itrcur = curbone->FindMotMarkOfMap( s_model->GetCurMotInfo()->motid );
	//			if( itrcur != curbone->GetMotMarkOfMapBegin() ){
	//				map<double, int>::iterator itrmark;
	//				for( itrmark = itrcur->second.begin(); itrmark != itrcur->second.end(); itrmark++ ){
	//					double curframe = itrmark->first;
	//					s_owpTimeline->newKey( curbone->GetWBoneName(), curframe, 0 );
	//				}
	//			}
	//		}
	//	}
	//}

	s_owpTimeline->callRewrite();
	s_owpTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開

	return 0;
}


void CreateMarkReq(int curboneno, int broflag)
{
	if (curboneno < 0) {
		return;
	}
	CBone* curbone = s_model->GetBoneByID(curboneno);
	if (curbone) {
		if (curbone->IsSkeleton()) {
			int curlineno = s_boneno2lineno[curboneno];
			if (curlineno >= 0) {
				int keynum;
				double startframe, endframe;
				s_editrange.GetRange(&keynum, &startframe, &endframe);
				s_model->AddBoneMotMark(s_owpTimeline, curboneno, curlineno, startframe, endframe, 1);
			}
		}

		if (curbone->GetChild(false)) {
			CreateMarkReq(curbone->GetChild(false)->GetBoneNo(), 1);
		}
		if (broflag && curbone->GetBrother(false)) {
			CreateMarkReq(curbone->GetBrother(false)->GetBoneNo(), 1);
		}

	}

}

int SetLTimelineMark(int curboneno)
{
	if (g_previewFlag != 0) {
		return 0;
	}

	if ((curboneno >= 0) && s_model && s_owpTimeline && s_owpLTimeline) {
		CBone* opebone = s_model->GetBoneByID(curboneno);
		if (opebone) {
			CBone* parentbone = opebone->GetParent(false);
			if (s_ikkind == 0) {
				//ikkind がROT(0)の場合はIK　それ以外のMV, SCALEの場合にはFK
				if (parentbone && parentbone->IsSkeleton()) {
					opebone = parentbone;
				}
			}

			int opeboneno = opebone->GetBoneNo();
			if (opeboneno >= 0) {
				int curlineno = s_boneno2lineno[opeboneno];
				if (curlineno >= 0) {
					//s_owpLTimeline->deleteLine(2);

					WCHAR markname[256] = { 0L };
					////swprintf_s( markname, 256, L"Mark:%s", opebone->GetWBoneName() );
					if (g_limitdegflag == true) {
						swprintf_s(markname, 256, L"[L] : %s", opebone->GetWBoneName());
					}
					else {
						swprintf_s(markname, 256, L"[W] : %s", opebone->GetWBoneName());
					}

					//s_owpLTimeline->newLine(0, 0, markname, RGB(168, 129, 129));

					if (s_owpPlayerButton) {
						s_owpPlayerButton->setJointName(markname);//2023/01/08
					}

					//if (s_owpTimeline && s_owpLTimeline) {
					//	double frame;
					//	for (frame = 0.0; frame < s_model->GetCurMotInfo()->frameleng; frame += 1.0) {
					//		KeyInfo chkki = s_owpTimeline->ExistKey(curlineno, frame);
					//		if (chkki.lineIndex >= 0) {
					//			s_owpLTimeline->newKey(markname, frame, 0);
					//		}
					//	}
					//}
				}

			}
		}
	}

	if (s_owpLTimeline) {
		s_owpLTimeline->callRewrite();
	}
	if (s_owpTimeline) {
		s_owpTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開
	}
	return 0;
}

int ExportFBXFile()
{
	if (!s_model || !s_owpLTimeline || !s_chascene) {
		_ASSERT(0);
		return 0;
	}

	g_previewFlag = 0;
	s_owpLTimeline->setCurrentTime(0.0, true);

	s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matVP, 0.0);
	
	WCHAR filename[MAX_PATH] = { 0L };
	OPENFILENAME ofn1;
	ZeroMemory(&ofn1, sizeof(OPENFILENAME));
	ofn1.lStructSize = sizeof(OPENFILENAME);
	//ofn1.hwndOwner = s_3dwnd;
	ofn1.hwndOwner = s_3dwnd;
	ofn1.hInstance = 0;
	ofn1.lpstrFilter = L"FBX file(*.fbx)\0";
	ofn1.lpstrCustomFilter = NULL;
	ofn1.nMaxCustFilter = 0;
	ofn1.nFilterIndex = 0;
	ofn1.lpstrFile = filename;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.lpstrFileTitle = NULL;
	ofn1.nMaxFileTitle = 0;
	ofn1.lpstrInitialDir = NULL;
	ofn1.lpstrTitle = L"GetFileNameDlg";
	//ofn1.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	ofn1.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn1.nFileOffset = 0;
	ofn1.nFileExtension = 0;
	ofn1.lpstrDefExt = L"fbx";
	ofn1.lCustData = NULL;
	ofn1.lpfnHook = NULL;
	ofn1.lpTemplateName = NULL;


	{
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
		//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
		InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

		if (GetOpenFileNameW(&ofn1) != IDOK) {
			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);
			return 0;
		}

		InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
		//UnhookWinEvent(hhook);
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
	}



	char fbxpath[MAX_PATH] = { 0 };
	WideCharToMultiByte(CP_UTF8, 0, filename, -1, fbxpath, MAX_PATH, NULL, NULL);


	{
		s_owpLTimeline->setCurrentTime(0.0, true);
		s_model->SetMotionFrame(0.0);
		ChaMatrix tmpwm = s_model->GetWorldMat();
		s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);

		//ここでAxisMatXの初期化
		s_model->CreateBtObject(g_limitdegflag, 1);
		s_model->CalcBtAxismat(2);//2
		s_model->SetInitAxisMatX(1);
	}


	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	char fbxdate[MAX_PATH] = { 0L };
	sprintf_s(fbxdate, MAX_PATH, "CommentForEGP_%04u%02u%02u%02u%02u%02u",
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	//CallF( WriteFBXFile( s_model, fbxpath, s_dummytri, mb, g_tmpmqomult, s_fbxbunki ), return 1 );
	int result = WriteFBXFile(g_limitdegflag, s_psdk, s_model, fbxpath, fbxdate);
	if (result != 0) {
		::MessageBox(NULL, L"保存に失敗しました。\n書き込み禁止ディレクトリの可能性があります。\n保存場所を変えて再試行してみてください。", L"エラー", MB_OK);
		_ASSERT(0);
		return 1;
	}

	if (s_model->GetOldAxisFlagAtLoading() == 0) {
		WCHAR lmtname[MAX_PATH] = { 0L };
		swprintf_s(lmtname, MAX_PATH, L"%s.lmt", filename);
		CLmtFile lmtfile;
		lmtfile.WriteLmtFile(lmtname, s_model, fbxdate);

		WCHAR rigname[MAX_PATH] = { 0L };
		swprintf_s(rigname, MAX_PATH, L"%s.rig", filename);
		CRigFile rigfile;
		rigfile.WriteRigFile(rigname, s_model);

	}


	return 0;
}

int ExportBntFile()
{
	if (!s_model || !s_owpLTimeline || !s_chascene) {
		_ASSERT(0);
		return 0;
	}

	g_previewFlag = 0;
	s_owpLTimeline->setCurrentTime(0.0, true);

	s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matVP, 0.0);



	WCHAR filename[MAX_PATH] = { 0L };
	OPENFILENAME ofn1;
	ZeroMemory(&ofn1, sizeof(OPENFILENAME));
	ofn1.lStructSize = sizeof(OPENFILENAME);
	ofn1.hwndOwner = s_3dwnd;
	ofn1.hInstance = 0;
	ofn1.lpstrFilter = L"BNT file(*.bnt)\0";
	ofn1.lpstrCustomFilter = NULL;
	ofn1.nMaxCustFilter = 0;
	ofn1.nFilterIndex = 0;
	ofn1.lpstrFile = filename;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.lpstrFileTitle = NULL;
	ofn1.nMaxFileTitle = 0;
	ofn1.lpstrInitialDir = NULL;
	ofn1.lpstrTitle = L"GetFileNameDlg";
	//ofn1.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	ofn1.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn1.nFileOffset = 0;
	ofn1.nFileExtension = 0;
	ofn1.lpstrDefExt = L"bnt";
	ofn1.lCustData = NULL;
	ofn1.lpfnHook = NULL;
	ofn1.lpTemplateName = NULL;


	{
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
		//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
		InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

		if (GetOpenFileNameW(&ofn1) != IDOK) {
			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);
			return 0;
		}

		InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
		//UnhookWinEvent(hhook);
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
	}

	//char fbxpath[MAX_PATH] = {0};
	//WideCharToMultiByte( CP_UTF8, 0, filename, -1, fbxpath, MAX_PATH, NULL, NULL );	

	if (s_chascene->ModelEmpty()) {
		_ASSERT(0);
		return 0;
	}
	MODELELEM wme = s_chascene->GetModelElem(0);
	CModel* curmodel = wme.modelptr;
	if (!curmodel) {
		return 0;
	}

	CBntFile bntfile;
	CallF(bntfile.WriteBntFile(g_limitdegflag, filename, wme), return 1);

	return 0;
}





int AddEditRangeHistory()
{
	static int s_historycnt = 0;

	if (!s_editrangehistory) {
		return 0;
	}

	if ((s_editrangehistoryno < 0) || (s_editrangehistoryno >= EDITRANGEHISTORYNUM)) {
		_ASSERT(0);
		s_editrangehistoryno = 0;
	}
	if ((s_editrangesetindex < 0) || (s_editrangesetindex >= EDITRANGEHISTORYNUM)) {
		_ASSERT(0);
		s_editrangesetindex = 0;
	}

	if (s_editrange.IsSameStartAndEnd()) {
		//_ASSERT(0);
		return 0;
	}


	int findflag = 0;
	int erhno;
	for (erhno = 0; erhno < EDITRANGEHISTORYNUM; erhno++) {
		if (*(s_editrangehistory + erhno) == s_editrange) {
			findflag++;
			break;
		}
	}

	if (findflag == 0) {
		s_editrangesetindex += 1;
		if (s_editrangesetindex >= EDITRANGEHISTORYNUM) {
			s_editrangesetindex = 0;
		}

		*(s_editrangehistory + s_editrangesetindex) = s_editrange;
		(s_editrangehistory + s_editrangesetindex)->SetSetFlag(1);
		(s_editrangehistory + s_editrangesetindex)->SetSetCnt(s_historycnt);
		s_historycnt++;

		s_editrangehistoryno = s_editrangesetindex;
	}
	return 0;
}

int RollBackEditRange(int prevrangeFlag, int nextrangeFlag)
{
	if ((s_editrangehistoryno < 0) || (s_editrangehistoryno >= EDITRANGEHISTORYNUM)) {
		_ASSERT(0);
		s_editrangehistoryno = 0;
	}

	int findindex = -1;
	int erhcnt;
	int curindex = s_editrangehistoryno;

	if (prevrangeFlag && (s_editrange.IsSameStartAndEnd())) {
		//prevボタンのとき　範囲が解除されている場合は現状復帰のためインデックスはそのまま
		if ((s_editrangehistory + curindex)->GetSetFlag() == 1) {
			findindex = curindex;
		}
	}
	else {
		for (erhcnt = 0; erhcnt < EDITRANGEHISTORYNUM; erhcnt++) {
			if (prevrangeFlag) {
				curindex -= 1;
			}
			else if (nextrangeFlag) {
				curindex += 1;
			}
			else {
				_ASSERT(0);
				break;
			}
			if (curindex < 0) {
				curindex = EDITRANGEHISTORYNUM - 1;
			}
			if (curindex >= EDITRANGEHISTORYNUM) {
				curindex = 0;
			}
			if ((s_editrangehistory + curindex)->GetSetFlag() == 1) {
				findindex = curindex;
				break;
			}
		}
	}

	if (findindex >= 0) {
		s_editrange = *(s_editrangehistory + findindex);
		s_editrangehistoryno = findindex;
	}

	return 0;
}

int CreateGUIDlgDispParams()
{
	if (s_guidlg[GUIDLG_DISP_AND_LIMITS]) {
		//already opened
		return 0;
	}

	s_guidlg[GUIDLG_DISP_AND_LIMITS] = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_GUIDISPPARAMS), g_mainhwnd, (DLGPROC)GUIDispParamsDlgProc);
	if (!s_guidlg[GUIDLG_DISP_AND_LIMITS]) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_guidlg[GUIDLG_DISP_AND_LIMITS], g_mainhwnd);
	SetWindowPos(
		s_guidlg[GUIDLG_DISP_AND_LIMITS],
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	ShowWindow(s_guidlg[GUIDLG_DISP_AND_LIMITS], SW_HIDE);
	return 0;

}
int CreateGUIDlgBrushes()
{
	if (s_guidlg[GUIDLG_BRUSHPARAMS]) {
		//already opened
		return 0;
	}

	s_guidlg[GUIDLG_BRUSHPARAMS] = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_GUIBRUSHESDLG), g_mainhwnd, (DLGPROC)GUIBrushesDlgProc);
	if (!s_guidlg[GUIDLG_BRUSHPARAMS]) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_guidlg[GUIDLG_BRUSHPARAMS], g_mainhwnd);
	SetWindowPos(
		s_guidlg[GUIDLG_BRUSHPARAMS],
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	ShowWindow(s_guidlg[GUIDLG_BRUSHPARAMS], SW_HIDE);
	return 0;

}
int CreateGUIDlgBullet()
{
	if (s_guidlg[GUIDLG_BULLETPHYSICS]) {
		//already opened
		return 0;
	}

	s_guidlg[GUIDLG_BULLETPHYSICS] = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_GUIBULLETDLG), g_mainhwnd, (DLGPROC)GUIBulletDlgProc);
	if (!s_guidlg[GUIDLG_BULLETPHYSICS]) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_guidlg[GUIDLG_BULLETPHYSICS], g_mainhwnd);
	SetWindowPos(
		s_guidlg[GUIDLG_BULLETPHYSICS],
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	ShowWindow(s_guidlg[GUIDLG_BULLETPHYSICS], SW_HIDE);
	return 0;

}
int CreateGUIDlgLOD()
{
	if (s_guidlg[GUIDLG_PROJ_AND_LOD]) {
		//already opened
		return 0;
	}

	s_guidlg[GUIDLG_PROJ_AND_LOD] = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_LODDLG), g_mainhwnd, (DLGPROC)GUILODDlgProc);
	if (!s_guidlg[GUIDLG_PROJ_AND_LOD]) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_guidlg[GUIDLG_PROJ_AND_LOD], g_mainhwnd);
	SetWindowPos(
		s_guidlg[GUIDLG_PROJ_AND_LOD],
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	ShowWindow(s_guidlg[GUIDLG_PROJ_AND_LOD], SW_HIDE);
	return 0;

}


int CreateLightsWnd()
{

	if (s_lightsforeditdlg) {
		//already opened
		return 0;
	}


	//s_dseullimitctrls.clear();


	s_lightsforeditdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_LIGHTSFOREDITDLG), g_mainhwnd, (DLGPROC)LightsForEditDlgProc);
	if (!s_lightsforeditdlg) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_lightsforeditdlg, g_mainhwnd);
	SetWindowPos(
		s_lightsforeditdlg,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	////s_dseullimitctrls.push_back(IDD_ANGLELIMITDLG);
	//s_dseullimitctrls.push_back(IDC_BONEAXIS);
	//s_dseullimitctrls.push_back(IDC_EDIT_XL);
	//s_dseullimitctrls.push_back(IDC_EDIT_XU);
	//s_dseullimitctrls.push_back(IDC_EDIT_YL);
	//s_dseullimitctrls.push_back(IDC_EDIT_YU);
	//s_dseullimitctrls.push_back(IDC_EDIT_ZL);
	//s_dseullimitctrls.push_back(IDC_EDIT_ZU);
	//s_dseullimitctrls.push_back(IDOK);


	//ShowWindow(s_lightsforeditdlg, SW_SHOW);
	//UpdateWindow(s_lightsforeditdlg);

	ShowWindow(s_lightsforeditdlg, SW_HIDE);
	//UpdateWindow(s_lightsforeditdlg);


	//AngleLimit2Bone();


	return 0;
}

int CreateLaterTransparentWnd()
{

	if (s_latertransparentdlg) {
		//already opened
		return 0;
	}


	////s_dseullimitctrls.clear();


	s_latertransparentdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_LATERTRANSPARENTDLG), g_mainhwnd, (DLGPROC)LaterTransparentDlgProc);
	if (!s_latertransparentdlg) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_latertransparentdlg, g_mainhwnd);
	SetWindowPos(
		s_latertransparentdlg,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	////s_dseullimitctrls.push_back(IDD_ANGLELIMITDLG);
	//s_dseullimitctrls.push_back(IDC_BONEAXIS);
	//s_dseullimitctrls.push_back(IDC_EDIT_XL);
	//s_dseullimitctrls.push_back(IDC_EDIT_XU);
	//s_dseullimitctrls.push_back(IDC_EDIT_YL);
	//s_dseullimitctrls.push_back(IDC_EDIT_YU);
	//s_dseullimitctrls.push_back(IDC_EDIT_ZL);
	//s_dseullimitctrls.push_back(IDC_EDIT_ZU);
	//s_dseullimitctrls.push_back(IDOK);


	//ShowWindow(s_lightsforeditdlg, SW_SHOW);
	//UpdateWindow(s_lightsforeditdlg);

	ShowWindow(s_latertransparentdlg, SW_HIDE);
	//UpdateWindow(s_lightsforeditdlg);


	//AngleLimit2Bone();


	return 0;
}

int CreateShadowParamsWnd()
{

	if (s_shadowparamsdlg) {
		//already opened
		return 0;
	}


	////s_dseullimitctrls.clear();


	s_shadowparamsdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SHADOWPARAMS), g_mainhwnd, (DLGPROC)ShadowParamsDlgProc);
	if (!s_shadowparamsdlg) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_shadowparamsdlg, g_mainhwnd);
	SetWindowPos(
		s_shadowparamsdlg,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	////s_dseullimitctrls.push_back(IDD_ANGLELIMITDLG);
	//s_dseullimitctrls.push_back(IDC_BONEAXIS);
	//s_dseullimitctrls.push_back(IDC_EDIT_XL);
	//s_dseullimitctrls.push_back(IDC_EDIT_XU);
	//s_dseullimitctrls.push_back(IDC_EDIT_YL);
	//s_dseullimitctrls.push_back(IDC_EDIT_YU);
	//s_dseullimitctrls.push_back(IDC_EDIT_ZL);
	//s_dseullimitctrls.push_back(IDC_EDIT_ZU);
	//s_dseullimitctrls.push_back(IDOK);


	//ShowWindow(s_lightsforeditdlg, SW_SHOW);
	//UpdateWindow(s_lightsforeditdlg);

	ShowWindow(s_shadowparamsdlg, SW_HIDE);
	//UpdateWindow(s_lightsforeditdlg);


	//AngleLimit2Bone();


	return 0;
}

int DispAngleLimitDlg()
{
	s_underanglelimithscroll = 0;

	if (s_anglelimitdlg) {
		//already opened
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	if (s_model->GetOldAxisFlagAtLoading() == 1) {
		::DSMessageBox(s_3dwnd, L"Work Only After Setting Of Axis.\nRetry after Saving FBX file.", L"error!!!", MB_OK);
		return 0;
	}

	s_dseullimitctrls.clear();
	ChaMatrix tmpwm = s_model->GetWorldMat();
	s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
	Bone2AngleLimit();

	/*
	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ANGLELIMITDLG),
		s_3dwnd, (DLGPROC)AngleLimitDlgProc);
	if (dlgret != IDOK){
		return 0;
	}
	*/
	//s_anglelimitdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ANGLELIMITDLG), s_3dwnd, (DLGPROC)AngleLimitDlgProc);
	//s_anglelimitdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ANGLELIMITDLG), g_mainhwnd, (DLGPROC)AngleLimitDlgProc);
	s_anglelimitdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ANGLELIMITDLG3), g_mainhwnd, (DLGPROC)AngleLimitDlgProc2);
	if (!s_anglelimitdlg) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_anglelimitdlg, g_mainhwnd);
	SetWindowPos(
		s_anglelimitdlg,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	//s_dseullimitctrls.push_back(IDD_ANGLELIMITDLG);
	s_dseullimitctrls.push_back(IDC_BONEAXIS);
	s_dseullimitctrls.push_back(IDC_EDIT_XL);
	s_dseullimitctrls.push_back(IDC_EDIT_XU);
	s_dseullimitctrls.push_back(IDC_EDIT_YL);
	s_dseullimitctrls.push_back(IDC_EDIT_YU);
	s_dseullimitctrls.push_back(IDC_EDIT_ZL);
	s_dseullimitctrls.push_back(IDC_EDIT_ZU);
	s_dseullimitctrls.push_back(IDOK);


	//::MoveWindow(s_anglelimitdlg, 1200, 32, 450, 858, TRUE);
	//s_rigidWnd->setSize(WindowSize(450, 858));//880
	//s_rigidWnd->setPos(WindowPos(1200, 32));

	ShowWindow(s_anglelimitdlg, SW_SHOW);
	UpdateWindow(s_anglelimitdlg);

	//AngleLimit2Bone();


	return 0;
}

int Bone2AngleLimit()
{
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	ANGLELIMIT saveal;
	saveal = s_anglelimit;


	CBone* curbone;
	curbone = s_model->GetBoneByID(s_curboneno);

	//オイラーグラフの表示と合わせるために選択ジョイントの１階層親のジョイントを扱う //2021/11/17
	if (curbone) {
		if (curbone->GetParent(false) && curbone->GetParent(false)->IsSkeleton()) {
			s_anglelimitbone = curbone->GetParent(false);
		}
		else {
			s_anglelimitbone = curbone;
		}
	}
	else {
		s_anglelimitbone = 0;
	}

	if (s_anglelimitbone) {
		MOTINFO* curmi;
		curmi = s_model->GetCurMotInfo();
		if (curmi) {
			s_anglelimit = s_anglelimitbone->GetAngleLimit(g_limitdegflag, 1);

			if (g_limitdegflag) {
				s_anglelimit.chkeul[AXIS_X] = min(s_anglelimit.upper[AXIS_X], s_anglelimit.chkeul[AXIS_X]);
				s_anglelimit.chkeul[AXIS_Y] = min(s_anglelimit.upper[AXIS_Y], s_anglelimit.chkeul[AXIS_Y]);
				s_anglelimit.chkeul[AXIS_Z] = min(s_anglelimit.upper[AXIS_Z], s_anglelimit.chkeul[AXIS_Z]);

				s_anglelimit.chkeul[AXIS_X] = max(s_anglelimit.lower[AXIS_X], s_anglelimit.chkeul[AXIS_X]);
				s_anglelimit.chkeul[AXIS_Y] = max(s_anglelimit.lower[AXIS_Y], s_anglelimit.chkeul[AXIS_Y]);
				s_anglelimit.chkeul[AXIS_Z] = max(s_anglelimit.lower[AXIS_Z], s_anglelimit.chkeul[AXIS_Z]);
			}
		}
	}
	else {
		_ASSERT(0);
		s_anglelimit.Init();
	}

	////setcheckflag == 0のときにはチェックボックスの状態を変えずに復元する
	//if (setcheckflag == 0) {
	//	s_anglelimit.applyeul[AXIS_X] = saveal.applyeul[AXIS_X];
	//	s_anglelimit.applyeul[AXIS_Y] = saveal.applyeul[AXIS_Y];
	//	s_anglelimit.applyeul[AXIS_Z] = saveal.applyeul[AXIS_Z];

	//	s_anglelimit.via180flag[AXIS_X] = saveal.via180flag[AXIS_X];
	//	s_anglelimit.via180flag[AXIS_Y] = saveal.via180flag[AXIS_Y];
	//	s_anglelimit.via180flag[AXIS_Z] = saveal.via180flag[AXIS_Z];
	//}


	return 0;
}

int AngleLimit2Bone_One(CBone* srcbone)
{
	if (s_model && srcbone && (srcbone->IsSkeleton())) {
		MOTINFO* curmi = s_model->GetCurMotInfo();
		if (curmi) {
			srcbone->SetAngleLimit(g_limitdegflag, s_anglelimit);
		}
		return 0;
	}
	else {
		return 1;
	}
}
void AngleLimit2Bone_Req(CBone* srcbone, int setbroflag)
{
	if (srcbone) {
		if (srcbone->IsSkeleton()) {
			AngleLimit2Bone_One(srcbone);
		}

		if (srcbone->GetChild(false)) {
			int newsetbroflag = 1;
			AngleLimit2Bone_Req(srcbone->GetChild(false), newsetbroflag);
		}
		if ((setbroflag) && (srcbone->GetBrother(false))) {
			AngleLimit2Bone_Req(srcbone->GetBrother(false), setbroflag);
		}
	}
}

int AngleLimit2Bone(int limit2boneflag)
{
	if (!s_model) {
		return 0;
	}
	if (!s_anglelimitbone) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	//if (g_previewFlag == 0) {
	if (s_anglelimitbone) {
		if (limit2boneflag == eLIM2BONE_LIM2BONE_ONE) {
			AngleLimit2Bone_One(s_anglelimitbone);
		}
		else if (limit2boneflag == eLIM2BONE_LIM2BONE_DEEPER) {
			int setbroflag = 0;
			AngleLimit2Bone_Req(s_anglelimitbone, setbroflag);
		}
		else if (limit2boneflag == eLIM2BONE_LIM2BONE_ALL) {
			int setbroflag = 0;
			AngleLimit2Bone_Req(s_model->GetTopBone(false), setbroflag);
		}
		else {
			_ASSERT(0);
			return 1;
		}
	}

	//}
//}

	return 0;
}

int InitAngleLimitEditInt(HWND hDlgWnd, int editresid, int srclimit)
{
	WCHAR strlimit[ANGLEDLGEDITLEN] = { 0L };
	swprintf_s(strlimit, ANGLEDLGEDITLEN, L"%d", srclimit);
	SetDlgItemText(hDlgWnd, editresid, strlimit);

	return 0;
}
int InitAngleLimitEditFloat(HWND hDlgWnd, int editresid, float srcfloat)
{
	WCHAR strfloat[ANGLEDLGEDITLEN] = { 0L };
	swprintf_s(strfloat, ANGLEDLGEDITLEN, L"%.1f", srcfloat);
	SetDlgItemText(hDlgWnd, editresid, strfloat);

	return 0;
}


int InitAngleLimitSlider(HWND hDlgWnd, int slresid, int txtresid, int srclimit)
{
	SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)-180);
	SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)180);

	SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_CLEARTICS, 0, 0);
	int tickcnt;
	for (tickcnt = 0; tickcnt <= 36; tickcnt++) {
		int tickval = (-180 + 10 * tickcnt);
		SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_SETTIC, 1, (LPARAM)(LONG)tickval);
	}

	SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)srclimit);

	WCHAR strval[256] = { 0L };
	swprintf_s(strval, 256, L"%d", srclimit);
	SetDlgItemText(hDlgWnd, txtresid, (LPCWSTR)strval);

	return 0;
}


int InitAngleLimitSliderFloat(HWND hDlgWnd, int slresid, int txtresid, float srclimit)
{
	SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)-180);
	SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)180);

	SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_CLEARTICS, 0, 0);
	int tickcnt;
	for (tickcnt = 0; tickcnt <= 36; tickcnt++) {
		int tickval = (-180 + 10 * tickcnt);
		SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_SETTIC, 1, (LPARAM)(LONG)tickval);
	}

	SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)((int)(srclimit + 0.1f)));

	WCHAR strval[256] = { 0L };
	swprintf_s(strval, 256, L"%.1f", srclimit);
	SetDlgItemText(hDlgWnd, txtresid, (LPCWSTR)strval);

	return 0;
}

int GetAngleLimitSliderVal(HWND hDlgWnd, int slresid, int txtresid, int* dstptr)
{
	int curval = (int)SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_GETPOS, 0, 0);
	*dstptr = curval;
	WCHAR strval[256];
	swprintf_s(strval, 256, L"%d", curval);
	SetDlgItemText(hDlgWnd, txtresid, (LPCWSTR)strval);

	return 0;
}

int GetAngleLimitSliderValFloat(HWND hDlgWnd, int slresid, int txtresid, float* dstptr)
{
	int curval = (int)SendMessage(GetDlgItem(hDlgWnd, slresid), TBM_GETPOS, 0, 0);
	float curvalfloat = (float)curval;

	*dstptr = curvalfloat;
	WCHAR strval[256];
	swprintf_s(strval, 256, L"%.1f", curvalfloat);
	SetDlgItemText(hDlgWnd, txtresid, (LPCWSTR)strval);

	return 0;
}

int CheckStr_SInt(const WCHAR* srcstr)
{
	if (!srcstr) {
		return 1;
	}
	size_t strleng = wcslen(srcstr);
	if ((strleng <= 0) || (strleng >= ANGLEDLGEDITLEN)) {
		_ASSERT(0);
		return 1;
	}

	bool errorflag = false;
	size_t strindex;
	for (strindex = 0; strindex < strleng; strindex++) {
		WCHAR curwc = *(srcstr + strindex);
		if (((curwc >= TEXT('0')) && (curwc <= TEXT('9'))) || (curwc == TEXT('+')) || (curwc == TEXT('-'))) {

		}
		else {
			errorflag = true;
			break;
		}
	}



	if (errorflag == false) {
		return 0;
	}
	else {
		return 1;
	}
}

int CheckStr_float(const WCHAR* srcstr)
{
	if (!srcstr) {
		return 1;
	}
	size_t strleng = wcslen(srcstr);
	if ((strleng <= 0) || (strleng >= 256)) {
		_ASSERT(0);
		return 1;
	}

	bool errorflag = false;
	size_t strindex;
	for (strindex = 0; strindex < strleng; strindex++) {
		WCHAR curwc = *(srcstr + strindex);
		if ((curwc >= TEXT('0')) && (curwc <= TEXT('9')) || (curwc == TEXT('+')) || (curwc == TEXT('-')) ||
			(curwc == TEXT('.'))
			) {

		}
		else {
			errorflag = true;
			break;
		}
	}



	if (errorflag == false) {
		return 0;
	}
	else {
		return 1;
	}
}



int GetAngleLimitEditInt(HWND hDlgWnd, int editresid, int* dstlimit)
{
	WCHAR stredit[ANGLEDLGEDITLEN] = { 0L };
	::ZeroMemory(stredit, sizeof(WCHAR) * ANGLEDLGEDITLEN);

	::GetDlgItemText(hDlgWnd, editresid, stredit, ANGLEDLGEDITLEN);

	stredit[ANGLEDLGEDITLEN - 1] = 0L;
	int result1;
	result1 = CheckStr_SInt(stredit);
	if (result1 == 0) {
		stredit[ANGLEDLGEDITLEN - 1] = 0L;

		SetLastError(0);
		int tmpint = _wtoi(stredit);
		DWORD dwresult = GetLastError();
		if (dwresult == 0) {
			*dstlimit = tmpint;
			return 0;
		}
		else {
			_ASSERT(0);
			*dstlimit = 0;
			return 1;
		}
	}
	else {
		_ASSERT(0);
		return 1;
	}
}

int Lights2DlgEach(HWND hDlgWnd, int lightindex,
	int iddirx, int iddiry, int iddirz,
	int idenable, int idwithviewrot, int idslider, int idtextlight)
{
	if (!hDlgWnd) {
		_ASSERT(0);
		return 1;
	}
	if ((lightindex < 0) || (lightindex >= LIGHTNUMMAX)) {
		_ASSERT(0);
		return 1;
	}
	if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
		_ASSERT(0);
		return 1;
	}


	if (g_lightEnable[g_lightSlot][lightindex] == true) {
		CheckDlgButton(hDlgWnd, idenable, true);
	}
	else {
		CheckDlgButton(hDlgWnd, idenable, false);
	}
	if (g_lightDirWithView[g_lightSlot][lightindex] == true) {
		CheckDlgButton(hDlgWnd, idwithviewrot, true);
	}
	else {
		CheckDlgButton(hDlgWnd, idwithviewrot, false);
	}
	WCHAR strdirx[256] = { 0L };
	swprintf_s(strdirx, 256, L"%.3f", g_lightDir[g_lightSlot][lightindex].x);
	SetDlgItemText(hDlgWnd, iddirx, strdirx);
	WCHAR strdiry[256] = { 0L };
	swprintf_s(strdiry, 256, L"%.3f", g_lightDir[g_lightSlot][lightindex].y);
	SetDlgItemText(hDlgWnd, iddiry, strdiry);
	WCHAR strdirz[256] = { 0L };
	swprintf_s(strdirz, 256, L"%.3f", g_lightDir[g_lightSlot][lightindex].z);
	SetDlgItemText(hDlgWnd, iddirz, strdirz);


	int sliderpos = (int)(g_lightScale[g_lightSlot][lightindex] * 100.0f + 0.0001f);
	SendMessage(GetDlgItem(hDlgWnd, idslider), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, idslider), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)300);
	SendMessage(GetDlgItem(hDlgWnd, idslider), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

	WCHAR strlight[256] = { 0L };
	swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][lightindex]);
	SetDlgItemText(hDlgWnd, idtextlight, strlight);

	
	return 0;
}

int Lights2Dlg(HWND hDlgWnd)
{
	if (hDlgWnd != 0) {


		if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
			_ASSERT(0);
			return 1;
		}


		HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO1);
		if (combownd != NULL) {
			SendMessage(combownd, CB_RESETCONTENT, 0, 0);
			int slotno;
			for (slotno = 0; slotno < LIGHTSLOTNUM; slotno++) {
				WCHAR strcombo[256];
				swprintf_s(strcombo, 256, L"Slot_%d", slotno);
				SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)strcombo);
			}
			::SendMessage(combownd, CB_SETCURSEL, (WPARAM)g_lightSlot, 0);
		}
		else {
			_ASSERT(0);
			return 1;
		}


		int result1 = Lights2DlgEach(hDlgWnd, 0,
			IDC_LIGHTDIRX1, IDC_LIGHTDIRY1, IDC_LIGHTDIRZ1,
			IDC_ENABLE1, IDC_WITHVIEWROT1, IDC_SLIDER1, IDC_TEXT_LIGHT1);
		if (result1 != 0) {
			_ASSERT(0);
			return 1;
		}

		int result2 = Lights2DlgEach(hDlgWnd, 1,
			IDC_LIGHTDIRX2, IDC_LIGHTDIRY2, IDC_LIGHTDIRZ2,
			IDC_ENABLE2, IDC_WITHVIEWROT2, IDC_SLIDER2, IDC_TEXT_LIGHT2);
		if (result2 != 0) {
			_ASSERT(0);
			return 1;
		}

		int result3 = Lights2DlgEach(hDlgWnd, 2,
			IDC_LIGHTDIRX3, IDC_LIGHTDIRY3, IDC_LIGHTDIRZ3,
			IDC_ENABLE3, IDC_WITHVIEWROT3, IDC_SLIDER3, IDC_TEXT_LIGHT3);
		if (result3 != 0) {
			_ASSERT(0);
			return 1;
		}

		int result4 = Lights2DlgEach(hDlgWnd, 3,
			IDC_LIGHTDIRX4, IDC_LIGHTDIRY4, IDC_LIGHTDIRZ4,
			IDC_ENABLE4, IDC_WITHVIEWROT4, IDC_SLIDER4, IDC_TEXT_LIGHT4);
		if (result4 != 0) {
			_ASSERT(0);
			return 1;
		}

		int result5 = Lights2DlgEach(hDlgWnd, 4,
			IDC_LIGHTDIRX5, IDC_LIGHTDIRY5, IDC_LIGHTDIRZ5,
			IDC_ENABLE5, IDC_WITHVIEWROT5, IDC_SLIDER5, IDC_TEXT_LIGHT5);
		if (result5 != 0) {
			_ASSERT(0);
			return 1;
		}

		int result6 = Lights2DlgEach(hDlgWnd, 5,
			IDC_LIGHTDIRX6, IDC_LIGHTDIRY6, IDC_LIGHTDIRZ6,
			IDC_ENABLE6, IDC_WITHVIEWROT6, IDC_SLIDER6, IDC_TEXT_LIGHT6);
		if (result6 != 0) {
			_ASSERT(0);
			return 1;
		}

		int result7 = Lights2DlgEach(hDlgWnd, 6,
			IDC_LIGHTDIRX7, IDC_LIGHTDIRY7, IDC_LIGHTDIRZ7,
			IDC_ENABLE7, IDC_WITHVIEWROT7, IDC_SLIDER7, IDC_TEXT_LIGHT7);
		if (result7 != 0) {
			_ASSERT(0);
			return 1;
		}

		int result8 = Lights2DlgEach(hDlgWnd, 7,
			IDC_LIGHTDIRX8, IDC_LIGHTDIRY8, IDC_LIGHTDIRZ8,
			IDC_ENABLE8, IDC_WITHVIEWROT8, IDC_SLIDER8, IDC_TEXT_LIGHT8);
		if (result8 != 0) {
			_ASSERT(0);
			return 1;
		}

	}
	return 0;
}

int Dlg2LightsEach(HWND hDlgWnd, int lightindex,
	int iddirx, int iddiry, int iddirz,
	int idenable, int idwithviewrot, int idslider)
{
	if (!hDlgWnd) {
		_ASSERT(0);
		return 1;
	}
	if ((lightindex < 0) || (lightindex >= LIGHTNUMMAX)) {
		_ASSERT(0);
		return 1;
	}
	if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
		_ASSERT(0);
		return 1;
	}



	WCHAR strdirx[256] = { 0L };
	GetDlgItemText(hDlgWnd, iddirx, strdirx, 256);
	WCHAR strdiry[256] = { 0L };
	GetDlgItemText(hDlgWnd, iddiry, strdiry, 256);
	WCHAR strdirz[256] = { 0L };
	GetDlgItemText(hDlgWnd, iddirz, strdirz, 256);
	int chkx, chky, chkz;
	chkx = CheckStr_float(strdirx);
	chky = CheckStr_float(strdiry);
	chkz = CheckStr_float(strdirz);
	if ((chkx != 0) || (chky != 0) || (chkz != 0)) {
		_ASSERT(0);
		return 2;//!!!!!! input error
	}
	float dirx, diry, dirz;
	dirx = (float)_wtof(strdirx);
	diry = (float)_wtof(strdiry);
	dirz = (float)_wtof(strdirz);
	g_lightDir[g_lightSlot][lightindex] = ChaVector3(dirx, diry, dirz);

	UINT chkenable = IsDlgButtonChecked(hDlgWnd, idenable);
	if (chkenable == BST_CHECKED) {
		g_lightEnable[g_lightSlot][lightindex] = true;
	}
	else {
		g_lightEnable[g_lightSlot][lightindex] = false;
	}
	UINT chkwithview = IsDlgButtonChecked(hDlgWnd, idwithviewrot);
	if (chkwithview == BST_CHECKED) {
		g_lightDirWithView[g_lightSlot][lightindex] = true;
	}
	else {
		g_lightDirWithView[g_lightSlot][lightindex] = false;
	}


	int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, idslider), TBM_GETPOS, 0, 0);
	g_lightScale[g_lightSlot][lightindex] = (float)((double)cursliderpos / 100.0);

	return 0;
}

int Dlg2Lights(HWND hDlgWnd, int lightindex)
{
	if (hDlgWnd != 0) {


		HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO1);
		if (combownd != NULL) {
			int combono;
			combono = (int)SendMessage(combownd, CB_GETCURSEL, 0, 0);
			if ((combono >= 0) && (combono < LIGHTSLOTNUM)) {
				g_lightSlot = combono;
			}
			else {
				_ASSERT(0);
				return 1;
			}
		}
		else {
			_ASSERT(0);
			return 1;
		}
		if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
			_ASSERT(0);
			return 1;
		}



		switch (lightindex)
		{
		case 0:
		{
			int result = Dlg2LightsEach(hDlgWnd, lightindex,
				IDC_LIGHTDIRX1, IDC_LIGHTDIRY1, IDC_LIGHTDIRZ1,
				IDC_ENABLE1, IDC_WITHVIEWROT1, IDC_SLIDER1);
			if (result == 0) {
				//そのまま
			}
			else if (result == 1) {
				//プログラム的エラー
				_ASSERT(0);
				return 1;
			}
			else if (result == 2) {
				//ユーザー入力エラー
				::MessageBoxW(hDlgWnd, L"ライト１の向きの数値が不正です。半角小数で指定してください。", L"Lights For Edit Dlg : Error !!!", MB_OK);
				return 1;
			}
			else { 
				//その他エラー
				_ASSERT(0);
				return 1;
			}
		}
		break;
		case 1:
		{
			int result = Dlg2LightsEach(hDlgWnd, lightindex,
				IDC_LIGHTDIRX2, IDC_LIGHTDIRY2, IDC_LIGHTDIRZ2,
				IDC_ENABLE2, IDC_WITHVIEWROT2, IDC_SLIDER2);
			if (result == 0) {
				//そのまま
			}
			else if (result == 1) {
				//プログラム的エラー
				_ASSERT(0);
				return 1;
			}
			else if (result == 2) {
				//ユーザー入力エラー
				::MessageBoxW(hDlgWnd, L"ライト２の向きの数値が不正です。半角小数で指定してください。", L"Lights For Edit Dlg : Error !!!", MB_OK);
				return 1;
			}
			else {
				//その他エラー
				_ASSERT(0);
				return 1;
			}
		}
			break;
		case 2:
		{
			int result = Dlg2LightsEach(hDlgWnd, lightindex,
				IDC_LIGHTDIRX3, IDC_LIGHTDIRY3, IDC_LIGHTDIRZ3,
				IDC_ENABLE3, IDC_WITHVIEWROT3, IDC_SLIDER3);
			if (result == 0) {
				//そのまま
			}
			else if (result == 1) {
				//プログラム的エラー
				_ASSERT(0);
				return 1;
			}
			else if (result == 2) {
				//ユーザー入力エラー
				::MessageBoxW(hDlgWnd, L"ライト３の向きの数値が不正です。半角小数で指定してください。", L"Lights For Edit Dlg : Error !!!", MB_OK);
				return 1;
			}
			else {
				//その他エラー
				_ASSERT(0);
				return 1;
			}
		}
			break;
		case 3:
		{
			int result = Dlg2LightsEach(hDlgWnd, lightindex,
				IDC_LIGHTDIRX4, IDC_LIGHTDIRY4, IDC_LIGHTDIRZ4,
				IDC_ENABLE4, IDC_WITHVIEWROT4, IDC_SLIDER4);
			if (result == 0) {
				//そのまま
			}
			else if (result == 1) {
				//プログラム的エラー
				_ASSERT(0);
				return 1;
			}
			else if (result == 2) {
				//ユーザー入力エラー
				::MessageBoxW(hDlgWnd, L"ライト４の向きの数値が不正です。半角小数で指定してください。", L"Lights For Edit Dlg : Error !!!", MB_OK);
				return 1;
			}
			else {
				//その他エラー
				_ASSERT(0);
				return 1;
			}
		}
			break;
		case 4:
		{
			int result = Dlg2LightsEach(hDlgWnd, lightindex,
				IDC_LIGHTDIRX5, IDC_LIGHTDIRY5, IDC_LIGHTDIRZ5,
				IDC_ENABLE5, IDC_WITHVIEWROT5, IDC_SLIDER5);
			if (result == 0) {
				//そのまま
			}
			else if (result == 1) {
				//プログラム的エラー
				_ASSERT(0);
				return 1;
			}
			else if (result == 2) {
				//ユーザー入力エラー
				::MessageBoxW(hDlgWnd, L"ライト５の向きの数値が不正です。半角小数で指定してください。", L"Lights For Edit Dlg : Error !!!", MB_OK);
				return 1;
			}
			else {
				//その他エラー
				_ASSERT(0);
				return 1;
			}
		}
			break;
		case 5:
		{
			int result = Dlg2LightsEach(hDlgWnd, lightindex,
				IDC_LIGHTDIRX6, IDC_LIGHTDIRY6, IDC_LIGHTDIRZ6,
				IDC_ENABLE6, IDC_WITHVIEWROT6, IDC_SLIDER6);
			if (result == 0) {
				//そのまま
			}
			else if (result == 1) {
				//プログラム的エラー
				_ASSERT(0);
				return 1;
			}
			else if (result == 2) {
				//ユーザー入力エラー
				::MessageBoxW(hDlgWnd, L"ライト６の向きの数値が不正です。半角小数で指定してください。", L"Lights For Edit Dlg : Error !!!", MB_OK);
				return 1;
			}
			else {
				//その他エラー
				_ASSERT(0);
				return 1;
			}
		}
			break;
		case 6:
		{
			int result = Dlg2LightsEach(hDlgWnd, lightindex,
				IDC_LIGHTDIRX7, IDC_LIGHTDIRY7, IDC_LIGHTDIRZ7,
				IDC_ENABLE7, IDC_WITHVIEWROT7, IDC_SLIDER7);
			if (result == 0) {
				//そのまま
			}
			else if (result == 1) {
				//プログラム的エラー
				_ASSERT(0);
				return 1;
			}
			else if (result == 2) {
				//ユーザー入力エラー
				::MessageBoxW(hDlgWnd, L"ライト７の向きの数値が不正です。半角小数で指定してください。", L"Lights For Edit Dlg : Error !!!", MB_OK);
				return 1;
			}
			else {
				//その他エラー
				_ASSERT(0);
				return 1;
			}
		}
			break;
		case 7:
		{
			int result = Dlg2LightsEach(hDlgWnd, lightindex,
				IDC_LIGHTDIRX8, IDC_LIGHTDIRY8, IDC_LIGHTDIRZ8,
				IDC_ENABLE8, IDC_WITHVIEWROT8, IDC_SLIDER8);
			if (result == 0) {
				//そのまま
			}
			else if (result == 1) {
				//プログラム的エラー
				_ASSERT(0);
				return 1;
			}
			else if (result == 2) {
				//ユーザー入力エラー
				::MessageBoxW(hDlgWnd, L"ライト８の向きの数値が不正です。半角小数で指定してください。", L"Lights For Edit Dlg : Error !!!", MB_OK);
				return 1;
			}
			else {
				//その他エラー
				_ASSERT(0);
				return 1;
			}
		}
			break;

		default:
			_ASSERT(0);
			return 1;
			break;
		}
	}

	return 0;
}


int LaterTransparent2Dlg(HWND hDlgWnd)
{

	//m_list_wnd.SendMessage( LB_RESETCONTENT, 0, 0 );
	HWND list1wnd = GetDlgItem(hDlgWnd, IDC_LIST1);
	if (!list1wnd) {
		_ASSERT(0);
		return 1;
	}
	HWND list2wnd = GetDlgItem(hDlgWnd, IDC_LIST2);
	if (!list2wnd) {
		_ASSERT(0);
		return 1;
	}
	::SendMessage(list1wnd, LB_RESETCONTENT, 0, 0);
	::SendMessage(list2wnd, LB_RESETCONTENT, 0, 0);

	if (!s_model) {
		return 0;
	}

	vector<string> modelstexturevec;
	int result = s_model->GetTextureNameVec(modelstexturevec);
	if (result == 0) {
		int texturenum = (int)modelstexturevec.size();

		int listno;
		for (listno = 0; listno < texturenum; listno++) {
			string curtexname = modelstexturevec[listno];
			char mbtexname[512] = { 0 };
			strcpy_s(mbtexname, 512, curtexname.c_str());
			WCHAR wctexname[512] = { 0L };
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, mbtexname, 512, wctexname, 512);

			LRESULT lres;
			lres = SendMessage(list1wnd, LB_ADDSTRING, 0, (LPARAM)wctexname);
			if ((lres == LB_ERR) || (lres == LB_ERRSPACE)) {
				_ASSERT(0);
				return 1;
			}
		}


		int laternum = s_model->GetLaterTransparentNum();
		int listno2;
		for (listno2 = 0; listno2 < laternum; listno2++) {
			string curlatername = s_model->GetLaterTransparent(listno2);
			char mblastername[512] = { 0 };
			strcpy_s(mblastername, 512, curlatername.c_str());
			WCHAR wclastername[512] = { 0L };
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, mblastername, 512, wclastername, 512);



			LRESULT lres2;
			lres2 = SendMessage(list2wnd, LB_ADDSTRING, 0, (LPARAM)wclastername);
			if ((lres2 == LB_ERR) || (lres2 == LB_ERRSPACE)) {
				_ASSERT(0);
				return 1;
			}
		}

	}
	else {
		_ASSERT(0);
		return 1;
	}



	return 0;
}


int Dlg2LaterTransparent(HWND hDlgWnd)
{
	if (!s_model) {
		return 0;
	}

	HWND list2wnd = GetDlgItem(hDlgWnd, IDC_LIST2);
	if (!list2wnd) {
		_ASSERT(0);
		return 1;
	}

	int elemnum = (int)SendMessage(list2wnd, LB_GETCOUNT, 0, 0);

	//リスト２をsavelist2に格納
	vector<wstring> savelist2;
	int elemno;
	for (elemno = 0; elemno < elemnum; elemno++) {
		int textlen;
		textlen = (int)SendMessage(list2wnd, LB_GETTEXTLEN, (WPARAM)elemno, 0);
		if ((textlen > 0) && (textlen < 512)) {
			WCHAR text2[512] = { 0L };
			int result = (int)SendMessage(list2wnd, LB_GETTEXT, (WPARAM)elemno, (LPARAM)(&text2[0]));
			if (result != LB_ERR) {
				savelist2.push_back(text2);
			}
			else {
				_ASSERT(0);
				return 1;
			}
		}
	}


	int result2 = s_model->SetLaterTransparentVec(savelist2);//丸ごと設定
	if (result2 != 0) {
		_ASSERT(0);
		return 1;
	}

	return 0;
}

int LODParams2Dlg(HWND hDlgWnd)
{
	WCHAR strdlg[256] = { 0L };

	//########
	//EditBox
	//########
	swprintf_s(strdlg, 256, L"%.2f", g_projnear);
	SetDlgItemText(hDlgWnd, IDC_EDIT_PROJNEAR, strdlg);

	swprintf_s(strdlg, 256, L"%.1f", g_projfar);
	SetDlgItemText(hDlgWnd, IDC_EDIT_PROJFAR, strdlg);

	//#######
	//Slider
	//#######
	int sliderpos = (int)(g_fovy * 180.0f / (float)PI + 0.0001f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_FOV2), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)10);
	//SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_FOV2), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)89);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_FOV2), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)179);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_FOV2), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);


	sliderpos = (int)(g_lodrate2L[CHKINVIEW_LOD0] * 100.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD0), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD0), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD0), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);
	sliderpos = (int)(g_lodrate2L[CHKINVIEW_LOD1] * 100.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD1), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD1), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD1), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

	sliderpos = (int)(g_lodrate3L[CHKINVIEW_LOD0] * 100.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD0), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD0), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD0), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);
	sliderpos = (int)(g_lodrate3L[CHKINVIEW_LOD1] * 100.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD1), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD1), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD1), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);
	sliderpos = (int)(g_lodrate3L[CHKINVIEW_LOD2] * 100.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD2), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD2), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD2), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

	//#####
	//Text
	//#####
	swprintf_s(strdlg, 256, L"FOV:%.1fdeg", g_fovy * 180.0f / (float)PI);
	SetDlgItemText(hDlgWnd, IDC_STATIC_FOV2, strdlg);


	swprintf_s(strdlg, 256, L"LOD0:%.2f", g_lodrate2L[CHKINVIEW_LOD0]);
	SetDlgItemText(hDlgWnd, IDC_STATIC_2L_LOD0, strdlg);
	swprintf_s(strdlg, 256, L"LOD1:%.2f", g_lodrate2L[CHKINVIEW_LOD1]);
	SetDlgItemText(hDlgWnd, IDC_STATIC_2L_LOD1, strdlg);

	swprintf_s(strdlg, 256, L"LOD0:%.2f", g_lodrate3L[CHKINVIEW_LOD0]);
	SetDlgItemText(hDlgWnd, IDC_STATIC_3L_LOD0, strdlg);
	swprintf_s(strdlg, 256, L"LOD1:%.2f", g_lodrate3L[CHKINVIEW_LOD1]);
	SetDlgItemText(hDlgWnd, IDC_STATIC_3L_LOD1, strdlg);
	swprintf_s(strdlg, 256, L"LOD2:%.2f", g_lodrate3L[CHKINVIEW_LOD2]);
	SetDlgItemText(hDlgWnd, IDC_STATIC_3L_LOD2, strdlg);


	return 0;
}

int ShadowParams2Dlg(HWND hDlgWnd)
{
	WCHAR strdlg[256] = { 0L };


	if ((g_shadowmap_slotno < 0) || (g_shadowmap_slotno >= SHADOWSLOTNUM)) {
		_ASSERT(0);
		g_shadowmap_slotno = 0;
	}

	//#########
	//ComboBox
	//#########
	HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO_SLOT);
	if (combownd != NULL) {
		SendMessage(combownd, CB_RESETCONTENT, 0, 0);
		int slotno;
		for (slotno = 0; slotno < SHADOWSLOTNUM; slotno++) {
			WCHAR strcombo[256];
			swprintf_s(strcombo, 256, L"slot:%d", slotno);
			SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)strcombo);
		}
		::SendMessage(combownd, CB_SETCURSEL, (WPARAM)g_shadowmap_slotno, 0);
	}
	else {
		_ASSERT(0);
		return 1;
	}


	//#########
	//CheckBox
	//#########
	if ((bool)g_enableshadow == true) {
		CheckDlgButton(hDlgWnd, IDC_CHECK_ENABLESHADOW, true);
	}
	else {
		CheckDlgButton(hDlgWnd, IDC_CHECK_ENABLESHADOW, false);
	}

	//########
	//EditBox
	//########
	swprintf_s(strdlg, 256, L"%.1f", g_shadowmap_plusup[g_shadowmap_slotno]);
	SetDlgItemText(hDlgWnd, IDC_EDIT_PLUSUP, strdlg);

	swprintf_s(strdlg, 256, L"%.1f", g_shadowmap_distscale[g_shadowmap_slotno]);
	SetDlgItemText(hDlgWnd, IDC_EDIT_PLUSRIGHT, strdlg);

	swprintf_s(strdlg, 256, L"%.1f", g_shadowmap_near[g_shadowmap_slotno]);
	SetDlgItemText(hDlgWnd, IDC_EDIT_NEAR, strdlg);

	swprintf_s(strdlg, 256, L"%.1f", g_shadowmap_far[g_shadowmap_slotno]);
	SetDlgItemText(hDlgWnd, IDC_EDIT_FAR, strdlg);

	//#######
	//Slider
	//#######
	int sliderpos = (int)(g_shadowmap_fov[g_shadowmap_slotno] + 0.0001f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_FOV), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)10);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_FOV), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)60);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_FOV), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

	sliderpos = (int)(g_shadowmap_color[g_shadowmap_slotno] * 100.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_COLOR), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_COLOR), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)200);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_COLOR), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

	sliderpos = (int)(g_shadowmap_bias[g_shadowmap_slotno] * 10000.0f);
	//SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BIAS), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)10);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BIAS), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);//2024/01/04 0も可
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BIAS), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)300);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BIAS), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

	sliderpos = (int)(g_shadowmap_projscale[g_shadowmap_slotno] * 10.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_PROJSCALE), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)1);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_PROJSCALE), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_PROJSCALE), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);


	//#####
	//Text
	//#####
	swprintf_s(strdlg, 256, L"FOV:%.1fdeg", g_shadowmap_fov[g_shadowmap_slotno]);
	SetDlgItemText(hDlgWnd, IDC_STATIC_FOV, strdlg);

	swprintf_s(strdlg, 256, L"Color:%.2f", g_shadowmap_color[g_shadowmap_slotno]);
	SetDlgItemText(hDlgWnd, IDC_STATIC_COLOR, strdlg);

	swprintf_s(strdlg, 256, L"Bias:%.3f", g_shadowmap_bias[g_shadowmap_slotno]);
	SetDlgItemText(hDlgWnd, IDC_STATIC_BIAS, strdlg);

	swprintf_s(strdlg, 256, L"SceneMult:%.1f", g_shadowmap_projscale[g_shadowmap_slotno]);
	SetDlgItemText(hDlgWnd, IDC_STATIC_PROJSCALE, strdlg);

	//#######
	//Button
	//#######
	CheckShadowDirectionButton(hDlgWnd, g_shadowmap_lightdir[g_shadowmap_slotno]);




	return 0;
}

void CheckShadowDirectionButton(HWND hDlgWnd, int srcshadowdir)
{
	//####################################################
	//Shadowプレートメニューから呼び出すShadowParamsダイアログ用
	//####################################################

	switch (srcshadowdir) {
	case 1:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_1), BM_SETSTATE, TRUE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_3), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_4), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_5), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_6), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_7), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_8), BM_SETSTATE, FALSE, 0);
		break;
	case 2:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_1), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_2), BM_SETSTATE, TRUE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_3), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_4), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_5), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_6), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_7), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_8), BM_SETSTATE, FALSE, 0);
		break;
	case 3:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_1), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_3), BM_SETSTATE, TRUE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_4), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_5), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_6), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_7), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_8), BM_SETSTATE, FALSE, 0);
		break;
	case 4:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_1), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_3), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_4), BM_SETSTATE, TRUE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_5), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_6), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_7), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_8), BM_SETSTATE, FALSE, 0);
		break;
	case 5:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_1), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_3), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_4), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_5), BM_SETSTATE, TRUE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_6), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_7), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_8), BM_SETSTATE, FALSE, 0);
		break;
	case 6:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_1), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_3), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_4), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_5), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_6), BM_SETSTATE, TRUE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_7), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_8), BM_SETSTATE, FALSE, 0);
		break;
	case 7:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_1), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_3), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_4), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_5), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_6), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_7), BM_SETSTATE, TRUE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_8), BM_SETSTATE, FALSE, 0);
		break;
	case 8:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_1), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_3), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_4), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_5), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_6), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_7), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_8), BM_SETSTATE, TRUE, 0);
		break;
	default:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_1), BM_SETSTATE, TRUE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_3), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_4), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_5), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_6), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_7), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADOWDIR_8), BM_SETSTATE, FALSE, 0);
		break;
	}
}


int AngleLimit2Dlg(HWND hDlgWnd, bool updateonlycheckeul)
{
	if (s_anglelimitbone && (hDlgWnd != 0)) {

		if (updateonlycheckeul == false) {

			SetDlgItemText(hDlgWnd, IDC_BONENAME, (LPCWSTR)s_anglelimitbone->GetWBoneName());

			SendMessage(GetDlgItem(hDlgWnd, IDC_BONEAXIS), CB_RESETCONTENT, 0, 0);
			WCHAR strcombo[256];
			wcscpy_s(strcombo, 256, L"CurrentBoneAxis");
			SendMessage(GetDlgItem(hDlgWnd, IDC_BONEAXIS), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentBoneAxis");
			SendMessage(GetDlgItem(hDlgWnd, IDC_BONEAXIS), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalBoneAxis");
			SendMessage(GetDlgItem(hDlgWnd, IDC_BONEAXIS), CB_ADDSTRING, 0, (LPARAM)strcombo);
			SendMessage(GetDlgItem(hDlgWnd, IDC_BONEAXIS), CB_SETCURSEL, s_anglelimit.boneaxiskind, 0);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_BONEAXIS), FALSE);//固定値


			//入力フィールドを毎フレーム更新すると　入力できないので　updateonlycheckeulのときには更新しない
			InitAngleLimitEditInt(hDlgWnd, IDC_EDIT_XL, s_anglelimit.lower[AXIS_X]);
			InitAngleLimitEditInt(hDlgWnd, IDC_EDIT_XU, s_anglelimit.upper[AXIS_X]);

			InitAngleLimitEditInt(hDlgWnd, IDC_EDIT_YL, s_anglelimit.lower[AXIS_Y]);
			InitAngleLimitEditInt(hDlgWnd, IDC_EDIT_YU, s_anglelimit.upper[AXIS_Y]);

			InitAngleLimitEditInt(hDlgWnd, IDC_EDIT_ZL, s_anglelimit.lower[AXIS_Z]);
			InitAngleLimitEditInt(hDlgWnd, IDC_EDIT_ZU, s_anglelimit.upper[AXIS_Z]);
		}


		InitAngleLimitEditFloat(hDlgWnd, IDC_EDIT_CHKX, s_anglelimit.chkeul[AXIS_X]);
		InitAngleLimitEditFloat(hDlgWnd, IDC_EDIT_CHKY, s_anglelimit.chkeul[AXIS_Y]);
		InitAngleLimitEditFloat(hDlgWnd, IDC_EDIT_CHKZ, s_anglelimit.chkeul[AXIS_Z]);


		//InitAngleLimitSlider(hDlgWnd, IDC_SLXL, IDC_XLVAL, s_anglelimit.lower[AXIS_X]);
		//InitAngleLimitSlider(hDlgWnd, IDC_SLXU, IDC_XUVAL, s_anglelimit.upper[AXIS_X]);
		//InitAngleLimitSliderFloat(hDlgWnd, IDC_SLCHKX, IDC_CHKXVAL, s_anglelimit.chkeul[AXIS_X]);

		//InitAngleLimitSlider(hDlgWnd, IDC_SLYL, IDC_YLVAL, s_anglelimit.lower[AXIS_Y]);
		//InitAngleLimitSlider(hDlgWnd, IDC_SLYU, IDC_YUVAL, s_anglelimit.upper[AXIS_Y]);
		//InitAngleLimitSliderFloat(hDlgWnd, IDC_SLCHKY, IDC_CHKYVAL, s_anglelimit.chkeul[AXIS_Y]);

		//InitAngleLimitSlider(hDlgWnd, IDC_SLZL, IDC_ZLVAL, s_anglelimit.lower[AXIS_Z]);
		//InitAngleLimitSlider(hDlgWnd, IDC_SLZU, IDC_ZUVAL, s_anglelimit.upper[AXIS_Z]);
		//InitAngleLimitSliderFloat(hDlgWnd, IDC_SLCHKZ, IDC_CHKZVAL, s_anglelimit.chkeul[AXIS_Z]);

		//if (s_anglelimit.via180flag[0] == 1){
		//	CheckDlgButton(hDlgWnd, IDC_CHECKX, BST_CHECKED);
		//}
		//else{
		//	CheckDlgButton(hDlgWnd, IDC_CHECKX, BST_UNCHECKED);
		//}
		//if (s_anglelimit.via180flag[1] == 1){
		//	CheckDlgButton(hDlgWnd, IDC_CHECKY, BST_CHECKED);
		//}
		//else{
		//	CheckDlgButton(hDlgWnd, IDC_CHECKY, BST_UNCHECKED);
		//}
		//if (s_anglelimit.via180flag[2] == 1){
		//	CheckDlgButton(hDlgWnd, IDC_CHECKZ, BST_CHECKED);
		//}
		//else{
		//	CheckDlgButton(hDlgWnd, IDC_CHECKZ, BST_UNCHECKED);
		//}


		//if (s_anglelimit.applyeul[AXIS_X] == 1) {
		//	CheckDlgButton(hDlgWnd, IDC_APPLYX, BST_CHECKED);
		//}
		//else {
		//	CheckDlgButton(hDlgWnd, IDC_APPLYX, BST_UNCHECKED);
		//}
		//if (s_anglelimit.applyeul[AXIS_Y] == 1) {
		//	CheckDlgButton(hDlgWnd, IDC_APPLYY, BST_CHECKED);
		//}
		//else {
		//	CheckDlgButton(hDlgWnd, IDC_APPLYY, BST_UNCHECKED);
		//}
		//if (s_anglelimit.applyeul[AXIS_Z] == 1) {
		//	CheckDlgButton(hDlgWnd, IDC_APPLYZ, BST_CHECKED);
		//}
		//else {
		//	CheckDlgButton(hDlgWnd, IDC_APPLYZ, BST_UNCHECKED);
		//}

	}
	else {
		_ASSERT(0);
	}

	return 0;
}

int AngleDlg2AngleLimit(HWND hDlgWnd)//2022/12/05 エラー入力通知ダイアログも出す
{
	int result_xl, result_xu;
	int result_yl, result_yu;
	int result_zl, result_zu;
	int val_xl, val_xu;
	int val_yl, val_yu;
	int val_zl, val_zu;

	result_xl = 1;
	result_xu = 1;
	result_yl = 1;
	result_yu = 1;
	result_zl = 1;
	result_zu = 1;
	val_xl = -180;
	val_xu = 180;
	val_yl = -180;
	val_yu = 180;
	val_zl = -180;
	val_zu = 180;
	bool errorflag = false;

	result_xl = GetAngleLimitEditInt(hDlgWnd, IDC_EDIT_XL, &val_xl);
	if (result_xl != 0) {
		::MessageBox(g_mainhwnd, L"AngleLimitDlgのXLowerの入力値が不正です。", L"入力し直してください。", MB_OK);
		errorflag = true;
	}
	result_xu = GetAngleLimitEditInt(hDlgWnd, IDC_EDIT_XU, &val_xu);
	if (result_xu != 0) {
		::MessageBox(g_mainhwnd, L"AngleLimitDlgのXUpperの入力値が不正です。", L"入力し直してください。", MB_OK);
		errorflag = true;
	}


	result_yl = GetAngleLimitEditInt(hDlgWnd, IDC_EDIT_YL, &val_yl);
	if (result_yl != 0) {
		::MessageBox(g_mainhwnd, L"AngleLimitDlgのYLowerの入力値が不正です。", L"入力し直してください。", MB_OK);
		errorflag = true;
	}
	result_yu = GetAngleLimitEditInt(hDlgWnd, IDC_EDIT_YU, &val_yu);
	if (result_yu != 0) {
		::MessageBox(g_mainhwnd, L"AngleLimitDlgのYUpperの入力値が不正です。", L"入力し直してください。", MB_OK);
		errorflag = true;
	}


	result_zl = GetAngleLimitEditInt(hDlgWnd, IDC_EDIT_ZL, &val_zl);
	if (result_zl != 0) {
		::MessageBox(g_mainhwnd, L"AngleLimitDlgのZLowerの入力値が不正です。", L"入力し直してください。", MB_OK);
		errorflag = true;
	}
	result_zu = GetAngleLimitEditInt(hDlgWnd, IDC_EDIT_ZU, &val_zu);
	if (result_zu != 0) {
		::MessageBox(g_mainhwnd, L"AngleLimitDlgのZUpperの入力値が不正です。", L"入力し直してください。", MB_OK);
		errorflag = true;
	}


	if (errorflag == false) {
		s_anglelimit.lower[AXIS_X] = val_xl;
		s_anglelimit.upper[AXIS_X] = val_xu;

		s_anglelimit.lower[AXIS_Y] = val_yl;
		s_anglelimit.upper[AXIS_Y] = val_yu;

		s_anglelimit.lower[AXIS_Z] = val_zl;
		s_anglelimit.upper[AXIS_Z] = val_zu;

		return 0;
	}
	else {
		return 1;
	}


}

int CopyLimitedWorldToWorld(CModel* srcmodel, bool allframeflag, bool setcursorflag, int operatingjointno, bool onpasteflag)
{
	HCURSOR oldcursor = NULL;
	if (setcursorflag) {
		//refreshEUlerGraph処理は時間がかかることがあるので砂時計カーソルにする
		oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
	}

	if (srcmodel) {
		ChaMatrix tmpwm = srcmodel->GetWorldMat();
		MOTINFO* curmi = srcmodel->GetCurMotInfo();
		if (curmi) {
			if (onpasteflag == false) {
				if (operatingjointno >= 0) {
					CBone* opebone = srcmodel->GetBoneByID(operatingjointno);
					if (opebone) {
						double roundingstartframe, roundingendframe;
						if (allframeflag == false) {
							int framenum;
							double startframe, endframe;
							s_editrange.GetRange(&framenum, &startframe, &endframe);
							roundingstartframe = RoundingTime(startframe);
							roundingendframe = RoundingTime(endframe);
						}
						else {
							roundingstartframe = 1.0;
							roundingendframe = RoundingTime(curmi->frameleng) - 1.0;
						}

						double curframe;
						for (curframe = roundingstartframe; curframe <= roundingendframe; curframe += 1.0) {
							srcmodel->SetMotionFrame(curframe);
							srcmodel->CopyLimitedWorldToWorldReq(opebone, curmi->motid, curframe);
						}
					}
				}
			}
			else {
				vector<CPELEM2>::iterator itrcp;
				for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
					CBone* srcbone = itrcp->bone;
					if (srcbone) {
						double roundingstartframe, roundingendframe;
						if (allframeflag == false) {
							int framenum;
							double startframe, endframe;
							s_editrange.GetRange(&framenum, &startframe, &endframe);
							roundingstartframe = RoundingTime(startframe);
							roundingendframe = RoundingTime(endframe);
						}
						else {
							roundingstartframe = 1.0;
							roundingendframe = RoundingTime(curmi->frameleng) - 1.0;
						}

						double curframe;
						for (curframe = roundingstartframe; curframe <= roundingendframe; curframe += 1.0) {
							srcmodel->SetMotionFrame(curframe);
							srcmodel->CopyLimitedWorldToWorldOne(srcbone, curmi->motid, curframe);
						}
					}
				}
			}
		}


		if (s_owpLTimeline) {
			double curframe = s_owpLTimeline->getCurrentTime();
			srcmodel->SetMotionFrame(curframe);
			srcmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
		}
	}

	if (setcursorflag && (oldcursor != NULL)) {
		//カーソルを元に戻す
		SetCursor(oldcursor);
	}

	return 0;
}


int CopyWorldToLimitedWorld(CModel* srcmodel)
{

	//呼び出し元で SetCursor 砂時計している

	if (srcmodel) {
		ChaMatrix tmpwm = srcmodel->GetWorldMat();
		//MOTINFO* curmi = srcmodel->GetCurMotInfo();
		//if (curmi) {
		//	double curframe;
		//	//for (curframe = 0.0; curframe < curmi->frameleng; curframe += 1.0) {
		//	for (curframe = 1.0; curframe < curmi->frameleng; curframe += 1.0) {
		//		srcmodel->SetMotionFrame(curframe);
		//		srcmodel->CopyWorldToLimitedWorldReq(srcmodel->GetTopBone(false), curmi->motid, curframe);
		//	}
		//}

		srcmodel->CopyWorldToLimitedWorld();//2023/10/20 MultiThreading


		if (s_owpLTimeline) {
			double curframe = s_owpLTimeline->getCurrentTime();
			srcmodel->SetMotionFrame(curframe);
			srcmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
		}
	}
	return 0;
}


int ApplyNewLimitsToWM(CModel* srcmodel)
{

	//呼び出し元で SetCursor 砂時計している

	if (srcmodel) {

		if (srcmodel->GetNoBoneFlag() == true) {
			return 0;
		}

		ChaMatrix tmpwm = srcmodel->GetWorldMat();
		MOTINFO* curmi = srcmodel->GetCurMotInfo();
		if (curmi) {
			ChaMatrix befeditparentmat;
			befeditparentmat.SetIdentity();
			double curframe2;
			//for (curframe = 0.0; curframe < curmi->frameleng; curframe += 1.0) {
			for (curframe2 = 1.0; curframe2 < curmi->frameleng; curframe2 += 1.0) {
				srcmodel->SetMotionFrame(curframe2);
				srcmodel->ApplyNewLimitsToWMReq(srcmodel->GetTopBone(false), curmi->motid, curframe2, befeditparentmat);
				//srcmodel->UpdateMatrix(&tmpwm, &s_matVP);
			}
		}

		if (s_owpLTimeline) {
			double curframe = s_owpLTimeline->getCurrentTime();
			srcmodel->SetMotionFrame(curframe);
			srcmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
		}
	}

	return 0;
}

int ApplyNewLimitsToWMSelected()
{
	if (s_model) {
		ChaMatrix tmpwm = s_model->GetWorldMat();
		MOTINFO* curmi = s_model->GetCurMotInfo();
		if (curmi) {

			int selectednum;
			double startframe, endframe;
			s_editrange.GetRange(&selectednum, &startframe, &endframe);

			int  istartframe, iendframe;
			istartframe = IntTime(startframe);
			iendframe = IntTime(endframe);
			int curframe;
			for (curframe = istartframe; curframe <= iendframe; curframe++) {
				s_model->SetMotionFrame((double)curframe);
				s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
			}
		}

		if (s_owpLTimeline) {
			double curframe = s_owpLTimeline->getCurrentTime();
			s_model->SetMotionFrame(curframe);
			s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
		}
	}

	return 0;
}

int UpdateAfterEditAngleLimit(int limit2boneflag, bool setcursorflag)//default : setcursorflag = true
{
	HCURSOR oldcursor = NULL;
	if (setcursorflag) {
		//refreshEUlerGraph処理は時間がかかることがあるので砂時計カーソルにする
		oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
	}

	switch (limit2boneflag) {
	case eLIM2BONE_LIM2BONE_ONE:
	case eLIM2BONE_LIM2BONE_DEEPER:
	case eLIM2BONE_LIM2BONE_ALL:
		//s_anglelimit --> limits of bone
		AngleLimit2Bone(limit2boneflag);
		break;
	case eLIM2BONE_BONE2LIM:
		//limits of bone --> s_anglelimit
		Bone2AngleLimit();
		break;
	case eLIM2BONE_NONE:
		break;
	}

	if (s_model) {
		ClearLimitedWM(s_model);
		CopyWorldToLimitedWorld(s_model);
		ApplyNewLimitsToWM(s_model);
	}


	//if (s_model && s_model->GetCurMotInfo()) {
	//	int curmotid = s_model->GetCurMotInfo()->motid;
	//	s_model->CalcBoneEul(curmotid);
	//}

	//読み込みなおし：lowerとupperは大小関係で入れ替わることがあるため適用後読み込みなおす。
	Bone2AngleLimit();
	//AngleLimit2Dlg(s_anglelimitdlg);
	ChangeCurrentBone();

	//UpdateEditedEuler();//selectした範囲のみ
	refreshEulerGraph();//モーション全体

	//s_underanglelimithscroll = 0;

	if (setcursorflag && (oldcursor != NULL)) {
		//カーソルを元に戻す
		SetCursor(oldcursor);
	}

	return 0;
}

LRESULT CALLBACK ModelWorldMatDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR strval[256] = { 0L };
	float value = 0.0f;
	ChaVector3 tmppos = ChaVector3(0.0f, 0.0f, 0.0f);
	ChaVector3 tmprot = ChaVector3(0.0f, 0.0f, 0.0f);

	switch (msg) {
	case WM_INITDIALOG:
	{
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model) {
			tmppos = s_model->GetModelPosition();
			tmprot = s_model->GetModelRotation();

			swprintf_s(strval, 256, L"%.3f", tmppos.x);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONX, strval);
			swprintf_s(strval, 256, L"%.3f", tmppos.y);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONY, strval);
			swprintf_s(strval, 256, L"%.3f", tmppos.z);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONZ, strval);

			swprintf_s(strval, 256, L"%.3f", tmprot.x);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_ROTATIONX, strval);
			swprintf_s(strval, 256, L"%.3f", tmprot.y);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_ROTATIONY, strval);
			swprintf_s(strval, 256, L"%.3f", tmprot.z);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_ROTATIONZ, strval);

		}

		//RECT dlgrect;
		//GetWindowRect(hDlgWnd, &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		s_modelworldmatdlgwnd = hDlgWnd;

		return FALSE;
	}
	break;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			ShowWindow(hDlgWnd, SW_HIDE);
			break;
		case IDCANCEL:
			ShowWindow(hDlgWnd, SW_HIDE);
			break;

		case IDC_TOCAMERAPOS:
		{
			swprintf_s(strval, 256, L"%.3f", g_camEye.x);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONX, strval);
			swprintf_s(strval, 256, L"%.3f", g_camEye.y);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONY, strval);
			swprintf_s(strval, 256, L"%.3f", g_camEye.z);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONZ, strval);

			s_model->SetModelPosition(g_camEye);
			s_model->CalcModelWorldMatOnLoad();
		}
			break;
		case IDC_TOCAMERATARGET:
		{
			swprintf_s(strval, 256, L"%.3f", g_camtargetpos.x);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONX, strval);
			swprintf_s(strval, 256, L"%.3f", g_camtargetpos.y);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONY, strval);
			swprintf_s(strval, 256, L"%.3f", g_camtargetpos.z);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONZ, strval);

			s_model->SetModelPosition(g_camtargetpos);
			s_model->CalcModelWorldMatOnLoad();
		}
			break;

		case IDC_APPLYMODELWORLDMAT:
		{
			if (s_model) {
				tmppos = s_model->GetModelPosition();
				tmprot = s_model->GetModelRotation();
				const float maxvalue = 100000.0f;
				const float minvalue = -maxvalue;
				const float maxvalue2 = 10000.0f;
				const float minvalue2 = -maxvalue;

				GetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONX, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= minvalue) && (value <= maxvalue)) {
					tmppos.x = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONY, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= minvalue) && (value <= maxvalue)) {
					tmppos.y = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONZ, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= minvalue) && (value <= maxvalue)) {
					tmppos.z = value;
				}

				GetDlgItemTextW(hDlgWnd, IDC_EDIT_ROTATIONX, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= minvalue) && (value <= maxvalue)) {
					tmprot.x = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_ROTATIONY, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= minvalue) && (value <= maxvalue)) {
					tmprot.y = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_ROTATIONZ, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= minvalue) && (value <= maxvalue)) {
					tmprot.z = value;
				}


				s_model->SetModelPosition(tmppos);
				s_model->SetModelRotation(tmprot);
				s_model->CalcModelWorldMatOnLoad();
			}

		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_CLOSE:
		ShowWindow(hDlgWnd, SW_HIDE);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}


LRESULT CALLBACK MaterialRateDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR strval[256] = { 0L };
	float value = 1.0f;
	ChaVector4 tmpmaterialrate = ChaVector4(1.0f, 1.0f, 1.0f, 1.0f);

	switch (msg) {
	case WM_INITDIALOG:
	{
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model) {
			ChaVector4 materialdisprate = s_model->GetMaterialDispRate();

			swprintf_s(strval, 256, L"%.3f", materialdisprate.x);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_DIFFUSERATE, strval);
			swprintf_s(strval, 256, L"%.3f", materialdisprate.y);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_SPECULARRATE, strval);
			swprintf_s(strval, 256, L"%.3f", materialdisprate.z);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_EMISSIVERATE, strval);
			swprintf_s(strval, 256, L"%.3f", materialdisprate.w);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_AMBIENTRATE, strval);
		}

		//RECT dlgrect;
		//GetWindowRect(hDlgWnd, &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		s_materialratedlgwnd = hDlgWnd;

		return FALSE;
	}
	break;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			ShowWindow(hDlgWnd, SW_HIDE);
			break;
		case IDCANCEL:
			ShowWindow(hDlgWnd, SW_HIDE);
			break;
		case IDC_APPLYMATERIALRATE:
		{
			if (s_model) {
				tmpmaterialrate = s_model->GetMaterialDispRate();

				const float maxvalue = 10000.0f;

				GetDlgItemTextW(hDlgWnd, IDC_EDIT_DIFFUSERATE, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= 0.0f) && (value <= maxvalue)) {
					tmpmaterialrate.x = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_SPECULARRATE, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= 0.0f) && (value <= maxvalue)) {
					tmpmaterialrate.y = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_EMISSIVERATE, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= 0.0f) && (value <= maxvalue)) {
					tmpmaterialrate.z = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_AMBIENTRATE, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= 0.0f) && (value <= maxvalue)) {
					tmpmaterialrate.w = value;
				}

				s_model->SetMaterialDispRate(tmpmaterialrate);

			}

		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_CLOSE:
		ShowWindow(hDlgWnd, SW_HIDE);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}

int OwnerDrawLightColorBar(HWND hDlgWnd, int lightindex, int idcolorbar)
{
	if (!hDlgWnd) {
		_ASSERT(0);
		return 1;
	}
	if ((lightindex < 0) || (lightindex >= LIGHTNUMMAX)) {
		_ASSERT(0);
		return 1;
	}
	if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
		_ASSERT(0);
		return 1;
	}


	COLORREF col = g_lightDiffuse[g_lightSlot][lightindex].ColorRef();
	HBRUSH hBrush = CreateSolidBrush(col);
	HWND hwnd = GetDlgItem(hDlgWnd, idcolorbar);
	HDC hdc = GetDC(hwnd);
	RECT rect;
	GetClientRect(hwnd, &rect);
	FillRect(hdc, &rect, hBrush);
	ReleaseDC(hwnd, hdc);
	DeleteObject(hBrush);

	return 0;
}

int ChooseLightColorBar(HWND hDlgWnd, int lightindex, int idcolorbar)
{
	if (!hDlgWnd) {
		_ASSERT(0);
		return 1;
	}
	if ((lightindex < 0) || (lightindex >= LIGHTNUMMAX)) {
		_ASSERT(0);
		return 1;
	}
	if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
		_ASSERT(0);
		return 1;
	}

	COLORREF colrgb = g_lightDiffuse[g_lightSlot][lightindex].ColorRef();
	int dlgret = s_coldlg.Choose(hDlgWnd, &colrgb);
	if (dlgret == 1) {
		float fr, fg, fb;
		fr = (float)((double)GetRValue(colrgb) / 255.0);
		fr = min(1.0f, fr);
		fr = max(0.0f, fr);
		fg = (float)((double)GetGValue(colrgb) / 255.0);
		fg = min(1.0f, fg);
		fg = max(0.0f, fg);
		fb = (float)((double)GetBValue(colrgb) / 255.0);
		fb = min(1.0f, fb);
		fb = max(0.0f, fb);

		g_lightDiffuse[g_lightSlot][lightindex] = ChaVector3(fr, fg, fb);
		SetLightDirection();

		HWND ctrlwnd = GetDlgItem(hDlgWnd, idcolorbar);
		RECT rect;
		GetClientRect(ctrlwnd, &rect);
		InvalidateRect(ctrlwnd, &rect, true);
	}

	return 0;
}
LRESULT CALLBACK LaterTransparentDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	switch (msg) {
	case WM_INITDIALOG:
	{
		LaterTransparent2Dlg(hDlgWnd);
		return FALSE;
	}
	break;

	case WM_COMMAND:

		switch (LOWORD(wp)) {

		case IDC_ADDTOLATERTRANSPARENT:
		{
			HWND list1wnd = GetDlgItem(hDlgWnd, IDC_LIST1);
			HWND list2wnd = GetDlgItem(hDlgWnd, IDC_LIST2);
			if (list1wnd && list2wnd) {
				int selindex1;
				selindex1 = (int)SendMessage(list1wnd, LB_GETCURSEL, 0, 0);
				if (selindex1 != LB_ERR) {//何も選択していないときもLB_ERRが返る
					int textlen1;
					textlen1 = (int)SendMessage(list1wnd, LB_GETTEXTLEN, (WPARAM)selindex1, 0);
					if ((textlen1 > 0) && (textlen1 < 512)) {
						WCHAR text1[512] = { 0L };
						int result1 = (int)SendMessage(list1wnd, LB_GETTEXT, (WPARAM)selindex1, (LPARAM)(&text1[0]));
						if (result1 != LB_ERR) {


							//text1と同じ名前がlist2にあるかどうかチェック　2023/10/10
							bool foundsame = false;
							{
								int chkelemnum = (int)SendMessage(list2wnd, LB_GETCOUNT, 0, 0);
								int chkelemno;
								for (chkelemno = 0; chkelemno < chkelemnum; chkelemno++) {
									WCHAR chktext2[512] = { 0L };
									int chktextlen2 = (int)SendMessage(list2wnd, LB_GETTEXTLEN, (WPARAM)chkelemno, 0);
									if ((chktextlen2 > 0) && (chktextlen2 < 512)) {
										int result2 = (int)SendMessage(list2wnd, LB_GETTEXT, (WPARAM)chkelemno, (LPARAM)(&chktext2[0]));
										if (result2 != LB_ERR) {
											if (wcscmp(text1, chktext2) == 0) {
												foundsame = true;
												break;
											}
										}
									}
								}
							}


							if (foundsame == false) {//list2にtext1がまだ存在しない場合に　list2にtext1をAdd
								LRESULT lres2;
								lres2 = SendMessage(list2wnd, LB_ADDSTRING, 0, (LPARAM)(&text1[0]));
								if ((lres2 == LB_ERR) || (lres2 == LB_ERRSPACE)) {
									_ASSERT(0);
									return FALSE;
								}


								//追加した要素を選択
								int elemnum = (int)SendMessage(list2wnd, LB_GETCOUNT, 0, 0);
								if (elemnum >= 1) {
									SendMessage(list2wnd, LB_SETCURSEL, (WPARAM)(elemnum - 1), 0);
								}
							}
						}
					}
				}
				else {
					//何も選択していないときもLB_ERRが返る
					return TRUE;
				}

				Dlg2LaterTransparent(hDlgWnd);
			}
		}
		break;
		case IDC_DELETEALL:
		{
			HWND list2wnd = GetDlgItem(hDlgWnd, IDC_LIST2);
			if (list2wnd) {
				::SendMessage(list2wnd, LB_RESETCONTENT, 0, 0);

				Dlg2LaterTransparent(hDlgWnd);
			}

		}
		break;
		case IDC_DELETEONE:
		{
			HWND list2wnd = GetDlgItem(hDlgWnd, IDC_LIST2);
			if (list2wnd) {
				int selindex;
				selindex = (int)SendMessage(list2wnd, LB_GETCURSEL, 0, 0);
				if (selindex != LB_ERR) {//何も選択していないときもLB_ERRが返る
					int ret;
					ret = (int)SendMessage(list2wnd, LB_DELETESTRING, (WPARAM)selindex, 0);
					if (ret == LB_ERR) {
						_ASSERT(0);
						return FALSE;
					}

					Dlg2LaterTransparent(hDlgWnd);
				}
				else {
					//何も選択していないときもLB_ERRが返る
					return TRUE;
				}
			}
		}
		break;
		case IDC_UPORDER:
		{
			HWND list2wnd = GetDlgItem(hDlgWnd, IDC_LIST2);
			if (list2wnd) {
				int selindex;
				selindex = (int)SendMessage(list2wnd, LB_GETCURSEL, 0, 0);
				if (selindex != LB_ERR) {//何も選択していないときもLB_ERRが返る

					int elemnum = (int)SendMessage(list2wnd, LB_GETCOUNT, 0, 0);

					if ((selindex != 0) && (elemnum > 0)) {//一番上以外の要素に対して操作

						//操作前のリストをsavelist2に格納
						vector<wstring> savelist2;
						int elemno;
						for (elemno = 0; elemno < elemnum; elemno++) {
							int textlen;
							textlen = (int)SendMessage(list2wnd, LB_GETTEXTLEN, (WPARAM)elemno, 0);
							if ((textlen > 0) && (textlen < 512)) {
								WCHAR text2[512] = { 0L };
								int result = (int)SendMessage(list2wnd, LB_GETTEXT, (WPARAM)elemno, (LPARAM)(&text2[0]));
								if (result != LB_ERR) {
									savelist2.push_back(text2);
								}
								else {
									_ASSERT(0);
									return FALSE;
								}
							}
						}

						//リストを全削除
						::SendMessage(list2wnd, LB_RESETCONTENT, 0, 0);

						//順番を変えて　list2にAddし直し
						int listno2;
						for (listno2 = 0; listno2 < elemnum; listno2++) {
							if (listno2 == (selindex - 1)) {
								LRESULT lres0;
								lres0 = SendMessage(list2wnd, LB_ADDSTRING, 0, (LPARAM)savelist2[selindex].c_str());
								if ((lres0 == LB_ERR) || (lres0 == LB_ERRSPACE)) {
									_ASSERT(0);
									return FALSE;
								}
							}
							else if (listno2 == selindex) {
								LRESULT lres1;
								lres1 = SendMessage(list2wnd, LB_ADDSTRING, 0, (LPARAM)savelist2[selindex - 1].c_str());
								if ((lres1 == LB_ERR) || (lres1 == LB_ERRSPACE)) {
									_ASSERT(0);
									return FALSE;
								}
							}
							else {
								LRESULT lres2;
								lres2 = SendMessage(list2wnd, LB_ADDSTRING, 0, (LPARAM)savelist2[listno2].c_str());
								if ((lres2 == LB_ERR) || (lres2 == LB_ERRSPACE)) {
									_ASSERT(0);
									return FALSE;
								}
							}

						}

						if ((selindex - 1) >= 0) {
							//UpOrderした要素を選択
							SendMessage(list2wnd, LB_SETCURSEL, (WPARAM)(selindex - 1), 0);
						}

						Dlg2LaterTransparent(hDlgWnd);
					}
					else {
						//一番上の要素に対してはUpOrder操作をしない
					}
				}
				else {
					//何も選択していないときもLB_ERRが返る
					return TRUE;
				}
			}
		}
		break;
		case IDC_DOWNORDER:
		{
			HWND list2wnd = GetDlgItem(hDlgWnd, IDC_LIST2);
			if (list2wnd) {
				int selindex;
				selindex = (int)SendMessage(list2wnd, LB_GETCURSEL, 0, 0);
				if (selindex != LB_ERR) {//何も選択していないときもLB_ERRが返る

					int elemnum = (int)SendMessage(list2wnd, LB_GETCOUNT, 0, 0);

					if ((selindex != (elemnum - 1)) && (elemnum > 0)) {//一番下以外の要素に対して操作

						//操作前のリストをsavelist2に格納
						vector<wstring> savelist2;
						int elemno;
						for (elemno = 0; elemno < elemnum; elemno++) {
							int textlen;
							textlen = (int)SendMessage(list2wnd, LB_GETTEXTLEN, (WPARAM)elemno, 0);
							if ((textlen > 0) && (textlen < 512)) {
								WCHAR text2[512] = { 0L };
								int result = (int)SendMessage(list2wnd, LB_GETTEXT, (WPARAM)elemno, (LPARAM)(&text2[0]));
								if (result != LB_ERR) {
									savelist2.push_back(text2);
								}
								else {
									_ASSERT(0);
									return FALSE;
								}
							}
						}

						//リストを全削除
						::SendMessage(list2wnd, LB_RESETCONTENT, 0, 0);

						//順番を変えて　list2にAddし直し
						int listno2;
						for (listno2 = 0; listno2 < elemnum; listno2++) {
							if (listno2 == selindex) {
								LRESULT lres0;
								lres0 = SendMessage(list2wnd, LB_ADDSTRING, 0, (LPARAM)savelist2[selindex + 1].c_str());
								if ((lres0 == LB_ERR) || (lres0 == LB_ERRSPACE)) {
									_ASSERT(0);
									return FALSE;
								}
							}
							else if (listno2 == (selindex + 1)) {
								LRESULT lres1;
								lres1 = SendMessage(list2wnd, LB_ADDSTRING, 0, (LPARAM)savelist2[selindex].c_str());
								if ((lres1 == LB_ERR) || (lres1 == LB_ERRSPACE)) {
									_ASSERT(0);
									return FALSE;
								}
							}
							else {
								LRESULT lres2;
								lres2 = SendMessage(list2wnd, LB_ADDSTRING, 0, (LPARAM)savelist2[listno2].c_str());
								if ((lres2 == LB_ERR) || (lres2 == LB_ERRSPACE)) {
									_ASSERT(0);
									return FALSE;
								}
							}
						}

						if ((selindex + 1) < elemnum) {
							//DownOrderした要素を選択
							SendMessage(list2wnd, LB_SETCURSEL, (WPARAM)(selindex + 1), 0);
						}

						Dlg2LaterTransparent(hDlgWnd);

					}
					else {
						//一番下の要素に対してはDownOrder操作をしない
					}
				}
				else {
					//何も選択していないときもLB_ERRが返る
					return TRUE;
				}
			}
		}
		break;

		case IDCANCEL:
			//EndDialog(hDlgWnd, IDCANCEL);
		break;
		default:
			return FALSE;
		break;
	}
	break;
	case WM_CLOSE:
		if (s_latertransparentdlg) {

			//if (s_lightstimerid > 0) {
			//	KillTimer(hDlgWnd, s_lightstimerid);
			//	s_lightstimerid = 0;
			//}

			//DestroyWindow(s_latertransparentdlg);
			//s_latertransparentdlg = 0;

			ShowLaterTransparentWnd(false);
		}
	break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}


LRESULT CALLBACK ShadowParamsDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR streditbox[256] = { 0L };
	float tempeditvalue;

	if ((g_shadowmap_slotno < 0) || (g_shadowmap_slotno >= SHADOWSLOTNUM)) {
		_ASSERT(0);
		g_shadowmap_slotno = 0;
	}


	switch (msg) {
	case WM_INITDIALOG:
	{
		ShadowParams2Dlg(hDlgWnd);
		return FALSE;
	}
	break;

	case WM_COMMAND:

		switch (LOWORD(wp)) {

		case IDC_CHECK_ENABLESHADOW:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_ENABLESHADOW);
			if (ischecked == BST_CHECKED) {
				g_enableshadow = true;
			}
			else {
				g_enableshadow = false;
			}
		}
		break;


		case IDC_SHADOWDIR_1:
			g_shadowmap_lightdir[g_shadowmap_slotno] = 1;
			CheckShadowDirectionButton(hDlgWnd, g_shadowmap_lightdir[g_shadowmap_slotno]);
			SetCamera3DFromEyePos();
			break;
		case IDC_SHADOWDIR_2:
			g_shadowmap_lightdir[g_shadowmap_slotno] = 2;
			CheckShadowDirectionButton(hDlgWnd, g_shadowmap_lightdir[g_shadowmap_slotno]);
			SetCamera3DFromEyePos();
			break;
		case IDC_SHADOWDIR_3:
			g_shadowmap_lightdir[g_shadowmap_slotno] = 3;
			CheckShadowDirectionButton(hDlgWnd, g_shadowmap_lightdir[g_shadowmap_slotno]);
			SetCamera3DFromEyePos();
			break;
		case IDC_SHADOWDIR_4:
			g_shadowmap_lightdir[g_shadowmap_slotno] = 4;
			CheckShadowDirectionButton(hDlgWnd, g_shadowmap_lightdir[g_shadowmap_slotno]);
			SetCamera3DFromEyePos();
			break;
		case IDC_SHADOWDIR_5:
			g_shadowmap_lightdir[g_shadowmap_slotno] = 5;
			CheckShadowDirectionButton(hDlgWnd, g_shadowmap_lightdir[g_shadowmap_slotno]);
			SetCamera3DFromEyePos();
			break;
		case IDC_SHADOWDIR_6:
			g_shadowmap_lightdir[g_shadowmap_slotno] = 6;
			CheckShadowDirectionButton(hDlgWnd, g_shadowmap_lightdir[g_shadowmap_slotno]);
			SetCamera3DFromEyePos();
			break;
		case IDC_SHADOWDIR_7:
			g_shadowmap_lightdir[g_shadowmap_slotno] = 7;
			CheckShadowDirectionButton(hDlgWnd, g_shadowmap_lightdir[g_shadowmap_slotno]);
			SetCamera3DFromEyePos();
			break;
		case IDC_SHADOWDIR_8:
			g_shadowmap_lightdir[g_shadowmap_slotno] = 8;
			CheckShadowDirectionButton(hDlgWnd, g_shadowmap_lightdir[g_shadowmap_slotno]);
			SetCamera3DFromEyePos();
			break;

		case IDC_APPLYEDITBOX:
			GetDlgItemText(hDlgWnd, IDC_EDIT_PLUSUP, streditbox, 256);
			tempeditvalue = (float)_wtof(streditbox);
			if ((tempeditvalue >= -50000.0f) && (tempeditvalue <= 50000.0f)) {
				g_shadowmap_plusup[g_shadowmap_slotno] = tempeditvalue;
			}
			else {
				::MessageBox(hDlgWnd, L"invalid editbox value : plusup", L"Invalid Value", MB_OK);
			}

			GetDlgItemText(hDlgWnd, IDC_EDIT_PLUSRIGHT, streditbox, 256);
			tempeditvalue = (float)_wtof(streditbox);
			if ((tempeditvalue >= -50000.0f) && (tempeditvalue <= 50000.0f)) {
				g_shadowmap_distscale[g_shadowmap_slotno] = tempeditvalue;
			}
			else {
				::MessageBox(hDlgWnd, L"invalid editbox value : plusright", L"Invalid Value", MB_OK);
			}

			GetDlgItemText(hDlgWnd, IDC_EDIT_NEAR, streditbox, 256);
			tempeditvalue = (float)_wtof(streditbox);
			if ((tempeditvalue >= 0.000010f) && (tempeditvalue <= 500000.0f)) {
				g_shadowmap_near[g_shadowmap_slotno] = tempeditvalue;
			}
			else {
				::MessageBox(hDlgWnd, L"invalid editbox value : near", L"Invalid Value", MB_OK);
			}

			GetDlgItemText(hDlgWnd, IDC_EDIT_FAR, streditbox, 256);
			tempeditvalue = (float)_wtof(streditbox);
			if ((tempeditvalue >= 0.000010f) && (tempeditvalue <= 500000.0f)) {
				g_shadowmap_far[g_shadowmap_slotno] = tempeditvalue;
			}
			else {
				::MessageBox(hDlgWnd, L"invalid editbox value : near", L"Invalid Value", MB_OK);
			}

			SetCamera3DFromEyePos();

			break;
		
		case IDC_INITSHADOW:
			g_shadowmap_fov[g_shadowmap_slotno] = 60.0f;
			g_shadowmap_projscale[g_shadowmap_slotno] = 1.0f;
			g_shadowmap_near[g_shadowmap_slotno] = 50.0f;
			g_shadowmap_far[g_shadowmap_slotno] = 2000.0f;
			g_shadowmap_color[g_shadowmap_slotno] = 0.5f;
			g_shadowmap_bias[g_shadowmap_slotno] = 0.0010f;
			g_shadowmap_plusup[g_shadowmap_slotno] = 300.0f;
			g_shadowmap_distscale[g_shadowmap_slotno] = 1.0f;
			g_shadowmap_lightdir[g_shadowmap_slotno] = 1;

			ShadowParams2Dlg(hDlgWnd);
			SetCamera3DFromEyePos();
			break;

		//##########
		//COMBO BOX
		//##########
		case IDC_COMBO_SLOT:
			if (HIWORD(wp) == CBN_SELCHANGE) {
				HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO_SLOT);
				if (combownd != NULL) {
					int combono;
					combono = (int)SendMessage(combownd, CB_GETCURSEL, 0, 0);
					if ((combono >= 0) && (combono < SHADOWSLOTNUM)) {
						g_shadowmap_slotno = combono;
						ShadowParams2Dlg(hDlgWnd);
						SetCamera3DFromEyePos();
					}
					else {
						_ASSERT(0);
						return false;
					}
				}
				else {
					_ASSERT(0);
					return false;
				}

			}
			break;



		case IDCANCEL:
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
			break;
		}
		break;

	case WM_HSCROLL:
		if (GetDlgItem(hDlgWnd, IDC_SLIDER_FOV) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_FOV), TBM_GETPOS, 0, 0);
			g_shadowmap_fov[g_shadowmap_slotno] = (float)cursliderpos;

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"FOV:%.1fdeg", g_shadowmap_fov[g_shadowmap_slotno]);
			SetDlgItemText(hDlgWnd, IDC_STATIC_FOV, strdlg);
			SetCamera3DFromEyePos();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_COLOR) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_COLOR), TBM_GETPOS, 0, 0);
			g_shadowmap_color[g_shadowmap_slotno] = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"Color:%.2f", g_shadowmap_color[g_shadowmap_slotno]);
			SetDlgItemText(hDlgWnd, IDC_STATIC_COLOR, strdlg);
			SetCamera3DFromEyePos();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_BIAS) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BIAS), TBM_GETPOS, 0, 0);
			g_shadowmap_bias[g_shadowmap_slotno] = (float)((double)cursliderpos / 10000.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"Bias:%.3f", g_shadowmap_bias[g_shadowmap_slotno]);
			SetDlgItemText(hDlgWnd, IDC_STATIC_BIAS, strdlg);
			SetCamera3DFromEyePos();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_PROJSCALE) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_PROJSCALE), TBM_GETPOS, 0, 0);
			g_shadowmap_projscale[g_shadowmap_slotno] = (float)((double)cursliderpos / 10.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"SceneMult:%.1f", g_shadowmap_projscale[g_shadowmap_slotno]);
			SetDlgItemText(hDlgWnd, IDC_STATIC_PROJSCALE, strdlg);
			SetCamera3DFromEyePos();
		}
		break;




	case WM_CLOSE:
		if (s_shadowparamsdlg) {

			//if (s_lightstimerid > 0) {
			//	KillTimer(hDlgWnd, s_lightstimerid);
			//	s_lightstimerid = 0;
			//}

			//DestroyWindow(s_latertransparentdlg);
			//s_latertransparentdlg = 0;

			ShowShadowParamsWnd(false);
		}
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}


//void CheckShaderTypeButton(HWND hDlgWnd, int srcshadertype)
//{
//	//############################
//	//DispAndLimitプレートメニュー用
//	//############################
//
//	switch (srcshadertype) {
//	case -1:
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO), BM_SETSTATE, TRUE, 0);//!!!!!!
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT), BM_SETSTATE, FALSE, 0);
//		//g_shadertype = srcshadertype;
//		break;
//	case MQOSHADER_PBR:
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR), BM_SETSTATE, TRUE, 0);//!!!!
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT), BM_SETSTATE, FALSE, 0);
//		//g_shadertype = srcshadertype;
//		break;
//	case MQOSHADER_STD:
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD), BM_SETSTATE, TRUE, 0);//!!!!!!!
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT), BM_SETSTATE, FALSE, 0);
//		//g_shadertype = srcshadertype;
//		break;
//	case MQOSHADER_NOLIGHT:
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT), BM_SETSTATE, TRUE, 0);//!!!!!!
//		//g_shadertype = srcshadertype;
//		break;
//	default:
//		_ASSERT(0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO), BM_SETSTATE, TRUE, 0);//!!!!
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD), BM_SETSTATE, FALSE, 0);
//		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT), BM_SETSTATE, FALSE, 0);
//		//g_shadertype = -1;
//		break;
//	}
//}

void CheckShaderTypeParamsButton(HWND hDlgWnd, int srcshadertype)
{
	//###############################################
	//Shaderプレートメニューから呼び出すparamsダイアログ用
	//###############################################

	switch (srcshadertype) {
	case -1:
	case -2:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO2), BM_SETSTATE, TRUE, 0);//!!!!!!
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT2), BM_SETSTATE, FALSE, 0);
		break;
	case MQOSHADER_PBR:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR2), BM_SETSTATE, TRUE, 0);//!!!!
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT2), BM_SETSTATE, FALSE, 0);
		break;
	case MQOSHADER_STD:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD2), BM_SETSTATE, TRUE, 0);//!!!!!!!
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT2), BM_SETSTATE, FALSE, 0);
		break;
	case MQOSHADER_NOLIGHT:
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT2), BM_SETSTATE, TRUE, 0);//!!!!!!
		break;
	default:
		//_ASSERT(0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_AUTO2), BM_SETSTATE, TRUE, 0);//!!!!
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_PBR2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_STD2), BM_SETSTATE, FALSE, 0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SHADER_NOLIGHT2), BM_SETSTATE, FALSE, 0);
		break;
	}
}

LRESULT CALLBACK GUIDispParamsDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
	{
		//Lights2Dlg(hDlgWnd);
		//EnableWindow(GetDlgItem(hDlgWnd, IDC_RESETLIM_CURRENT), FALSE);

		//#######
		//Button
		//#######
		// //マテリアル毎に設定することに
		//CheckShaderTypeButton(hDlgWnd, g_shadertype);


		//#######
		//Slider
		//#######
		int sliderpos = (int)(g_fLightScale * 10.0f);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_LIGHTS), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_LIGHTS), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_LIGHTS), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		sliderpos = g_UpdateMatrixThreads;
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_UPDATETHREADS), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)1);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_UPDATETHREADS), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)8);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_UPDATETHREADS), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		sliderpos = (int)(g_dspeed * 100.0f);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_SPEED), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_SPEED), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)700);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_SPEED), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		sliderpos = (int)(g_physicsmvrate * 10.0f);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_EDITRATE), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_EDITRATE), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)500);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_EDITRATE), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		sliderpos = (int)(g_bonemark_bright * 100.0f);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BONEMARK), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BONEMARK), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BONEMARK), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		sliderpos = (int)(g_rigidmark_alpha * 100.0f);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_RIGIDMARK), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_RIGIDMARK), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_RIGIDMARK), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		sliderpos = (int)(g_rigmark_alpha * 100.0f);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_RIGMARK), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_RIGMARK), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_RIGMARK), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);


		//#####
		//Text
		//#####
		WCHAR strdlg[256] = { 0L };
		swprintf_s(strdlg, 256, L"Enable Lights %.1f", g_fLightScale);
		SetDlgItemText(hDlgWnd, IDC_CHECK_LIGHTS, strdlg);

		swprintf_s(strdlg, 256, L"Update Threads %d", g_UpdateMatrixThreads);
		SetDlgItemText(hDlgWnd, IDC_STATIC_UPDATETHREADS, strdlg);

		swprintf_s(strdlg, 256, L"Speed %.2f", g_dspeed);
		SetDlgItemText(hDlgWnd, IDC_STATIC_SPEED, strdlg);

		swprintf_s(strdlg, 256, L"EditRate %.1f", g_physicsmvrate);
		SetDlgItemText(hDlgWnd, IDC_STATIC_EDITRATE, strdlg);

		//#########
		//ComboBox
		//#########
		HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO_IKLEVELS);
		if (combownd != NULL) {
			SendMessage(combownd, CB_RESETCONTENT, 0, 0);
			int slotno;
			for (slotno = 0; slotno < 15; slotno++) {
				WCHAR strcombo[256];
				swprintf_s(strcombo, 256, L"%d", (slotno + 1));
				SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)strcombo);
			}
			::SendMessage(combownd, CB_SETCURSEL, (WPARAM)(g_iklevel - 1), 0);
		}
		else {
			_ASSERT(0);
			return 1;
		}



		combownd = GetDlgItem(hDlgWnd, IDC_COMBO_AXISKIND);
		if (combownd != NULL) {
			SendMessage(combownd, CB_RESETCONTENT, 0, 0);

			WCHAR straxis[256];
			ULONG boneaxisindex;
			swprintf_s(straxis, 256, L"Current");
			boneaxisindex = BONEAXIS_CURRENT;
			SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)straxis);
			swprintf_s(straxis, 256, L"Parent");
			boneaxisindex = BONEAXIS_PARENT;
			SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)straxis);
			swprintf_s(straxis, 256, L"Global");
			boneaxisindex = BONEAXIS_GLOBAL;
			SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)straxis);
			swprintf_s(straxis, 256, L"BindPose");
			boneaxisindex = BONEAXIS_BINDPOSE;
			SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)straxis);
			SendMessage(combownd, CB_SETCURSEL, (WPARAM)g_boneaxis, 0);
		}
		else {
			_ASSERT(0);
			return 1;
		}


		combownd = GetDlgItem(hDlgWnd, IDC_COMBO_UVSET);
		if (combownd != NULL) {
			SendMessage(combownd, CB_RESETCONTENT, 0, 0);

			WCHAR struvset[256];
			ULONG uvindex;
			swprintf_s(struvset, 256, L"UVSet0");
			uvindex = BONEAXIS_CURRENT;
			SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)struvset);
			swprintf_s(struvset, 256, L"UVSet1");
			uvindex = BONEAXIS_PARENT;
			SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)struvset);
			SendMessage(combownd, CB_SETCURSEL, (WPARAM)g_uvset, 0);
		}
		else {
			_ASSERT(0);
			return 1;
		}


		//#########
		//CheckBox
		//#########
		if (g_hdrpbloom == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_BLOOM, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_BLOOM, false);
		}

		if (g_freefps == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_FREEFPS, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_FREEFPS, false);
		}

		if ((bool)g_lightflag == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_LIGHTS, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_LIGHTS, false);
		}

		if (g_HighRpmMode == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_HIGHRPM, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_HIGHRPM, false);
		}

		if ((bool)g_bonemarkflag == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_DISPBONE, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_DISPBONE, false);
		}

		if ((bool)g_rigidmarkflag == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_RIGIDMARK, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_RIGIDMARK, false);
		}

		if ((bool)s_camtargetflag == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_LOCKTOSEL, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_LOCKTOSEL, false);
		}

		if (g_preciseOnPreviewToo == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_PRECISE, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_PRECISE, false);
		}

		if (g_x180flag == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_X180, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_X180, false);
		}

		if (g_rotatetanim == true) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_TROT, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_TROT, false);
		}

		if (g_zpreflag == true) {
			CheckDlgButton(hDlgWnd, IDC_ZPREPASS, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_ZPREPASS, false);
		}


		return FALSE;
	}
	break;

	case WM_DRAWITEM://オーナードローコントロールの描画 : リソースでカラーバーボタンにオーナードロー属性を設定してある
	//DefWindowProc(hDlgWnd, msg, wp, lp);
	break;

	case WM_HSCROLL:
		if (GetDlgItem(hDlgWnd, IDC_SLIDER_LIGHTS) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_LIGHTS), TBM_GETPOS, 0, 0);
			g_fLightScale = (float)((double)cursliderpos / 10.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"Enable Lights %.1f", g_fLightScale);
			SetDlgItemText(hDlgWnd, IDC_CHECK_LIGHTS, strdlg);
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_UPDATETHREADS) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_UPDATETHREADS), TBM_GETPOS, 0, 0);
			g_UpdateMatrixThreads = cursliderpos;

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"Update Threads %d", g_UpdateMatrixThreads);
			SetDlgItemText(hDlgWnd, IDC_STATIC_UPDATETHREADS, strdlg);

			if (LOWORD(wp) == SB_ENDSCROLL) {
				//#################################################
				//ReleasedCaptureのときに　PrepairUndo用のフラグを立てる
				//#################################################
				s_changeupdatethreadsFlag = true;
			}

		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_SPEED) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_SPEED), TBM_GETPOS, 0, 0);
			g_dspeed = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"Speed %.2f", g_dspeed);
			SetDlgItemText(hDlgWnd, IDC_STATIC_SPEED, strdlg);

			s_model->SetTmpMotSpeed((float)g_dspeed);
			OnSetMotSpeed();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_EDITRATE) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_EDITRATE), TBM_GETPOS, 0, 0);
			g_physicsmvrate = (float)((double)cursliderpos / 10.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"EditRate %.1f", g_physicsmvrate);
			SetDlgItemText(hDlgWnd, IDC_STATIC_EDITRATE, strdlg);
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_BONEMARK) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BONEMARK), TBM_GETPOS, 0, 0);
			g_bonemark_bright = (float)((double)cursliderpos / 100.0);
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_RIGIDMARK) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_RIGIDMARK), TBM_GETPOS, 0, 0);
			g_rigidmark_alpha = (float)((double)cursliderpos / 100.0);
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_RIGMARK) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_RIGMARK), TBM_GETPOS, 0, 0);
			g_rigmark_alpha = (float)((double)cursliderpos / 100.0);
		}

	break;

	case WM_COMMAND:

		switch (LOWORD(wp)) {


		////マテリアル毎に設定することに
		//case IDC_SHADER_AUTO:
		//	CheckShaderTypeButton(hDlgWnd, -1);
		//	break;
		//case IDC_SHADER_PBR:
		//	CheckShaderTypeButton(hDlgWnd, MQOSHADER_PBR);
		//	break;
		//case IDC_SHADER_STD:
		//	CheckShaderTypeButton(hDlgWnd, MQOSHADER_STD);
		//	break;
		//case IDC_SHADER_NOLIGHT:
		//	CheckShaderTypeButton(hDlgWnd, MQOSHADER_NOLIGHT);
		//	break;

		case IDC_CHECK_BLOOM:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_BLOOM);
			if (ischecked == BST_CHECKED) {
				g_hdrpbloom = true;
			}
			else {
				g_hdrpbloom = false;
			}
		}
		break;

		case IDC_CHECK_FREEFPS:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_FREEFPS);
			if (ischecked == BST_CHECKED) {
				g_freefps = true;
			}
			else {
				g_freefps = false;
			}
		}
		break;

		case IDC_CHECK_LIGHTS:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_LIGHTS);
			if (ischecked == BST_CHECKED) {
				g_lightflag = 1;
			}
			else {
				g_lightflag = 0;
			}
		}
			break;
		case IDC_CHECK_HIGHRPM:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_HIGHRPM);
			if (ischecked == BST_CHECKED) {
				g_HighRpmMode = true;
			}
			else {
				g_HighRpmMode = false;
			}
		}
		break;
		case IDC_CHECK_DISPBONE:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_DISPBONE);
			if (ischecked == BST_CHECKED) {
				g_bonemarkflag = 1;
			}
			else {
				g_bonemarkflag = 0;
			}
		}
		break;
		case IDC_CHECK_RIGIDMARK:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_RIGIDMARK);
			if (ischecked == BST_CHECKED) {
				g_rigidmarkflag = 1;
			}
			else {
				g_rigidmarkflag = 0;
			}
		}
		break;
		case IDC_CHECK_LOCKTOSEL:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_LOCKTOSEL);
			if (ischecked == BST_CHECKED) {
				s_camtargetflag = 1;
			}
			else {
				s_camtargetflag = 0;
			}
		}
		break;
		case IDC_CHECK_PRECISE:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_PRECISE);
			if (ischecked == BST_CHECKED) {
				g_preciseOnPreviewToo = true;
			}
			else {
				g_preciseOnPreviewToo = false;
			}
		}
		break;
		case IDC_CHECK_X180:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_X180);
			if (ischecked == BST_CHECKED) {
				g_x180flag = true;
			}
			else {
				g_x180flag = false;
			}
		}
		break;
		case IDC_CHECK_TROT:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_TROT);
			if (ischecked == BST_CHECKED) {
				g_rotatetanim = true;
			}
			else {
				g_rotatetanim = false;
			}
		}
		break;
		case IDC_ZPREPASS:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_ZPREPASS);
			if (ischecked == BST_CHECKED) {
				g_zpreflag = true;
			}
			else {
				g_zpreflag = false;
			}
		}
		break;

	//##########
	//COMBO BOX
	//##########
		case IDC_COMBO_IKLEVELS:
			if (HIWORD(wp) == CBN_SELCHANGE) {
				HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO_IKLEVELS);
				if (combownd != NULL) {
					int combono;
					combono = (int)SendMessage(combownd, CB_GETCURSEL, 0, 0);
					if ((combono >= 0) && (combono < 15)) {
						g_iklevel = combono + 1;
					}
					else {
						_ASSERT(0);
						return false;
					}
				}
				else {
					_ASSERT(0);
					return false;
				}
				//RECT clientrect;
				//GetClientRect(hDlgWnd, &clientrect);
				//InvalidateRect(hDlgWnd, &clientrect, TRUE);
			}
			break;
		case IDC_COMBO_AXISKIND:
			if (HIWORD(wp) == CBN_SELCHANGE) {
				HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO_AXISKIND);
				if (combownd != NULL) {
					int combono;
					combono = (int)SendMessage(combownd, CB_GETCURSEL, 0, 0);
					if ((combono >= 0) && (combono <= 3)) {
						switch (combono) {
						case 0:
							g_boneaxis = BONEAXIS_CURRENT;
							break;
						case 1:
							g_boneaxis = BONEAXIS_PARENT;
							break;
						case 2:
							g_boneaxis = BONEAXIS_GLOBAL;
							break;
						case 3:
							g_boneaxis = BONEAXIS_BINDPOSE;
							break;
						default:
							g_boneaxis = BONEAXIS_CURRENT;
							break;
						}
					}
					else {
						_ASSERT(0);
						return false;
					}
				}
				else {
					_ASSERT(0);
					return false;
				}
				//RECT clientrect;
				//GetClientRect(hDlgWnd, &clientrect);
				//InvalidateRect(hDlgWnd, &clientrect, TRUE);
			}
			break;
		case IDC_COMBO_UVSET:
			if (HIWORD(wp) == CBN_SELCHANGE) {
				HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO_UVSET);
				if (combownd != NULL) {
					int combono;
					combono = (int)SendMessage(combownd, CB_GETCURSEL, 0, 0);
					if ((combono >= 0) && (combono <= 1)) {
						g_uvset = combono;
					}
					else {
						_ASSERT(0);
						return false;
					}
				}
				else {
					_ASSERT(0);
					return false;
				}
				//RECT clientrect;
				//GetClientRect(hDlgWnd, &clientrect);
				//InvalidateRect(hDlgWnd, &clientrect, TRUE);
			}
			break;

		//case IDC_COMBO1:
		//break;
		
		case IDCANCEL:
			//EndDialog(hDlgWnd, IDCANCEL);
			if (s_guidlg[GUIDLG_DISP_AND_LIMITS]) {
				ShowGUIDlgDispParams(false);
			}
			break;
		default:
			return FALSE;
			break;
		}
		break;
	case WM_CLOSE:
		if (s_guidlg[GUIDLG_DISP_AND_LIMITS]) {
			ShowGUIDlgDispParams(false);
		}
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}

LRESULT CALLBACK ShaderTypeParamsDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	
	if (!s_shadertypeparamsdlgwnd) {
		s_shadertypeparamsdlgwnd = hDlgWnd;//条件リターンより前でセット
	}


	if (!s_model) {
		return DefWindowProc(hDlgWnd, msg, wp, lp);
	}
	int materialnum = s_model->GetMQOMaterialSize();
	CMQOMaterial* curmqomat = nullptr;
	if ((s_shadertypeparamsindex < 0) || (s_shadertypeparamsindex >= (materialnum + 1))) {
		if (s_shadertypeparamsindex != -1) {
			int dbgflag1 = 1;
		}
		return DefWindowProc(hDlgWnd, msg, wp, lp);
	}
	int materialindex = s_shadertypeparamsindex - 1;
	int curshadertype;
	float curmetalcoef;
	float cursmoothcoef;
	float curlightscale[LIGHTNUMMAX];
	bool enableEmission = false;
	float emissiveScale = 1.0f;
	WCHAR wmaterialname[256] = { 0L };
	if (materialindex >= 0) {
		curmqomat = s_model->GetMQOMaterialByIndex(materialindex);
		if (curmqomat) {
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
				curmqomat->GetName(), 0, wmaterialname, 256);
			curshadertype = curmqomat->GetShaderType();
			curmetalcoef = curmqomat->GetMetalCoef();
			cursmoothcoef = curmqomat->GetSmoothCoef();
			int litno;
			for (litno = 0; litno < LIGHTNUMMAX; litno++) {
				curlightscale[litno] = curmqomat->GetLightScale(litno);
			}
			enableEmission = curmqomat->GetEnableEmission();
			emissiveScale = curmqomat->GetEmissiveScale();
		}
		else {
			_ASSERT(0);
			abort();
		}
	}
	else {
		curmqomat = 0;//全てのマテリアルに対して設定するボタンを押した場合
		wcscpy_s(wmaterialname, 256, L"(All)");
		curshadertype = -1;
		curmetalcoef = 0.250f;
		cursmoothcoef = 0.250f;
		int litno;
		for (litno = 0; litno < LIGHTNUMMAX; litno++) {
			curlightscale[litno] = 1.0f;
		}
		enableEmission = false;
		emissiveScale = 1.0f;
	}
	
	int lightsliderid[LIGHTNUMMAX] = {
		IDC_SL_LITSCALE1, IDC_SL_LITSCALE2, IDC_SL_LITSCALE3, IDC_SL_LITSCALE4,
		IDC_SL_LITSCALE5, IDC_SL_LITSCALE6, IDC_SL_LITSCALE7, IDC_SL_LITSCALE8
	};
	int lighttextid[LIGHTNUMMAX] = {
		IDC_STATIC_LIGHTSCALE1, IDC_STATIC_LIGHTSCALE2, IDC_STATIC_LIGHTSCALE3, IDC_STATIC_LIGHTSCALE4,
		IDC_STATIC_LIGHTSCALE5, IDC_STATIC_LIGHTSCALE6, IDC_STATIC_LIGHTSCALE7, IDC_STATIC_LIGHTSCALE8
	};

	switch (msg) {
	case WM_INITDIALOG:
	{
		SetMaterial2ShaderTypeParamsDlg(curmqomat);
		return FALSE;
	}
	break;

	case WM_DRAWITEM://オーナードローコントロールの描画 : リソースでカラーバーボタンにオーナードロー属性を設定してある
		//DefWindowProc(hDlgWnd, msg, wp, lp);
		break;

	case WM_HSCROLL:
		if (GetDlgItem(hDlgWnd, IDC_SLIDER_METALCOEF) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_METALCOEF), TBM_GETPOS, 0, 0);
			float newmetalcoef = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"MetalCoef %.2f", newmetalcoef);
			SetDlgItemText(hDlgWnd, IDC_STATIC_METALCOEF, strdlg);

			if (curmqomat) {
				curmqomat->SetMetalCoef(newmetalcoef);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetMetalCoef(newmetalcoef);
					}
				}
			}

			//if ((s_shadertypeparamsindex >= 1) && (s_shadertypeparamsindex < (materialnum + 1))) {
			//	if (s_metalcoeflabel[s_shadertypeparamsindex]) {
			//		WCHAR strdlg2[256] = { 0L };
			//		swprintf_s(strdlg2, 256, L"%.2f", newmetalcoef);
			//		s_metalcoeflabel[s_shadertypeparamsindex]->setName(strdlg2);
			//	}
			//}
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_SMOOTHCOEF) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_SMOOTHCOEF), TBM_GETPOS, 0, 0);
			float newsmoothcoef = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"SmoothCoef %.2f", newsmoothcoef);
			SetDlgItemText(hDlgWnd, IDC_STATIC_SMOOTHCOEF, strdlg);

			if (curmqomat) {
				curmqomat->SetSmoothCoef(newsmoothcoef);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetSmoothCoef(newsmoothcoef);
					}
				}
			}

			//if ((s_shadertypeparamsindex >= 1) && (s_shadertypeparamsindex < (materialnum + 1))) {
			//	if (s_smoothcoeflabel[s_shadertypeparamsindex]) {
			//		WCHAR strdlg2[256] = { 0L };
			//		swprintf_s(strdlg2, 256, L"%.2f", newsmoothcoef);
			//		s_smoothcoeflabel[s_shadertypeparamsindex]->setName(strdlg2);
			//	}
			//}
		}
		else if (GetDlgItem(hDlgWnd, IDC_SL_EMISCALE) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SL_EMISCALE), TBM_GETPOS, 0, 0);
			float newemiscale = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"Emission:%.2f", newemiscale);
			SetDlgItemText(hDlgWnd, IDC_CHECK_EMISSION, strdlg);

			if (curmqomat) {
				curmqomat->SetEmissiveScale(newemiscale);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetEmissiveScale(newemiscale);
					}
				}
			}
		}

		{
			int litno4;
			for (litno4 = 0; litno4 < LIGHTNUMMAX; litno4++) {
				HWND litwnd = GetDlgItem(hDlgWnd, lightsliderid[litno4]);
				if ((litwnd != NULL) && (litwnd == (HWND)lp)) {
					int cursliderpos = (int)SendMessage(litwnd, TBM_GETPOS, 0, 0);
					float newlitscale = (float)((double)cursliderpos / 100.0);

					WCHAR strdlg[256] = { 0L };
					swprintf_s(strdlg, 256, L"LightScale%d %.2f", (litno4 + 1), newlitscale);
					SetDlgItemText(hDlgWnd, lighttextid[litno4], strdlg);

					if (curmqomat) {
						curmqomat->SetLightScale(litno4, newlitscale);
					}
					else {
						int materialindex4;
						for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
							CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex4);
							if (setmqomat) {
								setmqomat->SetLightScale(litno4, newlitscale);
							}
						}
					}

					//if ((s_shadertypeparamsindex >= 1) && (s_shadertypeparamsindex < (materialnum + 1))) {
					//	bool isedited = false;
					//	if (curmqomat) {
					//		int litno5;
					//		for (litno5 = 0; litno5 < LIGHTNUMMAX; litno5++) {
					//			float curscale = curmqomat->GetLightScale(litno5);
					//			if ((curscale >= (1.0f - 0.0001f)) && (curscale <= (1.0f + 0.0001f))) {
					//				//1.0f
					//			}
					//			else {
					//				isedited = true;
					//				break;
					//			}
					//		}
					//	}
					//	else {
					//		if ((newlitscale >= (1.0f - 0.0001f)) && (newlitscale <= (1.0f + 0.0001f))) {
					//			//1.0f
					//		}
					//		else {
					//			isedited = true;
					//			break;
					//		}
					//	}
					//
					//	if (s_lightscalelabel[s_shadertypeparamsindex]) {
					//		WCHAR strdlg2[256] = { 0L };
					//		if (isedited) {
					//			wcscpy_s(strdlg2, 256, L"***");
					//		}
					//		else {
					//			wcscpy_s(strdlg2, 256, L"1.00");
					//		}
					//		s_lightscalelabel[s_shadertypeparamsindex]->setName(strdlg2);
					//
					//	}
					//}

				}
			}
		}
		break;

	case WM_COMMAND:

		switch (LOWORD(wp)) {


		case IDC_SHADER_AUTO2:
		{
			CheckShaderTypeParamsButton(hDlgWnd, -1);
			if (curmqomat) {
				curmqomat->SetShaderType(-1);

				if ((s_shadertypeparamsindex >= 1) && (s_shadertypeparamsindex < (materialnum + 1))) {
					if (s_shadertypelabel[s_shadertypeparamsindex]) {
						WCHAR strdlg2[256] = { 0L };
						wcscpy_s(strdlg2, 256, L"AUTO");
						s_shadertypelabel[s_shadertypeparamsindex]->setName(strdlg2);
					}
				}
			}
			else {
				int materialindex5;
				for (materialindex5 = 0; materialindex5 < materialnum; materialindex5++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex5);
					if (setmqomat) {
						setmqomat->SetShaderType(-1);
					}

					if (s_shadertypelabel[materialindex5]) {
						WCHAR strdlg2[256] = { 0L };
						wcscpy_s(strdlg2, 256, L"AUTO");
						s_shadertypelabel[materialindex5]->setName(strdlg2);
					}
				}
			}
		}
			break;
		case IDC_SHADER_PBR2:
		{
			CheckShaderTypeParamsButton(hDlgWnd, MQOSHADER_PBR);
			if (curmqomat) {
				curmqomat->SetShaderType(MQOSHADER_PBR);

				if ((s_shadertypeparamsindex >= 1) && (s_shadertypeparamsindex < (materialnum + 1))) {
					if (s_shadertypelabel[s_shadertypeparamsindex]) {
						WCHAR strdlg2[256] = { 0L };
						wcscpy_s(strdlg2, 256, L"PBR");
						s_shadertypelabel[s_shadertypeparamsindex]->setName(strdlg2);
					}
				}
			}
			else {
				int materialindex6;
				for (materialindex6 = 0; materialindex6 < materialnum; materialindex6++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex6);
					if (setmqomat) {
						setmqomat->SetShaderType(MQOSHADER_PBR);
					}

					if (s_shadertypelabel[materialindex6]) {
						WCHAR strdlg2[256] = { 0L };
						wcscpy_s(strdlg2, 256, L"PBR");
						s_shadertypelabel[materialindex6]->setName(strdlg2);
					}
				}
			}
		}
			break;
		case IDC_SHADER_STD2:
		{
			CheckShaderTypeParamsButton(hDlgWnd, MQOSHADER_STD);
			if (curmqomat) {
				curmqomat->SetShaderType(MQOSHADER_STD);

				if ((s_shadertypeparamsindex >= 1) && (s_shadertypeparamsindex < (materialnum + 1))) {
					if (s_shadertypelabel[s_shadertypeparamsindex]) {
						WCHAR strdlg2[256] = { 0L };
						wcscpy_s(strdlg2, 256, L"STD");
						s_shadertypelabel[s_shadertypeparamsindex]->setName(strdlg2);
					}
				}
			}
			else {
				int materialindex7;
				for (materialindex7 = 0; materialindex7 < materialnum; materialindex7++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex7);
					if (setmqomat) {
						setmqomat->SetShaderType(MQOSHADER_STD);
					}

					if (s_shadertypelabel[materialindex7]) {
						WCHAR strdlg2[256] = { 0L };
						wcscpy_s(strdlg2, 256, L"STD");
						s_shadertypelabel[materialindex7]->setName(strdlg2);
					}
				}
			}
		}
			break;
		case IDC_SHADER_NOLIGHT2:
		{
			CheckShaderTypeParamsButton(hDlgWnd, MQOSHADER_NOLIGHT);
			if (curmqomat) {
				curmqomat->SetShaderType(MQOSHADER_NOLIGHT);

				if ((s_shadertypeparamsindex >= 1) && (s_shadertypeparamsindex < (materialnum + 1))) {
					if (s_shadertypelabel[s_shadertypeparamsindex]) {
						WCHAR strdlg2[256] = { 0L };
						wcscpy_s(strdlg2, 256, L"NOLIGHT");
						s_shadertypelabel[s_shadertypeparamsindex]->setName(strdlg2);
					}
				}
			}
			else {
				int materialindex8;
				for (materialindex8 = 0; materialindex8 < materialnum; materialindex8++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex8);
					if (setmqomat) {
						setmqomat->SetShaderType(MQOSHADER_NOLIGHT);
					}

					if (s_shadertypelabel[materialindex8]) {
						WCHAR strdlg2[256] = { 0L };
						wcscpy_s(strdlg2, 256, L"NOLIGHT");
						s_shadertypelabel[materialindex8]->setName(strdlg2);
					}
				}
			}
		}
			break;



		case IDC_CHECK_EMISSION:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_EMISSION);
			if (ischecked == BST_CHECKED) {
				enableEmission = true;
			}
			else {
				enableEmission = false;
			}

			if (curmqomat) {
				curmqomat->SetEnableEmission(enableEmission);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetEnableEmission(enableEmission);
					}
				}
			}
		}
		break;




		case IDOK:
		case IDCANCEL:
			//EndDialog(hDlgWnd, IDCANCEL);
			//s_shadertypeparamsFlag = false;
			ShowWindow(hDlgWnd, SW_HIDE);

			//2023/12/30 以下２行　ここで呼び出すと２回目にSW_SHOWしても表示されないことがあるので　コメントアウト
			// WindowProcを回す必要があるため
			//s_shadertypeparamsindex = -1;
			//s_shadertypeparamsFlag = false;
			break;
		default:
			return FALSE;
			break;
		}
		break;
	case WM_CLOSE:
		//s_shadertypeparamsFlag = false;
		ShowWindow(hDlgWnd, SW_HIDE);

		//2023/12/30 以下２行　ここで呼び出すと２回目にSW_SHOWしても表示されないことがあるので　コメントアウト
		// WindowProcを回す必要があるため
		//s_shadertypeparamsindex = -1;
		//s_shadertypeparamsFlag = false;
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}


LRESULT CALLBACK GUIBrushesDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
	{
		//Lights2Dlg(hDlgWnd);
		//EnableWindow(GetDlgItem(hDlgWnd, IDC_RESETLIM_CURRENT), FALSE);

		//##########
		//Combo Box
		//##########
		HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO_BRUSHES);
		if (combownd != NULL) {
			SendMessage(combownd, CB_RESETCONTENT, 0, 0);

			int currentpluginno = 0;
			int pluginno;
			for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
				if ((s_plugin + pluginno)->validflag == 1) {
					//g_motionbrush_method = (s_plugin + pluginno)->menuid;//!!!!!!!!!!
					//break;

					WCHAR strcombo[256];
					swprintf_s(strcombo, 256, (s_plugin + pluginno)->pluginname);
					SendMessage(combownd, CB_ADDSTRING, 0, (LPARAM)strcombo);

					if (g_motionbrush_method == (s_plugin + pluginno)->menuid) {
						currentpluginno = pluginno;
					}
				}
			}
			::SendMessage(combownd, CB_SETCURSEL, (WPARAM)currentpluginno, 0);
		}
		else {
			_ASSERT(0);
			return 1;
		}


		//#######
		//Slider
		//#######
		int sliderpos = g_applyrate;
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_TOPPOS), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_TOPPOS), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_TOPPOS), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		sliderpos = g_brushrepeats;
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BRUSHREPEATS), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)1);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BRUSHREPEATS), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BRUSHREPEATS), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);
		CEditRange::SetApplyRate((double)g_applyrate);
		double applyframe = s_editrange.GetApplyFrame();

		//#####
		//Text
		//#####
		WCHAR strdlg[256] = { 0L };
		swprintf_s(strdlg, 256, L"TopPos %d%% : %d", g_applyrate, IntTime(applyframe));
		SetDlgItemText(hDlgWnd, IDC_STATIC_TOPPOS, strdlg);

		swprintf_s(strdlg, 256, L"Brush Repeats : %d", g_brushrepeats);
		SetDlgItemText(hDlgWnd, IDC_STATIC_DLG_BRUSHREPEATS, strdlg);

		//##########
		//Check Box
		//##########
		if (g_brushmirrorUflag == 1) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_BRUSHU, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_BRUSHU, false);
		}
		if (g_brushmirrorVflag == 1) {
			CheckDlgButton(hDlgWnd, IDC_CHECK_BRUSHV, true);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHECK_BRUSHV, false);
		}


		return FALSE;
	}
	break;

	case WM_DRAWITEM://オーナードローコントロールの描画 : リソースでカラーバーボタンにオーナードロー属性を設定してある
		//DefWindowProc(hDlgWnd, msg, wp, lp);
		break;

	case WM_HSCROLL:
		if (GetDlgItem(hDlgWnd, IDC_SLIDER_TOPPOS) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_TOPPOS), TBM_GETPOS, 0, 0);
			g_applyrate = cursliderpos;


			//2024/01/11 以下５行　内容を修正してUpdateTopPosText()に移動
			//CEditRange::SetApplyRate((double)g_applyrate);
			//double applyframe = s_editrange.GetApplyFrame();
			//WCHAR strdlg[256] = { 0L };
			//swprintf_s(strdlg, 256, L"TopPos %d%% : %d", g_applyrate, IntTime(applyframe));
			//SetDlgItemText(hDlgWnd, IDC_STATIC_TOPPOS, strdlg);


			if (s_editmotionflag < 0) {//IK中でないとき
				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}
				//PrepairUndo();//保存はOnFrameUtCheckBoxにて

				if (LOWORD(wp) == SB_ENDSCROLL) {
					//#################################################
					//ReleasedCaptureのときに　PrepairUndo用のフラグを立てる
					//#################################################
					s_utApplyRateFlag = true;//PrepairUndo();//保存はOnFrameUtCheckBoxにて
				}
			}
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_BRUSHREPEATS) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_BRUSHREPEATS), TBM_GETPOS, 0, 0);
			g_brushrepeats = cursliderpos;

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"Brush Repeats : %d", g_brushrepeats);
			SetDlgItemText(hDlgWnd, IDC_STATIC_DLG_BRUSHREPEATS, strdlg);

			if (s_editmotionflag < 0) {//IK中でないとき
				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}
				//PrepairUndo();//保存はOnFrameUtCheckBoxにて

				if (LOWORD(wp) == SB_ENDSCROLL) {
					//#################################################
					//ReleasedCaptureのときに　PrepairUndo用のフラグを立てる
					//#################################################
					s_utBrushRepeatsFlag = true;//PrepairUndo();//保存はOnFrameUtCheckBoxにて
				}
			}
		}

		break;

	//#########################################################################################
	//子供コントロールのWM_NOTIFYが来ないので　マウスを放したときの処理は　WM_HSCROLLのSB_ENDSCROLLで処理
	//#########################################################################################
	//case WM_NOTIFY:
	//{
	//	LPNMHDR nmhdr = reinterpret_cast<LPNMHDR>(lp);
	//	//if (nmhdr->code == TRBN_THUMBPOSCHANGING) //&& (nmhdr->hwndFrom == hSlider))
	//	//{
	//		NMTRBTHUMBPOSCHANGING* nmtrb = reinterpret_cast<NMTRBTHUMBPOSCHANGING*>(lp);
	//		switch (nmtrb->nReason)
	//		{
	//		case TB_ENDTRACK:
	//break;
	case WM_COMMAND:

		switch (LOWORD(wp)) {

		case IDC_COMBO_BRUSHES:
			if (HIWORD(wp) == CBN_SELCHANGE) {
				HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO_BRUSHES);
				if (combownd != NULL) {
					int combono;
					combono = (int)SendMessage(combownd, CB_GETCURSEL, 0, 0);
					if ((combono != CB_ERR) && (combono >= 0) && (combono < MAXPLUGIN)) {
						if ((s_plugin + combono)->validflag == 1) {
							g_motionbrush_method = (s_plugin + combono)->menuid;

							if (s_editmotionflag < 0) {//IK中でないとき
								int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
								if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
									_ASSERT(0);
									::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
									PostQuitMessage(result);
								}
								//PrepairUndo();//保存はOnFrameUtCheckBoxにて
							}
						}
						else {
							_ASSERT(0);
						}
					}
					else {
						_ASSERT(0);
					}
				}
				else {
					_ASSERT(0);
					return false;
				}
				//RECT clientrect;
				//GetClientRect(hDlgWnd, &clientrect);
				//InvalidateRect(hDlgWnd, &clientrect, TRUE);
			}
			break;

		case IDC_CHECK_BRUSHU:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_BRUSHU);
			if (ischecked == BST_CHECKED) {
				g_brushmirrorUflag = 1;
			}
			else {
				g_brushmirrorUflag = 0;
			}
			if (s_editmotionflag < 0) {//IK中でないとき
				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}
				//PrepairUndo();//保存はOnFrameUtCheckBoxにて
			}

			//##################
			//For PrepairUndo()
			//##################
			s_BrushMirrorUCheckBoxFlag = true;//UTDialogの
		}
		break;
		case IDC_CHECK_BRUSHV:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_BRUSHV);
			if (ischecked == BST_CHECKED) {
				g_brushmirrorVflag = 1;
			}
			else {
				g_brushmirrorVflag = 0;
			}
			if (s_editmotionflag < 0) {//IK中でないとき
				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}
				//PrepairUndo();//保存はOnFrameUtCheckBoxにて
			}

			//##################
			//For PrepairUndo()
			//##################
			s_BrushMirrorVCheckBoxFlag = true;//UTDialogの
		}
		break;




		case IDCANCEL:
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
			break;
		}
		break;
	case WM_CLOSE:
		if (s_guidlg[GUIDLG_BRUSHPARAMS]) {
			ShowGUIDlgBrushes(false);
		}
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;
}
LRESULT CALLBACK GUIBulletDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
	{
		//Lights2Dlg(hDlgWnd);
		//EnableWindow(GetDlgItem(hDlgWnd, IDC_RESETLIM_CURRENT), FALSE);

		//#######
		//Slider
		//#######
		int sliderpos = (int)g_btcalccnt;
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_CALCCNT), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)1);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_CALCCNT), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)10);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_CALCCNT), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		sliderpos = (int)(g_erp * 5000.0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_DLG_ERP), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_DLG_ERP), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)5000);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_DLG_ERP), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		//#####
		//Text 
		//#####
		WCHAR strdlg[256] = { 0L };
		swprintf_s(strdlg, 256, L"Bullet Calc Count : %d", (int)g_btcalccnt);
		SetDlgItemText(hDlgWnd, IDC_STATIC_CALCCNT, strdlg);

		swprintf_s(strdlg, 256, L"Position Correcting Rate : %.3f", g_erp);
		SetDlgItemText(hDlgWnd, IDC_STATIC_DLG_ERP, strdlg);

		return FALSE;
	}
	break;

	case WM_DRAWITEM://オーナードローコントロールの描画 : リソースでカラーバーボタンにオーナードロー属性を設定してある
		//DefWindowProc(hDlgWnd, msg, wp, lp);
		break;

	case WM_HSCROLL:
		if (GetDlgItem(hDlgWnd, IDC_SLIDER_CALCCNT) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_CALCCNT), TBM_GETPOS, 0, 0);
			g_btcalccnt = (double)cursliderpos;

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"Bullet Calc Count : %d", (int)g_btcalccnt);
			SetDlgItemText(hDlgWnd, IDC_STATIC_CALCCNT, strdlg);
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_DLG_ERP) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_DLG_ERP), TBM_GETPOS, 0, 0);
			g_erp = (double)cursliderpos / 5000.0;

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"Position Correcting Rate : %.3f", g_erp);
			SetDlgItemText(hDlgWnd, IDC_STATIC_DLG_ERP, strdlg);
		}
		break;
	//case WM_NOTIFY:
	//{
	//	LPNMHDR nmhdr = reinterpret_cast<LPNMHDR>(lp);
	//	if (nmhdr->code == TRBN_THUMBPOSCHANGING) //&& (nmhdr->hwndFrom == hSlider))
	//	{
	//		NMTRBTHUMBPOSCHANGING* nmtrb = reinterpret_cast<NMTRBTHUMBPOSCHANGING*>(lp);
	//		switch (nmtrb->nReason)
	//		{
	//		case TB_ENDTRACK:
	//			//if (GetDlgItem(hDlgWnd, IDC_SLIDER1) == nmhdr->hwndFrom)
	//			break;
	//		default:
	//			break;
	//		}
	//	}
	//}
	//break;
	case WM_COMMAND:

		switch (LOWORD(wp)) {

			//case IDC_COMBO1:
			//break;

		case IDCANCEL:
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
			break;
		}
		break;
	case WM_CLOSE:
		if (s_guidlg[GUIDLG_BULLETPHYSICS]) {
			ShowGUIDlgBullet(false);
		}
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;
}
LRESULT CALLBACK GUILODDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR streditbox[256] = { 0 };
	float tempeditvalue = 0.0f;


	switch (msg) {
	case WM_INITDIALOG:
	{
		LODParams2Dlg(hDlgWnd);
		return FALSE;
	}
	break;

	case WM_COMMAND:

		switch (LOWORD(wp)) {

		case IDC_APPLYEDITBOX:
			GetDlgItemText(hDlgWnd, IDC_EDIT_PROJNEAR, streditbox, 256);
			tempeditvalue = (float)_wtof(streditbox);
			if ((tempeditvalue >= 0.000010f) && (tempeditvalue <= 500000.0f)) {
				g_projnear = tempeditvalue;
			}
			else {
				::MessageBox(hDlgWnd, L"invalid editbox value : near", L"Invalid Value", MB_OK);
			}

			GetDlgItemText(hDlgWnd, IDC_EDIT_PROJFAR, streditbox, 256);
			tempeditvalue = (float)_wtof(streditbox);
			if ((tempeditvalue >= 0.000010f) && (tempeditvalue <= 500000.0f)) {
				g_projfar = tempeditvalue;
			}
			else {
				::MessageBox(hDlgWnd, L"invalid editbox value : far", L"Invalid Value", MB_OK);
			}

			SetCamera3DFromEyePos();//2023/12/30

			break;

		//case IDC_INITSHADOW:
		//	break;

		case IDCANCEL:
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
			break;
		}
		break;

	case WM_HSCROLL:
		if (GetDlgItem(hDlgWnd, IDC_SLIDER_FOV2) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_FOV2), TBM_GETPOS, 0, 0);
			g_fovy = (float)cursliderpos * (float)PI / 180.0f;

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"FOV:%.1fdeg", g_fovy * 180.0f / (float)PI);
			SetDlgItemText(hDlgWnd, IDC_STATIC_FOV2, strdlg);

			SetCamera3DFromEyePos();//2023/12/30
		}

		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD0) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD0), TBM_GETPOS, 0, 0);
			g_lodrate2L[CHKINVIEW_LOD0] = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"LOD0:%.2f", g_lodrate2L[CHKINVIEW_LOD0]);
			SetDlgItemText(hDlgWnd, IDC_STATIC_2L_LOD0, strdlg);
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD1) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_2L_LOD1), TBM_GETPOS, 0, 0);
			g_lodrate2L[CHKINVIEW_LOD1] = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"LOD1:%.2f", g_lodrate2L[CHKINVIEW_LOD1]);
			SetDlgItemText(hDlgWnd, IDC_STATIC_2L_LOD1, strdlg);
		}

		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD0) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD0), TBM_GETPOS, 0, 0);
			g_lodrate3L[CHKINVIEW_LOD0] = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"LOD0:%.2f", g_lodrate3L[CHKINVIEW_LOD0]);
			SetDlgItemText(hDlgWnd, IDC_STATIC_3L_LOD0, strdlg);
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD1) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD1), TBM_GETPOS, 0, 0);
			g_lodrate3L[CHKINVIEW_LOD1] = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"LOD1:%.2f", g_lodrate3L[CHKINVIEW_LOD1]);
			SetDlgItemText(hDlgWnd, IDC_STATIC_3L_LOD1, strdlg);
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD2) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_3L_LOD2), TBM_GETPOS, 0, 0);
			g_lodrate3L[CHKINVIEW_LOD2] = (float)((double)cursliderpos / 100.0);

			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"LOD2:%.2f", g_lodrate3L[CHKINVIEW_LOD2]);
			SetDlgItemText(hDlgWnd, IDC_STATIC_3L_LOD2, strdlg);
		}



		break;


	case WM_CLOSE:
		if (s_guidlg[GUIDLG_PROJ_AND_LOD]) {
			ShowGUIDlgLOD(false);
		}
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}



LRESULT CALLBACK LightsForEditDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	//static int s_lightstimerid = 2121;

	if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
		_ASSERT(0);
		return FALSE;
	}


	switch (msg) {
	case WM_INITDIALOG:
	{
		Lights2Dlg(hDlgWnd);

		//EnableWindow(GetDlgItem(hDlgWnd, IDC_RESETLIM_CURRENT), FALSE);
		//EnableWindow(GetDlgItem(hDlgWnd, IDC_RESET0_CURRENT), FALSE);
		//EnableWindow(GetDlgItem(hDlgWnd, IDC_REPLACE180TO170_CURRENT), FALSE);
		//EnableWindow(GetDlgItem(hDlgWnd, IDC_LIMITFROMMOTION_CURRENT), FALSE);

		//SetTimer(hDlgWnd, s_lightstimerid, 20, NULL);

		return FALSE;
	}
	break;



	case WM_DRAWITEM://オーナードローコントロールの描画 : リソースでカラーバーボタンにオーナードロー属性を設定してある
		{
			int result1 = OwnerDrawLightColorBar(hDlgWnd, 0, IDC_COLORBAR11);
			if (result1 != 0) {
				_ASSERT(0);
			}
			int result2 = OwnerDrawLightColorBar(hDlgWnd, 1, IDC_COLORBAR12);
			if (result2 != 0) {
				_ASSERT(0);
			}
			int result3 = OwnerDrawLightColorBar(hDlgWnd, 2, IDC_COLORBAR13);
			if (result3 != 0) {
				_ASSERT(0);
			}
			int result4 = OwnerDrawLightColorBar(hDlgWnd, 3, IDC_COLORBAR14);
			if (result4 != 0) {
				_ASSERT(0);
			}
			int result5 = OwnerDrawLightColorBar(hDlgWnd, 4, IDC_COLORBAR15);
			if (result5 != 0) {
				_ASSERT(0);
			}
			int result6 = OwnerDrawLightColorBar(hDlgWnd, 5, IDC_COLORBAR16);
			if (result6 != 0) {
				_ASSERT(0);
			}
			int result7 = OwnerDrawLightColorBar(hDlgWnd, 6, IDC_COLORBAR17);
			if (result7 != 0) {
				_ASSERT(0);
			}
			int result8 = OwnerDrawLightColorBar(hDlgWnd, 7, IDC_COLORBAR18);
			if (result8 != 0) {
				_ASSERT(0);
			}
	}
		//DefWindowProc(hDlgWnd, msg, wp, lp);
		break;

	case WM_HSCROLL:
		if (GetDlgItem(hDlgWnd, IDC_SLIDER1) == (HWND)lp)
		{
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER1), TBM_GETPOS, 0, 0);
			g_lightScale[g_lightSlot][0] = (float)((double)cursliderpos / 100.0);
			WCHAR strlight[256] = { 0L };
			swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][0]);
			SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT1, strlight);
			SetLightDirection();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER2) == (HWND)lp)
		{
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER2), TBM_GETPOS, 0, 0);
			g_lightScale[g_lightSlot][1] = (float)((double)cursliderpos / 100.0);
			WCHAR strlight[256] = { 0L };
			swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][1]);
			SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT2, strlight);
			SetLightDirection();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER3) == (HWND)lp)
		{
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER3), TBM_GETPOS, 0, 0);
			g_lightScale[g_lightSlot][2] = (float)((double)cursliderpos / 100.0);
			WCHAR strlight[256] = { 0L };
			swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][2]);
			SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT3, strlight);
			SetLightDirection();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER4) == (HWND)lp)
		{
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER4), TBM_GETPOS, 0, 0);
			g_lightScale[g_lightSlot][3] = (float)((double)cursliderpos / 100.0);
			WCHAR strlight[256] = { 0L };
			swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][3]);
			SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT4, strlight);
			SetLightDirection();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER5) == (HWND)lp)
		{
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER5), TBM_GETPOS, 0, 0);
			g_lightScale[g_lightSlot][4] = (float)((double)cursliderpos / 100.0);
			WCHAR strlight[256] = { 0L };
			swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][4]);
			SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT5, strlight);
			SetLightDirection();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER6) == (HWND)lp)
		{
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER6), TBM_GETPOS, 0, 0);
			g_lightScale[g_lightSlot][5] = (float)((double)cursliderpos / 100.0);
			WCHAR strlight[256] = { 0L };
			swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][5]);
			SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT6, strlight);
			SetLightDirection();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER7) == (HWND)lp)
		{
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER7), TBM_GETPOS, 0, 0);
			g_lightScale[g_lightSlot][6] = (float)((double)cursliderpos / 100.0);
			WCHAR strlight[256] = { 0L };
			swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][6]);
			SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT7, strlight);
			SetLightDirection();
		}
		else if (GetDlgItem(hDlgWnd, IDC_SLIDER8) == (HWND)lp)
		{
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER8), TBM_GETPOS, 0, 0);
			g_lightScale[g_lightSlot][7] = (float)((double)cursliderpos / 100.0);
			WCHAR strlight[256] = { 0L };
			swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][7]);
			SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT8, strlight);
			SetLightDirection();
		}
		break;

	case WM_NOTIFY:
		{
			LPNMHDR nmhdr = reinterpret_cast<LPNMHDR>(lp);
			if (nmhdr->code == TRBN_THUMBPOSCHANGING) //&& (nmhdr->hwndFrom == hSlider))
			{
				NMTRBTHUMBPOSCHANGING* nmtrb = reinterpret_cast<NMTRBTHUMBPOSCHANGING*>(lp);
				switch (nmtrb->nReason)
				{
				case TB_ENDTRACK:
					if (GetDlgItem(hDlgWnd, IDC_SLIDER1) == nmhdr->hwndFrom)
					{
						int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER1), TBM_GETPOS, 0, 0);
						g_lightScale[g_lightSlot][0] = (float)((double)cursliderpos / 100.0);
						WCHAR strlight[256] = { 0L };
						swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][0]);
						SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT1, strlight);
						SetLightDirection();
					}
					else if (GetDlgItem(hDlgWnd, IDC_SLIDER2) == nmhdr->hwndFrom)
					{
						int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER2), TBM_GETPOS, 0, 0);
						g_lightScale[g_lightSlot][1] = (float)((double)cursliderpos / 100.0);
						WCHAR strlight[256] = { 0L };
						swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][1]);
						SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT2, strlight);
						SetLightDirection();
					}
					else if (GetDlgItem(hDlgWnd, IDC_SLIDER3) == nmhdr->hwndFrom)
					{
						int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER3), TBM_GETPOS, 0, 0);
						g_lightScale[g_lightSlot][2] = (float)((double)cursliderpos / 100.0);
						WCHAR strlight[256] = { 0L };
						swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][2]);
						SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT3, strlight);
						SetLightDirection();
					}
					else if (GetDlgItem(hDlgWnd, IDC_SLIDER4) == nmhdr->hwndFrom)
					{
						int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER4), TBM_GETPOS, 0, 0);
						g_lightScale[g_lightSlot][3] = (float)((double)cursliderpos / 100.0);
						WCHAR strlight[256] = { 0L };
						swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][3]);
						SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT4, strlight);
						SetLightDirection();
					}
					else if (GetDlgItem(hDlgWnd, IDC_SLIDER5) == nmhdr->hwndFrom)
					{
						int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER5), TBM_GETPOS, 0, 0);
						g_lightScale[g_lightSlot][4] = (float)((double)cursliderpos / 100.0);
						WCHAR strlight[256] = { 0L };
						swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][4]);
						SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT5, strlight);
						SetLightDirection();
					}
					else if (GetDlgItem(hDlgWnd, IDC_SLIDER6) == nmhdr->hwndFrom)
					{
						int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER6), TBM_GETPOS, 0, 0);
						g_lightScale[g_lightSlot][5] = (float)((double)cursliderpos / 100.0);
						WCHAR strlight[256] = { 0L };
						swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][5]);
						SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT6, strlight);
						SetLightDirection();
					}
					else if (GetDlgItem(hDlgWnd, IDC_SLIDER7) == nmhdr->hwndFrom)
					{
						int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER7), TBM_GETPOS, 0, 0);
						g_lightScale[g_lightSlot][6] = (float)((double)cursliderpos / 100.0);
						WCHAR strlight[256] = { 0L };
						swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][6]);
						SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT7, strlight);
						SetLightDirection();
					}
					else if (GetDlgItem(hDlgWnd, IDC_SLIDER8) == nmhdr->hwndFrom)
					{
						int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER8), TBM_GETPOS, 0, 0);
						g_lightScale[g_lightSlot][7] = (float)((double)cursliderpos / 100.0);
						WCHAR strlight[256] = { 0L };
						swprintf_s(strlight, 256, L"%.2f", g_lightScale[g_lightSlot][7]);
						SetDlgItemText(hDlgWnd, IDC_TEXT_LIGHT8, strlight);
						SetLightDirection();
					}
					break;
				default:
					break;
				}
			}
		}
		break;
	case WM_COMMAND:

		switch (LOWORD(wp)) {

		case IDC_COMBO1:
			if (HIWORD(wp) == CBN_SELCHANGE) {
				HWND combownd = GetDlgItem(hDlgWnd, IDC_COMBO1);
				if (combownd != NULL) {
					int combono;
					combono = (int)SendMessage(combownd, CB_GETCURSEL, 0, 0);
					if ((combono >= 0) && (combono < LIGHTSLOTNUM)) {
						g_lightSlot = combono;
					}
					else {
						_ASSERT(0);
						return false;
					}
				}
				else {
					_ASSERT(0);
					return false;
				}
				if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
					_ASSERT(0);
					return false;
				}

				Lights2Dlg(hDlgWnd);

				RECT clientrect;
				GetClientRect(hDlgWnd, &clientrect);
				InvalidateRect(hDlgWnd, &clientrect, TRUE);

				SetLightDirection();
			}
			break;
		case IDC_SETLIGHT1:
		{
			int result1 = Dlg2Lights(hDlgWnd, 0);
			int result2 = Dlg2Lights(hDlgWnd, 1);
			int result3 = Dlg2Lights(hDlgWnd, 2);
			int result4 = Dlg2Lights(hDlgWnd, 3);
			int result5 = Dlg2Lights(hDlgWnd, 4);
			int result6 = Dlg2Lights(hDlgWnd, 5);
			int result7 = Dlg2Lights(hDlgWnd, 6);
			int result8 = Dlg2Lights(hDlgWnd, 7);
			//if ((result1 == 0) && (result2 == 0) && (result3 == 0) && (result4 == 0) &&
			//	(result5 == 0) && (result6 == 0) && (result7 == 0) && (result8 == 0)) {
				SetLightDirection();
			//}
		}
			break;

		case IDC_ENABLE1:
		case IDC_WITHVIEWROT1:
		{
			int result = Dlg2Lights(hDlgWnd, 0);
			SetLightDirection();
		}
		break;
		case IDC_ENABLE2:
		case IDC_WITHVIEWROT2:
		{
			int result = Dlg2Lights(hDlgWnd, 1);
			SetLightDirection();
		}
		break;
		case IDC_ENABLE3:
		case IDC_WITHVIEWROT3:
		{
			int result = Dlg2Lights(hDlgWnd, 2);
			SetLightDirection();
		}
		break;
		case IDC_ENABLE4:
		case IDC_WITHVIEWROT4:
		{
			int result = Dlg2Lights(hDlgWnd, 3);
			SetLightDirection();
		}
		break;
		case IDC_ENABLE5:
		case IDC_WITHVIEWROT5:
		{
			int result = Dlg2Lights(hDlgWnd, 4);
			SetLightDirection();
		}
		break;
		case IDC_ENABLE6:
		case IDC_WITHVIEWROT6:
		{
			int result = Dlg2Lights(hDlgWnd, 5);
			SetLightDirection();
		}
		break;
		case IDC_ENABLE7:
		case IDC_WITHVIEWROT7:
		{
			int result = Dlg2Lights(hDlgWnd, 6);
			SetLightDirection();
		}
		break;
		case IDC_ENABLE8:
		case IDC_WITHVIEWROT8:
		{
			int result = Dlg2Lights(hDlgWnd, 7);
			SetLightDirection();
		}
		break;


		case IDC_COLORBAR11:
		{
			int result = ChooseLightColorBar(hDlgWnd, 0, IDC_COLORBAR11);
			if (result != 0) {
				_ASSERT(0);
			}
		}
			break;
		case IDC_COLORBAR12:
		{
			int result = ChooseLightColorBar(hDlgWnd, 1, IDC_COLORBAR12);
			if (result != 0) {
				_ASSERT(0);
			}
		}
			break;
		case IDC_COLORBAR13:
		{
			int result = ChooseLightColorBar(hDlgWnd, 2, IDC_COLORBAR13);
			if (result != 0) {
				_ASSERT(0);
			}
		}
			break;
		case IDC_COLORBAR14:
		{
			int result = ChooseLightColorBar(hDlgWnd, 3, IDC_COLORBAR14);
			if (result != 0) {
				_ASSERT(0);
			}
		}
			break;
		case IDC_COLORBAR15:
		{
			int result = ChooseLightColorBar(hDlgWnd, 4, IDC_COLORBAR15);
			if (result != 0) {
				_ASSERT(0);
			}
		}
			break;
		case IDC_COLORBAR16:
		{
			int result = ChooseLightColorBar(hDlgWnd, 5, IDC_COLORBAR16);
			if (result != 0) {
				_ASSERT(0);
			}
		}
			break;
		case IDC_COLORBAR17:
		{
			int result = ChooseLightColorBar(hDlgWnd, 6, IDC_COLORBAR17);
			if (result != 0) {
				_ASSERT(0);
			}
		}
			break;
		case IDC_COLORBAR18:
		{
			int result = ChooseLightColorBar(hDlgWnd, 7, IDC_COLORBAR18);
			if (result != 0) {
				_ASSERT(0);
			}
		}
			break;


		case IDCANCEL:
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
			break;
		}
		break;
	case WM_CLOSE:
		if (s_lightsforeditdlg) {

			//if (s_lightstimerid > 0) {
			//	KillTimer(hDlgWnd, s_lightstimerid);
			//	s_lightstimerid = 0;
			//}
			
			//DestroyWindow(s_lightsforeditdlg);
			//s_lightsforeditdlg = 0;

			ShowLightsWnd(false);
		}
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}


LRESULT CALLBACK AngleLimitDlgProc2(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
	{
		Bone2AngleLimit();
		bool updateonlycheckeul = false;
		AngleLimit2Dlg(hDlgWnd, updateonlycheckeul);
		ClearLimitedWM(s_model);//2022/12/06

		//EnableWindow(GetDlgItem(hDlgWnd, IDC_RESETLIM_CURRENT), FALSE);
		//EnableWindow(GetDlgItem(hDlgWnd, IDC_RESET0_CURRENT), FALSE);
		//EnableWindow(GetDlgItem(hDlgWnd, IDC_REPLACE180TO170_CURRENT), FALSE);
		//EnableWindow(GetDlgItem(hDlgWnd, IDC_LIMITFROMMOTION_CURRENT), FALSE);

		return FALSE;
	}
	break;

	////for slider
	//case WM_LBUTTONDOWN:
	//	s_underanglelimithscroll = 1;
	//	break;
	//case WM_LBUTTONUP:
	//	s_underanglelimithscroll = 0;
	//	break;


	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDC_BONEAXIS:

			//lmtファイルによる固定値

			//{
			//	int combono = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_BONEAXIS), CB_GETCURSEL, 0, 0);
			//	if ((combono >= BONEAXIS_CURRENT) && (combono <= BONEAXIS_GLOBAL)){
			//		s_anglelimit.boneaxiskind = combono;
			//	}
			//}
			break;

		case IDC_APPLYONE:
		{
			s_changelimitangleFlag = true;
			PrepairUndo();//全フレーム変更の前に全フレーム保存

			int result1 = 0;
			result1 = AngleDlg2AngleLimit(hDlgWnd);//エラー入力通知ダイアログも出す
			if (result1 == 0) {
				UpdateAfterEditAngleLimit(eLIM2BONE_LIM2BONE_ONE);
			}

			PrepairUndo();//全フレーム変更後に全フレーム保存
			s_changelimitangleFlag = false;
		}
		break;
		case IDC_APPLYDEEPER:
		{
			s_changelimitangleFlag = true;
			PrepairUndo();//全フレーム変更の前に全フレーム保存

			int result1 = 0;
			result1 = AngleDlg2AngleLimit(hDlgWnd);//エラー入力通知ダイアログも出す
			if (result1 == 0) {
				UpdateAfterEditAngleLimit(eLIM2BONE_LIM2BONE_DEEPER);
			}

			PrepairUndo();//全フレーム変更後に全フレーム保存
			s_changelimitangleFlag = false;
		}
		break;
		case IDC_APPLYALL:
		{
			s_changelimitangleFlag = true;
			PrepairUndo();//全フレーム変更の前に全フレーム保存

			int result1 = 0;
			result1 = AngleDlg2AngleLimit(hDlgWnd);//エラー入力通知ダイアログも出す
			if (result1 == 0) {
				UpdateAfterEditAngleLimit(eLIM2BONE_LIM2BONE_ALL);
			}

			PrepairUndo();//全フレーム変更後に全フレーム保存
			s_changelimitangleFlag = false;
		}
		break;

		case IDC_BUTTON1:
		{
			//CopyToSymBone
			if (s_anglelimitbone && s_anglelimitdlg) {
				int symboneno = 0;
				int existflag = 0;
				s_model->GetSymBoneNo(s_anglelimitbone->GetBoneNo(), &symboneno, &existflag);
				if (symboneno >= 0) {
					CBone* symbone = s_model->GetBoneByID(symboneno);
					if (symbone) {
						ANGLELIMIT symanglelimit = s_anglelimit;
						//symanglelimit.lower[1] *= -1;
						symanglelimit.lower[2] *= -1;
						//symanglelimit.upper[1] *= -1;
						symanglelimit.upper[2] *= -1;

						MOTINFO* curmi;
						curmi = s_model->GetCurMotInfo();
						if (curmi) {
							s_changelimitangleFlag = true;
							PrepairUndo();//全フレーム変更の前に全フレーム保存

							symbone->SetAngleLimit(g_limitdegflag, symanglelimit);

							UpdateAfterEditAngleLimit(eLIM2BONE_NONE);

							PrepairUndo();//全フレーム変更後に全フレーム保存
							s_changelimitangleFlag = false;
						}
					}
				}
			}
		}
		break;
		case IDC_BUTTON2:
		{
			//CopyFromSymBone
			if (s_anglelimitbone && s_anglelimitdlg) {
				int symboneno = 0;
				int existflag = 0;
				s_model->GetSymBoneNo(s_anglelimitbone->GetBoneNo(), &symboneno, &existflag);
				if (symboneno >= 0) {
					CBone* symbone = s_model->GetBoneByID(symboneno);
					if (symbone) {
						MOTINFO* curmi;
						curmi = s_model->GetCurMotInfo();
						if (curmi) {

							s_changelimitangleFlag = true;
							PrepairUndo();//全フレーム変更の前に全フレーム保存

							ANGLELIMIT anglelimit = symbone->GetAngleLimit(g_limitdegflag, 0);
							ANGLELIMIT symanglelimit = anglelimit;
							//symanglelimit.lower[1] *= -1;
							symanglelimit.lower[2] *= -1;
							//symanglelimit.upper[1] *= -1;
							symanglelimit.upper[2] *= -1;

							//s_anglelimitbone->SetAngleLimit(symanglelimit, curmi->motid, curmi->curframe);
							s_anglelimit = symanglelimit;
							UpdateAfterEditAngleLimit(eLIM2BONE_LIM2BONE_ONE);

							bool updateonlycheckeul = false;
							AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
							UpdateWindow(s_anglelimitdlg);

							PrepairUndo();//全フレーム変更後に全フレーム保存
							s_changelimitangleFlag = false;

						}

					}
				}
			}
		}
		break;
		case IDC_BUTTON3:
		{
			//copy button
			if (s_anglelimitbone && s_anglelimitdlg) {
				s_anglelimitcopy = s_anglelimit;
			}
		}
		break;
		case IDC_BUTTON4:
		{
			//paste button
			if (s_anglelimitbone && s_anglelimitdlg) {
				s_changelimitangleFlag = true;
				PrepairUndo();//全フレーム変更の前に全フレーム保存

				s_anglelimit = s_anglelimitcopy;
				UpdateAfterEditAngleLimit(eLIM2BONE_LIM2BONE_ONE);
				bool updateonlycheckeul = false;
				AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
				UpdateWindow(s_anglelimitdlg);

				PrepairUndo();//全フレーム変更後に全フレーム保存
				s_changelimitangleFlag = false;

			}
		}
		break;


		//To All Bone
		case IDC_RESETLIM:
		{
			if (s_model && s_anglelimitdlg) {
				s_changelimitangleFlag = true;
				PrepairUndo();//全フレーム変更の前に全フレーム保存

				bool excludebt = false;
				s_model->ResetAngleLimit(excludebt, 180);

				UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM);

				bool updateonlycheckeul = false;
				AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
				UpdateWindow(s_anglelimitdlg);

				PrepairUndo();//全フレーム変更後に全フレーム保存
				s_changelimitangleFlag = false;

			}
		}
		break;
		case IDC_RESET0:
		{
			if (s_model && s_anglelimitdlg) {
				s_changelimitangleFlag = true;
				PrepairUndo();//全フレーム変更の前に全フレーム保存

				bool excludebt = false;
				s_model->ResetAngleLimit(excludebt, 0);

				UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM);

				bool updateonlycheckeul = false;
				AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
				UpdateWindow(s_anglelimitdlg);

				PrepairUndo();//全フレーム変更後に全フレーム保存
				s_changelimitangleFlag = false;

			}
		}
		break;
		case IDC_REPLACE180TO170:
		{
			if (s_model && s_anglelimitdlg) {
				s_changelimitangleFlag = true;
				PrepairUndo();//全フレーム変更の前に全フレーム保存

				s_model->AngleLimitReplace180to170();

				UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM);

				bool updateonlycheckeul = false;
				AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
				UpdateWindow(s_anglelimitdlg);

				PrepairUndo();//全フレーム変更後に全フレーム保存
				s_changelimitangleFlag = false;

			}

		}
		break;
		case IDC_LIMITFROMMOTION:
		{
			if (s_model && s_anglelimitdlg) {
				MOTINFO* curmi;
				curmi = s_model->GetCurMotInfo();
				if (curmi) {

					s_changelimitangleFlag = true;
					PrepairUndo();//全フレーム変更の前に全フレーム保存

					//長いフレームの処理は数秒時間がかかることがあるので砂時計カーソルにする
					HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

					//s_savelimitdegflag = g_limitdegflag;
					//ChangeLimitDegFlag(false, true, true);
					//g_limitdegflag = false;
					//if (s_LimitDegCheckBox) {
					//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
					//}


					//モーションからの設定の前に　まずはゼロ初期化する
					bool excludebt = true;
					s_model->ResetAngleLimit(excludebt, 0);
					UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM, false);


					//g_limitdegflagに関わらず　既存モーションの制限無しの姿勢を元に設定
					s_model->AdditiveCurrentToAngleLimit(0);//内部で全フレーム分処理

					//ChangeLimitDegFlag(s_savelimitdegflag, true, false);//updateeulはこれより後で呼ばれるUpdateAfterEditAngleLimitで
					//g_limitdegflag = s_savelimitdegflag;
					//if (s_LimitDegCheckBox) {
					//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
					//}

					UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM, false);

					bool updateonlycheckeul = false;
					AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
					UpdateWindow(s_anglelimitdlg);

					//カーソルを元に戻す
					SetCursor(oldcursor);

					PrepairUndo();//全フレーム変更後に全フレーム保存
					s_changelimitangleFlag = false;

				}
			}
		}
		break;

		//To AllBones From AllMotions
		case IDC_LIMITFROMALLMOTIONS:
		{
			if (s_model && s_anglelimitdlg) {
				MOTINFO* curmi;
				curmi = s_model->GetCurMotInfo();
				if (curmi) {
					bool savelimitflag = g_limitdegflag;

					s_changelimitangleFlag = true;
					PrepairUndo();//全フレーム変更の前に全フレーム保存

					//長いフレームの処理は数秒時間がかかることがあるので砂時計カーソルにする
					HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

					//if (savelimitflag == true) {
					//	//2023/10/18 制限角度キャプチャは　limitdegflag = falseにした状態で働く
					//	s_savelimitdegflag = true;
					//	ChangeLimitDegFlag(false, true, true);
					//}

					//モーションからの設定の前に　まずはゼロ初期化する
					bool excludebt = true;
					s_model->ResetAngleLimit(excludebt, 0);
					UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM, false);

					//g_limitdegflagに関わらず　既存モーションの制限無しの姿勢を元に設定
					s_model->AdditiveAllMotionsToAngleLimit();//内部で全モーション全フレーム分処理

					//ChangeLimitDegFlag(s_savelimitdegflag, true, false);//updateeulはこれより後で呼ばれるUpdateAfterEditAngleLimitで
					//if (savelimitflag == true) {
					//	//処理後に元に戻す
					//	s_savelimitdegflag = false;
					//	ChangeLimitDegFlag(true, true, true);
					//}

					UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM, false);

					//s_model->SetMotionFrame(1.0);
					//ChaMatrix tmpwm = s_model->GetWorldMat();
					//s_model->UpdateMatrix(&tmpwm, &s_matVP);

					bool updateonlycheckeul = false;
					AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
					UpdateWindow(s_anglelimitdlg);

					//カーソルを元に戻す
					SetCursor(oldcursor);

					PrepairUndo();//全フレーム変更後に全フレーム保存
					s_changelimitangleFlag = false;

				}
			}
		}
		break;


		case IDC_RESETLIM_CURRENT:
		{
			if (s_model && s_anglelimitdlg && s_anglelimitbone) {
				s_changelimitangleFlag = true;
				PrepairUndo();//全フレーム変更の前に全フレーム保存

				bool excludebt = false;
				s_model->ResetAngleLimit(excludebt, 180, s_anglelimitbone);//2022/12/05 curbone引数追加

				UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM);

				bool updateonlycheckeul = false;
				AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
				UpdateWindow(s_anglelimitdlg);

				PrepairUndo();//全フレーム変更後に全フレーム保存
				s_changelimitangleFlag = false;

			}
		}
		break;
		case IDC_RESET0_CURRENT:
		{
			if (s_model && s_anglelimitdlg && s_anglelimitbone) {
				s_changelimitangleFlag = true;
				PrepairUndo();//全フレーム変更の前に全フレーム保存

				bool excludebt = false;
				s_model->ResetAngleLimit(excludebt, 0, s_anglelimitbone);//2022/12/05 curbone引数追加

				UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM);

				bool updateonlycheckeul = false;
				AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
				UpdateWindow(s_anglelimitdlg);

				PrepairUndo();//全フレーム変更後に全フレーム保存
				s_changelimitangleFlag = false;

			}
		}
		break;
		case IDC_REPLACE180TO170_CURRENT:
		{
			if (s_model && s_anglelimitdlg && s_anglelimitbone) {
				s_changelimitangleFlag = true;
				PrepairUndo();//全フレーム変更の前に全フレーム保存

				s_model->AngleLimitReplace180to170(s_anglelimitbone);//2022/12/05 curbone引数追加

				UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM);

				bool updateonlycheckeul = false;
				AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
				UpdateWindow(s_anglelimitdlg);

				PrepairUndo();//全フレーム変更後に全フレーム保存
				s_changelimitangleFlag = false;

			}

		}
		break;
		case IDC_LIMITFROMMOTION_CURRENT:
		{
			if (s_model && s_anglelimitdlg && s_anglelimitbone) {
				MOTINFO* curmi;
				curmi = s_model->GetCurMotInfo();
				if (curmi) {
					bool savelimitflag = g_limitdegflag;

					////s_changelimitangleFlag = true;
					////PrepairUndo();//全フレーム変更の前に全フレーム保存

					//長いフレームの処理は数秒時間がかかることがあるので砂時計カーソルにする
					HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

					bool excludebt = true;
					s_model->ResetAngleLimit(excludebt, 0);
					UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM, false);

					s_model->AdditiveCurrentToAngleLimit(s_anglelimitbone);//2022/12/05 curbone引数追加

					//ChangeLimitDegFlag(s_savelimitdegflag, true, false);//updateeulはこれより後で呼ばれるUpdateAfterEditAngleLimitで

					UpdateAfterEditAngleLimit(eLIM2BONE_BONE2LIM, false);

					bool updateonlycheckeul = false;
					AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
					UpdateWindow(s_anglelimitdlg);

					//カーソルを元に戻す
					SetCursor(oldcursor);

					PrepairUndo();//全フレーム変更後に全フレーム保存
					s_changelimitangleFlag = false;

				}
			}
		}
		break;




		//case IDOK:
			//break;
		case IDCANCEL:
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
			break;
		}
		break;
	case WM_CLOSE:
		if (s_anglelimitdlg) {
			s_underanglelimithscroll = 0;
			DestroyWindow(s_anglelimitdlg);
			s_anglelimitdlg = 0;
		}
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}

int DispRotAxisDlg()
{
	if (s_rotaxisdlg) {
		//already opened
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	if (s_model->GetOldAxisFlagAtLoading() == 1) {
		::DSMessageBox(s_3dwnd, L"Work Only After Setting Of Axis.\nRetry After Saving FBX file.", L"error", MB_OK);
		return 0;
	}


	//s_rotaxisdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ROTAXISDLG), s_3dwnd, (DLGPROC)RotAxisDlgProc);
	s_rotaxisdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ROTAXISDLG), g_mainhwnd, (DLGPROC)RotAxisDlgProc);
	if (!s_rotaxisdlg) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_rotaxisdlg, g_mainhwnd);
	SetWindowPos(
		s_rotaxisdlg,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);


	ShowWindow(s_rotaxisdlg, SW_SHOW);
	UpdateWindow(s_rotaxisdlg);

	return 0;
}

int InitRotAxis()
{
	if (!s_rotaxisdlg) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (curbone) {
		RecalcBoneAxisX(curbone);
	}

	return 0;
}

int RotAxis(HWND hDlgWnd)
{
	if (!s_rotaxisdlg) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		return 0;
	}

	UINT checkflagX;
	checkflagX = IsDlgButtonChecked(hDlgWnd, IDC_RADIO1);
	if (checkflagX == BST_CHECKED) {
		s_rotaxiskind = AXIS_X;
	}
	else {
		UINT checkflagY;
		checkflagY = IsDlgButtonChecked(hDlgWnd, IDC_RADIO2);
		if (checkflagY == BST_CHECKED) {
			s_rotaxiskind = AXIS_Y;
		}
		else {
			UINT checkflagZ;
			checkflagZ = IsDlgButtonChecked(hDlgWnd, IDC_RADIO3);
			if (checkflagZ == BST_CHECKED) {
				s_rotaxiskind = AXIS_Z;
			}
		}
	}

	WCHAR strdeg[256] = { 0L };
	GetWindowText(GetDlgItem(hDlgWnd, IDC_EDITDEG), strdeg, 256);
	strdeg[256 - 1] = 0L;
	size_t len = wcslen(strdeg);
	//_ASSERT(0);
	if ((len > 0) && (len < 256)) {
		s_rotaxisdeg = (float)_wtof(strdeg);
		//_ASSERT(0);
		if ((s_rotaxisdeg >= -360.0f) && (s_rotaxisdeg <= 360.0f)) {
			float rotrad = s_rotaxisdeg * (float)DEG2PAI;
			ChaVector3 axis0;
			CQuaternion rotq;
			if (s_rotaxiskind == AXIS_X) {
				axis0 = ChaVector3(1.0f, 0.0f, 0.0f);
				rotq.SetAxisAndRot(axis0, rotrad);
			}
			else if (s_rotaxiskind == AXIS_Y) {
				axis0 = ChaVector3(0.0f, 1.0f, 0.0f);
				rotq.SetAxisAndRot(axis0, rotrad);
			}
			else if (s_rotaxiskind == AXIS_Z) {
				axis0 = ChaVector3(0.0f, 0.0f, 1.0f);
				rotq.SetAxisAndRot(axis0, rotrad);
			}
			else {
				_ASSERT(0);
				return 1;
			}

			ChaMatrix nodemat = curbone->GetNodeMat();
			CQuaternion noderot;
			noderot.RotationMatrix(nodemat);
			CQuaternion invnoderot;
			noderot.inv(&invnoderot);

			ChaMatrix newnodemat;
			newnodemat = nodemat * invnoderot.MakeRotMatX() * rotq.MakeRotMatX() * noderot.MakeRotMatX();

			ChaVector3 bonepos = curbone->GetJointFPos();
			newnodemat.SetTranslation(bonepos);

			curbone->SetNodeMat(newnodemat);

			MOTINFO* mi = s_model->GetCurMotInfo();
			if (mi) {
				s_model->CalcBoneEul(g_limitdegflag, mi->motid);
			}
			//WCHAR strmes[256];
			//swprintf_s(strmes, 256, L"rotaxis %d, rotdeg %.3f", s_rotaxiskind, s_rotaxisdeg);
			//::DSMessageBox(hDlgWnd, strmes, L"Check!!!", MB_OK);
		}
	}

	return 0;
}

LRESULT CALLBACK RotAxisDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
	{
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		CheckRadioButton(hDlgWnd, IDC_RADIO1, IDC_RADIO3, IDC_RADIO1);
		s_rotaxiskind = AXIS_X;
		WCHAR strdeg[256];
		swprintf_s(strdeg, 256, L"0");
		SetWindowText(GetDlgItem(hDlgWnd, IDC_EDITDEG), strdeg);

		CBone* curbone = s_model->GetBoneByID(s_curboneno);
		if (curbone) {
			SetWindowText(GetDlgItem(hDlgWnd, IDC_BONENAME), curbone->GetWBoneName());
		}

		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		s_rotzisdlghwnd = hDlgWnd;

		return FALSE;
	}
	break;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_rotzisdlghwnd = 0;

			//EndDialog(hDlgWnd, IDOK);
			if (s_rotaxisdlg) {
				DestroyWindow(s_rotaxisdlg);
				s_rotaxisdlg = 0;
			}
			break;
		case IDCANCEL:
			s_rotzisdlghwnd = 0;

			//EndDialog(hDlgWnd, IDCANCEL);
			if (s_rotaxisdlg) {
				DestroyWindow(s_rotaxisdlg);
				s_rotaxisdlg = 0;
			}
			break;
		case IDC_INITROT:
			InitRotAxis();
			break;
		case IDC_ROTATE:
			RotAxis(hDlgWnd);
			break;
		default:
			return FALSE;
		}
		break;
	case WM_CLOSE:
		s_rotzisdlghwnd = 0;

		if (s_rotaxisdlg) {
			DestroyWindow(s_rotaxisdlg);
			s_rotaxisdlg = 0;
		}
		break;
	default:
		return FALSE;
	}
	return TRUE;

}


int ChangeCurrentBone()
{
	static CModel* s_befmodel = 0;
	static CBone* s_befbone = 0;

	if (!s_model) {
		return 0;
	}
	if (s_model->GetLoadedFlag() == false) {//2021/08/23
		return 0;
	}
	if (s_nowloading == true) {
		return 0;
	}


	//if (g_retargetbatchflag == 0) {
	if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {

		if (s_model) {
			//CDXUTComboBox* pComboBox;
			//pComboBox = g_SampleUI.GetComboBox(IDC_COMBO_BONE);
			//CBone* pBone;
			//pBone = s_model->GetBoneByID(s_curboneno);
			//if (pBone) {
			//	pComboBox->SetSelectedByData(ULongToPtr(s_curboneno));
			//}

			CBone* curbone = s_model->GetBoneByID(s_curboneno);
			//if (curbone) {
			//	CDXUTComboBox* pComboBox3 = g_SampleUI.GetComboBox(IDC_COMBO_BONEAXIS);
			//	if (pComboBox3) {
			//		//ANGLELIMIT anglelimit = curbone->GetAngleLimit();
			//		//pComboBox3->SetSelectedByData(ULongToPtr(anglelimit.boneaxiskind));
			//		//g_boneaxis = anglelimit.boneaxiskind;
			//		g_boneaxis = (int)PtrToUlong(pComboBox3->GetSelectedData());
			//	}
			//}

			SetRigidLeng();
			SetImpWndParams();
			SetDmpWndParams();
			RigidElem2WndParam();
			if (s_anglelimitdlg) {
				//s_model->UpdateMatrix(&s_model->GetWorldMat(), &s_matVP);//commentout
				Bone2AngleLimit();
				bool updateonlycheckeul = false;
				AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);
			}

			//if (s_befbone != curbone) {
			//	refreshEulerGraph();
			//}


			//選択ボーンに変更が有った場合
			if ((s_befbone != curbone) || (s_befmodel != s_model)) {
				//if (s_owpTimeline) {
					//refreshTimeline(*s_owpTimeline);

				refreshEulerGraph();
				//s_tum.UpdateEditedEuler(refreshEulerGraph);//非ブロッキング


				//}


				PrepairUndo();
			}


			s_befbone = curbone;
			s_befmodel = s_model;
		}
		else {
			s_befbone = 0;
			s_befmodel = s_model;
		}
	}

	return 0;
}

int ChangeWallScrapingIKFlag(bool srcflag)
{
	g_wallscrapingikflag = srcflag;
	s_spscraping.state = srcflag;
	s_WallScrapingCheckBoxFlag = true;//!!!!! 副作用として　SaveUndoMotionが働く

	return 0;
}

int ChangeLimitDegFlag(bool srcflag, bool setcheckflag, bool updateeulflag)
{
	//処理中にチェックボックスの状態を変えることが出来ないように　砂時計カーソルにする
	HCURSOR oldcursor = NULL;
	oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));


	g_limitdegflag = srcflag;
	//if (setcheckflag && s_LimitDegCheckBox) {
	//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);//!!!!! 副作用として　SaveUndoMotionが働く
	//}

	s_splimiteul.state = srcflag;
	if (setcheckflag) {
		s_LimitDegCheckBoxFlag = true;//!!!!! 副作用として　SaveUndoMotionが働く
	}

	if (updateeulflag) {

		if (s_model && (g_limitdegflag == true)) {
			ClearLimitedWM(s_model);
			CopyWorldToLimitedWorld(s_model);
			ApplyNewLimitsToWM(s_model);
		}

		//if (g_limitdegflag == true) {
		//	vector<MODELELEM>::iterator itrmodel;
		//	for (itrmodel = s_modelindex.begin(); itrmodel != s_modelindex.end(); itrmodel++) {
		//		CModel* pmodel = itrmodel->modelptr;
		//		if (pmodel) {
		//			ClearLimitedWM(pmodel);
		//			ApplyNewLimitsToWM(pmodel);
		//		}
		//	}
		//}


		//2023/11/06 IK直後のグラフと　LimitEulオンオフ後のグラフが同一になるように
		MOTINFO* curmi = s_model->GetCurMotInfo();
		if (curmi) {
			s_model->CalcBoneEul(g_limitdegflag, curmi->motid);
		}


		//refreshEulerGraph();
		UpdateEditedEuler();
	}

	//if (s_model && s_model->GetCurMotInfo()) {
	//	int curmotid = s_model->GetCurMotInfo()->motid;
	//	s_model->CalcBoneEul(curmotid);
	//	refreshEulerGraph();
	//}
	//else {
	//	_ASSERT(0);
	//	return 1;
	//}

	if (oldcursor != NULL) {
		//カーソルを元に戻す
		SetCursor(oldcursor);
	}

	return 0;
}

int ChangeCameraMode(int forcemode)
{
	s_savecameraanimmode = g_cameraanimmode;

	if (forcemode == 0) {

		//強制オフでは無い場合

		if (s_spcameramode.state == false) {
			//現在のスイッチがオフの場合
			if (s_cameramodel) {
				//カメラモデルが存在する場合　オンにする
				g_cameraanimmode = 1;
				s_spcameramode.state = true;
			}
			else {
				//カメラモデルが存在しない場合
				//何もしない　オンにしない
			}
		}
		else {
			//現在のスイッチがオンかつオプションもオンの場合　オフにする
			g_cameraanimmode = 0;
			s_spcameramode.state = false;
		}
	}
	else if (forcemode == 1) {
		//強制　オフ
		g_cameraanimmode = 0;
		s_spcameramode.state = false;
	}
	else if (forcemode == 2) {
		//強制　オン
		g_cameraanimmode = 1;
		s_spcameramode.state = true;
	}
	else {
		_ASSERT(0);
	}

	return 0;
}

int ChangeCameraInherit()
{
	s_saveCameraInheritMode = g_cameraInheritMode;

	switch (s_spcamerainherit.mode) {
	case CAMERA_INHERIT_ALL:
		if (s_cameramodel) {
			//カメラモデルが存在する場合　次モード
			g_cameraInheritMode = CAMERA_INHERIT_CANCEL_NULL1;
			s_spcamerainherit.mode = 1;
		}
		else {
			//カメラモデルが存在しない場合
			//何もしない
		}
		break;
	case CAMERA_INHERIT_CANCEL_NULL1:
		if (s_cameramodel) {
			//カメラモデルが存在する場合　次モード
			g_cameraInheritMode = CAMERA_INHERIT_CANCEL_NULL2;
			s_spcamerainherit.mode = 2;
		}
		else {
			//カメラモデルが存在しない場合
			//何もしない
		}
		break;
	case CAMERA_INHERIT_CANCEL_NULL2:
		if (s_cameramodel) {
			//最初のモードへ
			g_cameraInheritMode = CAMERA_INHERIT_ALL;
			s_spcamerainherit.mode = 0;
		}
		else {
			//カメラモデルが存在しない場合
			//何もしない
		}
		break;
	default:
		break;
	}

	return 0;
}


bool FocusEditWnd()
{
	HWND focuswnd = GetFocus();
	if (focuswnd == NULL) {
		return false;
	}
	else {
		WCHAR strclassname[MAX_PATH] = { 0 };
		int result = GetClassName(focuswnd, strclassname, MAX_PATH);
		if (result != 0) {
			if ((wcscmp(strclassname, L"EDIT") == 0) || (wcscmp(strclassname, L"Edit") == 0)) {
				return true;//!!!!!!!!!!!!!!!
			}
			else {
				return false;
			}
		}
		else {
			return false;
		}
	}
}


int ChangeToolSpriteMode()
{
	s_toolspritemode++;
	if (s_toolspritemode >= 3) {
		s_toolspritemode = 0;
	}

	return 0;
}

int OnFrameKeyboard()
{
	MoveMemory(g_savekeybuf, g_keybuf, sizeof(BYTE) * 256);

	if (GetKeyboardState((PBYTE)g_keybuf) == FALSE) {
		//失敗した場合にはゴミが入らないように初期化
		//MoveMemory(g_savekeybuf, g_keybuf, sizeof(BYTE) * 256);
		ZeroMemory(g_keybuf, sizeof(BYTE) * 256);
	}

	//################################################################################
	//2023/08/24 Editコントロールに入力中は　キーボードショートカット機能は実行しない
	//################################################################################
	if (!FocusEditWnd()) {
		//プレートメニュー：スペースキーを押すたびにkind変更. Cキーを押し続けながらスペースキーを押すたびにplate変更.
		//2023/08/22 以下のメニュー変更にスペースキーを使うので　DXUTの　スペースキーのホットキー機能をコメントアウト
		if ((g_keybuf[VK_SPACE] & 0x80) && ((g_savekeybuf[VK_SPACE] & 0x80) == 0)) {
			if (g_keybuf['C'] & 0x80) {
				if (s_plateFlag == false) {
					s_plateFlag = true;
				}
			}
			else if (g_keybuf['V'] & 0x80) {
				ChangeToolSpriteMode();
			}
			else {
				if (s_frogFlag == false) {
					s_frogFlag = true;
				}
			}
		}


		//マニピュレータ：SHIFTを押している間は非表示
		if (g_keybuf[VK_SHIFT] & 0x80) {
			s_dispselect = false;
		}
		else {
			s_dispselect = true;
		}


		//Hを押しながら　左右矢印で　左右ハンド(手)を選択
		if (g_keybuf['H'] & 0x80) {//HandのH
			if ((g_keybuf[VK_LEFT] & 0x80) && ((g_savekeybuf[VK_LEFT] & 0x80) == 0)) {
				if (s_selecthand == 0) {
					s_selecthand = 2;//select RightHandJoint //モデル正面向かって左=右
				}
			}
			else if ((g_keybuf[VK_RIGHT] & 0x80) && ((g_savekeybuf[VK_RIGHT] & 0x80) == 0)) {
				if (s_selecthand == 0) {
					s_selecthand = 1;//select LeftHandJoint //モデル正面向かって右=左
				}
			}
		}


		//Fを押しながら　左右矢印で　左右フット(足)を選択
		if (g_keybuf['F'] & 0x80) {//FootのF
			if ((g_keybuf[VK_LEFT] & 0x80) && ((g_savekeybuf[VK_LEFT] & 0x80) == 0)) {
				if (s_selectfoot == 0) {
					s_selectfoot = 2;//select RightFootJoint //モデル正面向かって左=右
				}
			}
			else if ((g_keybuf[VK_RIGHT] & 0x80) && ((g_savekeybuf[VK_RIGHT] & 0x80) == 0)) {
				if (s_selectfoot == 0) {
					s_selectfoot = 1;//select LeftFootJoint //モデル正面向かって右=左
				}
			}
		}



		//if ((g_keybuf[VK_F9] & 0x80) && ((g_savekeybuf[VK_F9] & 0x80) == 0)) {
		//	StartBt(s_model, TRUE, 0, 1);
		//}
		//if ((g_keybuf[VK_F10] & 0x80) && ((g_savekeybuf[VK_F10] & 0x80) == 0)) {
		//	StartBt(s_model, TRUE, 1, 1);
		//}
		//if ((g_keybuf[' '] & 0x80) && ((g_savekeybuf[' '] & 0x80) == 0)) {
		//	if (s_bpWorld && s_model) {
		//		StartBt(s_model, TRUE, 2, 1);
		//	}
		//}
		if (g_keybuf[VK_CONTROL] & 0x80) {
			g_controlkey = true;
		}
		else {
			g_controlkey = false;
		}
		if (g_keybuf[VK_SHIFT] & 0x80) {
			g_shiftkey = true;
		}
		else {
			g_shiftkey = false;
		}

		if (g_keybuf['S'] & 0x80) {
			s_skey = true;
		}
		else {
			s_skey = false;
		}


		//end of BoneTwist on MouseWheel 
		if ((s_tkeyflag != 0) && (s_editmotionflag >= 0) && ((g_keybuf['T'] & 0x80) == 0)) {
			s_tkeyflag = 0;
			PrepairUndo();//ツイスト保存
		}

		/*
		if (g_controlkey == false){
			if (g_keybuf[VK_ADD] & 0x80){
				g_btcalccnt += 1.0;
				Sleep(200);
			}
			else if (g_keybuf[VK_SUBTRACT] & 0x80){
				if (g_btcalccnt >= 2.0){
					g_btcalccnt -= 1.0;
					Sleep(200);
				}
			}
		}
		else{
			if (g_keybuf[VK_ADD] & 0x80){
				if (g_erp <= 0.9){
					g_erp += 0.1;
					Sleep(200);
				}
			}
			else if (g_keybuf[VK_SUBTRACT] & 0x80){
				if (g_erp >= 0.1){
					g_erp -= 0.1;
					Sleep(200);
				}
			}
		}
		*/



		//####################################################################################################################
		//Undo,RedoのRedoのコマンドキーがCtrl + Shift + Zなので,　MButton用のキーとしてCtrl + Shiftは使えない。コメントアウト　2022/01/11
		//####################################################################################################################
		//if (g_ctrlshiftkeyformb == false) {
		//	if ((g_keybuf[VK_CONTROL] & 0x80) && (g_keybuf[VK_SHIFT] & 0x80)) {
		//		if (((g_savekeybuf[VK_CONTROL] & 0x80) == 0) || ((g_savekeybuf[VK_SHIFT] & 0x80) == 0)) {
		//			g_ctrlshiftkeyformb = true;
		//			//reset g_ctrlshiftkeyformb at the place of calling OnTimelineMButtonDown
		//		}
		//	}
		//}


		//##################
		//OnTimeLineWheel()
		//##################
		if (g_keybuf['A'] & 0x80) {
			s_akeycnt++;
		}
		else {
			s_akeycnt = 0;
		}
		if (g_keybuf['D'] & 0x80) {
			s_dkeycnt++;
		}
		else {
			s_dkeycnt = 0;
		}

		//if (g_keybuf['1'] & 0x80) {//num
		//	s_1keycnt++;
		//}
		//else {
		//	s_1keycnt = 0;
		//}



		/////// all model bone
		if (s_model && g_controlkey && (g_keybuf['A'] & 0x80) && !(g_savekeybuf['A'] & 0x80)) {
			s_allmodelbone = !s_allmodelbone;
		}

		//if (g_controlkey && (s_1keycnt == 1)) {
		//	s_dispsampleui = !s_dispsampleui;
		//}

	}

	return 0;
}

int OnFrameUtCheckBox()
{
	static int save_wallscrapingikflag = g_wallscrapingikflag;
	static bool save_limitdegflag = g_limitdegflag;
	static int save_brushmirrorUflag = g_brushmirrorUflag;
	static int save_brushmirrorVflag = g_brushmirrorVflag;
	static int save_ifmirrorVDiv2flag = g_ifmirrorVDiv2flag;
	static int save_brushrepeats = g_brushrepeats;
	static int save_applyrate = g_applyrate;


	////g_applyendflag = (int)s_ApplyEndCheckBox->GetChecked();
	////g_slerpoffflag = (int)s_SlerpOffCheckBox->GetChecked();
	////if (s_AbsIKCheckBox) {
	////	g_absikflag = (int)s_AbsIKCheckBox->GetChecked();
	////}

	////if (s_TPoseCheckBox) {
	////	g_tpose = (bool)s_TPoseCheckBox->GetChecked();
	////}
	//if (s_PreciseCheckBox) {
	//	g_preciseOnPreviewToo = (bool)s_PreciseCheckBox->GetChecked();
	//}
	//if (s_X180CheckBox) {
	//	g_x180flag = (bool)s_X180CheckBox->GetChecked();
	//}
	////if (s_VSyncCheckBox) {
	////	g_VSync = (bool)s_VSyncCheckBox->GetChecked();
	////}
	//if (s_TraRotCheckBox) {
	//	g_rotatetanim = (bool)s_TraRotCheckBox->GetChecked();
	//}
	////if (s_EdgeSmpCheckBox) {
	////	g_edgesmp = (bool)s_EdgeSmpCheckBox->GetChecked();
	////}
	//if (s_HighRpmCheckBox) {
	//	g_HighRpmMode = (int)s_HighRpmCheckBox->GetChecked();
	//}
	//if (s_BoneMarkCheckBox) {
	//	g_bonemarkflag = (int)s_BoneMarkCheckBox->GetChecked();
	//}
	//if (s_LightingCheckBox) {
	//	g_lightflag = (int)s_LightingCheckBox->GetChecked();
	//}
	//if (s_RigidMarkCheckBox) {
	//	g_rigidmarkflag = (int)s_RigidMarkCheckBox->GetChecked();
	//}
	////if (s_PseudoLocalCheckBox) {
	////	g_pseudolocalflag = (int)s_PseudoLocalCheckBox->GetChecked();
	////}



	//if (s_WallScrapingIKCheckBox && s_WallScrapingCheckBoxFlag) {
	if (s_WallScrapingCheckBoxFlag) {
		//g_wallscrapingikflag = (int)s_WallScrapingIKCheckBox->GetChecked();
		if (s_model && (save_wallscrapingikflag != g_wallscrapingikflag)) {
			PrepairUndo();
		}
		save_wallscrapingikflag = g_wallscrapingikflag;
		s_WallScrapingCheckBoxFlag = false;
	}


	//if (s_LimitDegCheckBox && s_LimitDegCheckBoxFlag) {
	if (s_LimitDegCheckBoxFlag) {
		//g_limitdegflag = s_LimitDegCheckBox->GetChecked();
		////if (s_model && s_model->GetCurMotInfo() && (s_curboneno >= 0) && (g_limitdegflag != s_beflimitdegflag)) {
		if (s_model && s_model->GetCurMotInfo() && (g_limitdegflag != s_beflimitdegflag)) {
			////s_model->CalcBoneEul(s_model->GetCurMotInfo()->motid);
			////refreshEulerGraph();
			//////s_tum.UpdateEditedEuler(refreshEulerGraph);//非ブロッキング

			//ChangeLimitDegFlag(g_limitdegflag, false, true);
			PrepairUndo();
		}
		s_beflimitdegflag = g_limitdegflag;
		s_LimitDegCheckBoxFlag = false;
	}


	if (s_BrushMirrorUCheckBoxFlag) {
		//g_brushmirrorUflag = (int)s_BrushMirrorUCheckBox->GetChecked();
		if (s_model && (save_brushmirrorUflag != g_brushmirrorUflag)) {
			PrepairUndo();
		}
		save_brushmirrorUflag = g_brushmirrorUflag;
		s_BrushMirrorUCheckBoxFlag = false;
	}
	if (s_BrushMirrorVCheckBoxFlag) {
		//g_brushmirrorVflag = (int)s_BrushMirrorVCheckBox->GetChecked();
		if (s_model && (save_brushmirrorVflag != g_brushmirrorVflag)) {
			PrepairUndo();
		}
		save_brushmirrorVflag = g_brushmirrorVflag;
		s_BrushMirrorVCheckBoxFlag = false;
	}
	if (s_IfMirrorVDiv2CheckBoxFlag) {
		//g_ifmirrorVDiv2flag = (int)s_IfMirrorVDiv2CheckBox->GetChecked();
		if (s_model && (save_ifmirrorVDiv2flag != g_ifmirrorVDiv2flag)) {
			PrepairUndo();
		}
		save_ifmirrorVDiv2flag = g_ifmirrorVDiv2flag;
		s_IfMirrorVDiv2CheckBoxFlag = false;
	}


	if (s_changeupdatethreadsFlag) {
		ChangeUpdateMatrixThreads();
		s_changeupdatethreadsFlag = false;
		//g_SampleUI.GetSlider(IDC_SL_UMTHREADS)->SetEnabled(true);//!!!!!!!!!
	}


	if (s_utBrushRepeatsFlag) {//値が変わって　かつ　マウスアップのとき
		//WCHAR sz[100] = { 0L };
		//g_brushrepeats = (int)(g_SampleUI.GetSlider(IDC_SL_BRUSHREPEATS)->GetValue());
		//swprintf_s(sz, 100, L"Brush Repeats : %d", g_brushrepeats);
		//g_SampleUI.GetStatic(IDC_STATIC_BRUSHREPEATS)->SetText(sz);
		if (s_model && (save_brushrepeats != g_brushrepeats)) {
			PrepairUndo();
		}
		save_brushrepeats = g_brushrepeats;

		s_utBrushRepeatsFlag = false;//OnGUIEventのBrushRepaetsスライダー
	}

	if (s_utApplyRateFlag) {//値が変わって　かつ　マウスアップのとき
		//WCHAR sz[100] = { 0L };
		//g_applyrate = g_SampleUI.GetSlider(IDC_SL_APPLYRATE)->GetValue();
		//CEditRange::SetApplyRate((double)g_applyrate);
		//swprintf_s(sz, 100, L"TopPos : %d%% : %d", g_applyrate, (int)(s_editrange.GetApplyFrame()));
		//g_SampleUI.GetStatic(IDC_STATIC_APPLYRATE)->SetText(sz);
		if (s_model && (save_applyrate != g_applyrate)) {
			PrepairUndo();
		}
		save_applyrate = g_applyrate;

		s_utApplyRateFlag = false;//OnGUIEventのApplyRateスライダー
	}


	return 0;
}

int OnFrameLightsForEdit()
{

	//毎フレームコントロールを更新すると　手で入力できなくなる
	//if (s_lightsforeditdlg) {
	//	Lights2Dlg(s_lightsforeditdlg);
	//}

	return 0;
}


int OnFrameAngleLimit(bool updateonlycheckeul)
{
	if (s_anglelimitdlg) {
		if (s_model && (s_underanglelimithscroll == 0)) {//HScroll中に値を取得して設定するとスライダーが動かないから
			//s_model->UpdateMatrix(&s_model->GetWorldMat(), &s_matVP);//commentout


			Bone2AngleLimit();
			AngleLimit2Dlg(s_anglelimitdlg, updateonlycheckeul);


			if (updateonlycheckeul == false) {
				if (g_previewFlag == 0) {//underchecking
					AngleLimit2Bone(eLIM2BONE_LIM2BONE_ONE);
				}
			}

			UpdateWindow(s_anglelimitdlg);

			//Bone2AngleLimit(setcheckflag);
			//AngleLimit2Dlg(s_anglelimitdlg);
		}
	}

	return 0;
}

int OnFrameProcessTime(double difftime, double* pnextframe, int* pendflag, int* ploopstartflag)
{
	if (!pnextframe || !pendflag || !ploopstartflag) {
		_ASSERT(0);
		return 1;
	}

	if (g_previewFlag != 0) {
		if (s_model && s_model->GetCurMotInfo()) {
			if (s_savepreviewFlag == 0) {
				//preview start frame
				s_previewrange = s_editrange;
				double rangestart;
				if (s_previewrange.IsSameStartAndEnd()) {
					rangestart = 1.0;
				}
				else {
					rangestart = s_previewrange.GetStartFrame();
				}
				s_model->SetMotionFrame(rangestart);
				*pnextframe = 0.0;
			}
			s_model->AdvanceTime(0, s_previewrange, g_previewFlag, difftime, pnextframe, pendflag, ploopstartflag, -1);
			if (*pendflag == 1) {
				g_previewFlag = 0;
			}
		}
	}

	return 0;
}

int OnFrameProcessCameraTime(double difftime, double* pnextframe, int* pendflag, int* ploopstartflag)
{
	if (!pnextframe || !pendflag || !ploopstartflag) {
		_ASSERT(0);
		return 1;
	}
	if (!s_model) {
		return 0;
	}

	if (!s_cameramodel) {//2024/01/31
		return 0;
	}
	//int cameramotid = s_model->GetCameraMotionId();
	int cameramotid = s_cameramodel->GetCameraMotionId();//2024/01/31
	if (cameramotid <= 0) {
		return 0;
	}

	if (g_previewFlag != 0) {
		if (s_savepreviewFlag == 0) {
			//preview start frame
			s_previewrange = s_editrange;
			double rangestart;
			if (s_previewrange.IsSameStartAndEnd()) {
				rangestart = 1.0;
			}
			else {
				rangestart = s_previewrange.GetStartFrame();
			}
			//s_model->SetMotionFrame(cameramotid, rangestart);
			s_cameramodel->SetMotionFrame(cameramotid, rangestart);
			*pnextframe = 0.0;
		}
		//s_model->AdvanceTime(0, s_previewrange, g_previewFlag, difftime, pnextframe, pendflag, ploopstartflag, cameramotid);//!!! cameramotid !!!
		s_cameramodel->AdvanceTime(0, s_previewrange, g_previewFlag, difftime, pnextframe, pendflag, ploopstartflag, cameramotid);//!!! cameramotid !!!
	}
	else {
		if (s_owpLTimeline) {
			*pnextframe = s_owpLTimeline->getCurrentTime();
		}
		else {
			*pnextframe = 1.0;
		}
	}
	//if (*pendflag == 1) {
	//	g_previewFlag = 0;
	//}

	
	//s_model->SetMotionSpeed(cameramotid, g_dspeed);
	//s_model->SetMotionFrame(cameramotid, *pnextframe);
	s_cameramodel->SetMotionSpeed(cameramotid, g_dspeed);
	s_cameramodel->SetMotionFrame(cameramotid, *pnextframe);

	return 0;
}



int OnFramePreviewCamera(double srcnextframe)
{
	double nextcameraframe = 0.0;

	if (!s_chascene) {
		return 0;
	}

	//eNull用の時間は　カメラの時間と同じとする　(とりあえず)
	s_chascene->SetENullTime(-1, srcnextframe);


	if (g_cameraanimmode != 0) {//2023/05/29 2023/06/04
	 
		//########################
		//カメラアニメモード　オン
		//########################

		if (s_cameramodel) {
			if (g_previewFlag ||
				((g_previewFlag == 0) && (s_savepreviewFlag != 0))) {
				nextcameraframe = srcnextframe;
			}
			else {
				if (s_owpLTimeline) {
					nextcameraframe = s_owpLTimeline->getCurrentTime();
				}
				else {
					nextcameraframe = 0.0;
				}
			}

			//double roundingframe = RoundingTime(nextcameraframe);
			//s_cameramodel->GetCameraAnimParams(roundingframe, g_camdist, &g_camEye, &g_camtargetpos, &g_cameraupdir, 0, g_cameraInheritMode);//g_camdist
			////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
			//s_cameraframe = roundingframe;


			//2024/01/31 NotRoundingTime
			s_cameramodel->GetCameraAnimParams(nextcameraframe, g_camdist, &g_camEye, &g_camtargetpos, &g_cameraupdir, 0, g_cameraInheritMode);//g_camdist
			s_cameraframe = nextcameraframe;

		}
		else {
			//######################################
			//カメラモデルが無い場合
			//GUIによるカメラ操作可能に
			//######################################
			//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		}
	}
	else {

		//########################
		//カメラアニメモード　オフ
		//########################

		//######################################
		//GUIによるカメラ操作可能に
		//######################################
		//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
	}
	ChaVector3 cameradiff = g_camtargetpos - g_camEye;
	g_camdist = (float)ChaVector3LengthDbl(&cameradiff);


	//###################################
	//ライトの向きは　カメラの向きに依存
	//###################################
	SetLightDirection();


	return 0;
}

int OnFramePreviewStop()
{
	if (!s_chascene) {
		return 0;
	}

	double currenttime;
	if (s_owpTimeline) {
		currenttime = s_owpLTimeline->getCurrentTime();
	}
	else {
		currenttime = 0.0;
	}
	
	s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matVP, currenttime);

	//s_tum.UpdateMatrix(s_modelindex, &s_matVP);//ブロッキング

	return 0;
}

int OnFramePreviewNormal(double nextframe, double difftime, int endflag, int loopstartflag)
{
	if (!s_chascene) {
		return 0;
	}


	//if (g_previewFlag != 0) {
	//	if (s_savepreviewFlag == 0) {
	//		//preview start frame
	//		s_previewrange = s_editrange;
	//		double rangestart;
	//		if (s_previewrange.IsSameStartAndEnd()) {
	//			rangestart = 1.0;
	//		}
	//		else {
	//			rangestart = s_previewrange.GetStartFrame();
	//		}
	//		s_model->SetMotionFrame(rangestart);
	//		*pdifftime = 0.0;
	//	}
	//}

	//int endflag = 0;
	//int loopstartflag = 0;
	//s_model->AdvanceTime(s_onefps, s_previewrange, g_previewFlag, *pdifftime, pnextframe, &endflag, &loopstartflag, -1);
	//if (endflag == 1) {
	//	g_previewFlag = 0;
	//}

	s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matVP, nextframe);

#ifndef SKIP_EULERGRAPH__
	if (s_owpTimeline) {
		s_owpLTimeline->setCurrentTime(nextframe, false);
	}
	if (s_owpEulerGraph) {
		s_owpEulerGraph->setCurrentTime(nextframe, false, true);
	}
#endif

	//2023/08/02　SetMotionFrameと同じループ内に移動
	//for (itrmodel = s_modelindex.begin(); itrmodel != s_modelindex.end(); itrmodel++) {
	//	CModel* curmodel = itrmodel->modelptr;
	//	if (curmodel) {
	//		ChaMatrix tmpwm = curmodel->GetWorldMat();
	//		curmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
	//	}
	//}



	//s_tum.UpdateMatrix(s_modelindex, &s_matVP);//ブロッキング


	//if (s_anglelimitdlg) {
	//	UpdateEditedEuler();
	//	//s_tum.UpdateEditedEuler(UpdateEditedEuler);//非ブロッキング
	//}


	//playerButtonのonefpsボタン
	//if (s_onefps == 1) {
	//	Sleep(1000);//1fps
	//}
	//else if (s_onefps == 2) {
	//	Sleep(500);//2fps
	//}


	return 0;
}



int OnFramePreviewBt(double nextframe, double difftime, int endflag, int loopstartflag)
{
	if (!s_model || !s_chascene) {
		return 0;
	}



	//安定のために　シミュ開始時の姿勢で　キネマティックしている回数
	int INITTERM;
	INITTERM = max(10, (int)(s_avrgfps * 0.1));

	bool recstopflag = false;
	BOOL firstmodelflag = TRUE;

	int modelnum = s_chascene->GetModelNum();
	int modelcount;
	for (modelcount = 0; modelcount < modelnum; modelcount++) {
		CModel* curmodel = s_chascene->GetModel(modelcount);
		if (curmodel && (curmodel->GetNoBoneFlag() == false)) {//2023/11/03 NoBoneのときはスキップ

			if (curmodel->GetBtCnt() <= INITTERM) {
				curmodel->SetKinematicFlag();
				//!!curmodel->SetBtEquilibriumPoint();
			}
			else {
				curmodel->SetBtKinFlagReq(curmodel->GetTopBt(), 0);
				//curmodel->SetBtEquilibriumPoint();
			}

			if ((curmodel == s_model) && (s_model->GetBtCnt() == 0)) {
				s_rectime = 0.0;
				s_reccnt = 0;
				s_model->PhysIKRec(g_limitdegflag, s_rectime);
			}

			if ((g_btsimurecflag == true) && ((loopstartflag == 1) || (endflag == 1))) {
				recstopflag = true;//!!!!!!!!!!!!!!!!!!!!!!!
				break;
			}


			if (firstmodelflag) {
#ifndef SKIP_EULERGRAPH__
				if (s_owpTimeline) {
					s_owpLTimeline->setCurrentTime(nextframe, false);
				}
				if (s_owpEulerGraph) {
					s_owpEulerGraph->setCurrentTime(nextframe, false, true);
				}
#endif
				firstmodelflag = false;
			}
			//if (endflag == 1) {
				//g_previewFlag = 0;
			//}

			curmodel->SetMotionFrame(nextframe);

		}
	}


	//2023/11/03 モデル単位マルチスレッド＆ダブルバッファ
	s_chascene->UpdateBtFunc(g_limitdegflag, nextframe, &s_matVP, loopstartflag, s_model, recstopflag, s_bpWorld, s_reccnt, StopBtRec);


	//60 x 60 frames limit : 60 sec limit
	if ((s_model->GetBtCnt() > 0) && (s_reccnt < MAXPHYSIKRECCNT)) {
		s_reccnt += 1.0;
	}


	return 0;
}

int StopBtRec()
{
	StopBt();
	s_model->ApplyPhysIkRec(g_limitdegflag);
	PrepairUndo();//物理REC用保存
	g_btsimurecflag = false;

	return 0;
}



//int OnFramePreviewBtAftFunc(double nextframe, CModel* curmodel)
//{
//	if (curmodel && (curmodel->GetBtCnt() != 0)) {
//		if (curmodel && curmodel->GetCurMotInfo()) {
//			ChaMatrix tmpwm = curmodel->GetWorldMat();
//			curmodel->SetBtMotion(g_limitdegflag, curmodel->GetBoneByID(s_curboneno), 0, nextframe, &tmpwm, &s_matVP);
//
//			//60 x 30 frames limit : 30 sec limit
//			if ((curmodel == s_model) && (s_model->GetBtCnt() > 0) && (s_reccnt < MAXPHYSIKRECCNT)) {
//				s_rectime = (double)((int)s_reccnt);
//				s_model->PhysIKRec(s_rectime);
//				s_reccnt++;
//			}
//		}
//	}
//
//	return 0;
//}



//void UpdateBtSimu(double nextframe, CModel* curmodel)
//{
//	if (!curmodel){
//		return;
//	}
//	int firstflag = 0;
//	if (s_savepreviewFlag != g_previewFlag){
//		firstflag = 1;
//	}
//	if (curmodel && curmodel->GetCurMotInfo()){
//		ChaMatrix tmpwm = curmodel->GetWorldMat();
//		curmodel->Motion2Bt(firstflag, nextframe, &tmpwm, &s_matVP, s_curboneno);
//	}
//	//s_bpWorld->setTimeStep(1.0f / 120.0f);// seconds
//	s_bpWorld->clientMoveAndDisplay();
//	if (curmodel && curmodel->GetCurMotInfo()){
//		ChaMatrix tmpwm = curmodel->GetWorldMat();
//		curmodel->SetBtMotion(curmodel->GetBoneByID(s_curboneno), 0, nextframe, &tmpwm, &s_matVP);
//	}
//}

//int OnFramePreviewRagdoll(double* pnextframe, double* pdifftime)
//{
//	static int s_underikflag = 0;
//	static int s_befunderikflag = 0;
//
//	int endflag = 0;
//
//	if (!s_model){
//		return 0;
//	}
//	CModel* curmodel = s_model;
//
//	//BOOL isstartframe = FALSE;
//	//double rangestart = 1.0;
//	//s_previewrange = s_editrange;
//	//if (s_previewrange.IsSameStartAndEnd()) {
//	//	rangestart = 1.0;
//	//}
//	//else {
//	//	rangestart = s_previewrange.GetStartFrame();
//	//}
//
//	//if (g_previewFlag != 0) {
//	//	if (s_savepreviewFlag == 0) {
//	//		//preview start frame
//	//		*pdifftime = 0.0;
//	//		*pnextframe = rangestart;
//	//		isstartframe = TRUE;
//	//	}
//	//}
//
//
//	//*pnextframe = s_previewrange.GetApplyFrame();
//	int tmpleng;
//	double tmpstart, tmpend;
//	s_previewrange.GetRange(&tmpleng, &tmpstart, &tmpend);
//	*pnextframe = s_previewrange.GetApplyFrame();
//	//*pnextframe = g_motionbrush_applyframe;
//
//	if (curmodel && curmodel->GetCurMotInfo()){
//		//if (s_onragdollik != 0){
//		//	if (s_underikflag == 0){
//		//		curmodel->BulletSimulationStop();
//		//		s_underikflag = 1;
//		//	}
//		//}
//
//
//		if (curmodel->GetBtCnt() <= g_prepcntonphysik) {
//			curmodel->SetKinematicFlag();
//			curmodel->SetMotionFrame(*pnextframe);
//
//			//UpdateBtSimu(*pnextframe, curmodel);
//			if (curmodel && curmodel->GetCurMotInfo()) {
//				int firstflag = 1;
//				ChaMatrix tmpwm = curmodel->GetWorldMat();
//				curmodel->Motion2Bt(firstflag, *pnextframe, &tmpwm, &s_matVP, s_curboneno);
//			}
//			curmodel->SetBtEquilibriumPoint();//必要
//
//			if (curmodel->GetBtCnt() == 0) {
//				s_rectime = 0.0;
//				s_reccnt = 0;
//				s_model->PhysIKRec(s_rectime);
//				SetKinematicToHand(curmodel, true);//指が変にならないように
//			}
//		}
//		else {
//			curmodel->SetRagdollKinFlag(s_curboneno, s_physicskind);
//			curmodel->SetBtEquilibriumPoint();//
//		}
//
//
//
//
//		//curmodel->SetRagdollKinFlag(s_curboneno, s_physicskind);
//
//	}
//
//	//physics mvの場合、クリックしていないときには直下のif文内を呼ばない。
//	//physics rotの場合、クリックしていなくても直下のif文内を呼んだほうが剛体がゆらゆらしない。
//	if((s_curboneno >= 0) && ((s_onragdollik != 0) || (s_physicskind == 0))){
//		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
//		POINT ptCursor;
//		GetCursorPos(&ptCursor);
//		::ScreenToClient(s_3dwnd, &ptCursor);
//		s_pickinfo.mousepos = ptCursor;
//
//		ChaVector3 tmpsc;
//		curmodel->TransformBone(s_pickinfo.winx, s_pickinfo.winy, s_curboneno, &s_pickinfo.objworld, &tmpsc, &s_pickinfo.objscreen);
//
//		if (s_oprigflag == 0) {//Rig操作ではないとき
//			ChaVector3 targetpos(0.0f, 0.0f, 0.0f);
//			CallF(CalcTargetPos(&targetpos), return 1);
//
//			s_model->SetDofRotAxis(s_pickinfo.buttonflag);//!!!!!!!!!!!!!!!!!!!!!!!
//
//
//			if (s_physicskind == 0) {
//				if (s_onragdollik == 1) {
//					int ikmaxlevel = 0;
//					curmodel->PhysicsRot(&s_editrange, s_pickinfo.pickobjno, targetpos, ikmaxlevel);
//				}
//				else if ((s_onragdollik == 2) || (s_onragdollik == 3)) {
//					float deltax = (float)((s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y)) * 0.1f;
//					if (g_controlkey == true) {
//						deltax *= 0.250f;
//					}
//					//s_editmotionflag = s_model->PhysicsRotAxisDelta(&s_editrange, s_pickinfo.buttonflag, s_pickinfo.pickobjno, deltax, g_iklevel, s_ikcnt, s_ikselectmat);
//					s_editmotionflag = s_model->PhysicsRotAxisDelta(&s_editrange, s_pickinfo.buttonflag, s_curboneno, deltax, g_iklevel, s_ikcnt, s_ikselectmat);
//					s_ikcnt++;
//				}
//
//				//if (s_curboneno <= 0){
//				//	::MessageBoxA(NULL, "OnFramePreviewRagdoll : curboneno error", "check", MB_OK);
//				//}
//
//			}
//			else {
//				//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//				//少しずつ動かさないと壊れやすい
//				//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//				int ikmaxlevel = 0;
//				ChaVector3 diffvec = (targetpos - s_pickinfo.objworld) * 0.2;//PhysicsMV関数内でさらにg_physicsmvrateが掛けられる。
//				curmodel->PhysicsMV(&s_editrange, s_pickinfo.pickobjno, diffvec);
//			}
//		}
//
//
//		CBone* curbone = s_model->GetBoneByID(s_curboneno);
//		if (curbone) {
//			CBone* parentbone = curbone->GetParent();
//			if (parentbone) {
//				s_editmotionflag = parentbone->GetBoneNo();
//			}
//			else {
//				s_editmotionflag = s_curboneno;
//			}
//			s_ikcnt++;
//		}
//
//
//	}
//
//
//	//curmodel->SetMotionFrame(s_editrange.GetStartFrame());
//	//*pnextframe = s_editrange.GetStartFrame();//!!!!!!!!!!!!!!!
//	{
//		int tmpleng2;
//		double tmpstart2, tmpend2;
//		s_previewrange.GetRange(&tmpleng2, &tmpstart2, &tmpend2);
//		*pnextframe = s_previewrange.GetApplyFrame();
//		curmodel->SetMotionFrame(*pnextframe);
//	}
//
//#ifndef SKIP_EULERGRAPH__
//	s_owpLTimeline->setCurrentTime(*pnextframe, false);
//	s_owpEulerGraph->setCurrentTime(*pnextframe, false, true);
//#endif
//
//
//	s_bpWorld->clientMoveAndDisplay();
//
//	if (curmodel && curmodel->GetCurMotInfo()){
//		ChaMatrix tmpwm = curmodel->GetWorldMat();
//		curmodel->SetBtMotion(curmodel->GetBoneByID(s_curboneno), 1, *pnextframe, &tmpwm, &s_matVP);
//		curmodel->UpdateMatrix(&tmpwm, &s_matVP, true);
//		curmodel->PlusPlusBtCnt();
//
//		//ドラッグ中だけ記録
//		if ((s_curboneno >= 0) && ((s_onragdollik != 0) || (s_physicskind == 0))) {
//			//60 x 30 frames limit : 30 sec limit
//			if ((curmodel->GetBtCnt() > g_prepcntonphysik) && (s_reccnt < MAXPHYSIKRECCNT)) {
//				s_rectime = (double)((int)s_reccnt);
//				s_model->PhysIKRec(s_rectime);
//				s_reccnt++;
//			}
//		}
//	}
//
//	s_bpWorld->clientMoveAndDisplay();//tmpkinematic部分のbullet情報変更がSetBtMotion内で生じるので、もう一回シミュをまわす。
//
//
//	s_befunderikflag = s_underikflag;
//
//	//if (s_anglelimitdlg) {
//	//	UpdateEditedEuler();
//	//	//s_tum.UpdateEditedEuler(UpdateEditedEuler);//非ブロッキング
//	//}
//
//
//	return 0;
//}

int OnFrameCloseFlag()
{
	// 終了フラグを確認

	if (s_closeFlag) {
		s_closeFlag = false;
		s_dispmw = false;
		if (s_timelineWnd) {
			s_timelineWnd->setVisible(0);
		}

	}
	if (s_LcloseFlag) {
		s_LcloseFlag = false;
		s_Ldispmw = false;
		if (s_LtimelineWnd) {
			s_LtimelineWnd->setVisible(0);
		}

	}
	if (s_closetoolFlag) {
		s_closetoolFlag = false;
		s_disptool = false;
		if (s_toolWnd) {
			s_toolWnd->setVisible(0);
		}
	}
	if (s_closeobjFlag) {
		s_closeobjFlag = false;
		s_dispobj = false;
		if (s_layerWnd) {
			s_layerWnd->setVisible(0);
		}
	}
	if (s_closemodelFlag) {
		s_closemodelFlag = false;
		s_dispmodel = false;
		if (s_modelpanel.panel) {
			s_modelpanel.panel->setVisible(0);
		}
	}
	if (s_closecameraFlag) {
		s_closecameraFlag = false;
		s_dispcamera = false;
		if (s_camerapanel.panel) {
			s_camerapanel.panel->setVisible(0);
		}
	}
	if (s_closemotionFlag) {
		s_closemotionFlag = false;
		s_dispmotion = false;
		if (s_motionpanel.panel) {
			s_motionpanel.panel->setVisible(0);
		}
	}
	if (s_closeconvboneFlag) {
		s_closeconvboneFlag = false;
		s_dispconvbone = false;
		if (s_convboneWnd) {
			s_convboneWnd->setVisible(false);
			s_convboneWnd->setListenMouse(false);
		}
	}
	if (s_DcloseFlag) {
		s_DcloseFlag = false;
		s_dmpanimWnd->setVisible(0);
		if (s_bpWorld) {
			s_bpWorld->setGlobalERP(btScalar(g_erp));
		}
		if (s_model) {
			CallF(s_model->CreateBtObject(g_limitdegflag, 0), return 1);
		}
	}
	if (s_RcloseFlag) {
		s_RcloseFlag = false;
		s_rigidWnd->setVisible(0);
		if (s_bpWorld) {
			s_bpWorld->setGlobalERP(btScalar(g_erp));
		}
		if (s_model) {
			CallF(s_model->CreateBtObject(g_limitdegflag, 0), return 1);
		}
	}
	if (s_ScloseFlag) {
		s_ScloseFlag = false;
		s_sidemenuWnd->setVisible(0);
	}
	if (s_IcloseFlag) {
		s_IcloseFlag = false;
		s_impWnd->setVisible(0);
		if (s_bpWorld) {
			s_bpWorld->setGlobalERP(btScalar(g_erp));
		}
		if (s_model) {
			CallF(s_model->CreateBtObject(g_limitdegflag, 0), return 1);
		}
	}
	if (s_GcloseFlag) {
		s_GcloseFlag = false;
		s_gpWnd->setVisible(0);
	}

	return 0;
}

int GetCurrentBoneFromTimeline(int* dstboneno)
{
	if (s_model && s_owpTimeline) {
		int curlineno = s_owpTimeline->getCurrentLine();// 選択行
		if (curlineno >= 0) {
			*dstboneno = s_lineno2boneno[curlineno];//*(&s_curboneno)
			SetLTimelineMark(s_curboneno);
			ChangeCurrentBone();
		}
		else {
			*dstboneno = -1;
		}
	}
	return 0;
}


int TimelineCursorToMotion()
{
	if (s_chascene && s_owpTimeline && s_model && s_model->GetCurMotInfo()) {

		GetCurrentBoneFromTimeline(&s_curboneno);

		// カーソル位置を姿勢に反映。
		if (g_previewFlag == 0) {//underchecking
			double curframe = s_owpTimeline->getCurrentTime();// 選択時刻

			s_chascene->SetMotionFrame(-1, curframe);
		}
	}
	return 0;
}


int OnFrameTimeLineWnd()
{
	// カーソル移動フラグを確認 //////////////////////////////////////////////////


	if (g_previewFlag != 0) {//underchecking

		if (g_preciseOnPreviewToo) {
			//2022/10/27 再生中でも選択ジョイント変更処理はする
			GetCurrentBoneFromTimeline(&s_curboneno);
		}

		//カレントフレームの１フレームを選択状態にしてしまうのでfalseにする
		s_cursorFlag = false;
		s_LcursorFlag = false;
		s_keyShiftFlag = false;
		s_LupFlag = false;
		s_cursorFlag = false;

		return 0;//!!!!!!!!!!!!!!!!!!!!!
	}

	if (s_zeroFrameFlag) {
		if (s_model) {
			if (s_owpTimeline && s_owpLTimeline && s_owpEulerGraph) {
				s_buttonselectstart = 0.0;
				s_buttonselectend = 0.0;
				s_buttonselecttothelast = 0;
				g_playingstart = 0.0;
				g_playingend = 0.0;
				OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);
				SetShowPosTime();
				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}
				PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
				g_underselectingframe = 0;
			}
		}
		s_zeroFrameFlag = false;
	}

	if (s_firstkeyFlag) {
		if (s_model) {
			s_buttonselectstart = 1.0;
			s_buttonselectend = 1.0;
			s_buttonselecttothelast = 0;
			g_playingstart = 1.0;
			g_playingend = 1.0;
			OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);
			SetShowPosTime();
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}
			PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
			g_underselectingframe = 0;
		}
		s_firstkeyFlag = false;
	}

	if (s_lastkeyFlag) {
		if (s_model && s_model->GetCurMotInfo()) {
			double lastframe = s_model->GetCurMotInfo()->frameleng - 1.0;

			s_buttonselectstart = lastframe;
			s_buttonselectend = lastframe;
			s_buttonselecttothelast = 0;
			g_playingstart = lastframe;
			g_playingend = lastframe;
			OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);
			SetShowPosTime();
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}
			PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
			g_underselectingframe = 0;
		}
		s_lastkeyFlag = false;
	}

	if (g_selecttolastFlag) {
		if (s_model && s_owpLTimeline) {
			s_buttonselectstart = s_owpLTimeline->getCurrentTime();
			if (s_model && s_model->GetCurMotInfo()) {
				s_buttonselectend = s_model->GetCurMotInfo()->frameleng - 1.0;
			}
			else {
				s_buttonselectend = s_buttonselectstart;
			}
			//g_applyrate = g_SampleUI.GetSlider(IDC_SL_APPLYRATE)->GetValue();
			CEditRange::SetApplyRate((double)g_applyrate);
			OnTimeLineButtonSelectFromSelectStartEnd(0);
			OnTimeLineSelectFromSelectedKey();
			DisplayApplyRateText();
			SetShowPosTime();
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}
			PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定

			g_underselectingframe = 0;
		}
		g_selecttolastFlag = false;
	}




	if (s_LstartFlag) {
		s_buttonselectstart = s_editrange.GetStartFrame();
		s_buttonselectend = s_editrange.GetEndFrame();
		if (s_owpTimeline) {
			s_owpTimeline->setCurrentTime(s_buttonselectstart, false);
		}
		if (s_owpLTimeline) {
			s_owpLTimeline->setCurrentTime(s_buttonselectstart, false);
		}
		if (s_chascene) {
			s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matVP, s_buttonselectstart);
		}

		Bone2AngleLimit();

		s_LstartFlag = false;
	}


	if (s_cursorFlag) {
		TimelineCursorToMotion();
		s_cursorFlag = false;
	}


	//selectFlagは　タイムライン選択範囲が１フレームでも変わるとtrueになる
	if (s_selectFlag) {//selectFlagとLupFlagは本来は別物　しかしLupのときだけ処理するものがある
		if (s_owpLTimeline) {
			s_selectKeyInfoList.clear();
			s_selectKeyInfoList = s_owpLTimeline->getSelectedKey();
			s_editrange.SetRange(s_selectKeyInfoList, s_owpLTimeline->getCurrentTime());
			CEditRange::SetApplyRate((double)g_applyrate);
			s_buttonselectstart = s_editrange.GetStartFrame();
			s_buttonselectend = s_editrange.GetEndFrame();


			if (s_mbuttoncnt != 0) {//2023/01/09 mbutton + wheelで選択を継続するため s_mbuttoncnt == 0のときには初期化しない
				g_underselectingframe = 0;
			}


			//_ASSERT(0);

			if (s_LupFlag) {//selectFlagとLupFlagは本来は別物　しかしLupのときだけ処理するものがある
				if (s_editmotionflag < 0) {
					int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
					if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
						_ASSERT(0);
						::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
						PostQuitMessage(result);
					}
				}

				OnTimeLineButtonSelectFromSelectStartEnd(0);

				//2022/09/13
				if (s_owpLTimeline) {
					//s_editmotionflag = s_curboneno;
					s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
					CEditRange::SetApplyRate((double)g_applyrate);

					if (s_undoredoFromPlayerButton == false) {
						PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
					}
					else {
						//playerbuttonからのundoredo時には　SaveUndoMotionしない
						s_undoredoFromPlayerButton = false;
					}

				}
			}
		}
		s_selectFlag = false;
	}

	if (s_LupFlag) {
		if (s_owpLTimeline) {
			if (g_previewFlag == 0) {
				//###################################################
				//prevrange nextrangeは　undo redo処理に変わりました
				//選択範囲だけの　履歴機能は　コメントアウト
				//###################################################
				//if (s_prevrangeFlag || s_nextrangeFlag) {
				//	RollBackEditRange(s_prevrangeFlag, s_nextrangeFlag);
				//	s_buttonselectstart = s_editrange.GetStartFrame();
				//	s_buttonselectend = s_editrange.GetEndFrame();

				//	g_underselectingframe = 0;

				//	if (s_editmotionflag < 0) {
				//		int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				//		if (result) {
				//			_ASSERT(0);
				//		}
				//	}

				//	OnTimeLineButtonSelectFromSelectStartEnd(0);

				//	//2022/09/13
				//	if (s_owpLTimeline) {
				//		//s_editmotionflag = s_curboneno;
				//		s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
				//		CEditRange::SetApplyRate((double)g_applyrate);
				//		PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
				//	}

				//}
			}
			else {
				//再生ボタンが押されたとき
				//_ASSERT(0);
				s_buttonselectstart = s_editrange.GetStartFrame();
				s_buttonselectend = s_editrange.GetEndFrame();
				g_underselectingframe = 0;
				//_ASSERT(0);

				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}

				OnTimeLineButtonSelectFromSelectStartEnd(0);

			}
		}

		s_LstartFlag = false;
		g_selecttolastFlag = false;
		s_prevrangeFlag = false;
		s_nextrangeFlag = false;


		s_LupFlag = false;
	}


	if (s_LcursorFlag) {
		OnTimeLineCursor();

		if (s_chascene && s_owpLTimeline && s_model && s_model->GetCurMotInfo()) {
			if (g_previewFlag == 0) {//underchecking
				double curframe = s_owpLTimeline->getCurrentTime();// 選択時刻
				s_chascene->SetMotionFrame(-1, curframe);
			}
		}

		//bool updateonlycheckeul = true;
		//OnFrameAngleLimit(updateonlycheckeul);//2022/12/30 commentout OnFrameUserMove()にて毎フレームupdateonlycheckeul = trueで呼び出す 

		s_LcursorFlag = false;
	}


	if (s_LstopFlag) {
		//停止ボタンが押されたとき
		//_ASSERT(0);
		//s_buttonselectstart = s_editrange.GetStartFrame();
		//s_buttonselectend = s_editrange.GetEndFrame();

		SetButtonStartEndFromPlaying();

		g_underselectingframe = 0;
		//_ASSERT(0);

		//int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
		//if (result) {
		//	_ASSERT(0);
		//}

		OnTimeLineButtonSelectFromSelectStartEnd(0);
		//_ASSERT(0);

		if (s_owpLTimeline && s_owpEulerGraph) {
			//プレビュー後に　CallRewrite --> InvalidateRect --> draw()を呼ぶため
			double currenttime = s_owpLTimeline->getCurrentTime();
			s_owpLTimeline->setCurrentTime(currenttime, false, true);
			s_owpEulerGraph->setCurrentTime(currenttime, false, true);
		}

		s_LstopFlag = false;
	}




	// キー移動フラグを確認 ///////////////////////////////////////////////////////////
	//if (s_keyShiftFlag){
	s_keyShiftFlag = false;
	//}

	return 0;
}

int OnFrameMouseButton()
{
	if (s_timelinembuttonFlag || g_ctrlshiftkeyformb) {
		s_timelinembuttonFlag = false;
		OnTimeLineMButtonDown(g_ctrlshiftkeyformb);
		g_ctrlshiftkeyformb = false;
	}
	if (s_timelinewheelFlag || (g_underselectingframe && ((g_keybuf['A'] & 0x80) || (g_keybuf['D'] & 0x80)))) {
		//if (s_timelinewheelFlag || (g_underselectingframe == 1) || (g_underselectingframe == 2)) {//wheeldeltaの値は取得後も消えない仕様のためこの条件だと止まらなくなる
		s_timelinewheelFlag = false;//OnTimeLineWheelの後ろにするとホイールしない？？？
		OnTimeLineWheel();
	}

	if (s_timelineshowposFlag) {
		s_timelineshowposFlag = false;//以下の処理の後にするとホイールしない？？？

		if (s_owpLTimeline) {
			s_owpLTimeline->WheelShowPosTime();
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->WheelShowPosTime();
			refreshEulerGraph();
			//s_tum.UpdateEditedEuler(refreshEulerGraph);//非ブロッキング
		}

	}


	if (s_timelineRUpFlag) {//s_timelineWnd
		s_timelineRUpFlag = false;

		GetCurrentBoneFromTimeline(&s_curboneno);
		if (s_curboneno > 0) {
			BoneRClick(s_curboneno);
		}
	}

	return 0;
}

int OnFrameToolWnd()
{

	if (s_frogFlag) {
		ChangeToNextPlateMenuKind(s_platemenukind, s_platemenuno);
		s_frogFlag = false;
	}
	if (s_plateFlag) {
		ChangeToNextPlateMenuPlate(s_platemenukind, s_platemenuno);
		s_plateFlag = false;
	}

	if (s_camtargetOnceflag) {
		if (s_model && (s_curboneno >= 0)) {
			CBone* curbone = s_model->GetBoneByID(s_curboneno);
			_ASSERT(curbone);
			if (curbone) {
				s_saveboneno = s_curboneno;

				if (s_camtargetflag) {
					g_befcamtargetpos = g_camtargetpos;
					g_camtargetpos = curbone->GetChildWorld();
				}
			}
		}
		s_camtargetOnceflag = 0;
	}



	//DispGroupWnd チェックボックスを右クリック　類似をチェックするためのコンテクストメニューを出す
	if (s_checksimilarFlag) {
		CheckSimilarMenu();
		s_checksimilarFlag = false;
	}



	if (s_selecthand == 1) {
		if (s_model) {
			CBone* selbone = 0;
			selbone = s_model->FindBoneByPattern("L_Hand");
			if (!selbone) {
				selbone = s_model->FindBoneByPattern("LeftHand");
			}
			if (selbone) {
				s_curboneno = selbone->GetBoneNo();

				if (s_owpTimeline) {
					s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
				}

				ChangeCurrentBone();
			}
		}
		s_selecthand = 0;
	}
	if (s_selecthand == 2) {
		if (s_model) {
			CBone* selbone = 0;
			selbone = s_model->FindBoneByPattern("R_Hand");
			if (!selbone) {
				selbone = s_model->FindBoneByPattern("RightHand");
			}
			if (selbone) {
				s_curboneno = selbone->GetBoneNo();

				if (s_owpTimeline) {
					s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
				}

				ChangeCurrentBone();
			}
		}
		s_selecthand = 0;
	}
	if (s_selectfoot == 1) {
		if (s_model) {
			CBone* selbone = 0;
			selbone = s_model->FindBoneByPattern("L_Foot");
			if (!selbone) {
				selbone = s_model->FindBoneByPattern("LeftFoot");
			}
			if (selbone) {
				s_curboneno = selbone->GetBoneNo();

				if (s_owpTimeline) {
					s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
				}

				ChangeCurrentBone();
			}
		}
		s_selectfoot = 0;
	}
	if (s_selectfoot == 2) {
		if (s_model) {
			CBone* selbone = 0;
			selbone = s_model->FindBoneByPattern("R_Foot");
			if (!selbone) {
				selbone = s_model->FindBoneByPattern("RightFoot");
			}
			if (selbone) {
				s_curboneno = selbone->GetBoneNo();

				if (s_owpTimeline) {
					s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
				}

				ChangeCurrentBone();
			}
		}
		s_selectfoot = 0;
	}




	//操作対象ボーンはs_selbonedlg::GetCpVec()にて取得。

	if (s_selboneFlag) {
		int result = -1;

		if (s_model && s_owpTimeline && s_owpLTimeline) {
			CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg();
			if (curcpdlg) {
				curcpdlg->SetModel(s_model);
				s_underframecopydlg = true;
				result = (int)curcpdlg->DoModal();
				s_underframecopydlg = false;
			}
		}

		s_selboneFlag = false;
		if ((result == IDOK) && (s_selboneAndPasteFlag == true) && (s_pasteFlag == false)) {
			s_pasteFlag = true;
		}
		s_selboneAndPasteFlag = false;
	}

	//if (s_180DegFlag) {
	//	//if (s_model && (s_curboneno >= 0)) {
	//	//	CBone* curbone = 0;
	//	//	CBone* adjustbone = 0;
	//	//	if (s_curboneno >= 0) {
	//	//		curbone = s_model->GetBoneByID(s_curboneno);
	//	//	}
	//	//	else {
	//	//		curbone = 0;
	//	//	}
	//	//	if (curbone) {
	//	//		if (curbone->GetParent()) {
	//	//			adjustbone = curbone->GetParent();
	//	//		}
	//	//		else {
	//	//			adjustbone = curbone;
	//	//		}
	//	//	}

	//	//	if (adjustbone) {
	//	//		s_model->Adjust180DegReq(adjustbone);
	//	//		refreshEulerGraph();
	//	//		PrepairUndo();//2022/10/27
	//	//	}
	//	//}
	//	s_180DegFlag = false;
	//}

	if (s_scaleAllInitFlag) {
		if (s_model) {
			MOTINFO* curmi = s_model->GetCurMotInfo();
			if (curmi) {

				PrepairUndo();//全フレーム変更の前に全フレーム保存

				//長いフレームの処理は数秒時間がかかることがあるので砂時計カーソルにする
				HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

				double motleng = curmi->frameleng;
				double frame;
				for (frame = 0.0; frame < motleng; frame += 1.0) {
					if (s_model->GetTopBone()) {
						s_model->SetMotionFrame(frame);
						bool broflag = false;
						InitMpByEulReq(INITMP_SCALE, s_model->GetTopBone(false), curmi->motid, frame, broflag);
					}
				}

				////2023/02/13
				////フィルターで滑らかに
				//int callnum = 1;
				//CallFilterFunc(callnum);
				bool copylw2w = true;
				FilterNoDlg(copylw2w);

				//カーソルを元に戻す
				SetCursor(oldcursor);

				//PrepairUndo();//全フレーム変更後に全フレーム保存 //FilterNoDlg内部から呼ぶ
			}
		}
		s_scaleAllInitFlag = false;
	}


	if (s_markFlag) {

		if (s_model && s_owpTimeline && s_owpLTimeline) {
			double curltime = s_owpLTimeline->getCurrentTime();
			KeyInfo ki = s_owpLTimeline->ExistKey(2, curltime);
			if (ki.lineIndex < 0) {
				s_owpLTimeline->newKey(s_strmark, curltime, 0);
			}
		}

		s_markFlag = false;
	}

	if (s_initmpFlag) {

		InitMpFromTool();

		s_initmpFlag = false;
	}

	if (s_skipJointMark != 0) {

		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->GetCurMotInfo()) {
			CBone* curbone = 0;
			if (s_curboneno >= 0) {
				curbone = s_model->GetBoneByID(s_curboneno);
			}
			else {
				curbone = 0;
			}

			SkipJointMarkReq(s_skipJointMark, curbone, false);

		}

		s_skipJointMark = 0;
	}

	if (s_cameradollyFlag) {
		if (s_model) {
			ShowCameraDollyDlg();
		}
		s_cameradollyFlag = false;
	}
	if (s_materialrateFlag) {
		if (s_model) {
			ShowMaterialRateDlg();
		}
		s_materialrateFlag = false;
	}
	if (s_modelworldmatFlag) {
		if (s_model) {
			ShowModelWorldMatDlg();
		}
		s_modelworldmatFlag = false;
	}
	if (s_shadertypeparamsFlag) {
		s_shadertypeparamsFlag = false;
		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			if ((s_shadertypeparamsindex >= 0) && (s_shadertypeparamsindex < (materialnum + 1))) {
				ShowShaderTypeParamsDlg();
			}
		}
	}

	if (s_interpolateFlag) {
		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->GetCurMotInfo()) {
			InterpolateFromTool();
		}
		s_interpolateFlag = false;
	}


	if ((s_opedelmodelcnt >= 0) && (s_underdelmodel == true)) {
		int modelcnt = s_opedelmodelcnt;
		bool ondelbutton = true;
		OnDelModel(modelcnt, ondelbutton);//s_modelpanel.modelindexはs_modelのindexなので違う

		s_opedelmodelcnt = -1;
		s_underdelmodel = false;
	}
	if ((s_opeselectmodelcnt >= 0) && s_modelpanel.panel) {
		s_modelpanel.modelindex = s_opeselectmodelcnt;
		OnModelMenu(true, s_modelpanel.modelindex, 1);
		s_modelpanel.panel->callRewrite();

		s_opeselectmodelcnt = -1;
	}

	if ((s_opedispmodelcnt >= 0) && s_underdispmodel && s_modelpanel.panel) {
		int modelcnt = s_opedispmodelcnt;
		OnDispModel(modelcnt);

		s_opedispmodelcnt = -1;
		s_underdispmodel = false;
	}


	if ((s_opedelmotioncnt >= 0) && (s_underdelmotion == true)) {
		int delmenuindex = s_opedelmotioncnt;
		bool ondelbutton = true;
		OnDelMotion(delmenuindex, ondelbutton);

		s_opedelmotioncnt = -1;
		s_underdelmotion = false;
	}
	if ((s_opeselectcameracnt >= 0) && s_camerapanel.panel) {
		int cameraindex = s_opeselectcameracnt;
		OnCameraMenu(true, cameraindex, 1);
		s_camerapanel.panel->callRewrite();

		s_opeselectcameracnt = -1;
	}
	if ((s_opeselectmotioncnt >= 0) && s_motionpanel.panel) {
		int motionindex = s_opeselectmotioncnt;
		OnAnimMenu(true, motionindex, 1);
		s_motionpanel.panel->callRewrite();

		s_opeselectmotioncnt = -1;
	}



	if (s_selCopyHisotryFlag) {

		GUIMenuSetVisible(-1, -1);

		GetCPTFileName(s_cptfilename);
		s_copyhistorydlg.SetNames(s_model, s_cptfilename);
		s_copyhistorydlg.ShowWindow(SW_SHOW);

		s_selCopyHisotryFlag = false;
	}

	if (s_copyLW2WFlag) {
		if (s_model && s_model->GetTopBone()) {

			int operatingjointno = s_model->GetTopBone(false)->GetBoneNo();

			PrepairUndo();//全フレーム変更するので　変更前にも保存

			bool allframeflag = true;
			bool setcursorflag = true;
			bool onpasteflag = false;
			CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);

			PrepairUndo();//変更後を保存

			refreshEulerGraph();
		}
		s_copyLW2WFlag = false;
	}

	if (s_copyFlag) {

		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->GetCurMotInfo()) {
			s_copymotvec.clear();
			s_copyKeyInfoList.clear();
			s_copyKeyInfoList = s_owpLTimeline->getSelectedKey();

			list<KeyInfo>::iterator itrcp;
			for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
				double curframe = RoundingTime(itrcp->time);
				InsertCopyMPReq(g_limitdegflag, s_model->GetTopBone(false), curframe);
			}


			//変更時は　s_symCopyFlagでの処理も合わせて変更
			int result1 = 0;
			int result2 = 0;
			if (!s_copymotvec.empty()) {
				//添付フォルダのファイルに記録
				WCHAR retcptfilename[MAX_PATH] = { 0L };
				result1 = WriteCPTFile(retcptfilename);
				if (result1 == 0) {
					result2 = WriteCPIFile(retcptfilename);//cp info
					if ((result2 != 0) && (retcptfilename[0] != 0)) {
						//ダイアログでコピーをCancelした場合含む
						//invalidな履歴はその場で削除
						BOOL bexist;
						bexist = PathFileExists(retcptfilename);
						if (bexist) {
							DeleteFileW(retcptfilename);
						}
					}
				}
			}
			if ((result1 == 0) && (result2 == 0)) {
				if (s_model) {
					PrepairUndo();
				}
				if (s_copyhistorydlg.GetCreatedFlag() == true) {
					GetCPTFileName(s_cptfilename);
					s_copyhistorydlg.SetNames(s_model, s_cptfilename);
				}
			}
		}

		s_copyFlag = false;
		s_undersymcopyFlag = false;
	}

	if (s_symcopyFlag2) {

		//s_symcopyFlagでメニューを出し　１周回ってからのコンテクストメニュー実行後の　s_symcopyFlag2

		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->GetCurMotInfo()) {

			s_copymotvec.clear();
			s_copyKeyInfoList.clear();
			s_copyKeyInfoList = s_owpLTimeline->getSelectedKey();

			list<KeyInfo>::iterator itrcp;
			for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
				double curframe = RoundingTime(itrcp->time);
				InsertSymMPReq(g_limitdegflag, s_model->GetTopBone(false), curframe, s_getsym_retmode);//s_getsym_retmode!!!
			}

			//変更時は　s_copyFlagでの処理も合わせて変更
			int result1 = 0;
			int result2 = 0;
			if (!s_copymotvec.empty()) {
				//添付フォルダのファイルに記録
				WCHAR retcptfilename[MAX_PATH] = { 0L };
				result1 = WriteCPTFile(retcptfilename);
				if (result1 == 0) {
					result2 = WriteCPIFile(retcptfilename);//cp info
					if ((result2 != 0) && (retcptfilename[0] != 0)) {
						//ダイアログでコピーをCancelした場合含む
						//invalidな履歴はその場で削除
						BOOL bexist;
						bexist = PathFileExists(retcptfilename);
						if (bexist) {
							DeleteFileW(retcptfilename);
						}
					}
				}
			}
			if ((result1 == 0) && (result2 == 0)) {
				if (s_model) {
					PrepairUndo();
				}
				if (s_copyhistorydlg.GetCreatedFlag() == true) {
					GetCPTFileName(s_cptfilename);
					s_copyhistorydlg.SetNames(s_model, s_cptfilename);
				}
			}
		}


		s_symcopyFlag2 = false;
		s_symcopyFlag = false;
		s_undersymcopyFlag = true;
	}

	if (s_symcopyFlag) {
		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->GetCurMotInfo()) {
			
			GetSymRootMode();//この関数が返った時点では　まだMsgProcでs_getsym_retmodeがセットされていない

			if (s_symcopyFlag2 == false) {

				//Flag2をセットして１周回す
				s_symcopyFlag2 = true;
			}
		}
		//s_symcopyFlag = false;
		//s_undersymcopyFlag = true;
	}


	if (s_RboneAndPasteFlag) {
		if (s_curboneno >= 0) {
			SetRJoint(s_curboneno);
			//s_RboneAndPasteFlag = false;//if(s_pasteFlag)ブロックの終わりで初期化する
			s_pasteFlag = true;
		}
	}


	if (s_pasteFlag) {

		HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));//長いフレームの保存は数秒時間がかかることがあるので砂時計カーソルにする


		//添付ファイルを読み取ってs_pastemotvecに格納する
		s_pastemotvec.clear();
		bool result;
		result = LoadCPTFile();

		if (result && s_model && s_owpTimeline && s_model->GetCurMotInfo() && !s_pastemotvec.empty())
		{
			vector<CBone*> vecopebone;
			if (s_RboneAndPasteFlag == true) {
				vecopebone = s_pasteRJoint;
			}
			else {
				CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg();
				if (curcpdlg) {
					vecopebone = curcpdlg->m_cpvec;
				}
				else {
					vecopebone.clear();
				}				
			}

			int cpnum = (int)vecopebone.size();
			int keynum = 0;
			double startframe, endframe, applyframe;

			double pastestartframe = 0.0;
			s_editrange.Clear();
			if (s_model && s_model->GetCurMotInfo()) {
				if (s_owpTimeline && s_owpLTimeline) {
					s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
					CEditRange::SetApplyRate((double)g_applyrate);
					s_editrange.GetRange(&keynum, &startframe, &endframe, &applyframe);
				}
			}

			//double curmaxframe = s_model->m_curmotinfo->frameleng;

			//コピーされたキーの先頭時刻を求める
			double copyStartTime = DBL_MAX;
			double copyEndTime = 0;
			vector<CPELEM2>::iterator itrcp;
			for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
				if (itrcp->mp.GetFrame() <= copyStartTime) {
					copyStartTime = itrcp->mp.GetFrame();
				}
				if (itrcp->mp.GetFrame() >= copyEndTime) {
					copyEndTime = itrcp->mp.GetFrame();
				}
			}


			if (keynum >= 0) {
				if (keynum == 0) {
					double motleng = s_model->GetCurMotInfo()->frameleng - 1;
					double srcendframe = min(motleng, startframe + (copyEndTime - copyStartTime));
					srcendframe = max(srcendframe, 0.0);
					PasteMotionPointJustInTerm(copyStartTime, copyEndTime, startframe, srcendframe);
				}
				else {
					PasteMotionPointJustInTerm(copyStartTime, copyEndTime, startframe, endframe);

					//if (keynum <= (int)(copyEndTime - copyStartTime + 1.0 + 0.1)){
					//	PasteMotionPointJustInTerm(copyStartTime, copyEndTime, startframe, endframe);
					//}else{
					//	PasteMotionPointJustInTerm(copyStartTime, copyEndTime, startframe, endframe);

					//	//コピー元の最終フレームの姿勢をコピー先の残りのフレームにペースト
					//	PasteMotionPointAfterCopyEnd(copyStartTime, copyEndTime, startframe, endframe);
					//}
				}
			}


			MOTINFO* curmi = s_model->GetCurMotInfo();
			if (curmi) {
				s_model->CalcBoneEul(g_limitdegflag, curmi->motid);//2023/11/05 既存モーションの上にペーストする際にギザギザしないように
			}


			//UpdateEditedEuler();
			refreshEulerGraph();

			//s_model->SaveUndoMotion(s_curboneno, s_curbaseno, &s_editrange, (double)g_applyrate);
			if (s_model) {
				PrepairUndo();
			}
		}

		s_RboneAndPasteFlag = false;
		s_pasteFlag = false;

		if (oldcursor) {
			SetCursor(oldcursor);
		}

	}

	if (s_motpropFlag) {

		if (s_model && s_model->GetCurMotInfo()) {
			int dlgret;
			dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_MOTPROPDLG),
				s_3dwnd, (DLGPROC)MotPropDlgProc);
			if ((dlgret == IDOK) && s_tmpmotname[0]) {
				WideCharToMultiByte(CP_ACP, 0, s_tmpmotname, -1, s_model->GetCurMotInfo()->motname, 256, NULL, NULL);
				//s_model->m_curmotinfo->frameleng = s_tmpmotframeleng;
				s_model->GetCurMotInfo()->loopflag = s_tmpmotloop;
				double oldframeleng = s_model->GetCurMotInfo()->frameleng;

				if (s_owpTimeline) {
					s_owpTimeline->setMaxTime(s_tmpmotframeleng);
				}
				s_model->ChangeMotFrameLeng(s_model->GetCurMotInfo()->motid, s_tmpmotframeleng);//はみ出たmpも削除
				InitCurMotion(0, oldframeleng);

				//メニュー書き換え, timeline update
				OnAnimMenu(true, s_motmenuindexmap[s_model]);
			}
		}

		s_motpropFlag = false;
	}

	if (s_retargetguiFlag) {
		if (s_model && s_model->GetCurMotInfo()) {

			HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

			s_savelimitdegflag = g_limitdegflag;
			//ChangeLimitDegFlag(false, true, true);//2023/10/23　1.2.0.27_RC2にて コメントアウト
			s_saveretargetmodel = s_curmodelmenuindex;//終了時にOnModelMenuを呼ぶために保存

			RetargetMotion();

			//ChangeLimitDegFlag(s_savelimitdegflag, true, true);//2023/10/23　1.2.0.27_RC2にて コメントアウト
			OnModelMenu(true, s_saveretargetmodel, 1);

			if (oldcursor) {
				SetCursor(oldcursor);
			}
		}

		s_retargetguiFlag = false;
	}


	if (s_filterFlag) {//ToolWindowの平滑化ボタン用
		FilterFromTool();
		s_filterFlag = false;
	}

	if (s_smoothFlag) {//s_spsmoothボタン用
		if (s_model && s_model->GetCurMotInfo()) {
			//PrepairUndo();

			//ギザギザを平滑化
			bool copylw2w = true;
			FilterNoDlg(copylw2w);

			//PrepairUndo();//FilterNoDlg内部から呼ぶ
		}
		s_smoothFlag = false;
	}

	if (s_constexeFlag) {//s_spconstexeボタン用
		if (s_model && s_model->GetCurMotInfo() && s_model->GetTopBone()) {

			HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
			OnTimeLineButtonSelectFromSelectStartEnd(0);
			OnTimeLineSelectFromSelectedKey();
			s_model->PosConstraintExecuteFromButton(g_limitdegflag, &s_editrange);

			//ギザギザを平滑化
			bool copylw2w = true;
			FilterNoDlg(copylw2w);

			if (oldcursor) {
				SetCursor(oldcursor);
			}
		}
		s_constexeFlag = false;
	}
	if (s_constrefreshFlag) {//s_spconstexeボタン用
		if (s_model && s_model->GetCurMotInfo()) {

			s_model->RefreshPosConstraint();

			//PrepairUndo();
		}
		s_constrefreshFlag = false;
	}


	if (s_btresetFlag == true) {
		if (s_model) {
			StartBt(s_model, TRUE, 2, 1);//flag = 2 --> resetflag = 1
		}

		s_btresetFlag = false;
	}

	if (s_newmotFlag == true) {
		AddMotion(0);
		s_newmotFlag = false;
	}

	if (s_delcurmotFlag == true) {
		s_underdelmotion = true;
		OnDelMotion(s_motmenuindexmap[s_model]);
		s_underdelmotion = false;
		s_delcurmotFlag = false;
	}

	if (s_delmodelFlag == true) {
		s_underdelmodel = true;
		OnDelModel(s_curmodelmenuindex);
		s_underdelmodel = false;
		s_delmodelFlag = false;
	}
	if (s_delallmodelFlag == true) {
		s_underdelmodel = true;
		OnDelAllModel();
		s_underdelmodel = false;
		s_delallmodelFlag = false;
	}


	if (s_deleteFlag) {
		s_deleteFlag = false;
		/***
		if( s_model && s_owpTimeline && s_model->m_curmotinfo){
		s_owpTimeline->deleteKey();
		//motionpointのdeleteはdelete Listenerでする。
		s_model->SaveUndoMotion(s_curboneno, s_curbaseno, &s_editrange, (double)g_applyrate);
		}
		***/
	}


	// 削除されたキー情報のスタックを確認 ////////////////////////////////////////////
	for (; s_deletedKeyInfoList.begin() != s_deletedKeyInfoList.end();
		s_deletedKeyInfoList.pop_front()) {
		/***
		CMotionPoint* mpptr = (CMotionPoint*)( s_deletedKeyInfoList.begin()->object );
		CBone* boneptr = s_model->m_bonelist[ s_lineno2boneno[ s_deletedKeyInfoList.begin()->lineIndex ] ];
		mpptr->LeaveFromChain( s_model->m_curmotinfo->motid, boneptr );
		//_ASSERT( 0 );
		delete mpptr;
		***/
	}

	return 0;
}

int SetRJoint(int srcboneno)
{
	s_pasteRJoint.clear();

	if (!s_model) {
		return 0;
	}

	CBone* startbone = s_model->GetBoneByID(srcboneno);
	if (startbone) {
		AddRJointReq(startbone);
	}
	return 0;

}
void AddRJointReq(CBone* srcbone)
{
	if (!s_model) {
		return;
	}

	if (srcbone) {
		s_pasteRJoint.push_back(srcbone);

		if (srcbone->GetChild(false)) {
			AddRJointReq(srcbone->GetChild(false));
		}
		if (srcbone->GetBrother(false)) {
			AddRJointReq(srcbone->GetBrother(false));
		}
	}

}

int CreateCopyHistoryDlg()
{
	if (s_copyhistorydlg.GetCreatedFlag() == false) {
		s_copyhistorydlg.Create(g_mainhwnd);
	}
	SetParent(s_copyhistorydlg.m_hWnd, g_mainhwnd);

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}


	SetWindowPos(
		s_copyhistorydlg.m_hWnd,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	s_copyhistorydlg.ShowWindow(SW_HIDE);

	s_copyhistorydlg.ParamsToDlg(s_model);
	GetCPTFileName(s_cptfilename);
	s_copyhistorydlg.SetNames(s_model, s_cptfilename);

	return 0;
}
int CreateDollyHistoryDlg()
{
	if (s_dollyhistorydlg.GetCreatedFlag() == false) {
		s_dollyhistorydlg.Create(g_mainhwnd);
		s_dollyhistorydlg.SetUpdateFunc(UpdateCameraPosAndTarget);
	}
	SetParent(s_dollyhistorydlg.m_hWnd, g_mainhwnd);

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}


	SetWindowPos(
		s_dollyhistorydlg.m_hWnd,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);

	s_dollyhistorydlg.ShowWindow(SW_HIDE);
	s_dollyhistorydlg.ParamsToDlg();
	vector<DOLLYELEM> vechistory;
	vechistory.clear();
	s_dollyhistorydlg.LoadDollyHistory(vechistory);
	s_dollyhistorydlg.SetNames(vechistory);

	return 0;
}


void ResetPasteDoneFlagReq(CBone* srcbone)
{
	if (!s_model || !srcbone) {
		_ASSERT(0);
		return;
	}

	srcbone->SetPasteDoneFlag(false);

	if (srcbone->GetChild(false)) {
		ResetPasteDoneFlagReq(srcbone->GetChild(false));
	}
	if (srcbone->GetBrother(false)) {
		ResetPasteDoneFlagReq(srcbone->GetBrother(false));
	}
}

CMotionPoint CalcPasteMotionPoint(CBone* srcbone, double srcframe, double srcframe2, double interpolaterate)
{
	CMotionPoint retmp;
	retmp.InitParams();

	if (!s_model) {
		_ASSERT(0);
		return retmp;
	}

	CMotionPoint mp0;
	CMotionPoint mp1;
	mp0.InitParams();
	mp1.InitParams();
	bool getflag0 = false;
	bool getflag1 = false;
	vector<CPELEM2>::iterator itrcp;
	for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
		CBone* chkbone = itrcp->bone;
		if (chkbone && (chkbone == srcbone)) {
			CMotionPoint srcmp = itrcp->mp;
			if (!getflag0 && IsEqualRoundingTime(srcmp.GetFrame(), srcframe)) {
				mp0 = itrcp->mp;
				getflag0 = true;
			}
			if (!getflag1 && IsEqualRoundingTime(srcmp.GetFrame(), srcframe2)) {
				mp1 = itrcp->mp;
				getflag1 = true;
			}
			if (getflag0 && getflag1) {
				break;
			}
		}
	}

	if (!getflag0) {
		_ASSERT(0);
		return retmp;
	}

	if (!getflag1 || (interpolaterate == 0.0)) {
		retmp = mp0;
	}
	else {
		ChaMatrix resultwm;
		ChaMatrix wm0;
		ChaMatrix wm1;
		resultwm.SetIdentity();
		wm0.SetIdentity();
		wm1.SetIdentity();

		wm0 = mp0.GetWorldMat();
		wm1 = mp1.GetWorldMat();
		resultwm =  (wm0 * (1.0 - interpolaterate)) + (wm1 * interpolaterate);

		retmp = mp0;
		retmp.SetWorldMat(resultwm);
	}

	return retmp;
}



int PasteMotionPoint(CBone* srcbone, CMotionPoint srcmp, double newframe)
{
	if (!s_model) {
		_ASSERT(0);
		return 1;
	}

	vector<CBone*> vecopebone;
	if (s_RboneAndPasteFlag == true) {
		vecopebone = s_pasteRJoint;
	}
	else {
		CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg();
		if (curcpdlg) {
			vecopebone = curcpdlg->m_cpvec;
		}
		else {
			vecopebone.clear();
		}
	}

	int cpnum = (int)vecopebone.size();

	int docopyflag = 0;
	int hasNotMvParFlag = 1;//ペーストするジョイントの内　親ジョイントがペースト対象ではない場合のフラグ
	ChaMatrix notmvparmat;
	ChaMatrixIdentity(&notmvparmat);
	if (cpnum != 0) {
		//selected bone at selbonedlg
		int cpno;
		for (cpno = 0; cpno < cpnum; cpno++) {
			CBone* chkbone = vecopebone[cpno];
			if (chkbone == srcbone) {
				docopyflag = 1;

				CBone* parentbone = srcbone->GetParent(false);
				if (parentbone && parentbone->IsSkeleton()) {
					int cpno2;
					for (cpno2 = 0; cpno2 < cpnum; cpno2++) {
						CBone* chkparentbone = vecopebone[cpno2];
						if (chkparentbone == parentbone) {
							hasNotMvParFlag = 0;
						}
					}
				}
				else {
					hasNotMvParFlag = 0;
				}

				break;
			}
			else {
				hasNotMvParFlag = 0;
			}
		}
	}
	else {
		docopyflag = 1;// all bone
		hasNotMvParFlag = 0;
	}

	if (srcbone && (docopyflag == 1)) {
		if (s_model->GetCurMotInfo()) {
			int curmotid = s_model->GetCurMotInfo()->motid;
			srcbone->PasteMotionPoint(g_limitdegflag, curmotid, RoundingTime(newframe), srcmp);
		}
	}

	return 0;
}

int PasteNotMvParMotionPoint(CBone* srcbone, 
	double copystarttime, double srcframe, double srcframe2, double interpolaterate, 
	double dststartframe, double newframe)
{
	//###########################
	//return operatingjointno
	//###########################

	int operatingjointno = 0;

	if (!s_model) {
		_ASSERT(0);
		return operatingjointno;
	}

	vector<CBone*> vecopebone;
	if (s_RboneAndPasteFlag == true) {
		vecopebone = s_pasteRJoint;
	}
	else {
		CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg();
		if (curcpdlg) {
			vecopebone = curcpdlg->m_cpvec;
		}
		else {
			vecopebone.clear();
		}
	}

	int cpnum = (int)vecopebone.size();


	int docopyflag = 0;
	int hasNotMvParFlag = 1;//ペーストするジョイントの内　親ジョイントがペースト対象ではない場合のフラグ
	ChaMatrix notmvparmat;
	ChaMatrixIdentity(&notmvparmat);

	if (cpnum != 0) {
		//selected bone at selbonedlg
		int cpno;
		for (cpno = 0; cpno < cpnum; cpno++) {
			CBone* chkbone = vecopebone[cpno];
			if (chkbone == srcbone) {
				docopyflag = 1;

				CBone* parentbone = srcbone->GetParent(false);
				if (parentbone && parentbone->IsSkeleton()) {
					int cpno2;
					for (cpno2 = 0; cpno2 < cpnum; cpno2++) {
						CBone* chkparentbone = vecopebone[cpno2];
						if (chkparentbone == parentbone) {
							hasNotMvParFlag = 0;
						}
					}
				}
				else {
					hasNotMvParFlag = 0;
				}

				break;
			}
			else {
				hasNotMvParFlag = 0;
			}
		}
	}
	else {
		docopyflag = 1;// all bone
		hasNotMvParFlag = 0;
	}


	if (srcbone && (docopyflag == 1)) {
		CMotionPoint* newmp = 0;
		if (s_model->GetCurMotInfo()) {
			int curmotid = s_model->GetCurMotInfo()->motid;
			newmp = srcbone->GetMotionPoint(curmotid, newframe);
			if (newmp) {
				if (hasNotMvParFlag == 1) {
					CBone* parentbone = srcbone->GetParent(false);
					if (parentbone && parentbone->IsSkeleton()) {

						operatingjointno = parentbone->GetBoneNo();//!!!! For CopyLimitedWorldToWorld()

						ChaMatrix parentwm = parentbone->GetWorldMat(g_limitdegflag,
							curmotid, newframe, 0);
						ChaMatrix parentwm0 = parentbone->GetWorldMat(g_limitdegflag,
							curmotid, RoundingTime(dststartframe), 0);


						if (parentbone->IsHipsBone()) {

							//####################################################################################
							//NotMvがhipsの場合
							//ペースト後の最初のフレームのparentboneの位置が同じで　コピー側のtraanimで動くように
							//####################################################################################

							ChaMatrix srclocalparent0;
							srclocalparent0.SetIdentity();
							ChaMatrix srclocalparent;
							srclocalparent.SetIdentity();


							//2023/11/02 src側のsrcframeの姿勢は　滑らかさのために補間する
							CMotionPoint srcmp;
							srcmp = CalcPasteMotionPoint(parentbone, srcframe, srcframe2, interpolaterate);
							srclocalparent = srcmp.GetWorldMat();
							
							//src側のstartframeの姿勢は　rate=0.0でそのままの姿勢
							CMotionPoint srcstartmp;
							srcstartmp = CalcPasteMotionPoint(parentbone, copystarttime, copystarttime, 0.0);
							srclocalparent0 = srcstartmp.GetWorldMat();

							//vector<CPELEM2>::iterator itrcp;
							//for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
							//	CBone* findbone = itrcp->bone;
							//	if (findbone && findbone == parentbone) {
							//		CMotionPoint findmp = itrcp->mp;
							//		if (IsEqualRoundingTime(findmp.GetFrame(), srcframe)) {
							//			srclocalparent = findmp.GetWorldMat();//copy情報としてローカルが格納されているがhipsなので実質global
							//		}
							//		if (IsEqualRoundingTime(findmp.GetFrame(), copystarttime)) {
							//			srclocalparent0 = findmp.GetWorldMat();//copy情報としてローカルが格納されているがhipsなので実質global
							//		}
							//	}
							//}

							ChaMatrix smat0, rmat0, tmat0, tanimmat0;
							GetSRTandTraAnim(parentwm0, parentbone->GetNodeMat(), &smat0, &rmat0, &tmat0, &tanimmat0);
							ChaMatrix srcsmat0, srcrmat0, srctmat0, srctanimmat0;
							GetSRTandTraAnim(srclocalparent0, parentbone->GetNodeMat(), &srcsmat0, &srcrmat0, &srctmat0, &srctanimmat0);

							ChaMatrix newparentwm = srclocalparent * ChaMatrixInv(srctanimmat0) * tanimmat0;

							parentbone->UpdateCurrentWM(g_limitdegflag, curmotid, newframe, newparentwm);

						}
						else {
							//######################
							//NotMvがhips以外の場合
							//######################
							bool setbroflag = false;
							srcbone->UpdateParentWMReq(g_limitdegflag, setbroflag,
								curmotid, newframe, parentwm, parentwm);

						}
					}
				}
			}
		}
	}

	return operatingjointno;//!!!!!!!!!!
}

int PasteMotionPointJustInTerm(double copyStartTime, double copyEndTime, double startframe, double endframe)
{
	if (!s_model) {
		_ASSERT(0);
		return 1;
	}

	vector<CBone*> vecopebone;
	if (s_RboneAndPasteFlag == true) {
		vecopebone = s_pasteRJoint;
	}
	else {
		CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg();
		if (curcpdlg) {
			vecopebone = curcpdlg->m_cpvec;
		}
		else {
			vecopebone.clear();
		}
	}

	int cpnum = (int)vecopebone.size();

	double srcleng;
	double dstleng;
	srcleng = copyEndTime - copyStartTime + 1;
	dstleng = endframe - startframe + 1;
	double roundingstartframe, roundingendframe;
	roundingstartframe = RoundingTime(startframe);
	roundingendframe = RoundingTime(endframe);
	double dstframe;
	for (dstframe = roundingstartframe; dstframe <= roundingendframe; dstframe += 1.0) {

		ResetPasteDoneFlagReq(s_model->GetTopBone(false));//!!!!

		//####################################################################################
		//2023/11/02
		//コピーフレーム長が短く　ペーストフレーム長が長い場合にも　結果が滑らかになるように
		//srcjustframeの端数を考慮して　CalcPasteMotionPoint()で　姿勢を補間する
		//####################################################################################
		double dstrate = (dstframe - roundingstartframe) / dstleng;
		double srcjustframe = copyStartTime + dstrate * srcleng;
		double srcframe;
		srcframe = RoundingTime(srcjustframe);
		double srcframe2;
		srcframe2 = min((srcframe + 1.0), RoundingTime(copyEndTime));
		double interpolaterate = (srcjustframe - srcframe);

		vector<CPELEM2>::iterator itrcp;
		for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
			CBone* srcbone = itrcp->bone;
			if (srcbone && (srcbone->GetPasteDoneFlag() == false)) {
				CMotionPoint srcmp;
				srcmp = CalcPasteMotionPoint(srcbone, srcframe, srcframe2, interpolaterate);
				PasteMotionPoint(srcbone, srcmp, dstframe);

				srcbone->SetPasteDoneFlag(true);//!!!!!
			}

			//if (srcbone) {
			//	CMotionPoint srcmp = itrcp->mp;
			//	if (IsEqualRoundingTime(srcmp.GetFrame(), srcframe)) {
			//		PasteMotionPoint(srcbone, srcmp, dstframe);
			//	}
			//}
		}
	}
	ResetPasteDoneFlagReq(s_model->GetTopBone(false));//!!!!念のためにここでもリセットしておく



	////移動しないボーンのための処理
	int operatingjointno = 0;
	for (dstframe = roundingstartframe; dstframe <= roundingendframe; dstframe += 1.0) {

		ResetPasteDoneFlagReq(s_model->GetTopBone(false));//!!!!

		//double dstrate = (dstframe - startframe) / dstleng;
		double dstrate = (dstframe - roundingstartframe) / dstleng;

		double srcjustframe = copyStartTime + dstrate * srcleng;
		double srcframe;
		srcframe = RoundingTime(srcjustframe);
		double srcframe2;
		srcframe2 = min((srcframe + 1.0), RoundingTime(copyEndTime));
		double interpolaterate = (srcjustframe - srcframe);

		vector<CPELEM2>::iterator itrcp;
		for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
			CBone* srcbone = itrcp->bone;
			if (srcbone && (srcbone->GetPasteDoneFlag() == false)) {
				CMotionPoint srcmp = itrcp->mp;
				if (IsEqualRoundingTime(srcmp.GetFrame(), srcframe)) {
					int resultjointno = PasteNotMvParMotionPoint(srcbone, 
						RoundingTime(copyStartTime), srcframe, srcframe2, interpolaterate,
						RoundingTime(startframe), dstframe);

					if (resultjointno >= 0) {
						if (operatingjointno > resultjointno) {
							operatingjointno = resultjointno;//0以上で最小のboneno
						}
					}
					else {
						_ASSERT(0);
					}

					srcbone->SetPasteDoneFlag(true);//!!!!!
				}
			}
		}
	}


	//2023/02/05
	//limitedにペーストした場合には　ペーストしたものと同じものをunlimitedにもペースト
	//更に　limitedに　現在の制限角度を適用する
	//
	//ペースト範囲のオイラー角はPasteMotionPoint()-->SetWorldMat()-->CalcLocalEulXYZ()で計算済
	//
	if (g_limitdegflag == true) {
		bool allframeflag = false;
		bool setcursorflag = false;
		bool onpasteflag = true;
		CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);
		//MOTINFO* curmi = s_model->GetCurMotInfo();
		//if (curmi) {
		//	s_model->CalcBoneEul(g_limitdegflag, curmi->motid);//2023/10/20 CopyWorldToLimitedWorldの後　ApplyNewLimitsToWMよりも前
		//}
		ApplyNewLimitsToWM(s_model);
	}

	//vector<CPELEM>::iterator itrcp;
	//for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++){
	//	CBone* srcbone = itrcp->bone;
	//	if (srcbone){
	//		CMotionPoint srcmp = itrcp->mp;
	//		double newframe = (double)((int)(srcmp.GetFrame() - copyStartTime + startframe + 0.1));//!!!!!!!!!!!!!!!!!!
	//		if ((newframe >= startframe) && (newframe <= endframe)){
	//			PasteMotionPoint(srcbone, srcmp, newframe);
	//		}
	//	}
	//}

	////移動しないボーンのための処理
	//for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++){
	//	CBone* srcbone = itrcp->bone;
	//	if (srcbone){
	//		CMotionPoint srcmp = itrcp->mp;
	//		double newframe = (double)((int)(srcmp.GetFrame() - copyStartTime + startframe + 0.1));//!!!!!!!!!!!!!!!!!!
	//		if ((newframe >= startframe) && (newframe <= endframe)){
	//			PasteNotMvParMotionPoint(srcbone, srcmp, newframe);
	//		}
	//	}
	//}

	return 0;
}

//int PasteMotionPointAfterCopyEnd(double copyStartTime, double copyEndTime, double startframe, double endframe)
//{
//	vector<CPELEM2>::iterator itrcp;
//
//	double newframe;
//	for (newframe = (double)((int)(copyEndTime - copyStartTime + startframe + 0.1)); newframe <= endframe; newframe += 1.0) {
//		for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
//			CBone* srcbone = itrcp->bone;
//			if (srcbone) {
//				CMotionPoint srcmp = itrcp->mp;
//				if (itrcp->mp.GetFrame() == copyEndTime) {
//					PasteMotionPoint(srcbone, srcmp, newframe);
//				}
//			}
//		}
//	}
//
//	//移動しないボーンのための処理
//	for (newframe = (double)((int)(copyEndTime - copyStartTime + startframe + 0.1)); newframe <= endframe; newframe += 1.0) {
//		for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
//			CBone* srcbone = itrcp->bone;
//			if (srcbone) {
//				CMotionPoint srcmp = itrcp->mp;
//				if (itrcp->mp.GetFrame() == copyEndTime) {
//					PasteNotMvParMotionPoint(srcbone, srcmp, newframe);
//				}
//			}
//		}
//	}
//
//	return 0;
//}


void DispProgressCalcLimitedWM()
{
	LONG framenum = InterlockedAdd(&s_progressnum, 0);
	LONG curframe = InterlockedAdd(&s_progresscnt, 0);
	LONG modelnum = InterlockedAdd(&s_progressmodelnum, 0);
	LONG modelcnt = InterlockedAdd(&s_progressmodelcnt, 0);
	LONG befframenum = InterlockedAdd(&s_befprogressnum, 0);
	LONG befcurframe = InterlockedAdd(&s_befprogresscnt, 0);
	LONG befmodelnum = InterlockedAdd(&s_befprogressmodelnum, 0);
	LONG befmodelcnt = InterlockedAdd(&s_befprogressmodelcnt, 0);

	if ((framenum != 0) && (modelnum != 0) &&
		((framenum != befframenum) || (curframe != befcurframe) || (modelnum != befmodelnum) || (modelcnt != befmodelcnt))) {//ちらつかないように変更があったときだけ
		//if ((curframe % 25) == 0) {
		if (s_progresswnd) {
			HWND hProg2;
			hProg2 = GetDlgItem(s_progresswnd, IDC_PROGRESS1);
			if (hProg2) {
				//現在位置を設定 
				int curpercent = (int)((double)curframe / (double)framenum * 100.0);
				curpercent = min(100, curpercent);
				curpercent = max(0, curpercent);
				SendMessage(hProg2, PBM_SETPOS, (WPARAM)curpercent, 0);
			}
		}
		if (s_progresswnd) {
			WCHAR strnumcnt[1024] = { 0L };
			swprintf_s(strnumcnt, 1024, L"%d / %d chara (cnt / num)", modelcnt, modelnum);
			SetDlgItemTextW(s_progresswnd, IDC_STRBVH2FBXBATCH, strnumcnt);

			UpdateWindow(s_progresswnd);
		}
		//SleepEx(1, TRUE);
	//}
	}

	InterlockedExchange(&s_befprogressnum, framenum);
	InterlockedExchange(&s_befprogresscnt, curframe);
	InterlockedExchange(&s_befprogressmodelnum, modelnum);
	InterlockedExchange(&s_befprogressmodelcnt, modelcnt);
}

int OnFrameBatchThread()
{
	//bhv2fbx batch
	if (InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 1) {//under thread working
		LONG fbxnum = InterlockedAdd(&s_bvh2fbxnum, 0);
		LONG fbxcnt = InterlockedAdd(&s_bvh2fbxcnt, 0);
		LONG beffbxnum = InterlockedAdd(&s_befbvh2fbxnum, 0);
		LONG beffbxcnt = InterlockedAdd(&s_befbvh2fbxcnt, 0);
		if (s_bvh2fbxbatchwnd && (fbxnum > 0) &&
			((fbxnum != beffbxnum) || (fbxcnt != beffbxcnt))) {//ちらつかないように変更があったときだけ
			WCHAR strnumcnt[1024] = { 0L };
			swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (fbxcnt + 1), fbxnum);
			SetDlgItemTextW(s_bvh2fbxbatchwnd, IDC_STRBVH2FBXBATCH, strnumcnt);

			if (s_bvh2fbxbatchwnd) {
				HWND hProg = GetDlgItem(s_bvh2fbxbatchwnd, IDC_PROGRESS1);
				if (hProg) {
					//現在位置を設定
					int percent = (int)((double)fbxcnt / (double)fbxnum * 100.0);
					SendMessage(hProg, PBM_SETPOS, percent, 0);
					//ステップの範囲を設定 
					//SendMessage(hProg, PBM_SETSTEP, 1, 0);
				}
				UpdateWindow(s_bvh2fbxbatchwnd);
			}
		}
		InterlockedExchange(&s_befbvh2fbxnum, fbxnum);
		InterlockedExchange(&s_befbvh2fbxcnt, fbxcnt);
	}
	else if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 2) || (InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 3)) {//2はダイアログでのキャンセル
		InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)0);
		if (s_bvh2fbxbatchwnd) {
			SendMessage(s_bvh2fbxbatchwnd, WM_CLOSE, 0, 0);
		}
		InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)0);//WM_CLOSEで変わる可能性あり
		InterlockedExchange(&s_bvh2fbxcnt, 0);
		InterlockedExchange(&s_bvh2fbxnum, 0);
		InterlockedExchange(&s_befbvh2fbxnum, 0);
		InterlockedExchange(&s_befbvh2fbxcnt, 0);

		if (s_chascene && (s_chascene->GetModelNum() > 0)) {
			OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
		}
	}


	//retarget batch
	if (InterlockedAdd(&g_retargetbatchflag, 0) == 1) {//under thread working
		LONG retargetnum = InterlockedAdd(&s_retargetnum, 0);
		LONG retargetcnt = InterlockedAdd(&s_retargetcnt, 0);
		LONG befretargetnum = InterlockedAdd(&s_befretargetnum, 0);
		LONG befretargetcnt = InterlockedAdd(&s_befretargetcnt, 0);
		if (s_retargetbatchwnd && (retargetnum > 0) &&
			((retargetnum != befretargetnum) || (retargetcnt != befretargetcnt))) {//ちらつかないように変更があったときだけ
			WCHAR strnumcnt[1024] = { 0L };
			swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", retargetcnt, retargetnum);
			SetDlgItemTextW(s_retargetbatchwnd, IDC_STRBVH2FBXBATCH, strnumcnt);

			if (s_retargetbatchwnd) {
				HWND hProg = GetDlgItem(s_retargetbatchwnd, IDC_PROGRESS1);
				if (hProg) {
					//現在位置を設定
					int percent = (int)((double)retargetcnt / (double)retargetnum * 100.0);
					SendMessage(hProg, PBM_SETPOS, percent, 0);
					//ステップの範囲を設定 
					//SendMessage(hProg, PBM_SETSTEP, 1, 0);
				}
				UpdateWindow(s_retargetbatchwnd);
			}
		}
		InterlockedExchange(&s_befretargetnum, retargetnum);
		InterlockedExchange(&s_befretargetcnt, retargetcnt);
	}
	else if ((InterlockedAdd(&g_retargetbatchflag, 0) == 2) || (InterlockedAdd(&g_retargetbatchflag, 0) == 3)) {//2はダイアログでのキャンセル
		InterlockedExchange(&g_retargetbatchflag, (LONG)0);
		if (s_retargetbatchwnd) {
			SendMessage(s_retargetbatchwnd, WM_CLOSE, 0, 0);
		}
		InterlockedExchange(&g_retargetbatchflag, (LONG)0);//WM_CLOSEで変わる可能性あり
		InterlockedExchange(&s_retargetcnt, 0);
		InterlockedExchange(&s_retargetnum, 0);
		InterlockedExchange(&s_befretargetnum, 0);
		InterlockedExchange(&s_befretargetcnt, 0);


		//2023/02/15
		//ChangeLimitDegFlag(s_savelimitdegflag, true, true);//2023/10/23 1.2.0.27_RC2にて　コメントアウト
		OnModelMenu(true, s_saveretargetmodel, 1);
	}


	return 0;
}

int OnFrameStartPreview(double curtime, double* psavetime)
{

	//normal preview start
	if (s_calclimitedwmState == 2) {

		//2022/08/12 リアルタイム計算に変更

		//if (InterlockedAdd(&g_calclimitedwmflag, 0) == 1) {//under threadfunc working
		//	DispProgressCalcLimitedWM();
		//}
		//else if (InterlockedAdd(&g_calclimitedwmflag, 0) == 2) {//confirm threadfunc finished
		s_calclimitedwmState = 0;
		g_previewFlag = 1;//!!!!!!
		InterlockedExchange(&g_calclimitedwmflag, (LONG)0);
		//}
		*psavetime = curtime;
	}
	if (s_calclimitedwmState == 1) {
		s_calclimitedwmState = 2;
		//CalcLimitedWorldMat();//2022/08/12 リアルタイム計算に変更
	}

	//preview to backword
	if (s_calclimitedwmState == 22) {

		//2022/08/12 リアルタイム計算に変更

		//if (InterlockedAdd(&g_calclimitedwmflag, 0) == 1) {//under threadfunc working
		//	DispProgressCalcLimitedWM();
		//}
		//else if (InterlockedAdd(&g_calclimitedwmflag, 0) == 2) {//confirm threadfunc finished
		s_calclimitedwmState = 0;
		g_previewFlag = -1;//!!!!!
		InterlockedExchange(&g_calclimitedwmflag, (LONG)0);
		//}
		*psavetime = curtime;
	}
	if (s_calclimitedwmState == 11) {
		s_calclimitedwmState = 22;
		//CalcLimitedWorldMat();//2022/08/12 リアルタイム計算に変更
	}


	//bullet simulation start
	if (s_calclimitedwmState == 107) {
		s_calclimitedwmState = 0;
		StartBt(s_model, TRUE, 0, 1);
		*psavetime = curtime;
	}
	if ((s_calclimitedwmState >= 103) && (s_calclimitedwmState <= 106)) {
		s_calclimitedwmState++;
	}
	if (s_calclimitedwmState == 102) {

		//2022/08/12 リアルタイム計算に変更

		//if (InterlockedAdd(&g_calclimitedwmflag, 0) == 1) {//under threadfunc working
		//	DispProgressCalcLimitedWM();
		//}
		//else if (InterlockedAdd(&g_calclimitedwmflag, 0) == 2) {//confirm threadfunc finished
		s_calclimitedwmState = 103;
		InterlockedExchange(&g_calclimitedwmflag, (LONG)0);
		//}
	}
	if (s_calclimitedwmState == 101) {
		s_calclimitedwmState = 102;
		//CalcLimitedWorldMat();//2022/08/12 リアルタイム計算に変更
		*psavetime = curtime;
	}
	if (s_calclimitedwmState == 1001) {
		s_calclimitedwmState = 102;
		//CalcLimitedWorldMat();//2022/08/12 リアルタイム計算に変更
		g_btsimurecflag = true;//rec flag
		*psavetime = curtime;
	}

	return 0;
}



int OnSpriteUndo()
{
	static bool s_underoperation = false;//再入禁止用
	if (s_underoperation == true) {
		return 0;
	}
	s_underoperation = true;


	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));


	bool undodoneflag = false;
	double tmpselectstart = 1.0;
	double tmpselectend = 1.0;
	double tmpapplyrate = 50.0;

	BRUSHSTATE brushstate;
	brushstate.Init();


	///////////// undo
	if (s_model && (s_undoFlag == true)) {
		//undo
		StopBt();
		s_model->RollBackUndoMotion(g_limitdegflag, g_mainhwnd,
			0, &s_curboneno, &s_curbaseno,
			&tmpselectstart, &tmpselectend, &tmpapplyrate, &brushstate);//!!!!!!!!!!!

		RollbackBrushState(brushstate);//ブラシパラメータ復元

		undodoneflag = true;
	}
	else if (s_model && (s_redoFlag == true))
	{
		//redo
		StopBt();
		s_model->RollBackUndoMotion(g_limitdegflag, g_mainhwnd,
			1, &s_curboneno, &s_curbaseno,
			&tmpselectstart, &tmpselectend, &tmpapplyrate, &brushstate);//!!!!!!!!!!!

		RollbackBrushState(brushstate);//ブラシパラメータ復元

		undodoneflag = true;
	}

	if (s_model && (undodoneflag == true)) {
		//s_copyKeyInfoList.clear();
		//s_deletedKeyInfoList.clear();
		//s_selectKeyInfoList.clear();

		if (s_model->GetCurMotInfo() && (s_model->GetCurMotInfo()->motid != s_curmotid)) {
			int chkcnt = 0;
			int findflag = 0;
			map<int, MOTINFO*>::iterator itrmi;
			for (itrmi = s_model->GetMotInfoBegin(); itrmi != s_model->GetMotInfoEnd(); itrmi++) {
				MOTINFO* curmi = itrmi->second;
				if (curmi) {
					if (curmi == s_model->GetCurMotInfo()) {
						findflag = 1;
						break;
					}
					chkcnt++;
				}
			}

			if (findflag == 1) {
				int selindex;
				selindex = chkcnt;
				OnAnimMenu(true, selindex, 0);
			}
		}
		else {
			if (s_model) {
				//メニュー書き換え, timeline update
				OnAnimMenu(true, s_motmenuindexmap[s_model], 0);
			}
		}

		if (s_curboneno >= 0) {
			ChangeCurrentBone();

			int curlineno = s_boneno2lineno[s_curboneno];
			if (s_owpTimeline) {
				s_owpTimeline->setCurrentLine(curlineno, true);
			}
			SetTimelineMark();
			SetLTimelineMark(s_curboneno);
		}

		OnGUIEventSpeed();

		MOTINFO* curmi;
		curmi = s_model->GetCurMotInfo();
		if (curmi) {
			s_buttonselectstart = max(0.0, tmpselectstart);
			s_buttonselectstart = min((curmi->frameleng - 1.0), s_buttonselectstart);

			s_buttonselectend = max(0.0, tmpselectend);
			s_buttonselectend = min((curmi->frameleng - 1.0), s_buttonselectend);


			//注意：applyrateはbrushstateには入っていない
			g_applyrate = (int)tmpapplyrate;
			CEditRange::SetApplyRate((double)g_applyrate);

			OnTimeLineButtonSelectFromSelectStartEnd(0);
			SetShowPosTime();//CreateMotionBrushより前で呼ばないと　TopPosを変えた後のUndoRedoで　描画がずれることがある

			DisplayApplyRateText();

			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}

			//SetShowPosTime();//CreateMotionBrushより前で呼ばないと　TopPosを変えた後のUndoRedoで　描画がずれることがある

			SavePlayingStartEnd();


			//##############################################
			//2023/02/05
			//制限角度値とCMotionPointを丸ごと復元するので
			//limitedの計算し直しの必要なし
			//##############################################
			//#########################################################################
			//2022/12/06
			//保存時とは制限角度が異なっている可能性があるので　制限角度のために再計算
			//#########################################################################
			//if (g_limitdegflag == true) {
			//	ClearLimitedWM(s_model);
			//	ApplyNewLimitsToWM(s_model);//2022/12/18
			//}


			//limitedへの変更を　worldに反映
			if (g_limitdegflag == true) {
				bool allframeflag = false;
				bool setcursorflag = false;
				bool onpasteflag = false;
				int operatingjointno = 0;
				if (s_model && s_model->GetTopBone()) {
					operatingjointno = s_model->GetTopBone(false)->GetBoneNo();
				}
				CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);
			}
			

			//2023/11/03 hipsを３回転してアンドゥしたときに　編集範囲の境目で　オイラーグラフが連続するために必要
			s_model->CalcBoneEul(g_limitdegflag, curmi->motid);




			refreshEulerGraph();

			//s_selectFlag = true;
			//s_LupFlag = true;
		}
	}


	//select復元
	//s_pickinfo.buttonflag = PICK_CENTER;
	s_pickinfo.pickobjno = s_curboneno;



	s_undoFlag = false;
	s_redoFlag = false;

	s_underoperation = false;


	if (oldcursor != NULL) {
		SetCursor(oldcursor);
	}

	return 0;

}
int OnFrameUndo(bool fromds, int fromdskind)
{
	static bool s_underoperation = false;//再入禁止用
	if (s_underoperation == true) {
		return 0;
	}
	s_underoperation = true;


	//2022/11/07 playerbuttonのprevrange, nextrangeに　undo, redoとして対応


	if (s_undoFlag == true) {
		//playerbutton prevrange
		//undo
		s_undoFlag = true;
		OnSpriteUndo();
	}
	else if (s_redoFlag == true) {
		//playerbutton nextrange
		//redo
		s_redoFlag = true;
		OnSpriteUndo();
	}
	//keyboard event
	else if (fromds || (s_model && g_controlkey && (g_keybuf['Z'] & 0x80) && !(g_savekeybuf['Z'] & 0x80))) {

		if (((fromds && (fromdskind == 1)) || (g_keybuf[VK_SHIFT] & 0x80)) && (s_undoFlag == false) && (s_redoFlag == false)) {
			//redo
			s_redoFlag = true;
			OnSpriteUndo();
		}
		else if (((fromds && (fromdskind == 0)) || !fromds) && (s_undoFlag == false) && (s_redoFlag == false)) {
			//undo
			s_undoFlag = true;
			OnSpriteUndo();
		}
	}

	s_underoperation = false;

	return 0;
}

int OnFrameUpdateGround()
{

	if (s_ground) {
		ChaMatrix tmpwm = s_ground->GetWorldMat();
		s_ground->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
	}

	if (s_gplane && s_bpWorld && s_bpWorld->m_rigidbodyG) {
		ChaMatrix gpmat = s_inimat;
		gpmat.data[MATI_42] = s_bpWorld->m_gplaneh;
		s_gplane->UpdateMatrix(g_limitdegflag, &gpmat, &s_matVP);
	}
	return 0;
}

int OnFrameInitBtWorld()
{
	if (!s_model || !s_btWorld) {
		return 0;
	}

	CModel* curmodel = s_model;


	//vector<MODELELEM>::iterator itrmodel;
	//for (itrmodel = s_modelindex.begin(); itrmodel != s_modelindex.end(); itrmodel++){
		//CModel* curmodel = itrmodel->modelptr;
		//if (curmodel && (curmodel->GetLoadedFlag() == true) && (curmodel->GetCreateBtFlag() == false)){
	curmodel->SetBtWorld(s_btWorld);
	//	CallF(curmodel->CreateBtObject(s_coldisp, 1), return 1);
	//}

	//curmodel->PlusPlusBtCnt();

//}
	return 0;
}

int InitPluginMenu()
{

	//g_SampleUI.AddComboBox(IDC_COMBO_MOTIONBRUSH_METHOD, 35, iY += addh, ctrlxlen + 25, ctrlh);
	//s_ui_motionbrush = g_SampleUI.GetControl(IDC_COMBO_MOTIONBRUSH_METHOD);
	//_ASSERT(s_ui_motionbrush);
	//s_dsutgui0.push_back(s_ui_motionbrush);
	//s_dsutguiid0.push_back(IDC_COMBO_MOTIONBRUSH_METHOD);
	//CDXUTComboBox* pComboBox5 = g_SampleUI.GetComboBox(IDC_COMBO_MOTIONBRUSH_METHOD);
	//pComboBox5->RemoveAllItems();
	//pComboBox5->AddItem(L"Linear", ULongToPtr(0));
	//pComboBox5->AddItem(L"Cos(x+PI)", ULongToPtr(1));
	//pComboBox5->AddItem(L"Cos(x^2+PI)", ULongToPtr(2));
	//pComboBox5->AddItem(L"Rect", ULongToPtr(3));
	//pComboBox5->SetSelectedByData(ULongToPtr(0));


	s_plugin = new CPluginElem[MAXPLUGIN];
	if (!s_plugin) {
		DbgOut(L"viewer : InitPluginMenu : plugin alloc error !!!\n");
		_ASSERT(0);
		return 1;
	}

	///////////
	WCHAR plugindir[MAX_PATH];
	wcscpy_s(plugindir, MAX_PATH, g_basedir);
	WCHAR* lasten = 0;
	WCHAR* last2en = 0;
	lasten = wcsrchr(plugindir, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return S_FALSE;
	}
	*lasten = 0L;
	last2en = wcsrchr(plugindir, TEXT('\\'));
	if (!last2en) {
		_ASSERT(0);
		return S_FALSE;
	}
	*last2en = 0L;
	wcscat_s(plugindir, MAX_PATH, L"\\BrushesFolder\\");

	WCHAR finddir[_MAX_PATH];
	ZeroMemory(finddir, sizeof(WCHAR) * _MAX_PATH);
	wcscpy_s(finddir, _MAX_PATH, plugindir);
	wcscat(finddir, L"*.dll");

	///////////
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;
	hFind = FindFirstFile(finddir, &FindFileData);
	int pluginno = 0;

	if (hFind != INVALID_HANDLE_VALUE) {
		WCHAR pluginpath[_MAX_PATH];
		wcscpy_s(pluginpath, _MAX_PATH, plugindir);
		wcscat(pluginpath, FindFileData.cFileName);
		DbgOut(L"InitPluginMenu : FindFirst : %s\r\n", FindFileData.cFileName);

		(s_plugin + pluginno)->SetFilePath(pluginpath);
		(s_plugin + pluginno)->LoadPlugin();
		pluginno++;

		BOOL bret = 1;
		while (bret != 0) {
			bret = FindNextFile(hFind, &FindFileData);
			if (bret != 0) {

				wcscpy_s(pluginpath, _MAX_PATH, plugindir);
				wcscat(pluginpath, FindFileData.cFileName);
				DbgOut(L"InitPluginMenu : FindNext : %s\r\n", FindFileData.cFileName);

				(s_plugin + pluginno)->SetFilePath(pluginpath);
				(s_plugin + pluginno)->LoadPlugin();

				pluginno++;
			}
		}

		FindClose(hFind);
	}


	//一番最初のブラシをカレントのブラシとしてセット
	if (g_motionbrush_method <= 0) {
		int pluginno;
		for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
			if ((s_plugin + pluginno)->validflag == 1) {
				g_motionbrush_method = (s_plugin + pluginno)->menuid;//!!!!!!!!!!
				break;
			}
		}
	}



	////g_SampleUI.AddComboBox(IDC_COMBO_MOTIONBRUSH_METHOD, 35, iY += addh, ctrlxlen + 25, ctrlh);
	////s_ui_motionbrush = g_SampleUI.GetControl(IDC_COMBO_MOTIONBRUSH_METHOD);
	////_ASSERT(s_ui_motionbrush);
	////s_dsutgui0.push_back(s_ui_motionbrush);
	////s_dsutguiid0.push_back(IDC_COMBO_MOTIONBRUSH_METHOD);
	//CDXUTComboBox* pComboBox5 = g_SampleUI.GetComboBox(IDC_COMBO_MOTIONBRUSH_METHOD);
	//pComboBox5->RemoveAllItems();


	////pComboBox5->AddItem(L"Linear", ULongToPtr(0));
	////pComboBox5->AddItem(L"Cos(x+PI)", ULongToPtr(1));
	////pComboBox5->AddItem(L"Cos(x^2+PI)", ULongToPtr(2));
	////pComboBox5->AddItem(L"Rect", ULongToPtr(3));
	////pComboBox5->SetSelectedByData(ULongToPtr(0));
	int setno = 0;
	int firstmenuno = -1;
	for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
		if ((s_plugin + pluginno)->validflag == 1) {
			int menuid = setno;
			if (firstmenuno == -1) {
				firstmenuno = menuid;
			}
			//pComboBox5->AddItem((s_plugin + pluginno)->pluginname, ULongToPtr(menuid));
			(s_plugin + pluginno)->menuid = menuid;
			setno++;
		}
	}
	//pComboBox5->SetSelectedByData(ULongToPtr(firstmenuno));

	return 0;
}


bool UnderDragOperation_L()
{

	if (s_twistcameraFlag) {
		return false;
	}
	if (s_rbuttonSelectFlag) {
		return false;
	}


	if (s_oprigflag == 0) {
		if ((s_ikkind == 0) && (s_editmotionflag >= 0)) {
			if (s_pickinfo.buttonflag == PICK_CENTER) {
				return true;
			}
			else if ((s_pickinfo.buttonflag == PICK_X) ||
				(s_pickinfo.buttonflag == PICK_Y) ||
				(s_pickinfo.buttonflag == PICK_Z) ||
				(s_pickinfo.buttonflag == PICK_SPA_X) ||
				(s_pickinfo.buttonflag == PICK_SPA_Y) ||
				(s_pickinfo.buttonflag == PICK_SPA_Z)) {
				return true;
			}
		}
		else if ((s_ikkind == 1) && (s_editmotionflag >= 0)) {
			if (s_pickinfo.buttonflag == PICK_CENTER) {
				return true;
			}
			else if ((s_pickinfo.buttonflag == PICK_X) ||
				(s_pickinfo.buttonflag == PICK_Y) ||
				(s_pickinfo.buttonflag == PICK_Z) ||
				(s_pickinfo.buttonflag == PICK_SPA_X) ||
				(s_pickinfo.buttonflag == PICK_SPA_Y) ||
				(s_pickinfo.buttonflag == PICK_SPA_Z)) {
				return true;
			}
		}
		else if ((s_ikkind == 2) && (s_editmotionflag >= 0)) {
			if (s_pickinfo.buttonflag == PICK_CENTER) {
				return true;
			}
			else if ((s_pickinfo.buttonflag == PICK_X) ||
				(s_pickinfo.buttonflag == PICK_Y) ||
				(s_pickinfo.buttonflag == PICK_Z) ||
				(s_pickinfo.buttonflag == PICK_SPA_X) ||
				(s_pickinfo.buttonflag == PICK_SPA_Y) ||
				(s_pickinfo.buttonflag == PICK_SPA_Z)) {
				return true;
			}
		}

	}
	else {
		if (s_customrigbone && (s_customrigno >= 0) && (s_editmotionflag >= 0)) {
			return true;
		}
	}

	//camera
	if ((s_pickinfo.buttonflag == PICK_CAMROT) ||
		(s_pickinfo.buttonflag == PICK_CAMMOVE) ||
		(s_pickinfo.buttonflag == PICK_CAMDIST)) {
		return true;
	}

	return false;
}

bool UnderDragOperation_R()
{
	if (s_twistcameraFlag == true) {
		return true;
	}
	if (s_rbuttonSelectFlag == true) {
		return true;
	}


	return false;
}



int VisibleUtDialog()
{
	bool visibleflag = !(UnderDragOperation_R() || UnderDragOperation_L());

	if (visibleflag != s_utcontrolvisible) {

		//g_SampleUI.SetVisible(visibleflag);

		s_utcontrolvisible = visibleflag;
	}

	return 0;
}


int CreateUtDialog()
{

//	// Initialize dialogs
//	//g_SettingsDlg.Init(&g_DialogResourceManager);
//	g_SampleUI.Init(&g_DialogResourceManager);
//
//	int iY;
//	g_SampleUI.SetCallback(OnGUIEvent);
//	//iY = 15;
//	iY = 0;
//
//	int ctrlh = 25;
//	int addh = ctrlh + 2;
//
//	int ctrlxlen = 120;
//	int checkboxxlen = 120;
//
//	WCHAR sz[100];
//	//################
//	//utguikind == 0
//	//################
//		//iY += 24;
//
//	int iX0;
//
//	if (g_4kresolution) {
//		//iY = s_mainheight - (520 - MAINMENUAIMBARH);
//		//iY = s_mainheight - 210 - addh - 10;
//		//iY = s_mainheight - 210 - 10;
//
//		//iY = s_mainheight - 210 - 10 - 3 * addh;
//		//iY = s_mainheight - 210 - 2 * addh - 10;
//		iY = s_mainheight - 210 - 10 - addh - 10;
//		iX0 = s_mainwidth / 2 - 180 - 2 * 180 - 30;
//	}
//	else {
//		//iY = 0;
//		iY = 0;
//		//iY = addh;
//		iX0 = 0;
//	}
//
//
//	s_dsutgui0.clear();
//	s_dsutguiid0.clear();
//
//
//	if (g_4kresolution) {
//
//		//2022/11/08
//		//4KTVでウインドウ大を選んだ場合　コンボボックスは見切れないように　一番上に配置
//
//		g_SampleUI.AddComboBox(IDC_COMBO_IKLEVEL, iX0 + 35, 20, ctrlxlen, ctrlh);//Comboの要素が見切れないようになるべく上方に配置
//		s_ui_iklevel = g_SampleUI.GetControl(IDC_COMBO_IKLEVEL);
//		_ASSERT(s_ui_iklevel);
//		s_dsutgui0.push_back(s_ui_iklevel);
//		s_dsutguiid0.push_back(IDC_COMBO_IKLEVEL);
//		CDXUTComboBox* pComboBox0 = g_SampleUI.GetComboBox(IDC_COMBO_IKLEVEL);
//		pComboBox0->RemoveAllItems();
//		int level;
//		for (level = 0; level < 15; level++) {
//			ULONG levelval = (ULONG)level;
//			WCHAR strlevel[256];
//			swprintf_s(strlevel, 256, L"%02d", level);
//			pComboBox0->AddItem(strlevel, ULongToPtr(levelval));
//		}
//		pComboBox0->SetSelectedByData(ULongToPtr(1));
//
//		g_SampleUI.AddComboBox(IDC_COMBO_BONEAXIS, (s_mainwidth / 2 - 180 - 180 - 40 + 35), 20, ctrlxlen, ctrlh);
//		s_ui_boneaxis = g_SampleUI.GetControl(IDC_COMBO_BONEAXIS);
//		_ASSERT(s_ui_boneaxis);
//		s_dsutgui0.push_back(s_ui_boneaxis);
//		s_dsutguiid0.push_back(IDC_COMBO_BONEAXIS);
//		CDXUTComboBox* pComboBox3 = g_SampleUI.GetComboBox(IDC_COMBO_BONEAXIS);
//		pComboBox3->RemoveAllItems();
//		WCHAR straxis[256];
//		ULONG boneaxisindex;
//		swprintf_s(straxis, 256, L"Current");
//		boneaxisindex = BONEAXIS_CURRENT;
//		pComboBox3->AddItem(straxis, ULongToPtr(boneaxisindex));
//		swprintf_s(straxis, 256, L"Parent");
//		boneaxisindex = BONEAXIS_PARENT;
//		pComboBox3->AddItem(straxis, ULongToPtr(boneaxisindex));
//		swprintf_s(straxis, 256, L"Global");
//		boneaxisindex = BONEAXIS_GLOBAL;
//		pComboBox3->AddItem(straxis, ULongToPtr(boneaxisindex));
//		swprintf_s(straxis, 256, L"BindPose");
//		boneaxisindex = BONEAXIS_BINDPOSE;
//		pComboBox3->AddItem(straxis, ULongToPtr(boneaxisindex));
//		pComboBox3->SetSelectedByData(ULongToPtr((LONG)g_boneaxis));
//	}
//
//
//	g_SampleUI.AddComboBox(IDC_COMBO_FPS, iX0 + 25, iY, ctrlxlen, ctrlh);//Comboの要素が見切れないようになるべく上方に配置
//	s_ui_fpskind = g_SampleUI.GetControl(IDC_COMBO_FPS);
//	_ASSERT(s_ui_fpskind);
//	s_dsutgui0.push_back(s_ui_fpskind);
//	s_dsutguiid0.push_back(IDC_COMBO_FPS);
//	CDXUTComboBox* pComboBoxFps = g_SampleUI.GetComboBox(IDC_COMBO_FPS);
//	pComboBoxFps->RemoveAllItems();
//	WCHAR strfpskind[256];
//	swprintf_s(strfpskind, 256, L"free fps");
//	pComboBoxFps->AddItem(strfpskind, ULongToPtr(0));
//	swprintf_s(strfpskind, 256, L"100fps");
//	pComboBoxFps->AddItem(strfpskind, ULongToPtr(1));
//	swprintf_s(strfpskind, 256, L"60fps");
//	pComboBoxFps->AddItem(strfpskind, ULongToPtr(2));
//	swprintf_s(strfpskind, 256, L"30fps");
//	pComboBoxFps->AddItem(strfpskind, ULongToPtr(3));
//	swprintf_s(strfpskind, 256, L"15fps");
//	pComboBoxFps->AddItem(strfpskind, ULongToPtr(4));
//	pComboBoxFps->SetSelectedByData(ULongToPtr(0));
//	g_fpskind = 0;
//	g_VSync = false;
//
//
//	swprintf_s(sz, 100, L"Lighting");
//	g_SampleUI.AddCheckBox(IDC_LIGHTING, sz, iX0 + 25, iY += addh, 
//		checkboxxlen, 16, (bool)g_lightflag, 0U, false, &s_LightingCheckBox);
//	s_ui_lighting = g_SampleUI.GetControl(IDC_LIGHTING);
//	_ASSERT(s_ui_lighting);
//	s_dsutgui0.push_back(s_ui_lighting);//s_dsutgui1
//	s_dsutguiid0.push_back(IDC_LIGHTING);//s_dsutgui1
//
//	g_SampleUI.AddSlider(IDC_LIGHT_SCALE, iX0 + 25, iY += addh, 100, ctrlh, 0, 20, (int)(g_fLightScale * 10.0f));
//	s_ui_lightscale = g_SampleUI.GetControl(IDC_LIGHT_SCALE);
//	_ASSERT(s_ui_lightscale);
//	s_dsutgui0.push_back(s_ui_lightscale);
//	s_dsutguiid0.push_back(IDC_LIGHT_SCALE);
//
//	g_SampleUI.AddCheckBox(IDC_BMARK, L"DispBone", iX0 + 25, iY += addh, 
//		checkboxxlen, 16, true, 0U, false, &s_BoneMarkCheckBox);
//	s_ui_dispbone = g_SampleUI.GetControl(IDC_BMARK);
//	_ASSERT(s_ui_dispbone);
//	s_dsutgui0.push_back(s_ui_dispbone);
//	s_dsutguiid0.push_back(IDC_BMARK);
//	g_SampleUI.AddCheckBox(IDC_RMARK, L"DispRigid", iX0 + 25, iY += addh, checkboxxlen, 16, true, 0U, false, &s_RigidMarkCheckBox);
//	s_ui_disprigid = g_SampleUI.GetControl(IDC_RMARK);
//	_ASSERT(s_ui_disprigid);
//	s_dsutgui0.push_back(s_ui_disprigid);
//	s_dsutguiid0.push_back(IDC_RMARK);
//
//
//	s_savebonemarkflag = 1;
//	s_saverigidmarkflag = 1;
//
//
//	g_SampleUI.AddCheckBox(IDC_CAMTARGET, L"LockToSel", iX0 + 25, iY += addh, ctrlxlen, 16, false, 0U, false, &s_CamTargetCheckBox);
//	s_ui_locktosel = g_SampleUI.GetControl(IDC_CAMTARGET);
//	_ASSERT(s_ui_locktosel);
//	s_dsutgui0.push_back(s_ui_locktosel);
//	s_dsutguiid0.push_back(IDC_CAMTARGET);
//
//
//	//iY += addh;
//
//	if (g_4kresolution == false) {
//		//2022/11/08
//		//4KTVではない場合　コンボボックスはコンパクトに見切れない程度に上に配置　(g_4kresolution == true時は上述)
//
//		g_SampleUI.AddComboBox(IDC_COMBO_IKLEVEL, iX0 + 25, iY += addh, ctrlxlen, ctrlh);
//		s_ui_iklevel = g_SampleUI.GetControl(IDC_COMBO_IKLEVEL);
//		_ASSERT(s_ui_iklevel);
//		s_dsutgui0.push_back(s_ui_iklevel);
//		s_dsutguiid0.push_back(IDC_COMBO_IKLEVEL);
//		CDXUTComboBox* pComboBox0 = g_SampleUI.GetComboBox(IDC_COMBO_IKLEVEL);
//		pComboBox0->RemoveAllItems();
//		int level;
//		for (level = 0; level < 15; level++) {
//			ULONG levelval = (ULONG)level;
//			WCHAR strlevel[256];
//			swprintf_s(strlevel, 256, L"%02d", level);
//			pComboBox0->AddItem(strlevel, ULongToPtr(levelval));
//		}
//		pComboBox0->SetSelectedByData(ULongToPtr(1));
//
//		g_SampleUI.AddComboBox(IDC_COMBO_BONEAXIS, iX0 + 25, iY += addh, ctrlxlen, ctrlh);
//		s_ui_boneaxis = g_SampleUI.GetControl(IDC_COMBO_BONEAXIS);
//		_ASSERT(s_ui_boneaxis);
//		s_dsutgui0.push_back(s_ui_boneaxis);
//		s_dsutguiid0.push_back(IDC_COMBO_BONEAXIS);
//		CDXUTComboBox* pComboBox3 = g_SampleUI.GetComboBox(IDC_COMBO_BONEAXIS);
//		pComboBox3->RemoveAllItems();
//		WCHAR straxis[256];
//		ULONG boneaxisindex;
//		swprintf_s(straxis, 256, L"Current");
//		boneaxisindex = BONEAXIS_CURRENT;
//		pComboBox3->AddItem(straxis, ULongToPtr(boneaxisindex));
//		swprintf_s(straxis, 256, L"Parent");
//		boneaxisindex = BONEAXIS_PARENT;
//		pComboBox3->AddItem(straxis, ULongToPtr(boneaxisindex));
//		swprintf_s(straxis, 256, L"Global");
//		boneaxisindex = BONEAXIS_GLOBAL;
//		pComboBox3->AddItem(straxis, ULongToPtr(boneaxisindex));
//		swprintf_s(straxis, 256, L"BindPose");
//		boneaxisindex = BONEAXIS_BINDPOSE;
//		pComboBox3->AddItem(straxis, ULongToPtr(boneaxisindex));
//		pComboBox3->SetSelectedByData(ULongToPtr((LONG)g_boneaxis));
//	}
//
//	g_SampleUI.AddCheckBox(IDC_PRECISEONPREVIEWTOO, L"PreciseOnPreviewToo", iX0 + 25, iY += addh, checkboxxlen, 16, g_preciseOnPreviewToo, 0U, false, &s_PreciseCheckBox);
//	s_ui_precise = g_SampleUI.GetControl(IDC_PRECISEONPREVIEWTOO);
//	_ASSERT(s_ui_precise);
//	s_dsutgui0.push_back(s_ui_precise);
//	s_dsutguiid0.push_back(IDC_PRECISEONPREVIEWTOO);
//
//
//	g_SampleUI.AddCheckBox(IDC_X180, L"X180", 
//		iX0 + 25, iY += addh, checkboxxlen / 2 - 5, 16, 
//		g_x180flag, 0U, false, &s_X180CheckBox);
//	s_ui_x180 = g_SampleUI.GetControl(IDC_X180);
//	_ASSERT(s_ui_x180);
//	s_dsutgui0.push_back(s_ui_x180);
//	s_dsutguiid0.push_back(IDC_X180);
//
//
//	g_SampleUI.AddCheckBox(IDC_TRAROT, L"TRot", 
//		iX0 + checkboxxlen / 2 + 5 + 30, iY, checkboxxlen / 2 - 5, 16,
//		g_rotatetanim, 0U, false, &s_TraRotCheckBox);
//	s_ui_trarot = g_SampleUI.GetControl(IDC_TRAROT);
//	_ASSERT(s_ui_trarot);
//	s_dsutgui0.push_back(s_ui_trarot);
//	s_dsutguiid0.push_back(IDC_TRAROT);
//
//	if (g_4kresolution) {
//		//iY = s_mainheight - (520 - MAINMENUAIMBARH);
//		//iY = s_mainheight - 210 - 3 * addh - 10;
//		//iY = s_mainheight - 210 - 4 * addh - 10;
//
//		//iY = s_mainheight - 210 - 2 * addh - 10;
//		//iY = s_mainheight - 210 - 3 * addh - 10;
//		iY = s_mainheight - 210 - addh - 10;
//		iX0 = s_mainwidth / 2 - 180 - 180 - 40;
//	}
//	else {
//		//そのまま続き
//		//iY += addh;
//		iX0 = 0;
//	}
//
//	{//2-->1移動
//		swprintf_s(sz, 100, L"UpdateThreads : %d", g_UpdateMatrixThreads);
//		//g_SampleUI.AddStatic(IDC_STATIC_NUMTHREAD, sz, iX0, iY += addh2, ctrlxlen, ctrlh);
//		g_SampleUI.AddStatic(IDC_STATIC_UMTHREADS, sz, iX0 + 35, iY += addh, ctrlxlen, 18);
//		s_ui_umthreads = g_SampleUI.GetControl(IDC_STATIC_UMTHREADS);
//		_ASSERT(s_ui_umthreads);
//		s_dsutgui0.push_back(s_ui_umthreads);//s_dsutgui1
//		s_dsutguiid0.push_back(IDC_STATIC_UMTHREADS);//s_dsutgui1
//		//g_SampleUI.AddSlider(IDC_SL_NUMTHREAD, iX0, iY += addh2, 100, ctrlh, 1, 4, g_numthread);
//		g_SampleUI.AddSlider(IDC_SL_UMTHREADS, iX0 + 35, iY += (18 + 2), 100, ctrlh, 1, MAXUPDATEMATRIXTHREAD, g_UpdateMatrixThreads);
//		s_ui_slumthreads = g_SampleUI.GetControl(IDC_SL_UMTHREADS);
//		_ASSERT(s_ui_slumthreads);
//		s_dsutgui0.push_back(s_ui_slumthreads);//s_dsutgui1
//		s_dsutguiid0.push_back(IDC_SL_UMTHREADS);//s_dsutgui1
//
//		g_SampleUI.AddCheckBox(IDC_HIGHRPM, L"high rpm", iX0 + 35, iY += addh, checkboxxlen, 16, false, 0U, false, &s_HighRpmCheckBox);
//		s_ui_highrpmon = g_SampleUI.GetControl(IDC_HIGHRPM);
//		_ASSERT(s_ui_highrpmon);
//		s_dsutgui0.push_back(s_ui_highrpmon);
//		s_dsutguiid0.push_back(IDC_HIGHRPM);
//
//		swprintf_s(sz, 100, L"Speed: %0.2f", g_dspeed);
//		//g_SampleUI.AddStatic(IDC_SPEED_STATIC, sz, iX0, iY += addh, ctrlxlen, ctrlh);
//		g_SampleUI.AddStatic(IDC_SPEED_STATIC, sz, iX0 + 35, iY += addh, ctrlxlen, 18);
//		s_ui_texspeed = g_SampleUI.GetControl(IDC_SPEED_STATIC);
//		_ASSERT(s_ui_texspeed);
//		s_dsutgui0.push_back(s_ui_texspeed);//s_dsutgui1
//		s_dsutguiid0.push_back(IDC_SPEED_STATIC);//s_dsutgui1
//		//g_SampleUI.AddSlider(IDC_SPEED, iX0, iY += addh, 100, ctrlh, 0, 700, (int)(g_dspeed * 100.0f));
//		g_SampleUI.AddSlider(IDC_SPEED, iX0 + 35, iY += (18 + 2), 100, ctrlh, 0, 700, (int)(g_dspeed * 100.0f));
//		s_ui_speed = g_SampleUI.GetControl(IDC_SPEED);
//		_ASSERT(s_ui_speed);
//		s_dsutgui0.push_back(s_ui_speed);//!!!!!!!!!!!!!!!! dsutgui1
//		s_dsutguiid0.push_back(IDC_SPEED);
//
//		//g_SampleUI.AddCheckBox(IDC_PSEUDOLOCAL, L"PseudoLocal", iX0, iY += addh, checkboxxlen, 16, true, 0U, false, &s_PseudoLocalCheckBox);
//		//s_ui_pseudolocal = g_SampleUI.GetControl(IDC_PSEUDOLOCAL);
//		//_ASSERT(s_ui_pseudolocal);
//		//s_dsutgui0.push_back(s_ui_pseudolocal);
//		//s_dsutguiid0.push_back(IDC_PSEUDOLOCAL);
//
//		////g_SampleUI.AddCheckBox(IDC_LIMITDEG, L"LimitEul", iX0, iY += addh, checkboxxlen, 16, true, 0U, false, &s_LimitDegCheckBox);
//		//g_SampleUI.AddCheckBox(IDC_LIMITDEG, L"LimitEul", iX0 + 35, iY += addh, checkboxxlen, 16, g_limitdegflag, 0U, false, &s_LimitDegCheckBox);
//		//s_ui_limiteul = g_SampleUI.GetControl(IDC_LIMITDEG);
//		//_ASSERT(s_ui_limiteul);
//		//s_dsutgui0.push_back(s_ui_limiteul);
//		//s_dsutguiid0.push_back(IDC_LIMITDEG);
//		//g_SampleUI.AddCheckBox(IDC_ABS_IK, L"AbsIKOn", iX0, iY += addh, checkboxxlen, 16, false, 0U, false, &s_AbsIKCheckBox);
//		//s_ui_absikon = g_SampleUI.GetControl(IDC_ABS_IK);
//		//_ASSERT(s_ui_absikon);
//		//s_dsutgui0.push_back(s_ui_absikon);
//		//s_dsutguiid0.push_back(IDC_ABS_IK);
//
//		//g_SampleUI.AddCheckBox(IDC_WALLSCRAPINGIK, L"WallScrapingIK", iX0 + 35, iY += addh, checkboxxlen, 16, (g_wallscrapingikflag == 1), 0U, false, &s_WallScrapingIKCheckBox);
//		//s_ui_wallscrapingik = g_SampleUI.GetControl(IDC_WALLSCRAPINGIK);
//		//_ASSERT(s_ui_wallscrapingik);
//		//s_dsutgui0.push_back(s_ui_wallscrapingik);
//		//s_dsutguiid0.push_back(IDC_WALLSCRAPINGIK);
//
//	}
//
//	{//3-->1移動
//		swprintf_s(sz, 100, L"EditRate : %.3f", g_physicsmvrate);
//		//g_SampleUI.AddStatic(IDC_STATIC_PHYSICS_MV_SLIDER, sz, iX0, iY += addh, ctrlxlen, ctrlh);
//		g_SampleUI.AddStatic(IDC_STATIC_PHYSICS_MV_SLIDER, sz, iX0 + 35, iY += addh, ctrlxlen, 18);
//		s_ui_texphysmv = g_SampleUI.GetControl(IDC_STATIC_PHYSICS_MV_SLIDER);
//		_ASSERT(s_ui_texphysmv);
//		s_dsutgui0.push_back(s_ui_texphysmv);//s_dsutgui1
//		s_dsutguiid0.push_back(IDC_STATIC_PHYSICS_MV_SLIDER);//s_dsutgui1
//		//g_SampleUI.AddSlider(IDC_PHYSICS_MV_SLIDER, iX0, iY += addh, 100, ctrlh, 0, 100, (int)(g_physicsmvrate * 100.0f));
//		g_SampleUI.AddSlider(IDC_PHYSICS_MV_SLIDER, iX0 + 35, iY += (18 + 2), 100, ctrlh, 0, 100, (int)(g_physicsmvrate * 100.0f));
//		s_ui_slphysmv = g_SampleUI.GetControl(IDC_PHYSICS_MV_SLIDER);
//		_ASSERT(s_ui_slphysmv);
//		s_dsutgui0.push_back(s_ui_slphysmv);
//		s_dsutguiid0.push_back(IDC_PHYSICS_MV_SLIDER);
//	}
//
//
//
//	//################
//	//utguikind == 1
//	//################
//		//Left Bottom
//	s_dsutgui1.clear();
//	s_dsutguiid1.clear();
//
//	//iY = s_mainheight - 210;
//	iY = s_mainheight - 190;
//	int startx = s_mainwidth / 2 - 180;
//
//	int brushmethody;
//	if (g_4kresolution) {
//		brushmethody = 20;
//	}
//	else {
//		brushmethody = 56;
//	}
//
//	{// 1-->2移動
//		g_SampleUI.AddComboBox(IDC_COMBO_MOTIONBRUSH_METHOD, startx - 15, brushmethody, ctrlxlen + 25, ctrlh);//ドロップダウンリストが全部表示されるように上方に配置
//		s_ui_motionbrush = g_SampleUI.GetControl(IDC_COMBO_MOTIONBRUSH_METHOD);
//		_ASSERT(s_ui_motionbrush);
//		s_dsutgui1.push_back(s_ui_motionbrush);
//		s_dsutguiid1.push_back(IDC_COMBO_MOTIONBRUSH_METHOD);
//		InitPluginMenu();
//
//
//		//swprintf_s(sz, 100, L"TopPos : %d%% ", g_applyrate);
//		CEditRange::SetApplyRate((double)g_applyrate);
//
//		swprintf_s(sz, 100, L"TopPos:%d%%:%d", g_applyrate, 1);// current frame is 1 at first.
//		//g_SampleUI.AddStatic(IDC_STATIC_APPLYRATE, sz, 35, iY += addh, ctrlxlen, ctrlh);
//		g_SampleUI.AddStatic(IDC_STATIC_APPLYRATE, sz, startx, iY += addh, ctrlxlen, 18);
//		s_ui_texapplyrate = g_SampleUI.GetControl(IDC_STATIC_APPLYRATE);
//		_ASSERT(s_ui_texapplyrate);
//		s_dsutgui1.push_back(s_ui_texapplyrate);
//		s_dsutguiid1.push_back(IDC_STATIC_APPLYRATE);
//		//g_SampleUI.AddSlider(IDC_SL_APPLYRATE, 50, iY += addh, 100, ctrlh, 0, 100, g_applyrate);
//		g_SampleUI.AddSlider(IDC_SL_APPLYRATE, startx, iY += (18 + 2), 100, ctrlh, 0, 100, g_applyrate);
//		s_ui_slapplyrate = g_SampleUI.GetControl(IDC_SL_APPLYRATE);
//		_ASSERT(s_ui_slapplyrate);
//		CEditRange::SetApplyRate(g_applyrate);
//		s_dsutgui1.push_back(s_ui_slapplyrate);
//		s_dsutguiid1.push_back(IDC_SL_APPLYRATE);
//
//		//swprintf_s( sz, 100, L"IK First Rate : %f", g_ikfirst );
//		swprintf_s(sz, 100, L"Brush Repeats : %d", g_brushrepeats);
//		//g_SampleUI.AddStatic(IDC_STATIC_BRUSHREPEATS, sz, 35, iY += addh, ctrlxlen, ctrlh);
//		g_SampleUI.AddStatic(IDC_STATIC_BRUSHREPEATS, sz, startx, iY += addh, ctrlxlen, 18);
//		s_ui_texbrushrepeats = g_SampleUI.GetControl(IDC_STATIC_BRUSHREPEATS);
//		_ASSERT(s_ui_texbrushrepeats);
//		s_dsutgui1.push_back(s_ui_texbrushrepeats);
//		s_dsutguiid1.push_back(IDC_STATIC_BRUSHREPEATS);
//		//g_SampleUI.AddSlider(IDC_SL_BRUSHREPEATS, 50, iY += addh, 100, ctrlh, 0, 10, (int)g_brushrepeats);
//		g_SampleUI.AddSlider(IDC_SL_BRUSHREPEATS, startx, iY += (18 + 2), 100, ctrlh, 0, 10, (int)g_brushrepeats);
//		s_ui_brushrepeats = g_SampleUI.GetControl(IDC_SL_BRUSHREPEATS);
//		_ASSERT(s_ui_brushrepeats);
//		s_dsutgui1.push_back(s_ui_brushrepeats);
//		s_dsutguiid1.push_back(IDC_SL_BRUSHREPEATS);
//
//		g_SampleUI.AddCheckBox(IDC_BRUSH_MIRROR_U, L"U", startx, iY += addh, checkboxxlen / 2 - 5, 16, false, 0U, false, &s_BrushMirrorUCheckBox);
//		s_ui_brushmirroru = g_SampleUI.GetControl(IDC_BRUSH_MIRROR_U);
//		_ASSERT(s_ui_brushmirroru);
//		s_dsutgui1.push_back(s_ui_brushmirroru);
//		s_dsutguiid1.push_back(IDC_BRUSH_MIRROR_U);
//
//		g_SampleUI.AddCheckBox(IDC_BRUSH_MIRROR_V, L"V", startx + checkboxxlen / 2 + 5, iY, checkboxxlen / 2 - 5, 16, false, 0U, false, &s_BrushMirrorVCheckBox);
//		s_ui_brushmirrorv = g_SampleUI.GetControl(IDC_BRUSH_MIRROR_V);
//		_ASSERT(s_ui_brushmirrorv);
//		s_dsutgui1.push_back(s_ui_brushmirrorv);
//		s_dsutguiid1.push_back(IDC_BRUSH_MIRROR_V);
//	}
//
//
//
//
//
//
//	//################
//	//utguikind == 2
//	//################
//		//CenterRight Bottom
//	s_dsutgui2.clear();
//	s_dsutguiid2.clear();
//
//	//Center Bottom
//	//iY = s_mainheight - 210;
//	iY = s_mainheight - 155;
//	startx = s_mainwidth / 2 - 50;
//
//	int addh2 = 27;
//
//	//g_SampleUI.AddCheckBox(IDC_EDGESMP, L"edge sampling",
//	//	startx, iY += addh, checkboxxlen, 16,
//	//	g_edgesmp, 0U, false, &s_EdgeSmpCheckBox);
//	//s_ui_edgesmp = g_SampleUI.GetControl(IDC_EDGESMP);
//	//_ASSERT(s_ui_edgesmp);
//	//s_dsutgui1.push_back(s_ui_edgesmp);
//	//s_dsutguiid1.push_back(IDC_EDGESMP);
//
//
//	//iY += 10;
//	g_SampleUI.AddButton(IDC_BTSTART, L"BT start", startx, iY += addh, 100, ctrlh);
//	s_ui_btstart = g_SampleUI.GetControl(IDC_BTSTART);
//	_ASSERT(s_ui_btstart);
//	s_dsutgui2.push_back(s_ui_btstart);
//	s_dsutguiid2.push_back(IDC_BTSTART);
//
//	//iY += 3;
//	g_SampleUI.AddButton(IDC_BTRECSTART, L"BT REC", startx, iY += addh2, 100, ctrlh);
//	s_ui_btrecstart = g_SampleUI.GetControl(IDC_BTRECSTART);
//	_ASSERT(s_ui_btrecstart);
//	s_dsutgui2.push_back(s_ui_btrecstart);
//	s_dsutguiid2.push_back(IDC_BTRECSTART);
//
//	//iY += 3;
//	g_SampleUI.AddButton(IDC_STOP_BT, L"STOP BT", startx, iY += addh2, 100, ctrlh);
//	s_ui_stopbt = g_SampleUI.GetControl(IDC_STOP_BT);
//	_ASSERT(s_ui_stopbt);
//	s_dsutgui2.push_back(s_ui_stopbt);
//	s_dsutguiid2.push_back(IDC_STOP_BT);
//
//
//
//
//
//	//iY = s_mainheight - 210;
//	//iY = s_mainheight - 210 - addh;
//	iY = s_mainheight - 155 - addh;
//	startx = s_mainwidth / 2 - 50 + 130;
//
//	swprintf_s(sz, 100, L"BT CalcCnt: %0.2f", g_btcalccnt);
//	//g_SampleUI.AddStatic(IDC_STATIC_BTCALCCNT, sz, startx, iY += addh, ctrlxlen, ctrlh);
//	g_SampleUI.AddStatic(IDC_STATIC_BTCALCCNT, sz, startx, iY += addh, ctrlxlen, 18);
//	s_ui_texbtcalccnt = g_SampleUI.GetControl(IDC_STATIC_BTCALCCNT);
//	_ASSERT(s_ui_texbtcalccnt);
//	s_dsutgui2.push_back(s_ui_texbtcalccnt);
//	s_dsutguiid2.push_back(IDC_STATIC_BTCALCCNT);
//	//g_SampleUI.AddSlider(IDC_BTCALCCNT, startx, iY += addh, 100, ctrlh, 1, 100, (int)(g_btcalccnt));
//	g_SampleUI.AddSlider(IDC_BTCALCCNT, startx, iY += (18 + 2), 100, ctrlh, 1, 100, (int)(g_btcalccnt));
//	s_ui_btcalccnt = g_SampleUI.GetControl(IDC_BTCALCCNT);
//	_ASSERT(s_ui_btcalccnt);
//	s_dsutgui2.push_back(s_ui_btcalccnt);
//	s_dsutguiid2.push_back(IDC_BTCALCCNT);
//
//	swprintf_s(sz, 100, L"BT ERP: %0.5f", g_erp);
//	//g_SampleUI.AddStatic(IDC_STATIC_ERP0, sz, startx, iY += addh, ctrlxlen, ctrlh);
//	g_SampleUI.AddStatic(IDC_STATIC_ERP0, sz, startx, iY += addh, ctrlxlen, 18);
//	s_ui_texerp = g_SampleUI.GetControl(IDC_STATIC_ERP0);
//	_ASSERT(s_ui_texerp);
//	s_dsutgui2.push_back(s_ui_texerp);
//	s_dsutguiid2.push_back(IDC_STATIC_ERP0);
//	//g_SampleUI.AddSlider(IDC_ERP, startx, iY += addh, 100, ctrlh, 0, 5000, (int)(g_erp * 5000.0 + 0.4));
//	g_SampleUI.AddSlider(IDC_ERP, startx, iY += (18 + 2), 100, ctrlh, 0, 5000, (int)(g_erp * 5000.0 + 0.4));
//	s_ui_erp = g_SampleUI.GetControl(IDC_ERP);
//	_ASSERT(s_ui_erp);
//	s_dsutgui2.push_back(s_ui_erp);
//	s_dsutguiid2.push_back(IDC_ERP);
//
//	//swprintf_s(sz, 100, L"ThreadNum : %d(%d)", g_numthread, gNumIslands);
//	////g_SampleUI.AddStatic(IDC_STATIC_NUMTHREAD, sz, startx, iY += addh2, ctrlxlen, ctrlh);
//	//g_SampleUI.AddStatic(IDC_STATIC_NUMTHREAD, sz, startx, iY += addh2, ctrlxlen, 18);
//	//s_ui_texthreadnum = g_SampleUI.GetControl(IDC_STATIC_NUMTHREAD);
//	//_ASSERT(s_ui_texthreadnum);
//	//s_dsutgui2.push_back(s_ui_texthreadnum);
//	//s_dsutguiid2.push_back(IDC_STATIC_NUMTHREAD);
//	////g_SampleUI.AddSlider(IDC_SL_NUMTHREAD, startx, iY += addh2, 100, ctrlh, 1, 4, g_numthread);
//	//g_SampleUI.AddSlider(IDC_SL_NUMTHREAD, startx, iY += (18 + 2), 100, ctrlh, 1, 4, g_numthread);
//	//s_ui_slthreadnum = g_SampleUI.GetControl(IDC_SL_NUMTHREAD);
//	//_ASSERT(s_ui_slthreadnum);
//	//s_dsutgui2.push_back(s_ui_slthreadnum);
//	//s_dsutguiid2.push_back(IDC_SL_NUMTHREAD);
//
//
////################
////utguikind == 3
////################
//	//Right Bottom
//	s_dsutgui3.clear();
//	s_dsutguiid3.clear();
//
//	if (g_4kresolution) {
//		//iY = s_mainheight - 210 - addh;
//		//iY = s_mainheight - 170 - addh;
//		iY = s_mainheight - 155 - addh;
//		startx = s_mainwidth / 2 - 50 + 130 + 140;
//	}
//	else {
//		//iY = s_mainheight - 210 - addh;
//		//iY = s_mainheight - 170 - addh;
//		iY = s_mainheight - 155 - addh;
//		startx = s_mainwidth - 150;
//	}
//
//	{//Experimental新規
//		//g_SampleUI.AddCheckBox(IDC_VSYNC, L"VSync", startx, iY + addh, checkboxxlen / 2, 16, g_VSync, 0U, false, &s_VSyncCheckBox);
//		//s_ui_vsync = g_SampleUI.GetControl(IDC_VSYNC);
//		//_ASSERT(s_ui_vsync);
//		//s_dsutgui3.push_back(s_ui_vsync);
//		//s_dsutguiid3.push_back(IDC_VSYNC);
//
//	}
//
//	{//1-->Experimental
//		swprintf_s(sz, 100, L"ReferencePos : %d", g_refposstep);
//		//g_SampleUI.AddStatic(IDC_STATIC_IKRATE, sz, 35, iY += addh, ctrlxlen, ctrlh);
//		g_SampleUI.AddStatic(IDC_STATIC_REF, sz, startx, iY += addh, ctrlxlen, 18);
//		s_ui_texref = g_SampleUI.GetControl(IDC_STATIC_REF);
//		_ASSERT(s_ui_texref);
//		s_dsutgui3.push_back(s_ui_texref);
//		s_dsutguiid3.push_back(IDC_STATIC_REF);
//		//g_SampleUI.AddSlider(IDC_SL_IKRATE, 50, iY += addh, 100, ctrlh, 0, 100, (int)(g_ikrate * 100.0f));
//		g_SampleUI.AddSlider(IDC_SL_REFPOSSTEP, startx, iY += (18 + 2), 100, ctrlh, 1, 50, g_refposstep);
//		s_ui_slirefpos = g_SampleUI.GetControl(IDC_SL_REFPOSSTEP);
//		g_SampleUI.AddSlider(IDC_SL_REFALPHA, startx, iY += (18 + 2), 100, ctrlh, 1, 100, g_refalpha);
//		s_ui_slirefalpha = g_SampleUI.GetControl(IDC_SL_REFALPHA);
//		_ASSERT(s_ui_slirefalpha);
//		s_dsutgui3.push_back(s_ui_slirefpos);
//		s_dsutguiid3.push_back(IDC_SL_REFPOSSTEP);
//		s_dsutgui3.push_back(s_ui_slirefalpha);
//		s_dsutguiid3.push_back(IDC_SL_REFALPHA);
//	}
//
//
//	//if (g_usephysik == 1) {//EditMot%d.iniファイルを編集してUsePhysIKに１を指定した時のみのオプション機能（乱れやすい。少しだけ動かして物理的なノイズを加える位の役には立つかもしれないのでオプションとして残す。）
//	//	iY += 10;
//	//	g_SampleUI.AddButton(IDC_PHYSICS_IK, L"PhysRotStart", startx, iY += addh, 100, ctrlh);
//	//	s_ui_physrotstart = g_SampleUI.GetControl(IDC_PHYSICS_IK);
//	//	_ASSERT(s_ui_physrotstart);
//	//	s_dsutgui3.push_back(s_ui_physrotstart);
//	//	s_dsutguiid3.push_back(IDC_PHYSICS_IK);
//	//	iY += 5;
//	//	g_SampleUI.AddButton(IDC_PHYSICS_MV_IK, L"PhysMvStart", startx, iY += addh, 100, ctrlh);
//	//	s_ui_physmvstart = g_SampleUI.GetControl(IDC_PHYSICS_MV_IK);
//	//	_ASSERT(s_ui_physmvstart);
//	//	s_dsutgui3.push_back(s_ui_physmvstart);
//	//	s_dsutguiid3.push_back(IDC_PHYSICS_MV_IK);
//	//	iY += 5;
//	//	g_SampleUI.AddButton(IDC_PHYSICS_IK_STOP, L"PhysIkStop", startx, iY += addh, 100, ctrlh);
//	//	s_ui_physikstop = g_SampleUI.GetControl(IDC_PHYSICS_IK_STOP);
//	//	_ASSERT(s_ui_physikstop);
//	//	s_dsutgui3.push_back(s_ui_physikstop);
//	//	s_dsutguiid3.push_back(IDC_PHYSICS_IK_STOP);
//	//}
//
//
//	//iY += 5;
//	//g_SampleUI.AddButton(IDC_APPLY_BT, L"Apply BT", startx, iY += addh, 100, ctrlh);


	return 0;

}

int CreateTimelineWnd()
{

	s_rctreewnd.top = MAINMENUAIMBARH;
	s_rctreewnd.left = 0;


	s_timelineWnd = new OrgWindow(
		0,
		L"TimeLine",				//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		//WindowPos(0, 0),		//位置
		//WindowSize(400, 600),	//サイズ
		WindowPos(0, MAINMENUAIMBARH),		//位置
		WindowSize(s_timelinewidth, s_timelineheight),	//サイズ 
		//WindowSize(150,540),	//サイズ
		L"TimeLine",				//タイトル
		g_mainhwnd,					//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70);				//カラー
		0, 0, 0);				//カラー
	if (s_timelineWnd) {
		s_rctreewnd.right = s_timelinewidth;
		s_rctreewnd.bottom = s_timelineheight;

		s_timelineWnd->callRewrite();


		// ウィンドウの閉じるボタンのイベントリスナーに
		// 終了フラグcloseFlagをオンにするラムダ関数を登録する
		s_timelineWnd->setCloseListener([]() {
			if (s_model) {
				s_closeFlag = true;
			}
			});


		// ウィンドウのキーボードイベントリスナーに
		// コピー/カット/ペーストフラグcopyFlag/cutFlag/pasteFlagをオンにするラムダ関数を登録する
		// コピー等のキーボードを使用する処理はキーボードイベントリスナーを使用しなくても
		// メインループ内でマイフレームキー状態を監視することで作成可能である。
		s_timelineWnd->setKeyboardEventListener([](const KeyboardEvent& e) {
			if (s_model) {
				if (e.ctrlKey && !e.repeat && e.onDown) {
					//switch (e.keyCode) {
					//###############################################################################################################
					//2023/08/18 : Ctrl + C, Vのコピーペーストは　ダイアログのEditCtrlとのバッティング対策が出来るまでコメントアウト
					//###############################################################################################################
					//case 'C':
					//	s_copyFlag = true;
					//	break;
					//case 'B':
					//	s_symcopyFlag = true;
					//	break;
					//case 'X':
					//	s_cutFlag = true;
					//	break;
					//case 'V':
					//	s_pasteFlag = true;
					//	break;
					//case 'P':
					//	//g_previewFlag = 1;
					//	s_calclimitedwmState = 1;
					//	break;
					//case 'S':
					//	g_previewFlag = 0;
					//	break;
					//case 'D':
					//	s_deleteFlag = true;
					//	break;
					//default:
					//	break;
					//}
				}
			}
		});
	}
	else {
		_ASSERT(0);
		return 1;
	}


	return 0;
}

void SavePlayingStartEnd()
{
	g_playingstart = g_motionbrush_startframe;
	g_playingend = g_motionbrush_endframe;
}
void SetButtonStartEndFromPlaying()
{
	s_buttonselectstart = g_playingstart;
	s_buttonselectend = g_playingend;
}

int CreateLongTimelineWnd()
{

	//////////
	///////// Long Timeline

	s_rcltwnd.top = 0;
	s_rcltwnd.left = 0;

	s_LtimelineWnd = new OrgWindow(
		0,
		L"EditRangeTimeLine",				//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		//WindowPos( 250, 825 ),		//位置
		//WindowPos(200, 645),		//位置
		WindowPos(s_toolwidth, s_2ndposy),		//位置
		WindowSize(s_longtimelinewidth, s_longtimelineheight),	//サイズ
		L"EditRangeTimeLine",				//タイトル
		g_mainhwnd,					//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70);				//カラー
		0, 0, 0);				//カラー
	if (s_LtimelineWnd) {
		s_rcltwnd.bottom = s_longtimelineheight;
		s_rcltwnd.right = s_longtimelinewidth;


		s_LtimelineWnd->callRewrite();


		/////////
		s_owpPlayerButton = new OWP_PlayerButton(s_longtimelinewidth);
		if (s_owpPlayerButton) {
			//s_owpPlayerButton->setButtonSize(20);
			s_LtimelineWnd->addParts(*s_owpPlayerButton);//owp_timelineより前

			s_owpPlayerButton->setPhysicsPlayButtonListener([]() {
				if (s_model) {
					s_calclimitedwmState = 101;
				}
				});
			s_owpPlayerButton->setPhysicsRecButtonListener([]() {
				if (s_model) {
					if (g_motionbrush_numframe < 10) {
						WCHAR strmes[1024] = { 0L };
						swprintf_s(strmes, 1024, L"複数フレームを選択してから再試行してください。\nPlease select more than 10 frames and try again.");
						::DSMessageBox(NULL, strmes, L"error!!!", MB_OK);
					}
					else {
						s_calclimitedwmState = 1001;
					}
				}
				});

			s_owpPlayerButton->setFrontPlayButtonListener([]() {
				if (s_model) {
					s_calclimitedwmState = 1; s_LstartFlag = true; s_LcursorFlag = true;
					//s_LtimelineWnd->setDoneFlag(1);
				}
				});
			s_owpPlayerButton->setBackPlayButtonListener([]() {
				if (s_model) {
					s_calclimitedwmState = 11; s_LstartFlag = true; s_LcursorFlag = true;
					//s_LtimelineWnd->setDoneFlag(1);
				}
				});


			s_owpPlayerButton->setFrontStepButtonListener([]() {
				//##################################
				//means to step to the last frame
				//##################################
				if (s_model) {
					//s_LstartFlag = true; s_LcursorFlag = true; s_lastkeyFlag = true;
					//s_LtimelineWnd->setDoneFlag(1);

					s_LstopFlag = true;
					g_previewFlag = 0;
					s_LcursorFlag = true;
					s_lastkeyFlag = true;
				}
				});
			s_owpPlayerButton->setBackStepButtonListener([]() {
				//##################################
				//means to step to the first frame
				//##################################
				if (s_model) {
					//s_LstartFlag = true; s_LcursorFlag = true; s_firstkeyFlag = true;
					//s_LtimelineWnd->setDoneFlag(1);

					s_LstopFlag = true;
					g_previewFlag = 0;
					s_LcursorFlag = true;
					s_firstkeyFlag = true;
				}
				});


			//s_owpPlayerButton->setOneFpsButtonListener([]() {
			//	if (s_model) {

			//		int tmponefps;
			//		if (s_onefps == 0) {
			//			tmponefps = 1;
			//		}
			//		else if (s_onefps == 1) {
			//			tmponefps = 2;
			//		}
			//		else if (s_onefps == 2) {
			//			tmponefps = 0;
			//		}
			//		else {
			//			tmponefps = 0;
			//		}
			//		s_onefps = tmponefps;

			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setStopButtonListener([]() {
			//	if (s_model) {
			//		s_LstopFlag = true; s_LcursorFlag = true; g_previewFlag = 0;
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			s_owpPlayerButton->setResetButtonListener([]() {
				//##############################################
				// means to stop preview and step to first key 
				//##############################################
				if (s_model) {
					if (s_owpLTimeline) {
						s_LstopFlag = true;
						g_previewFlag = 0;
						s_LcursorFlag = true;
						//s_firstkeyFlag = true;
						////s_LtimelineWnd->setDoneFlag(1);
					}
				}
				});

			s_owpPlayerButton->setSelectToLastButtonListener([]() {
				if (s_model) {
					//g_underselecttolast = true;  s_LcursorFlag = true; g_selecttolastFlag = true;
					//g_underselecttolast = false;  s_LcursorFlag = true; g_selecttolastFlag = true;
					////s_LtimelineWnd->setDoneFlag(1);

					if (s_owpLTimeline) {
						s_LstopFlag = true;
						g_previewFlag = 0;
						s_LcursorFlag = true;
						g_selecttolastFlag = true;
						//s_LtimelineWnd->setDoneFlag(1);
					}
				}
				});
			//s_owpPlayerButton->setBtResetButtonListener([]() {
			//	if (s_model) {
			//		s_btresetFlag = true;
			//		//StartBt(s_model, TRUE, 0, 1);
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setPrevRangeButtonListener([]() {
			//	if (s_model) {
			//		//g_undereditrange = true; s_prevrangeFlag = true;
			//		////s_LtimelineWnd->setDoneFlag(1);

			//		RollbackCurBoneNo();//2022/11/07
			//		s_undoFlag = true;//2022/11/02 選択範囲だけの履歴をやめて　アンドゥに

			//		//2022/11/27 playerbuttonからundoredoすると　s_LupFlagとs_selectFlagがtrueになり　PrepairUndoが呼ばれる
			//		//undoredo結果が　SaveUndoMotionされないように　s_undoredoFromPlayerButtonフラグを立てる
			//		s_undoredoFromPlayerButton = true;
			//	}
			//	});
			//s_owpPlayerButton->setNextRangeButtonListener([]() {
			//	if (s_model) {
			//		//g_undereditrange = true; s_nextrangeFlag = true;
			//		////s_LtimelineWnd->setDoneFlag(1);

			//		RollbackCurBoneNo();//2022/11/07
			//		s_redoFlag = true;//2022/11/02 選択範囲だけの履歴をやめて　リドゥに

			//		//2022/11/27 playerbuttonからundoredoすると　s_LupFlagとs_selectFlagがtrueになり　PrepairUndoが呼ばれる
			//		//undoredo結果が　SaveUndoMotionされないように　s_undoredoFromPlayerButtonフラグを立てる
			//		s_undoredoFromPlayerButton = true;
			//	}
			//	});
			//s_owpPlayerButton->setPlusDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->PlusDisp();
			//		s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		//s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setMinusDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->MinusDisp();
			//		s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		//s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setPlusOffsetDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setMinusOffsetDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setResetDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->ResetScaleAndOffset();
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});


			//###################################
			//s_owpLTimelineの関連ラムダをコメントとしてコピペ
			//###################################
			//s_owpLTimeline->setCursorListener([]() { s_LcursorFlag = true; });
			//s_owpLTimeline->setSelectListener([]() { s_selectFlag = true; });
			//s_owpLTimeline->setMouseMDownListener([]() {
			//	s_timelinembuttonFlag = true;
			//	if (s_mbuttoncnt == 0) {
			//		s_mbuttoncnt = 1;
			//	}
			//	else {
			//		s_mbuttoncnt = 0;
			//	}
			//});
			//s_owpLTimeline->setMouseWheelListener([]() {
			//	s_timelinewheelFlag = true;
			//});
		}
		else {
			_ASSERT(0);
			return 1;
		}

		//####################################
		//s_LtimelineWndのラムダ　s_owpLTimelineではない。
		//####################################
		s_LtimelineWnd->setCloseListener([]() {
			if (s_model) {
				s_LcloseFlag = true;
			}
			});
		s_LtimelineWnd->setLDownListener([]() {
			if (s_model) {
				g_underselectingframe = 1;
			}
			});
		s_LtimelineWnd->setLUpListener([]() {
			if (s_model) {
				s_LupFlag = true;
			}
			});

		s_LtimelineWnd->setPos(WindowPos(s_toolwidth, s_2ndposy));
		s_LtimelineWnd->setSizeMin(OrgWinGUI::WindowSize(100, 100));
		s_LtimelineWnd->setSize(WindowSize(s_longtimelinewidth, s_longtimelineheight));
		//s_LtimelineWnd->refreshPosAndSize();//2022/09/20
		s_LtimelineWnd->callRewrite();
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;
}

int CreateDmpAnimWnd()
{

	s_dsdampctrls.clear();

	/////////

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	s_dmpanimWnd = new OrgWindow(
		0,
		_T("dampAnimWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),
		WindowSize(s_sidewidth, s_sideheight),		//サイズ
		_T("AnimOfDumping"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		false,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否

	if (s_dmpanimWnd) {

		s_dmpgroupcheck = new OWP_CheckBoxA(L"SetToAllRigidsMeansToSetToSameGroup", 0);
		if (!s_dmpgroupcheck) {
			_ASSERT(0);
			return 1;
		}
		s_dmpanimLlabel = new OWP_Label(L"posSpringDumpingPerFrame");
		if (!s_dmpanimLlabel) {
			_ASSERT(0);
			return 1;
		}
		s_dmpanimLSlider = new OWP_Slider(0.0, 1.0, 0.0);
		if (!s_dmpanimLSlider) {
			_ASSERT(0);
			return 1;
		}
		s_dmpanimAlabel = new OWP_Label(L"rotSpringDumpingPerFrame");
		if (!s_dmpanimAlabel) {
			_ASSERT(0);
			return 1;
		}
		s_dmpanimASlider = new OWP_Slider(0.0, 1.0, 0.0);
		if (!s_dmpanimASlider) {
			_ASSERT(0);
			return 1;
		}
		s_dmpanimB = new OWP_Button(L"SetToAllRigids");
		if (!s_dmpanimB) {
			_ASSERT(0);
			return 1;
		}

		int slw2 = 500;
		if (s_dmpanimLSlider) {
			s_dmpanimLSlider->setSize(WindowSize(slw2, 40));
			s_dmpanimASlider->setSize(WindowSize(slw2, 40));
		}

		if (s_dmpanimWnd) {
			if (s_dmpgroupcheck) {
				s_dmpanimWnd->addParts(*s_dmpgroupcheck);
			}
			if (s_dmpanimLlabel) {
				s_dmpanimWnd->addParts(*s_dmpanimLlabel);
			}
			if (s_dmpanimLSlider) {
				s_dmpanimWnd->addParts(*s_dmpanimLSlider);
			}
			if (s_dmpanimAlabel) {
				s_dmpanimWnd->addParts(*s_dmpanimAlabel);
			}
			if (s_dmpanimASlider) {
				s_dmpanimWnd->addParts(*s_dmpanimASlider);
			}
			if (s_dmpanimB) {
				s_dmpanimWnd->addParts(*s_dmpanimB);
			}
		}


		s_dsdampctrls.push_back(s_dmpgroupcheck);
		s_dsdampctrls.push_back(s_dmpanimLlabel);
		s_dsdampctrls.push_back(s_dmpanimLSlider);
		s_dsdampctrls.push_back(s_dmpanimAlabel);
		s_dsdampctrls.push_back(s_dmpanimASlider);
		s_dsdampctrls.push_back(s_dmpanimB);

		if (s_dmpanimWnd) {
			s_dmpanimWnd->setCloseListener([]() {
				if (s_model) {
					s_DcloseFlag = true;
				}
				});

			if (s_dmpanimLSlider) {
				s_dmpanimLSlider->setCursorListener([]() {
					if (s_model) {
						CRigidElem* curre = s_model->GetRgdRigidElem(s_rgdindexmap[s_model], s_curboneno);
						if (curre) {
							float val = (float)s_dmpanimLSlider->getValue();
							curre->SetDampanimL(val);
						}
						s_dmpanimWnd->callRewrite();						//再描画
					}
					});
			}
			if (s_dmpanimASlider) {
				s_dmpanimASlider->setCursorListener([]() {
					if (s_model) {
						CRigidElem* curre = s_model->GetRgdRigidElem(s_rgdindexmap[s_model], s_curboneno);
						if (curre) {
							float val = (float)s_dmpanimASlider->getValue();
							curre->SetDampanimA(val);
						}
						s_dmpanimWnd->callRewrite();						//再描画
					}
					});
			}
			if (s_dmpanimB) {
				s_dmpanimB->setButtonListener([]() {
					if (s_model && (s_rgdindexmap[s_model] >= 0)) {
						float valL = (float)s_dmpanimLSlider->getValue();
						float valA = (float)s_dmpanimASlider->getValue();
						int chkg = (int)s_dmpgroupcheck->getValue();
						int gid = -1;
						if (chkg) {
							CRigidElem* curre = s_model->GetRgdRigidElem(s_rgdindexmap[s_model], s_curboneno);
							if (curre) {
								gid = curre->GetGroupid();
							}
							else {
								gid = -1;
							}
						}
						s_model->SetAllDampAnimData(gid, s_rgdindexmap[s_model], valL, valA);
					}
					});
			}

			s_dmpanimWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
			s_dmpanimWnd->setPos(WindowPos(windowposx, s_sidemenuheight));

			//１クリック目問題対応
			s_dmpanimWnd->refreshPosAndSize();//2022/09/20

			s_dmpanimWnd->callRewrite();
		}
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;
}

int CreateMainMenuAimBarWnd()
{

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}


	s_mainmenuaimbarWnd = new OrgWindow(
		0,
		_T("MainMenuAimBarWnd"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
								//WindowPos(100, 200),		//位置
		WindowPos(0, 0),
		//WindowSize(450,880),		//サイズ
		//WindowSize(450,680),		//サイズ
		//WindowSize(450, 760),		//サイズ
		WindowSize(windowposx, MAINMENUAIMBARH),		//サイズ
		_T("MainMenuAimBarWnd"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true, true);					//サイズ変更の可否

	if (s_mainmenuaimbarWnd) {
		//s_sidemenuWnd->setCloseListener([]() { s_ScloseFlag = true; });

		s_mainmenuaimbarWnd->setBlackTheme();
		s_mainmenulabel = new OWP_Label(L".");
		if (s_mainmenulabel) {
			s_mainmenuaimbarWnd->addParts(*s_mainmenulabel);

			//450, 32
			s_rcmainmenuaimbarwnd.top = 0;
			s_rcmainmenuaimbarwnd.left = 0;
			s_rcmainmenuaimbarwnd.bottom = MAINMENUAIMBARH;

			s_mainmenuaimbarWnd->setPos(WindowPos(0, 0));
			//if (g_4kresolution) {
			//	s_mainmenuaimbarWnd->setSize(WindowSize(1200 * 2, MAINMENUAIMBARH));
			//	s_rcmainmenuaimbarwnd.right = 1200 * 2;
			//}
			//else {
			//	s_mainmenuaimbarWnd->setSize(WindowSize(1200, MAINMENUAIMBARH));
			//	s_rcmainmenuaimbarwnd.right = 1200;
			//}
			s_mainmenuaimbarWnd->setSize(WindowSize(windowposx, MAINMENUAIMBARH));
			s_rcmainmenuaimbarwnd.right = windowposx;

			//１クリック目問題対応
			s_mainmenuaimbarWnd->refreshPosAndSize();//2022/09/20


			s_mainmenuaimbarWnd->callRewrite();						//再描画
		}
		else {
			_ASSERT(0);
			return 1;
		}
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;

}

int CreateSideMenuWnd()
{
	s_sidemenuWnd = new OrgWindow(
		0,
		_T("SideMenuWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
								//WindowPos(100, 200),		//位置
		WindowPos(0, 0),
		//WindowSize(450,880),		//サイズ
		//WindowSize(450,680),		//サイズ
		//WindowSize(450, 760),		//サイズ
		WindowSize(s_sidemenuwidth, s_sidemenuheight),		//サイズ
		_T("SideMenu"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true, true);					//サイズ変更の可否

	if (s_sidemenuWnd) {
		s_sidemenusp = new OWP_Separator(s_sidemenuWnd, true, 0.5, true);
		if (!s_sidemenusp) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenuWnd->addParts(*s_sidemenusp);

		s_sidemenusp1 = new OWP_Separator(s_sidemenuWnd, true, 0.5, true);
		if (!s_sidemenusp1) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenusp2 = new OWP_Separator(s_sidemenuWnd, true, 0.5, true);
		if (!s_sidemenusp2) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenusp->addParts1(*s_sidemenusp1);
		s_sidemenusp->addParts2(*s_sidemenusp2);

		s_sidemenu_rigid = new OWP_Button(L"Rigid");
		if (!s_sidemenu_rigid) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenu_limiteul = new OWP_Button(L"LimitEul");
		if (!s_sidemenu_limiteul) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenu_copyhistory = new OWP_Button(L"CopyHistory");
		if (!s_sidemenu_copyhistory) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenu_retarget = new OWP_Button(L"Retarget");
		if (!s_sidemenu_retarget) {
			_ASSERT(0);
			return 1;
		}

		if (s_sidemenusp1) {
			if (s_sidemenu_rigid) {
				s_sidemenusp1->addParts1(*s_sidemenu_rigid);
			}
			if (s_sidemenu_limiteul) {
				s_sidemenusp1->addParts2(*s_sidemenu_limiteul);
			}
		}
		if (s_sidemenusp2) {
			if (s_sidemenu_copyhistory) {
				s_sidemenusp2->addParts1(*s_sidemenu_copyhistory);
			}
			if (s_sidemenu_retarget) {
				s_sidemenusp2->addParts2(*s_sidemenu_retarget);
			}
		}

		s_sidemenuWnd->setCloseListener([]() {
			if (s_model) {
				s_ScloseFlag = true;
			}
			});
		if (s_sidemenu_rigid) {
			s_sidemenu_rigid->setButtonListener([]() {
				if (s_model && (s_curboneno >= 0)) {
					s_platemenukind = SPPLATEMENUKIND_RIGID;
					GUIMenuSetVisible(s_platemenukind, 1);
					s_sidemenuWnd->callRewrite();						//再描画
				}
				});
		}
		if (s_sidemenu_limiteul) {
			s_sidemenu_limiteul->setButtonListener([]() {
				if (s_model && (s_curboneno >= 0)) {
					s_platemenukind = SPPLATEMENUKIND_RETARGET;
					GUIMenuSetVisible(s_platemenukind, 2);
					s_sidemenuWnd->callRewrite();						//再描画
				}
				});
		}
		if (s_sidemenu_copyhistory) {
			s_sidemenu_copyhistory->setButtonListener([]() {
				if (s_model && (s_curboneno >= 0)) {
					s_selCopyHisotryFlag = true;
					s_sidemenuWnd->callRewrite();						//再描画
				}
				});
		}
		if (s_sidemenu_retarget) {
			s_sidemenu_retarget->setButtonListener([]() {
				if (s_model && (s_curboneno >= 0)) {
					s_platemenukind = SPPLATEMENUKIND_RETARGET;
					GUIMenuSetVisible(s_platemenukind, 1);
					s_sidemenuWnd->callRewrite();						//再描画
				}
				});
		}

		int windowposx;
		if (g_4kresolution) {
			//windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
			windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
		}
		else {
			//windowposx = s_timelinewidth + s_mainwidth;
			windowposx = s_timelinewidth + s_mainwidth;
		}

		s_sidemenuWnd->setPos(WindowPos(windowposx, 0));

		//450, 32
		s_rcsidemenuwnd.top = 0;
		s_rcsidemenuwnd.left = 0;
		s_rcsidemenuwnd.bottom = s_sidemenuheight;
		s_rcsidemenuwnd.right = s_sidemenuwidth;

		//１クリック目問題対応
		s_sidemenuWnd->refreshPosAndSize();//2022/09/20


		s_sidemenuWnd->callRewrite();						//再描画

	}
	else {
		_ASSERT(0);
		return 1;
	}

	

	return 0;
}

int CreatePlaceFolderWnd()
{
	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}


	s_placefolderWnd = new OrgWindow(
		0,
		_T("PlaceFolderWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),
		WindowSize(s_sidewidth, s_sideheight),		//サイズ
		_T("PlaceFolderWindow"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true, true);					//サイズ変更の可否

	if (s_placefolderWnd) {
		//s_placefolderlabel_1 = new OWP_Label(L"After Loading Model Data,");
		//if (!s_placefolderlabel_1) {
		//	_ASSERT(0);
		//	return 1;
		//}
		//s_placefolderlabel_2 = new OWP_Label(L"Click Frog Button for Change Plate Menu.");
		//if (!s_placefolderlabel_2) {
		//	_ASSERT(0);
		//	return 1;
		//}
		//s_placefolderlabel_3 = new OWP_Label(L" ");
		//if (!s_placefolderlabel_3) {
		//	_ASSERT(0);
		//	return 1;
		//}


		WCHAR shortcuttext[SHORTCUTTEXTNUM][80] = {
			L" ",
			L" ",
			L"ShortCutKey",
			L" ",
			L"　Menu",
			L"　　SpaceKey　：　Change kind of PlateMenu.",
			L"　　C + SpaceKey　：　Change Plate.",
			L"　　V + SpaceKey　：　Change ToolShortCutButtons.",
			L" ",
			L"　Joint Selection",
			
			L"　　H + LeftArrow or RightArrow　：　Select LeftHand or RightHand.",
			L"	　　　JointName whitch contain string L_Hand or LeftHand",
			L"	　　　JointName whitch contain string R_Hand or RightHand",
			L"　　F + LeftArrow or RightArrow　：　Select LeftFoot or RightFoot.",
			L"	　　　JointName whitch contain string L_Foot or LeftFoot",
			L"	　　　JointName whitch contain string R_Foot or RightFoot",
			L" ",
			L"　　LeftArrow or RightArrow　：　Select joint whitch is at same depth level.",
			L" ",
			L"　　UpperArrow or LowerArrow　：　Select parent joint or child joint.",
			
			L" ",
			L" ",
			L"　Edit Motion",
			L"　　T + MouseWheel　：　Twist motion.",
			L" ",
			L" ",
			L"　Timeline",
			L"　　Ctrl + MouseWheel　：　Move frame selection by 1 frame.",
			L" ",
			L" ",

			L"　Manipulator",
			L"　　S + Mouse_R_Drag　：　Change manipulator scale.",
			L" ",
			L" ",
			L"　OWP_Slider",
			L"　　Drag on CenterBar　：　Slide starting from clicked position.",
			L"    LButton DoubleClick :  Set value of clicked position.",
			L"    RButton DoubleClick :  Undo value limited to 1,000,000 times.",
			L"    Mouse Wheel : Slide per a pixel.",
			L" ",

			L" ",
			L"　DispGroupWindow",
			L"　　RButton on a Element　：　Context Menu for SimilarCheck.",
			L" ",
			L" ",
			L"　OWP_ScrollWindow",
			L"　　MouseWheel on ScrollBar　：　Scroll Window.",
			L" "
		};

		int textno;
		for (textno = 0; textno < SHORTCUTTEXTNUM; textno++) {
			s_shortcuttext[textno] = new OWP_Label(shortcuttext[textno]);
			if (!s_shortcuttext[textno]) {
				_ASSERT(0);
				return 1;
			}
		}



		//s_placefolderWnd->addParts(*s_placefolderlabel_1);
		//s_placefolderWnd->addParts(*s_placefolderlabel_2);
		//s_placefolderWnd->addParts(*s_placefolderlabel_3);
		for (textno = 0; textno < SHORTCUTTEXTNUM; textno++) {
			s_placefolderWnd->addParts(*s_shortcuttext[textno]);
		}


		s_placefolderWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
		s_placefolderWnd->setPos(WindowPos(windowposx, s_sidemenuheight));

		//１クリック目問題対応
		s_placefolderWnd->refreshPosAndSize();//2022/09/20


		s_placefolderWnd->callRewrite();						//再描画

		s_placefolderWnd->setVisible(false);
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;

}


int CreateDispGroupWnd()
{


	if (!s_model) {
		return 0;
	}

	DestroyDispGroupWnd();


	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	s_groupWnd = new OrgWindow(
		0,
		_T("DispGroupWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),
		WindowSize(s_sidewidth, s_sideheight),		//サイズ
		_T("DispGroupWindow"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true, true);					//サイズ変更の可否

	if (s_groupWnd) {

		s_groupWnd->setSizeMin(WindowSize(150, 150));		// 最小サイズを設定


		s_groupsetB = new OWP_Button(L"Set");
		if (!s_groupsetB) {
			_ASSERT(0);
			return 1;
		}
		s_groupgetB = new OWP_Button(L"Get");
		if (!s_groupgetB) {
			_ASSERT(0);
			return 1;
		}
		//s_grouptestB = new OWP_Button(L"Test");
		//if (!s_grouptestB) {
		//	_ASSERT(0);
		//	return 1;
		//}
		s_grouponB = new OWP_Button(L"ON");
		if (!s_grouponB) {
			_ASSERT(0);
			return 1;
		}
		s_groupoffB = new OWP_Button(L"OFF");
		if (!s_groupoffB) {
			_ASSERT(0);
			return 1;
		}
		s_grouplabel11 = new OWP_Label(L"---------");
		if (!s_grouplabel11) {
			_ASSERT(0);
			return 1;
		}
		s_grouplabel12 = new OWP_Label(L"---------");
		if (!s_grouplabel12) {
			_ASSERT(0);
			return 1;
		}
		s_grouplabel21 = new OWP_Label(L"---------");
		if (!s_grouplabel21) {
			_ASSERT(0);
			return 1;
		}
		s_grouplabel22 = new OWP_Label(L"---------");
		if (!s_grouplabel22) {
			_ASSERT(0);
			return 1;
		}


		int groupindex0;
		for (groupindex0 = 0; groupindex0 < MAXDISPGROUPNUM; groupindex0++) {
			WCHAR groupname[256] = { 0L };
			swprintf_s(groupname, 256, L"%02d", groupindex0 + 1);
			s_groupselect[groupindex0] = new OWP_CheckBoxA(groupname, 0);
			if (!s_groupselect[groupindex0]) {
				_ASSERT(0);
				return 1;
			}
		}

		int result = s_model->SetDispGroupGUI(s_groupobjvec);
		if (result != 0) {
			_ASSERT(0);
			return 1;
		}
		s_grouplinenum = (int)s_groupobjvec.size();

		if (s_grouplinenum <= 0) {
			return 0;
		}


		double centerrate;
		int linedatasize;
		if (g_4kresolution) {
			centerrate = (double)12 / (double)140;
			//linedatasize = max(140, linenum + 12);
			//linedatasize = max(106, (linenum + 12));
			linedatasize = (int)((double)s_grouplinenum * 1.2);
		}
		else {
			centerrate = (double)12 / (double)70;
			//linedatasize = max(70, linenum + 12);
			//linedatasize = max(54, (linenum + 12));
			linedatasize = (int)((double)s_grouplinenum * 1.2);
		}



		//スクロールウインドウ		
		s_groupSCWnd = new OWP_ScrollWnd(L"DispGroupScWnd", true);
		if (!s_groupSCWnd) {
			_ASSERT(0);
			return 1;
		}
		s_groupSCWnd->setLineDataSize(linedatasize);//!!!!!!!!!!!!!
		//s_groupWnd->addParts(*s_groupSCWnd);


		
		s_groupsp0 = new OWP_Separator(s_groupWnd, false, centerrate, false);//上段と下段を格納
		if (!s_groupsp0) {
			_ASSERT(0);
			return 1;
		}
		//s_groupSCWnd->addParts(*s_groupsp0);
		s_groupWnd->addParts(*s_groupsp0);
		

		s_groupsp = new OWP_Separator(s_groupWnd, false, 0.5, true);//ウインドウ上段部分用
		if (!s_groupsp) {
			_ASSERT(0);
			return 1;
		}
		s_groupsp0->addParts1(*s_groupsp);


		s_groupsp0->addParts2(*s_groupSCWnd);
		s_groupsp3 = new OWP_Separator(s_groupWnd, false, 0.8, true, s_groupSCWnd);//parent : s_groupSCWnd　下段　objチェックボックスとtestボタン用
		if (!s_groupsp3) {
			_ASSERT(0);
			return 1;
		}
		s_groupSCWnd->addParts(*s_groupsp3);
		int lineno;
		for (lineno = 0; lineno < s_grouplinenum; lineno++) {
			s_groupsp3->addParts1(*(s_groupobjvec[lineno]));

			OWP_Button* testbutton = new OWP_Button(L"Test");
			if (!testbutton) {
				_ASSERT(0);
				return 1;
			}
			s_grouptestBvec.push_back(testbutton);
			s_groupsp3->addParts2(*(s_grouptestBvec[lineno]));
		}


		s_groupsp1 = new OWP_Separator(s_groupWnd, false, 0.5, true);//上段　グループ番号チェックボックス用
		if (!s_groupsp1) {
			_ASSERT(0);
			return 1;
		}
		s_groupsp->addParts1(*s_groupsp1);

		s_groupsp2 = new OWP_Separator(s_groupWnd, false, 0.5, true);//上段　グループ番号チェックボックス用
		if (!s_groupsp2) {
			_ASSERT(0);
			return 1;
		}
		s_groupsp->addParts2(*s_groupsp2);

		for (groupindex0 = 0; groupindex0 < MAXDISPGROUPNUM; groupindex0++) {
			int colno = groupindex0 % 4;
			if (colno == 0) {
				s_groupsp1->addParts1(*s_groupselect[groupindex0]);
			}
			else if (colno == 1) {
				s_groupsp1->addParts2(*s_groupselect[groupindex0]);
			}
			else if (colno == 2) {
				s_groupsp2->addParts1(*s_groupselect[groupindex0]);
			}
			else {
				s_groupsp2->addParts2(*s_groupselect[groupindex0]);
			}
		}
		
		s_groupsp1->addParts1(*s_grouplabel11);
		s_groupsp1->addParts2(*s_grouplabel12);
		s_groupsp2->addParts1(*s_grouplabel21);
		s_groupsp2->addParts2(*s_grouplabel22);

		s_groupsp1->addParts1(*s_groupsetB);
		s_groupsp1->addParts2(*s_groupgetB);
		s_groupsp2->addParts1(*s_grouponB);
		s_groupsp2->addParts2(*s_groupoffB);
		//s_groupsp2->addParts2(*s_grouptestB);

		{//testボタンのラムダ関数
			int lineno1;
			for (lineno1 = 0; lineno1 < s_grouplinenum; lineno1++) {
				if (s_grouptestBvec[lineno1]) {
					s_grouptestBvec[lineno1]->setButtonListener([lineno1]() {

						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

						//ボタンのtext色をリセット
						int lineno;
						for (lineno = 0; lineno < s_grouplinenum; lineno++) {
							COLORREF normalcol = RGB(255, 255, 255);
							s_grouptestBvec[lineno]->setTextColor(normalcol);
						}

						bool currentstate = s_disponlyoneobj;

						if (lineno1 == s_onlyoneobjno) {
							//現在表示中のobjをオフにした場合にだけ　s_disponlyoneobjをオフにする
							//他のobjのTestボタンを押した場合には　s_disponlyoneobjオンのまま　表示objを変更する
							
							s_disponlyoneobj = false;//!!!!!!!!
							s_onlyoneobjno = -1;//!!!!!!!!
						}
						else {
							s_disponlyoneobj = true;//!!!!!!!!
							s_onlyoneobjno = lineno1;//!!!!!!!!

							COLORREF importantcol = RGB(168, 129, 129);
							s_grouptestBvec[lineno1]->setTextColor(importantcol);
						}

						if (oldcursor) {
							SetCursor(oldcursor);
						}
					});
				}
			}
		}

		{//groupselectボタンのラムダ関数
			int groupindex;
			for (groupindex = 0; groupindex < MAXDISPGROUPNUM; groupindex++) {
				if (s_groupselect[groupindex]) {
					s_groupselect[groupindex]->setButtonListener([groupindex]() {
						bool ischecked = s_groupselect[groupindex]->getValue();
						if (ischecked) {
							//チェックの場合には　他のグループセレクトボタンはチェックを外す(排他的)
							int groupindex2;
							for (groupindex2 = 0; groupindex2 < MAXDISPGROUPNUM; groupindex2++) {
								if ((groupindex2 != groupindex) && s_groupselect[groupindex2]) {
									s_groupselect[groupindex2]->setValue(false);
								}
							}
						}
						if (s_groupWnd) {
							s_groupWnd->callRewrite();
						}
					});
				}
			}
		}

		{//setボタンのラムダ関数
			if (s_groupsetB) {
				s_groupsetB->setButtonListener([]() {
					if (s_model) {

						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

						//選択中のグループ番号を取得
						int selectedgroupno = 0;
						int groupindex;
						for (groupindex = 0; groupindex < MAXDISPGROUPNUM; groupindex++) {
							if (s_groupselect[groupindex] && s_groupselect[groupindex]->getValue()) {
								selectedgroupno = groupindex + 1;//groupno = groupindex + 1
								break;
							}
						}

						//チェックの付いているobjectに対してselectedgroupindexを設定
						if (selectedgroupno >= 1) {
							int lineno1;
							for (lineno1 = 0; lineno1 < s_grouplinenum; lineno1++) {
								if (s_groupobjvec[lineno1] && s_groupobjvec[lineno1]->getValue()) {
									s_model->SetDispGroup(selectedgroupno - 1, lineno1);
								}
							}
							s_model->MakeDispGroupForRender();
						}

						if (oldcursor) {
							SetCursor(oldcursor);
						}

					}
				});
			}
		}

		{//getボタンのラムダ関数
			if (s_groupgetB) {
				s_groupgetB->setButtonListener([]() {
					if (s_model) {

						s_groupUnderGetting = true;//s_groupgetBボタンの処理中は　groupobjvecのチェック処理をスキップ

						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));


						//objectのチェックを全てリセット
						int lineno1;
						for (lineno1 = 0; lineno1 < s_grouplinenum; lineno1++) {
							if (s_groupobjvec[lineno1]) {
								s_groupobjvec[lineno1]->setValue(false);
							}
						}


						//選択中のグループ番号を取得
						int selectedgroupno = 0;
						int groupindex;
						for (groupindex = 0; groupindex < MAXDISPGROUPNUM; groupindex++) {
							if (s_groupselect[groupindex] && s_groupselect[groupindex]->getValue()) {
								selectedgroupno = groupindex + 1;//groupno = groupindex + 1
								break;
							}
						}

						//selectedgroupnoに属するgroupobjvecチェックボックスにチェックを入れる
						if (selectedgroupno >= 1) {

							//selectedgroupnoに属するobjectを取得
							vector<DISPGROUPELEM> digvec;
							digvec.clear();
							s_model->GetDispGroupForRender(selectedgroupno - 1, digvec);//groupindex = groupno - 1

							//objvecにチェックを入れる
							int digvecsize = (int)digvec.size();
							int digno;
							for (digno = 0; digno < digvecsize; digno++) {
								DISPGROUPELEM digelem = digvec[digno];
								int objno = digelem.objno;
								if ((objno >= 0) && (objno < s_grouplinenum) && s_groupobjvec[objno]) {
									s_groupobjvec[objno]->setValue(true);
								}
							}
							if (s_groupWnd) {
								s_groupWnd->callRewrite();
							}
						}

						if (oldcursor) {
							SetCursor(oldcursor);
						}

						s_groupUnderGetting = false;//s_groupgetBボタンの処理中は　groupobjvecのチェック処理をスキップ
					}
				});
			}
		}

		{//ONボタン
			if(s_grouponB){
				s_grouponB->setButtonListener([]() {
					if (s_model) {
						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

						//選択中のグループ番号を取得
						int selectedgroupno = 0;
						int groupindex;
						for (groupindex = 0; groupindex < MAXDISPGROUPNUM; groupindex++) {
							if (s_groupselect[groupindex] && s_groupselect[groupindex]->getValue()) {
								selectedgroupno = groupindex + 1;//groupno = groupindex + 1
								break;
							}
						}

						//selectedgroupnoの表示をオン
						if (selectedgroupno >= 1) {//groupindex = groupno - 1
							s_model->SetDispGroupON(selectedgroupno - 1, true);
						}

						if (oldcursor) {
							SetCursor(oldcursor);
						}
					}
				});
			}
		}

		{//OFFボタン
			if (s_groupoffB) {
				s_groupoffB->setButtonListener([]() {
					if (s_model) {

						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

						//選択中のグループ番号を取得
						int selectedgroupno = 0;
						int groupindex;
						for (groupindex = 0; groupindex < MAXDISPGROUPNUM; groupindex++) {
							if (s_groupselect[groupindex] && s_groupselect[groupindex]->getValue()) {
								selectedgroupno = groupindex + 1;//groupno = groupindex + 1
								break;
							}
						}

						//selectedgroupnoの表示をオフ
						if (selectedgroupno >= 1) {//groupindex = groupno - 1
							s_model->SetDispGroupON(selectedgroupno - 1, false);
						}

						if (oldcursor) {
							SetCursor(oldcursor);
						}

					}
				});
			}
		}

		{//objvecボタン

			//チェックを入れたobjectの子供treeも一緒にチェックを入れる
			int objno1;
			for (objno1 = 0; objno1 < s_grouplinenum; objno1++) {
				if (s_groupobjvec[objno1]) {

					//左クリックで　チェックボックスのチェックをオンオフ
					s_groupobjvec[objno1]->setButtonListener([objno1]() {
						if (s_model) {
							if (s_groupUnderGetting == false) {//s_groupgetBボタンの処理中は　groupobjvecのチェック処理をスキップ)								
								HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

								vector<int> selectedobjtree;
								selectedobjtree.clear();
								s_model->GetSelectedObjTree(objno1, selectedobjtree);//objno1の子供のobjectTreeを取得


								bool newstate;
								if (s_groupobjvec[objno1] && s_groupobjvec[objno1]->getValue()) {
									newstate = true;
								}
								else {
									newstate = false;
								}


								int selectedobjnum = (int)selectedobjtree.size();
								int objindex;
								for (objindex = 0; objindex < selectedobjnum; objindex++) {
									int selectedobjno = selectedobjtree[objindex];
									if ((selectedobjno >= 0) && (selectedobjno < s_grouplinenum) && (selectedobjno != objno1)) {
										s_groupobjvec[selectedobjno]->setValue(newstate);
									}
								}

								if (oldcursor) {
									SetCursor(oldcursor);
								}
							}
						}
					});


					//右クリックメニュー
					s_groupobjvec[objno1]->setContextMenuListener([objno1]() {
						if (s_model && (s_groupUnderGetting == false) && (s_checksimilarFlag == false)) {//s_groupgetBボタンの処理中は　groupobjvecのチェック処理をスキップ)								
								s_checksimilarFlag = true;
								s_checksimilarobjno = objno1;
						}
					});

				}
			}
		}



		//autoResizeしないと　チェックボックス４段目以下が反応なかった
		s_groupSCWnd->autoResize();
		s_groupsp3->autoResize();
		s_groupsp1->autoResize();
		s_groupsp2->autoResize();
		s_groupsp->autoResize();
		s_groupsp0->autoResize();

		s_groupWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
		s_groupWnd->setPos(WindowPos(windowposx, s_sidemenuheight));
		//１クリック目問題対応
		s_groupWnd->refreshPosAndSize();
		s_groupWnd->autoResizeAllParts();
		s_groupWnd->setVisible(false);
	}



	return 0;
}

int CheckSimilarGroup(int opetype)
{
	if (s_model && (s_grouplinenum > 0) && 
		(opetype >= 0) && (opetype <= 3) && 
		(s_checksimilarobjno >= 0) && (s_checksimilarobjno < s_grouplinenum)) {
		
		OWP_CheckBoxA* srccheckbox = s_groupobjvec[s_checksimilarobjno];
		if (srccheckbox) {
			WCHAR similarname[512] = { 0L };
			int result = srccheckbox->getName(similarname, 512);
			if ((result == 0) && (similarname[0] != 0L)) {
				WCHAR pattern0[512] = { 0L };

				WCHAR* patptr0 = wcschr(similarname, TEXT('_'));
				if (patptr0) {
					if (patptr0 != similarname) {//2023/10/08 先頭の文字が '_'以外の場合だけ処理する
						*patptr0 = 0L;

						if ((wcscmp(similarname, L"Prefab") == 0) || (wcscmp(similarname, L"prefab") == 0)) {

							//2024/01/19
							//名前の先頭がPrefab_またはprefab_の場合にはもう１つ後の_までをパターン文字列とする

							WCHAR* patptr1 = wcschr(patptr0 + 1, TEXT('_'));
							if (patptr1) {
								*patptr0 = TEXT('_');
								*patptr1 = 0L;
								wcscpy_s(pattern0, 512, similarname);
							}
							else {
								wcscpy_s(pattern0, 512, similarname);
							}
						}
						else {
							wcscpy_s(pattern0, 512, similarname);
						}

						int pattern0len = (int)wcslen(pattern0);

						if ((opetype == 0) || (opetype == 1)) {
							//#####################
							//pattern include num
							//#####################

							int objno1;
							for (objno1 = 0; objno1 < s_grouplinenum; objno1++) {
								if (s_groupobjvec[objno1]) {
									WCHAR chkname[512] = { 0L };
									int result1 = s_groupobjvec[objno1]->getName(chkname, 512);
									if ((result == 0) && (chkname[0] != 0L)) {
										WCHAR* findptr = wcsstr(chkname, pattern0);//check if pattern is included
										if (findptr) {
											if (opetype == 0) {
												s_groupobjvec[objno1]->setValue(true);
											}
											else if (opetype == 1) {
												s_groupobjvec[objno1]->setValue(false);
											}
											else {
												_ASSERT(0);
												return 1;
											}
										}
									}
								}
							}
						}
						else if ((opetype == 2) || (opetype == 3)) {
							//#####################
							//pattern exclude num
							//#####################

							bool numflag = true;
							int findpos = pattern0len - 1;
							while (numflag && (findpos > 1)) {
								WCHAR chkwc = pattern0[findpos];
								if ((chkwc == TEXT('0')) || (chkwc == TEXT('1')) || (chkwc == TEXT('2')) || (chkwc == TEXT('3')) || (chkwc == TEXT('4')) ||
									(chkwc == TEXT('5')) || (chkwc == TEXT('6')) || (chkwc == TEXT('7')) || (chkwc == TEXT('8')) || (chkwc == TEXT('9'))) {
									findpos--;
								}
								else {
									numflag = false;
									break;
								}
							}
							if ((findpos >= 0) && (findpos < pattern0len)) {
								pattern0[findpos + 1] = 0L;

								int objno1;
								for (objno1 = 0; objno1 < s_grouplinenum; objno1++) {
									if (s_groupobjvec[objno1]) {
										WCHAR chkname[512] = { 0L };
										int result1 = s_groupobjvec[objno1]->getName(chkname, 512);
										if ((result == 0) && (chkname[0] != 0L)) {
											WCHAR* findptr = wcsstr(chkname, pattern0);//check if pattern is included
											if (findptr) {
												if (opetype == 2) {
													s_groupobjvec[objno1]->setValue(true);
												}
												else if (opetype == 3) {
													s_groupobjvec[objno1]->setValue(false);
												}
												else {
													_ASSERT(0);
													return 1;
												}
											}
										}
									}
								}
							}
						}
						else {
							_ASSERT(0);
							return 1;
						}
					}
					else {
						//先頭の文字が　'_'　の場合　は操作の対象外

					}
				}
			}
		}
	}
	else {
		return 1;
	}

	return 0;
}


int CheckSimilarMenu()
{
	if (!s_model) {
		return 0;
	}

	HWND parwnd;
	parwnd = s_3dwnd;


	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_CHECKSIMILARGROUP);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}


	WCHAR strmenu[256] = { 0L };
	int setmenuid;

	setmenuid = ID_RMENU_0 + 0 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"SimilarON (pattern include number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);
	
	setmenuid = ID_RMENU_0 + 1 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"SimilarOFF (pattern include number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);

	setmenuid = ID_RMENU_0 + 2 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"SimilarON (pattern exclude number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);

	setmenuid = ID_RMENU_0 + 3 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"SimilarOFF (pattern exclude number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);



	POINT pt;
	GetCursorPos(&pt);
	//::ScreenToClient(parwnd, &pt);

	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	return 0;
}



int DestroyDispGroupWnd()
{
	if (s_groupWnd) {
		s_groupWnd->setListenMouse(false);
		s_groupWnd->setVisible(false);
		//delete s_groupWnd;
		//s_groupWnd = 0;
	}


	if (s_groupsetB) {
		delete s_groupsetB;
		s_groupsetB = 0;
	}
	if (s_groupgetB) {
		delete s_groupgetB;
		s_groupgetB = 0;
	}
	if (s_grouponB) {
		delete s_grouponB;
		s_grouponB = 0;
	}
	if (s_groupoffB) {
		delete s_groupoffB;
		s_groupoffB = 0;
	}
	if (s_grouplabel11) {
		delete s_grouplabel11;
		s_grouplabel11 = 0;
	}
	if (s_grouplabel12) {
		delete s_grouplabel12;
		s_grouplabel12 = 0;
	}
	if (s_grouplabel21) {
		delete s_grouplabel21;
		s_grouplabel21 = 0;
	}
	if (s_grouplabel22) {
		delete s_grouplabel22;
		s_grouplabel22 = 0;
	}

	int selno;
	for (selno = 0; selno < MAXDISPGROUPNUM; selno++) {
		if (s_groupselect[selno]) {
			delete s_groupselect[selno];
		}
	}
	ZeroMemory(s_groupselect, sizeof(OWP_CheckBoxA*) * MAXDISPGROUPNUM);

	

	int objno;
	size_t objnum = s_groupobjvec.size();
	for (objno = 0; objno < objnum; objno++) {
		if (s_groupobjvec[objno]) {
			delete s_groupobjvec[objno];
		}
	}
	s_groupobjvec.clear();

	int testno;
	size_t testnum = s_grouptestBvec.size();
	for (testno = 0; testno < testnum; testno++) {
		if (s_grouptestBvec[testno]) {
			delete s_grouptestBvec[testno];
		}
	}
	s_grouptestBvec.clear();

	s_grouplinenum = 0;


	if (s_groupsp3) {
		delete s_groupsp3;
		s_groupsp3 = 0;
	}
	if (s_groupsp2) {
		delete s_groupsp2;
		s_groupsp2 = 0;
	}
	if (s_groupsp1) {
		delete s_groupsp1;
		s_groupsp1 = 0;
	}
	if (s_groupsp) {
		delete s_groupsp;
		s_groupsp = 0;
	}
	if (s_groupsp0) {
		delete s_groupsp0;
		s_groupsp0 = 0;
	}
	if (s_groupSCWnd) {
		delete s_groupSCWnd;
		s_groupSCWnd = 0;
	}

	if (s_groupWnd) {
		delete s_groupWnd;
		s_groupWnd = 0;
	}


	s_disponlyoneobj = false;
	s_onlyoneobjno = -1;


	return 0;
}



int CreateRigidWnd()
{

	/////////
	//s_rigidWnd = new OrgWindow(
	//	0,
	//	_T("RigidWindow"),		//ウィンドウクラス名
	//	GetModuleHandle(NULL),	//インスタンスハンドル
	//							//WindowPos(100, 200),		//位置
	//	WindowPos(1216, 48),
	//	//WindowSize(450,880),		//サイズ
	//	//WindowSize(450,680),		//サイズ
	//	//WindowSize(450, 760),		//サイズ
	//	WindowSize(450, 780),		//サイズ
	//	_T("剛体設定ウィンドウ"),	//タイトル
	//	g_mainhwnd,	//親ウィンドウハンドル
	//	true,					//表示・非表示状態
	//	70, 50, 70,				//カラー
	//	true,					//閉じられるか否か
	//	true);					//サイズ変更の可否

	s_dsrigidctrls.clear();

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	s_rigidWnd = new OrgWindow(
		0,
		_T("RigidWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),
		WindowSize(s_sidewidth, s_sideheight),		//サイズ
		_T("RigidWindow"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true, true);					//サイズ変更の可否

	if (s_rigidWnd) {
		bool limitradionamelen = false;

		s_groupcheck = new OWP_CheckBoxA(L"ToAll_MeansToSetToSameGroupRigids", 0);
		if (!s_groupcheck) {
			_ASSERT(0);
			return 1;
		}
		s_sphrateSlider = new OWP_Slider(0.6, 20.0, 0.0);
		if (!s_sphrateSlider) {
			_ASSERT(0);
			return 1;
		}
		s_boxzSlider = new OWP_Slider(0.6, 20.0, 0.0);
		if (!s_boxzSlider) {
			_ASSERT(0);
			return 1;
		}
		s_massSlider = new OWP_Slider(g_initmass, 30.0, 0.0);
		if (!s_massSlider) {
			_ASSERT(0);
			return 1;
		}
		//s_massSeparator = new OWP_Separator(s_rigidWnd, true, 0.5, true);
		//s_massSeparator1 = new OWP_Separator(s_rigidWnd, true, 0.5, true);
		//s_massSeparator2 = new OWP_Separator(s_rigidWnd, true, 0.5, true);
		s_massB = new OWP_Button(L"MassToAll");
		if (!s_massB) {
			_ASSERT(0);
			return 1;
		}
		s_thicknessB = new OWP_Button(L"ThicknessToAll");
		if (!s_thicknessB) {
			_ASSERT(0);
			return 1;
		}
		s_depthB = new OWP_Button(L"DepthToAll");
		if (!s_depthB) {
			_ASSERT(0);
			return 1;
		}
		s_massspacelabel = new OWP_Label(L"(Space4)");
		if (!s_massspacelabel) {
			_ASSERT(0);
			return 1;
		}
		s_validSeparator = new OWP_Separator(s_rigidWnd, true, 0.5, true);
		if (!s_validSeparator) {
			_ASSERT(0);
			return 1;
		}
		s_skipB = new OWP_Button(L"ToAll");
		if (!s_skipB) {
			_ASSERT(0);
			return 1;
		}
		s_rigidskip = new OWP_CheckBoxA(L"Valid/Invalid (有効/無効)", 1);
		if (!s_rigidskip) {
			_ASSERT(0);
			return 1;
		}
		s_forbidSeparator = new OWP_Separator(s_rigidWnd, true, 0.5, true);
		if (!s_forbidSeparator) {
			_ASSERT(0);
			return 1;
		}
		s_forbidB = new OWP_Button(L"ToAll");
		if (!s_forbidB) {
			_ASSERT(0);
			return 1;
		}
		s_forbidrot = new OWP_CheckBoxA(L"ForbidRot", 0);
		if (!s_forbidrot) {
			_ASSERT(0);
			return 1;
		}
		//s_allrigidenableB = new OWP_Button(L"ValidateAllRigids");
		//s_allrigiddisableB = new OWP_Button(L"InvalidateAllRigids");
		s_btgSlider = new OWP_Slider(-1.0, 1.0, -1.0);
		if (!s_btgSlider) {
			_ASSERT(0);
			return 1;
		}
		s_btgscSlider = new OWP_Slider(10.0, 100.0, 0.0);
		if (!s_btgscSlider) {
			_ASSERT(0);
			return 1;
		}
		s_btgB = new OWP_Button(L"GToAll");
		if (!s_btgB) {
			_ASSERT(0);
			return 1;
		}
		s_btforceSeparator = new OWP_Separator(s_rigidWnd, true, 0.5, true);
		if (!s_btforceSeparator) {
			_ASSERT(0);
			return 1;
		}
		s_btforce = new OWP_CheckBoxA(L"RigidBodySimulation", 0);
		if (!s_btforce) {
			_ASSERT(0);
			return 1;
		}
		s_btforceB = new OWP_Button(L"ToAll");
		if (!s_btforceB) {
			_ASSERT(0);
			return 1;
		}

		s_shplabel = new OWP_Label(L"Thickness");
		if (!s_shplabel) {
			_ASSERT(0);
			return 1;
		}
		s_boxzlabel = new OWP_Label(L"Depth");
		if (!s_boxzlabel) {
			_ASSERT(0);
			return 1;
		}
		s_massSLlabel = new OWP_Label(L"Mass");
		if (!s_massSLlabel) {
			_ASSERT(0);
			return 1;
		}
		s_btglabel = new OWP_Label(L"Gravity");
		if (!s_btglabel) {
			_ASSERT(0);
			return 1;
		}
		s_btgsclabel = new OWP_Label(L"ScaleOfGravity");
		if (!s_btgsclabel) {
			_ASSERT(0);
			return 1;
		}

		s_namelabel = new OWP_Label(L"BonaName:????");
		if (!s_namelabel) {
			_ASSERT(0);
			return 1;
		}
		s_lenglabel = new OWP_Label(L"BoneLength:*****[m]");
		if (!s_lenglabel) {
			_ASSERT(0);
			return 1;
		}


		s_kB = new OWP_Button(L"SpringParamsToAll");
		if (!s_kB) {
			_ASSERT(0);
			return 1;
		}
		s_restB = new OWP_Button(L"RestitutionAndFrictionToAll");
		if (!s_restB) {
			_ASSERT(0);
			return 1;
		}

		s_colSeparator = new OWP_Separator(s_rigidWnd, true, 0.5, true);
		if (!s_colSeparator) {
			_ASSERT(0);
			return 1;
		}
		s_colB = new OWP_Button(L"ToAll");
		if (!s_colB) {
			_ASSERT(0);
			return 1;
		}
		s_colradio = new OWP_RadioButton(L"Cone", limitradionamelen);
		if (!s_colradio) {
			_ASSERT(0);
			return 1;
		}
		s_colradio->addLine(L"Capsule");
		s_colradio->addLine(L"Sphere");
		s_colradio->addLine(L"Rectangular");

		s_lkradio = new OWP_RadioButton(L"[posSpring]very weak", limitradionamelen);
		if (!s_lkradio) {
			_ASSERT(0);
			return 1;
		}
		s_lkradio->addLine(L"[posSpring]weak");
		s_lkradio->addLine(L"[posSpring]regular");
		s_lkradio->addLine(L"[posSpring]custom");

		//s_lkSlider = new OWP_Slider(g_initcuslk, 1e6, 1e4);//60000
		//s_lkSlider = new OWP_Slider(g_initcuslk, 1e10, 1e8);//60000
		s_lkSlider = new OWP_Slider(g_initcuslk, 1e4, 1e2);//60000
		if (!s_lkSlider) {
			_ASSERT(0);
			return 1;
		}
		s_lklabel = new OWP_Label(L"posSpring customValue");
		if (!s_lklabel) {
			_ASSERT(0);
			return 1;
		}

		s_akradio = new OWP_RadioButton(L"[rotSpring]very weak", limitradionamelen);
		if (!s_akradio) {
			_ASSERT(0);
			return 1;
		}
		s_akradio->addLine(L"[rotSpring]weak");
		s_akradio->addLine(L"[rotSpring]regular");
		s_akradio->addLine(L"[rotSpring]custom");

		//s_akSlider = new OWP_Slider(g_initcusak, 6000.0f, 0.0f);//300
		//s_akSlider = new OWP_Slider(g_initcusak, 30.0f, 0.0f);//300
		//s_akSlider = new OWP_Slider(g_initcusak, 3000.0f, 30.0f);//300
		//s_akSlider = new OWP_Slider(g_initcusak, 3000.0f, 10.0f);//300 ver10024
		s_akSlider = new OWP_Slider(g_initcusak, 3000.0f, 2.0f);//2022/07/19
		if (!s_akSlider) {
			_ASSERT(0);
			return 1;
		}
		//s_akSlider = new OWP_Slider(g_initcusak, 1.0f, 0.0f);//2023/01/18
		s_aklabel = new OWP_Label(L"rotSpring customValue");
		if (!s_aklabel) {
			_ASSERT(0);
			return 1;
		}

		s_restSlider = new OWP_Slider(0.5f, 1.0f, 0.0f);
		if (!s_restSlider) {
			_ASSERT(0);
			return 1;
		}
		s_restlabel = new OWP_Label(L"RigidRestitution");
		if (!s_restlabel) {
			_ASSERT(0);
			return 1;
		}
		s_fricSlider = new OWP_Slider(0.5f, 1.0f, 0.0f);
		if (!s_fricSlider) {
			_ASSERT(0);
			return 1;
		}
		s_friclabel = new OWP_Label(L"RigidFriction");
		if (!s_friclabel) {
			_ASSERT(0);
			return 1;
		}


		s_ldmplabel = new OWP_Label(L"[posSpring]rateOfDumping");
		if (!s_ldmplabel) {
			_ASSERT(0);
			return 1;
		}
		s_admplabel = new OWP_Label(L"[rotSpring]rateOfDumping");
		if (!s_admplabel) {
			_ASSERT(0);
			return 1;
		}
		s_ldmpSlider = new OWP_Slider(g_l_dmp, 1.0, 0.0);
		if (!s_ldmpSlider) {
			_ASSERT(0);
			return 1;
		}
		s_admpSlider = new OWP_Slider(g_a_dmp, 1.0, 0.0);
		if (!s_admpSlider) {
			_ASSERT(0);
			return 1;
		}
		s_dmpB = new OWP_Button(L"DumpingToAll");
		if (!s_dmpB) {
			_ASSERT(0);
			return 1;
		}
		s_groupB = new OWP_Button(L"SetRigidGroupIDForConflict");
		if (!s_groupB) {
			_ASSERT(0);
			return 1;
		}
		s_gcoliB = new OWP_Button(L"SetGroundGroupIDForConflict");
		if (!s_gcoliB) {
			_ASSERT(0);
			return 1;
		}




		COLORREF colorToAll = RGB(64, 128 + 32, 128 + 32);
		COLORREF colorValidInvalid = RGB(168, 129, 129);

		s_groupcheck->setTextColor(colorToAll);
		s_massB->setTextColor(colorToAll);
		s_thicknessB->setTextColor(colorToAll);
		s_depthB->setTextColor(colorToAll);
		s_skipB->setTextColor(colorToAll);
		s_forbidB->setTextColor(colorToAll);
		s_btgB->setTextColor(colorToAll);
		s_btforceB->setTextColor(colorToAll);
		s_colB->setTextColor(colorToAll);
		s_dmpB->setTextColor(colorToAll);
		s_kB->setTextColor(colorToAll);
		s_restB->setTextColor(colorToAll);


		s_rigidskip->setTextColor(colorValidInvalid);
		s_btforce->setTextColor(colorValidInvalid);



		int slw = 350;

		s_sphrateSlider->setSize(WindowSize(slw, 40));
		s_boxzSlider->setSize(WindowSize(slw, 40));
		s_massSlider->setSize(WindowSize(slw, 40));
		s_btgSlider->setSize(WindowSize(slw, 40));
		s_btgscSlider->setSize(WindowSize(slw, 40));
		s_ldmpSlider->setSize(WindowSize(slw, 40));
		s_admpSlider->setSize(WindowSize(slw, 40));
		s_lkSlider->setSize(WindowSize(slw, 40));
		s_akSlider->setSize(WindowSize(slw, 40));
		s_restSlider->setSize(WindowSize(slw, 40));
		s_fricSlider->setSize(WindowSize(slw, 40));


		s_rigidWnd->addParts(*s_namelabel);
		s_rigidWnd->addParts(*s_groupcheck);
		s_rigidWnd->addParts(*s_shplabel);
		s_rigidWnd->addParts(*s_sphrateSlider);
		s_rigidWnd->addParts(*s_thicknessB);
		s_rigidWnd->addParts(*s_boxzlabel);
		s_rigidWnd->addParts(*s_boxzSlider);
		s_rigidWnd->addParts(*s_depthB);
		s_rigidWnd->addParts(*s_massSLlabel);
		s_rigidWnd->addParts(*s_massSlider);
		s_rigidWnd->addParts(*s_massB);

		////s_rigidWnd->addParts(*s_massB);
		////s_massB->setColor(64, 128, 128);
		////s_thicknessB->setColor(64, 128, 128);
		////s_depthB->setColor(64, 128, 128);
		//s_rigidWnd->addParts(*s_massSeparator);
		//s_massSeparator->addParts1(*s_massSeparator1);
		//s_massSeparator->addParts2(*s_massSeparator2);
		//s_massSeparator1->addParts1(*s_massB);
		//s_massSeparator1->addParts2(*s_thicknessB);
		//s_massSeparator2->addParts1(*s_depthB);
		////s_massSeparator2->addParts2(*s_massspacelabel);

		s_rigidWnd->addParts(*s_lenglabel);

		s_rigidWnd->addParts(*s_validSeparator);
		s_validSeparator->addParts1(*s_rigidskip);
		s_validSeparator->addParts2(*s_skipB);
		//s_rigidWnd->addParts(*s_rigidskip);

		s_rigidWnd->addParts(*s_forbidSeparator);
		s_forbidSeparator->addParts1(*s_forbidrot);
		s_forbidSeparator->addParts2(*s_forbidB);
		//s_rigidWnd->addParts(*s_forbidrot);
		//s_rigidWnd->addParts(*s_allrigidenableB);
		//s_rigidWnd->addParts(*s_allrigiddisableB);


		s_rigidWnd->addParts(*s_colSeparator);
		s_colSeparator->addParts1(*s_colradio);
		s_colSeparator->addParts2(*s_colB);
		//s_rigidWnd->addParts(*s_colradio);

		s_rigidWnd->addParts(*s_lkradio);
		s_rigidWnd->addParts(*s_lklabel);
		s_rigidWnd->addParts(*s_lkSlider);
		s_rigidWnd->addParts(*s_akradio);
		s_rigidWnd->addParts(*s_aklabel);
		s_rigidWnd->addParts(*s_akSlider);
		s_rigidWnd->addParts(*s_kB);

		s_rigidWnd->addParts(*s_restlabel);
		s_rigidWnd->addParts(*s_restSlider);
		s_rigidWnd->addParts(*s_friclabel);
		s_rigidWnd->addParts(*s_fricSlider);
		s_rigidWnd->addParts(*s_restB);


		s_rigidWnd->addParts(*s_ldmplabel);
		s_rigidWnd->addParts(*s_ldmpSlider);
		s_rigidWnd->addParts(*s_admplabel);
		s_rigidWnd->addParts(*s_admpSlider);
		s_rigidWnd->addParts(*s_dmpB);

		s_rigidWnd->addParts(*s_btglabel);
		s_rigidWnd->addParts(*s_btgSlider);
		s_rigidWnd->addParts(*s_btgsclabel);
		s_rigidWnd->addParts(*s_btgscSlider);

		s_rigidWnd->addParts(*s_btgB);

		//s_rigidWnd->addParts(*s_btforce);
		s_rigidWnd->addParts(*s_btforceSeparator);
		s_btforceSeparator->addParts1(*s_btforce);
		s_btforceSeparator->addParts2(*s_btforceB);

		s_rigidWnd->addParts(*s_groupB);
		s_rigidWnd->addParts(*s_gcoliB);
		/////////
		s_dsrigidctrls.push_back(s_namelabel);
		s_dsrigidctrls.push_back(s_groupcheck);
		s_dsrigidctrls.push_back(s_shplabel);
		s_dsrigidctrls.push_back(s_sphrateSlider);
		s_dsrigidctrls.push_back(s_boxzlabel);
		s_dsrigidctrls.push_back(s_boxzSlider);
		s_dsrigidctrls.push_back(s_massSLlabel);
		s_dsrigidctrls.push_back(s_massSlider);
		s_dsrigidctrls.push_back(s_massB);
		s_dsrigidctrls.push_back(s_thicknessB);
		s_dsrigidctrls.push_back(s_depthB);
		s_dsrigidctrls.push_back(s_lenglabel);
		s_dsrigidctrls.push_back(s_rigidskip);
		s_dsrigidctrls.push_back(s_skipB);
		s_dsrigidctrls.push_back(s_forbidrot);
		s_dsrigidctrls.push_back(s_forbidB);
		//s_dsrigidctrls.push_back(s_allrigidenableB);
		//s_dsrigidctrls.push_back(s_allrigiddisableB);

		s_dsrigidctrls.push_back(s_colradio);
		s_dsrigidctrls.push_back(s_colB);

		s_dsrigidctrls.push_back(s_lkradio);
		s_dsrigidctrls.push_back(s_lklabel);
		s_dsrigidctrls.push_back(s_lkSlider);
		s_dsrigidctrls.push_back(s_akradio);
		s_dsrigidctrls.push_back(s_aklabel);
		s_dsrigidctrls.push_back(s_akSlider);
		s_dsrigidctrls.push_back(s_kB);

		s_dsrigidctrls.push_back(s_restlabel);
		s_dsrigidctrls.push_back(s_restSlider);
		s_dsrigidctrls.push_back(s_friclabel);
		s_dsrigidctrls.push_back(s_fricSlider);
		s_dsrigidctrls.push_back(s_restB);


		s_dsrigidctrls.push_back(s_ldmplabel);
		s_dsrigidctrls.push_back(s_ldmpSlider);
		s_dsrigidctrls.push_back(s_admplabel);
		s_dsrigidctrls.push_back(s_admpSlider);
		s_dsrigidctrls.push_back(s_dmpB);

		s_dsrigidctrls.push_back(s_btglabel);
		s_dsrigidctrls.push_back(s_btgSlider);
		s_dsrigidctrls.push_back(s_btgsclabel);
		s_dsrigidctrls.push_back(s_btgscSlider);
		s_dsrigidctrls.push_back(s_btgB);
		s_dsrigidctrls.push_back(s_btforce);
		s_dsrigidctrls.push_back(s_btforceB);

		s_dsrigidctrls.push_back(s_groupB);
		s_dsrigidctrls.push_back(s_gcoliB);


		s_rigidWnd->setCloseListener([]() {
			if (s_model) {
				s_RcloseFlag = true;
			}
			});

		s_sphrateSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_sphrateSlider) {
						float val = (float)s_sphrateSlider->getValue();
						curre->SetSphrate(val);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_boxzSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_boxzSlider) {
						float val = (float)s_boxzSlider->getValue();
						curre->SetBoxzrate(val);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});

		s_massSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_massSlider) {
						float val = (float)s_massSlider->getValue();
						curre->SetMass(val);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});

		s_ldmpSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_ldmpSlider) {
						float val = (float)s_ldmpSlider->getValue();
						curre->SetLDamping(val);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_admpSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_admpSlider) {
						float val = (float)s_admpSlider->getValue();
						curre->SetADamping(val);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});

		s_lkSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_lkSlider) {
						float val = (float)s_lkSlider->getValue();
						curre->SetCusLk(val);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_akSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_akSlider) {
						float val = (float)s_akSlider->getValue();
						curre->SetCusAk(val);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});


		s_restSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_restSlider) {
						float val = (float)s_restSlider->getValue();
						curre->SetRestitution(val);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_fricSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_fricSlider) {
						float val = (float)s_fricSlider->getValue();
						curre->SetFriction(val);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_rigidskip->setButtonListener([]() {
			if (s_model && s_rigidWnd) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					if (s_rigidskip) {
						bool validflag = s_rigidskip->getValue();
						if (validflag == false) {
							curre->SetSkipflag(1);
						}
						else {
							curre->SetSkipflag(0);
						}
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_skipB->setButtonListener([]() {
			if (s_model && s_rigidskip && s_groupcheck) {
				bool validflag = s_rigidskip->getValue();
				int skipflag;
				if (validflag == false) {
					skipflag = 1;
				}
				else {
					skipflag = 0;
				}
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllSkipflagData(gid, s_reindexmap[s_model], skipflag);
			}
			});

		s_forbidrot->setButtonListener([]() {
			if (s_model && s_rigidWnd && s_forbidrot) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					bool validflag = s_forbidrot->getValue();
					if (validflag == false) {
						curre->SetForbidRotFlag(0);
					}
					else {
						curre->SetForbidRotFlag(1);
					}
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_forbidB->setButtonListener([]() {
			if (s_model && s_forbidrot && s_groupcheck) {
				bool validflag = s_forbidrot->getValue();
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllForbidrotData(gid, s_reindexmap[s_model], validflag);
			}
			});

		//s_allrigidenableB->setButtonListener([](){
		//	if (s_model){
		//		s_model->EnableAllRigidElem(s_reindexmap[s_model]);
		//	}
		//	s_rigidWnd->callRewrite();						//再描画
		//});
		//s_allrigiddisableB->setButtonListener([](){
		//	if (s_model){
		//		s_model->DisableAllRigidElem(s_reindexmap[s_model]);
		//	}
		//	s_rigidWnd->callRewrite();						//再描画
		//});


		s_btforce->setButtonListener([]() {
			if (s_model && (s_curboneno >= 0) && s_btforce) {
				CBone* curbone = s_model->GetBoneByID(s_curboneno);
				if (curbone) {
					CBone* parentbone = curbone->GetParent(false);
					if (parentbone && parentbone->IsSkeleton()) {
						bool kinflag = s_btforce->getValue();
						if (kinflag == false) {
							parentbone->SetBtForce(0);
						}
						else {
							parentbone->SetBtForce(1);
						}
					}
				}
			}
			s_rigidWnd->callRewrite();						//再描画
			});

		s_btgSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd && s_btgSlider) {
				float btg = (float)s_btgSlider->getValue();
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					curre->SetBtg(btg);
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_btgscSlider->setCursorListener([]() {
			if (s_model && s_rigidWnd && s_btgscSlider) {
				float btgsc = (float)s_btgscSlider->getValue();
				if (s_model && (s_reindexmap[s_model] >= 0)) {
					REINFO tmpinfo = s_model->GetRigidElemInfo(s_reindexmap[s_model]);
					tmpinfo.btgscale = btgsc;
					s_model->SetRigidElemInfo(s_reindexmap[s_model], tmpinfo);
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});

		s_colradio->setSelectListener([]() {
			if (s_model && s_rigidWnd && s_colradio) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					int val = s_colradio->getSelectIndex();
					curre->SetColtype(val);
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_colB->setButtonListener([]() {
			if (s_model && s_colradio && s_groupcheck) {
				int val = s_colradio->getSelectIndex();
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllColtypeData(gid, s_reindexmap[s_model], val);
			}
			});

		s_lkradio->setSelectListener([]() {
			if (s_model && s_rigidWnd && s_lkradio) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					int val = s_lkradio->getSelectIndex();
					curre->SetLKindex(val);
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});
		s_akradio->setSelectListener([]() {
			if (s_model && s_rigidWnd && s_akradio) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					int val = s_akradio->getSelectIndex();
					curre->SetAKindex(val);
				}
				s_rigidWnd->callRewrite();						//再描画
			}
			});

		s_kB->setButtonListener([]() {
			if (s_model && s_lkradio && s_akradio && s_lkSlider && s_akSlider && s_groupcheck) {
				int lindex = s_lkradio->getSelectIndex();
				int aindex = s_akradio->getSelectIndex();
				float cuslk = (float)s_lkSlider->getValue();
				float cusak = (float)s_akSlider->getValue();
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllKData(gid, s_reindexmap[s_model], lindex, aindex, cuslk, cusak);
			}
			});
		s_restB->setButtonListener([]() {
			if (s_model && s_restSlider && s_fricSlider && s_groupcheck) {
				float rest = (float)s_restSlider->getValue();
				float fric = (float)s_fricSlider->getValue();
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllRestData(gid, s_reindexmap[s_model], rest, fric);
			}
			});
		s_dmpB->setButtonListener([]() {
			if (s_model && s_ldmpSlider && s_admpSlider && s_groupcheck) {
				float ldmp = (float)s_ldmpSlider->getValue();
				float admp = (float)s_admpSlider->getValue();
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllDmpData(gid, s_reindexmap[s_model], ldmp, admp);
			}
			});

		s_groupB->setButtonListener([]() {
			if (s_model) {
				CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
				if (curre) {
					CColiIDDlg dlg(curre);
					s_pcolidlg = &dlg;
					s_undercolidlg = true;

					dlg.DoModal();
					if (dlg.m_setgroup == 1) {
						if (s_model) {
							s_model->SetColiIDtoGroup(curre);
						}
					}

					s_undercolidlg = false;
					s_pcolidlg = 0;

				}
			}
			});
		s_gcoliB->setButtonListener([]() {
			if (s_model) {
				if (s_bpWorld) {
					CGColiIDDlg dlg(s_bpWorld->m_coliids, s_bpWorld->m_myselfflag);
					s_pgcolidlg = &dlg;
					s_undergcolidlg = true;

					int dlgret = (int)dlg.DoModal();
					if (dlgret == IDOK) {
						s_bpWorld->m_coliids = dlg.m_coliids;
						s_bpWorld->m_myselfflag = dlg.m_myself;
						s_bpWorld->RemakeG();
					}

					s_undergcolidlg = false;
					s_pgcolidlg = 0;
				}
			}
			});

		s_massB->setButtonListener([]() {
			if (s_model && s_massSlider && s_groupcheck) {
				float mass = (float)s_massSlider->getValue();
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllMassData(gid, s_reindexmap[s_model], mass);
			}
			//		_ASSERT( 0 );
			});
		s_thicknessB->setButtonListener([]() {
			if (s_model && s_sphrateSlider && s_groupcheck) {
				float sphrate = (float)s_sphrateSlider->getValue();
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllSphrateData(gid, s_reindexmap[s_model], sphrate);
			}
			//		_ASSERT( 0 );
			});
		s_depthB->setButtonListener([]() {
			if (s_model && s_boxzSlider && s_groupcheck) {
				float boxzrate = (float)s_boxzSlider->getValue();
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllBoxzrateData(gid, s_reindexmap[s_model], boxzrate);
			}
			//		_ASSERT( 0 );
			});
		s_btgB->setButtonListener([]() {
			if (s_model && s_btgSlider && s_groupcheck) {
				float btg = (float)s_btgSlider->getValue();
				int chkg = (int)s_groupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllBtgData(gid, s_reindexmap[s_model], btg);
			}
			});
		s_btforceB->setButtonListener([]() {
			if (s_model && s_btforce) {
				bool kinflag = s_btforce->getValue();
				s_model->SetAllBtforceData(s_reindexmap[s_model], kinflag);
			}
			});

		s_rigidWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
		s_rigidWnd->setPos(WindowPos(windowposx, s_sidemenuheight));

		//１クリック目問題対応
		s_rigidWnd->refreshPosAndSize();//2022/09/20


		s_rigidWnd->callRewrite();						//再描画
		s_rigidWnd->setVisible(false);

		s_rcrigidwnd.top = s_sidemenuheight;
		s_rcrigidwnd.left = 0;

		s_rcrigidwnd.bottom = s_sideheight;
		s_rcrigidwnd.right = s_sidewidth;

	}
	else {
		_ASSERT(0);
		return 1;
	}

	
	return 0;
}

void DestroyShaderTypeWnd()
{
	if (s_modelnamelabel) {
		delete s_modelnamelabel;
		s_modelnamelabel = 0;
	}

	int index;
	for (index = 0; index < (MAXMATERIALNUM + 1); index++) {
		if (s_materialnameB[index]) {
			delete s_materialnameB[index];
			s_materialnameB[index] = 0;
		}
		if (s_shadertypelabel[index]) {
			delete s_shadertypelabel[index];
			s_shadertypelabel[index] = 0;
		}
		if (s_metalcoeflabel[index]) {
			delete s_metalcoeflabel[index];
			s_metalcoeflabel[index] = 0;
		}
		if (s_lightscalelabel[index]) {
			delete s_lightscalelabel[index];
			s_lightscalelabel[index] = 0;
		}
	}


	if (s_shadersp2) {
		delete s_shadersp2;
		s_shadersp2 = 0;
	}
	if (s_shadersp3) {
		delete s_shadersp3;
		s_shadersp3 = 0;
	}
	if (s_shadersp1) {
		delete s_shadersp1;
		s_shadersp1 = 0;
	}
	if (s_SCshadertype) {
		delete s_SCshadertype;
		s_SCshadertype = 0;
	}

	if (s_shadertypeWnd) {
		delete s_shadertypeWnd;
		s_shadertypeWnd = 0;
	}

}


int CreateShaderTypeWnd()
{
	DestroyShaderTypeWnd();


	//s_dsrigidctrls.clear();

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	s_shadertypeWnd = new OrgWindow(
		0,
		_T("ShaderTypeWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),
		WindowSize(s_sidewidth, s_sideheight),		//サイズ
		_T("ShderTypeWindow"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true, true);					//サイズ変更の可否



	if (!s_model) {
		//モデルが無い場合には　ウインドウ枠だけ作成してリターン
		return 0;
	}

	int materialnum = s_model->GetMQOMaterialSize();

	if (s_shadertypeWnd) {
		int linedatasize;
		linedatasize = (int)((double)(materialnum + 1) * 1.2);


		s_SCshadertype = new OWP_ScrollWnd(L"ShaderTypeScWnd", true);
		if (!s_SCshadertype) {
			_ASSERT(0);
			return 1;
		}
		s_SCshadertype->setLineDataSize(linedatasize);//!!!!!!!!!!!!!
		s_shadertypeWnd->addParts(*s_SCshadertype);


		//s_shadersp1 = new OWP_Separator(s_shadertypeWnd, false, 0.75, true);
		s_shadersp1 = new OWP_Separator(s_shadertypeWnd, false, 0.75, true, s_SCshadertype);//2023/12/22
		if (!s_shadersp1) {
			_ASSERT(0);
			return 1;
		}
		s_SCshadertype->addParts(*s_shadersp1);

		//s_shadersp2 = new OWP_Separator(s_shadertypeWnd, false, 0.80, true, s_SCshadertype);
		//if (!s_shadersp2) {
		//	_ASSERT(0);
		//	return 1;
		//}
		//s_shadersp1->addParts1(*s_shadersp2);

		//s_shadersp3 = new OWP_Separator(s_shadertypeWnd, false, 0.5, true, s_SCshadertype);
		//if (!s_shadersp3) {
		//	_ASSERT(0);
		//	return 1;
		//}
		//s_shadersp1->addParts2(*s_shadersp3);

		//見出し行　見出し行のs_materialnameBは全てのマテリアルに適用するためのボタン
		//OrgWinGUI::OrgWindowParts::color_tag colorforindex;//RGB(168, 129, 129)
		//colorforindex.r = 168;
		//colorforindex.g = 129;
		//colorforindex.b = 129;
		COLORREF indexcolor = RGB(168, 129, 129);
		s_materialnameB[0] = new OWP_Button(L"MaterialName");
		if (!s_materialnameB[0]) {
			_ASSERT(0);
			return 1;
		}
		s_materialnameB[0]->setTextColor(indexcolor);
		s_shadertypelabel[0] = new OWP_Label(L"ShaderType");
		if (!s_shadertypelabel[0]) {
			_ASSERT(0);
			return 1;
		}
		//s_shadertypelabel[0]->setTextColor(indexcolor);
		//s_metalcoeflabel[0] = new OWP_Label(L"MetalCoef");
		//if (!s_metalcoeflabel[0]) {
		//	_ASSERT(0);
		//	return 1;
		//}
		//s_metalcoeflabel[0]->setTextColor(indexcolor);
		//s_lightscalelabel[0] = new OWP_Label(L"LightScale");
		//if (!s_lightscalelabel[0]) {
		//	_ASSERT(0);
		//	return 1;
		//}
		//s_lightscalelabel[0]->setTextColor(indexcolor);

		//s_shadersp2->addParts1(*(s_materialnameB[0]));
		//s_shadersp2->addParts2(*(s_shadertypelabel[0]));
		//s_shadersp3->addParts1(*(s_metalcoeflabel[0]));
		//s_shadersp3->addParts2(*(s_lightscalelabel[0]));

		s_shadersp1->addParts1(*(s_materialnameB[0]));
		s_shadersp1->addParts2(*(s_shadertypelabel[0]));



		int setindex;
		for (setindex = 1; setindex < (materialnum + 1); setindex++) {

			if (setindex == materialnum) {
				int dbgflag2 = 1;
			}

			int materialindex = setindex - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);
			if (!curmqomat) {
				_ASSERT(0);
				return 1;
			}


			char name[256] = { 0 };
			strcpy_s(name, 256, curmqomat->GetName());
			WCHAR wname[256] = { 0L };
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, name, 256, wname, 256);
			s_materialnameB[setindex] = new OWP_Button(wname);
			if (!s_materialnameB[setindex]) {
				_ASSERT(0);
				return 1;
			}


			int shadertype = curmqomat->GetShaderType();
			WCHAR strshadertype[256] = { 0L };
			switch (shadertype) {
			case MQOSHADER_PBR:
				wcscpy_s(strshadertype, 256, L"PBR");
				break;
			case MQOSHADER_STD:
				wcscpy_s(strshadertype, 256, L"STD");
				break;
			case MQOSHADER_NOLIGHT:
				wcscpy_s(strshadertype, 256, L"NOLIGHT");
				break;
			case -1:
			case -2:
				wcscpy_s(strshadertype, 256, L"AUTO");
				break;
			default:
				_ASSERT(0);
				wcscpy_s(strshadertype, 256, L"Unknown");
				break;
			}
			s_shadertypelabel[setindex] = new OWP_Label(strshadertype);
			if (!s_shadertypelabel[setindex]) {
				_ASSERT(0);
				return 1;
			}
			
			//float metalcoef = curmqomat->GetMetalCoef();
			//WCHAR strmetalcoef[256] = { 0L };
			//swprintf_s(strmetalcoef, 256, L"%.3f", metalcoef);
			//s_metalcoeflabel[setindex] = new OWP_Label(strmetalcoef);
			//if (!s_metalcoeflabel[setindex]) {
			//	_ASSERT(0);
			//	return 1;
			//}

			//WCHAR strlightscale[256] = { 0L };
			//bool isedited = false;
			//int litno5;
			//for (litno5 = 0; litno5 < LIGHTNUMMAX; litno5++) {
			//	float curscale = curmqomat->GetLightScale(litno5);
			//	if ((curscale >= (1.0f - 0.0001f)) && (curscale <= (1.0f + 0.0001f))) {
			//		//1.0f
			//	}
			//	else {
			//		isedited = true;
			//		break;
			//	}
			//}
			//if (isedited) {
			//	wcscpy_s(strlightscale, 256, L"***");
			//}
			//else {
			//	wcscpy_s(strlightscale, 256, L"1.00");
			//}
			//s_lightscalelabel[setindex] = new OWP_Label(strlightscale);
			//if (!s_lightscalelabel[setindex]) {
			//	_ASSERT(0);
			//	return 1;
			//}


			////s_shadersp2->addParts1(*(s_materialnameB[materialindex]));
			////s_shadersp2->addParts2(*(s_shadertypelabel[materialindex]));
			////s_shadersp3->addParts1(*(s_metalcoeflabel[materialindex]));
			////s_shadersp3->addParts2(*(s_lightscalelabel[materialindex]));
			//s_shadersp2->addParts1(*(s_materialnameB[setindex]));
			//s_shadersp2->addParts2(*(s_shadertypelabel[setindex]));
			//s_shadersp3->addParts1(*(s_metalcoeflabel[setindex]));
			//s_shadersp3->addParts2(*(s_lightscalelabel[setindex]));


			s_shadersp1->addParts1(*(s_materialnameB[setindex]));
			s_shadersp1->addParts2(*(s_shadertypelabel[setindex]));

		}


		//ボタンのラムダ関数
		int setindex2;
		for (setindex2 = 0; setindex2 < (materialnum + 1); setindex2++) {

			if (setindex2 == materialnum) {
				int dbgflag3 = 1;
			}

			//int materialindex = setindex2 - 1;	
			if (s_materialnameB[setindex2]) {
				s_materialnameB[setindex2]->setButtonListener([setindex2]() {
					//if (!s_shadertypeparamsFlag) {//開いたまま別マテリアルの表示をするためにコメントアウト
						s_shadertypeparamsindex = setindex2;//index==0は全てのマテリアルに設定. それ以外はindex - 1のマテリアルに設定
						s_shadertypeparamsFlag = true;
					//}
				});
			}
		}


		//autoResizeしないと　チェックボックス４段目以下が反応なかった
		//s_SCshadertype->autoResize();
		//s_shadersp3->autoResize();
		//s_shadersp2->autoResize();
		//s_shadersp1->autoResize();

		s_shadertypeWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
		s_shadertypeWnd->setPos(WindowPos(windowposx, s_sidemenuheight));
		//１クリック目問題対応
		s_shadertypeWnd->refreshPosAndSize();
		s_shadertypeWnd->autoResizeAllParts();
		s_shadertypeWnd->setVisible(false);



		s_rcshadertypewnd.bottom = s_sideheight;
		s_rcshadertypewnd.right = s_sidewidth;

	}
	else {
		_ASSERT(0);
		return 1;
	}


	return 0;
}


int CreateImpulseWnd()
{

	s_dsimpulsectrls.clear();

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	//////////
	s_impWnd = new OrgWindow(
		0,
		_T("ImpulseWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),
		WindowSize(s_sidewidth, s_sideheight),		//サイズ
		_T("ImpulseWindow"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		false,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否

	if (s_impWnd) {
		s_impgroupcheck = new OWP_CheckBoxA(L"SetToAllRigidSMeansToSetSameGroup", 0);
		if (!s_impgroupcheck) {
			_ASSERT(0);
			return 1;
		}
		s_impxSlider = new OWP_Slider(0.0, 50.0, -50.0);
		if (!s_impxSlider) {
			_ASSERT(0);
			return 1;
		}
		s_impySlider = new OWP_Slider(0.0, 50.0, -50.0);
		if (!s_impySlider) {
			_ASSERT(0);
			return 1;
		}
		s_impzSlider = new OWP_Slider(0.0, 50.0, -50.0);
		if (!s_impzSlider) {
			_ASSERT(0);
			return 1;
		}
		s_impscaleSlider = new OWP_Slider(1.0, 10.0, 0.0);
		if (!s_impscaleSlider) {
			_ASSERT(0);
			return 1;
		}
		s_impxlabel = new OWP_Label(L"Impulse X");
		if (!s_impxlabel) {
			_ASSERT(0);
			return 1;
		}
		s_impylabel = new OWP_Label(L"Impulse Y");
		if (!s_impylabel) {
			_ASSERT(0);
			return 1;
		}
		s_impzlabel = new OWP_Label(L"Impulse Z");
		if (!s_impzlabel) {
			_ASSERT(0);
			return 1;
		}
		s_impscalelabel = new OWP_Label(L"ScaleOfImpulse ");
		if (!s_impscalelabel) {
			_ASSERT(0);
			return 1;
		}
		s_impallB = new OWP_Button(L"SetImpulseToAllRigies");
		if (!s_impallB) {
			_ASSERT(0);
			return 1;
		}

		int slw = 350;

		s_impzSlider->setSize(WindowSize(slw, 40));
		s_impySlider->setSize(WindowSize(slw, 40));

		s_impWnd->addParts(*s_impgroupcheck);
		s_impWnd->addParts(*s_impxlabel);
		s_impWnd->addParts(*s_impxSlider);
		s_impWnd->addParts(*s_impylabel);
		s_impWnd->addParts(*s_impySlider);
		s_impWnd->addParts(*s_impzlabel);
		s_impWnd->addParts(*s_impzSlider);
		s_impWnd->addParts(*s_impscalelabel);
		s_impWnd->addParts(*s_impscaleSlider);
		s_impWnd->addParts(*s_impallB);
		/////////
		s_dsimpulsectrls.push_back(s_impgroupcheck);
		s_dsimpulsectrls.push_back(s_impxlabel);
		s_dsimpulsectrls.push_back(s_impxSlider);
		s_dsimpulsectrls.push_back(s_impylabel);
		s_dsimpulsectrls.push_back(s_impySlider);
		s_dsimpulsectrls.push_back(s_impzlabel);
		s_dsimpulsectrls.push_back(s_impzSlider);
		s_dsimpulsectrls.push_back(s_impscalelabel);
		s_dsimpulsectrls.push_back(s_impscaleSlider);
		s_dsimpulsectrls.push_back(s_impallB);


		s_impWnd->setCloseListener([]() {
			if (s_model) {
				s_IcloseFlag = true;
			}
			});

		s_impzSlider->setCursorListener([]() {
			if (s_model && s_impWnd && s_impzSlider) {
				float val = (float)s_impzSlider->getValue();
				if (s_model) {
					s_model->SetImp(s_curboneno, 2, val);
				}
				s_impWnd->callRewrite();						//再描画
			}
			});
		s_impySlider->setCursorListener([]() {
			if (s_model && s_impWnd && s_impySlider) {
				float val = (float)s_impySlider->getValue();
				if (s_model) {
					s_model->SetImp(s_curboneno, 1, val);
				}
				s_impWnd->callRewrite();						//再描画
			}
			});
		s_impxSlider->setCursorListener([]() {
			if (s_model && s_impWnd && s_impxSlider) {
				float val = (float)s_impxSlider->getValue();
				if (s_model) {
					s_model->SetImp(s_curboneno, 0, val);
				}
				s_impWnd->callRewrite();						//再描画
			}
			});
		s_impscaleSlider->setCursorListener([]() {
			if (s_model && s_impWnd && s_impscaleSlider) {
				float scale = (float)s_impscaleSlider->getValue();
				g_impscale = scale;
				s_impWnd->callRewrite();						//再描画
			}
			});
		s_impallB->setButtonListener([]() {
			if (s_model && s_impxSlider && s_impySlider && s_impzSlider && s_impgroupcheck) {
				float impx = (float)s_impxSlider->getValue();
				float impy = (float)s_impySlider->getValue();
				float impz = (float)s_impzSlider->getValue();
				int chkg = (int)s_impgroupcheck->getValue();
				int gid = -1;
				if (chkg) {
					CRigidElem* curre = s_model->GetRgdRigidElem(s_rgdindexmap[s_model], s_curboneno);
					if (curre) {
						gid = curre->GetGroupid();
					}
					else {
						gid = -1;
					}
				}
				s_model->SetAllImpulseData(gid, impx, impy, impz);
			}
			});
		//////////


		s_impWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
		s_impWnd->setPos(WindowPos(windowposx, s_sidemenuheight));

		//１クリック目問題対応
		s_impWnd->refreshPosAndSize();//2022/09/20

		s_impWnd->callRewrite();

	}
	else {
		_ASSERT(0);
		return 1;
	}

	
	return 0;
}

int CreateGPlaneWnd()
{

	s_dsgpctrls.clear();

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}


	//////////
	s_gpWnd = new OrgWindow(
		0,
		_T("GPlaneWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),		//位置
		WindowSize(s_sidewidth, s_sideheight),		//サイズ
		_T("GroudOfPhysics"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		false,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否

	if (s_gpWnd) {
		s_ghSlider = new OWP_Slider(-1.5, 5.0, -15.0);
		if (!s_ghSlider) {
			_ASSERT(0);
			return 1;
		}
		s_gsizexSlider = new OWP_Slider(5.0, 50.0, -50.0);
		if (!s_gsizexSlider) {
			_ASSERT(0);
			return 1;
		}
		s_gsizezSlider = new OWP_Slider(5.0, 50.0, -50.0);
		if (!s_gsizezSlider) {
			_ASSERT(0);
			return 1;
		}
		s_ghlabel = new OWP_Label(L"Height");
		if (!s_ghlabel) {
			_ASSERT(0);
			return 1;
		}
		s_gsizexlabel = new OWP_Label(L"SizeOfX");
		if (!s_gsizexlabel) {
			_ASSERT(0);
			return 1;
		}
		s_gsizezlabel = new OWP_Label(L"SizeOfZ");
		if (!s_gsizezlabel) {
			_ASSERT(0);
			return 1;
		}
		s_gpdisp = new OWP_CheckBoxA(L"Display", 1);
		if (!s_gpdisp) {
			_ASSERT(0);
			return 1;
		}

		s_grestSlider = new OWP_Slider(0.5, 1.0, 0.0);
		if (!s_grestSlider) {
			_ASSERT(0);
			return 1;
		}
		s_gfricSlider = new OWP_Slider(0.5, 1.0, 0.0);
		if (!s_gfricSlider) {
			_ASSERT(0);
			return 1;
		}
		s_grestlabel = new OWP_Label(L"Restitution");
		if (!s_grestlabel) {
			_ASSERT(0);
			return 1;
		}
		s_gfriclabel = new OWP_Label(L"Friction");
		if (!s_gfriclabel) {
			_ASSERT(0);
			return 1;
		}


		int slw = 350;

		s_ghSlider->setSize(WindowSize(slw, 40));
		s_gsizexSlider->setSize(WindowSize(slw, 40));
		s_gsizezSlider->setSize(WindowSize(slw, 40));
		s_grestSlider->setSize(WindowSize(slw, 40));
		s_gfricSlider->setSize(WindowSize(slw, 40));

		s_gpWnd->addParts(*s_ghlabel);
		s_gpWnd->addParts(*s_ghSlider);
		s_gpWnd->addParts(*s_gsizexlabel);
		s_gpWnd->addParts(*s_gsizexSlider);
		s_gpWnd->addParts(*s_gsizezlabel);
		s_gpWnd->addParts(*s_gsizezSlider);
		s_gpWnd->addParts(*s_gpdisp);

		s_gpWnd->addParts(*s_grestlabel);
		s_gpWnd->addParts(*s_grestSlider);
		s_gpWnd->addParts(*s_gfriclabel);
		s_gpWnd->addParts(*s_gfricSlider);
		/////////
		s_dsgpctrls.push_back(s_ghlabel);
		s_dsgpctrls.push_back(s_ghSlider);
		s_dsgpctrls.push_back(s_gsizexlabel);
		s_dsgpctrls.push_back(s_gsizexSlider);
		s_dsgpctrls.push_back(s_gsizezlabel);
		s_dsgpctrls.push_back(s_gsizezSlider);
		s_dsgpctrls.push_back(s_gpdisp);

		s_dsgpctrls.push_back(s_grestlabel);
		s_dsgpctrls.push_back(s_grestSlider);
		s_dsgpctrls.push_back(s_gfriclabel);
		s_dsgpctrls.push_back(s_gfricSlider);

		s_gpWnd->setCloseListener([]() {
			if (s_model) {
				s_GcloseFlag = true;
			}
			});

		s_ghSlider->setCursorListener([]() {
			if (s_model) {
				if (s_bpWorld && s_gpWnd && s_ghSlider && s_gplane) {
					s_bpWorld->m_gplaneh = (float)s_ghSlider->getValue();
					s_bpWorld->RemakeG();

					ChaVector3 tra(0.0f, 0.0f, 0.0f);
					ChaVector3 mult(s_bpWorld->m_gplanesize.x, 1.0f, s_bpWorld->m_gplanesize.y);
					CallF(s_gplane->MultDispObj(mult, tra), return);

					s_gpWnd->callRewrite();						//再描画
				}
			}
			});
		s_gsizexSlider->setCursorListener([]() {
			if (s_model && s_gpWnd && s_gsizexSlider) {
				if (s_bpWorld && s_gplane) {
					s_bpWorld->m_gplanesize.x = (float)s_gsizexSlider->getValue();

					ChaVector3 tra(0.0f, 0.0f, 0.0f);
					ChaVector3 mult(s_bpWorld->m_gplanesize.x, 1.0f, s_bpWorld->m_gplanesize.y);
					CallF(s_gplane->MultDispObj(mult, tra), return);
					s_gpWnd->callRewrite();						//再描画
				}
			}
			});
		s_gsizezSlider->setCursorListener([]() {
			if (s_model && s_gpWnd && s_gsizezSlider) {
				if (s_bpWorld && s_gplane) {
					s_bpWorld->m_gplanesize.y = (float)s_gsizezSlider->getValue();

					ChaVector3 tra(0.0f, 0.0f, 0.0f);
					ChaVector3 mult(s_bpWorld->m_gplanesize.x, 1.0f, s_bpWorld->m_gplanesize.y);
					CallF(s_gplane->MultDispObj(mult, tra), return);
					s_gpWnd->callRewrite();						//再描画
				}
			}
			});
		s_gpdisp->setButtonListener([]() {
			if (s_model && s_gpWnd && s_gpdisp) {
				if (s_bpWorld) {
					bool dispflag = s_gpdisp->getValue();
					s_bpWorld->m_gplanedisp = (int)dispflag;
					s_gpWnd->callRewrite();						//再描画
				}
			}
			});
		s_grestSlider->setCursorListener([]() {
			if (s_model && s_gpWnd && s_grestSlider) {
				if (s_bpWorld && s_gplane) {
					s_bpWorld->m_restitution = (float)s_grestSlider->getValue();
					s_bpWorld->RemakeG();

					s_gpWnd->callRewrite();						//再描画
				}
			}
			});
		s_gfricSlider->setCursorListener([]() {
			if (s_model && s_gpWnd && s_gfricSlider) {
				if (s_bpWorld && s_gplane) {
					s_bpWorld->m_friction = (float)s_gfricSlider->getValue();
					s_bpWorld->RemakeG();

					s_gpWnd->callRewrite();						//再描画
				}
			}
			});


		s_gpWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
		s_gpWnd->setPos(WindowPos(windowposx, s_sidemenuheight));

		//１クリック目問題対応
		s_gpWnd->refreshPosAndSize();//2022/09/20

		s_gpWnd->callRewrite();
	}
	else {
		_ASSERT(0);
		return 1;
	}
	
	return 0;
}

int CreateToolWnd()
{
	/////////
	// ツールウィンドウを作成してボタン類を追加
	s_toolWnd = new OrgWindow(
		0,
		L"ToolWindow_",		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		//WindowPos(400, 580),		//位置
		//WindowPos(50, 645),		//位置
		WindowPos(0, s_2ndposy),		//位置
		WindowSize(s_toolwidth, s_toolheight),		//サイズ
		L"ToolWindow",	//タイトル
		//s_timelineWnd->getHWnd(),	//親ウィンドウハンドル
		g_mainhwnd,
		true,					//表示・非表示状態
		//70, 50, 70);// ,				//カラー
		0, 0, 0);				//カラー

	//	true);// ,					//閉じられるか否か
	//	false);					//サイズ変更の可否

	//s_toolWnd->callRewrite();

	if (s_toolWnd) {
		s_toolSelBoneB = new OWP_Button(_T("コマンド対象ボーン target bone"));
		if (!s_toolSelBoneB) {
			_ASSERT(0);
			return 1;
		}
		s_toolSelectCopyFileName = new OWP_Button(_T("コピー履歴選択 sel cp history"));
		if (!s_toolSelectCopyFileName) {
			_ASSERT(0);
			return 1;
		}
		s_toolCopyB = new OWP_Button(_T("コピー copy"));
		if (!s_toolCopyB) {
			_ASSERT(0);
			return 1;
		}
		s_toolSymCopyB = new OWP_Button(_T("対称コピー sym copy"));
		if (!s_toolSymCopyB) {
			_ASSERT(0);
			return 1;
		}
		//s_toolCutB = new OWP_Button(_T("カット"));
		s_toolPasteB = new OWP_Button(_T("ペースト paste"));
		if (!s_toolPasteB) {
			_ASSERT(0);
			return 1;
		}
		s_toolInitMPB = new OWP_Button(_T("姿勢初期化 init"));
		if (!s_toolInitMPB) {
			_ASSERT(0);
			return 1;
		}
		//s_toolDeleteB = new OWP_Button(_T("削除"));
		//s_toolMarkB = new OWP_Button(_T("マーク作成"));
		s_toolMotPropB = new OWP_Button(_T("プロパティ property"));
		if (!s_toolMotPropB) {
			_ASSERT(0);
			return 1;
		}
		s_toolFilterB = new OWP_Button(_T("平滑化 smoothing"));
		if (!s_toolFilterB) {
			_ASSERT(0);
			return 1;
		}
		s_toolInterpolateB = new OWP_Button(_T("補間 interpolate"));
		if (!s_toolInterpolateB) {
			_ASSERT(0);
			return 1;
		}
		s_toolZeroFrameB = new OWP_Button(_T("Edit 0 Frame"));
		if (!s_toolZeroFrameB) {
			_ASSERT(0);
			return 1;
		}
		s_toolSkipRenderBoneMarkB = new OWP_Button(_T("jointマークスキップ(Deeper)"));
		if (!s_toolSkipRenderBoneMarkB) {
			_ASSERT(0);
			return 1;
		}
		s_toolSkipRenderBoneMarkB2 = new OWP_Button(_T("jointマークスキップReset(Deeper)"));
		if (!s_toolSkipRenderBoneMarkB2) {
			_ASSERT(0);
			return 1;
		}
		//s_tool180deg = new OWP_Button(_T("180度修正 180deg Adjust Euler"));
		s_toolScaleInitAllB = new OWP_Button(_T("ScaleAllInit(ギザギザしたら押す)"));
		if (!s_toolScaleInitAllB) {
			_ASSERT(0);
			return 1;
		}
		s_toolCameraDollyB = new OWP_Button(_T("カメラ数値ドリー (CameraDolly)"));
		if (!s_toolCameraDollyB) {
			_ASSERT(0);
			return 1;
		}
		s_toolMaterialRateB = new OWP_Button(_T("モデルマテリアル倍率MaterialRate"));
		if (!s_toolMaterialRateB) {
			_ASSERT(0);
			return 1;
		}
		s_toolModelWorldMatB = new OWP_Button(_T("モデル位置向きModelWorldMat"));
		if (!s_toolModelWorldMatB) {
			_ASSERT(0);
			return 1;
		}



		s_toolWnd->addParts(*s_toolSelBoneB);
		s_toolWnd->addParts(*s_toolSelectCopyFileName);
		s_toolWnd->addParts(*s_toolCopyB);
		s_toolWnd->addParts(*s_toolSymCopyB);
		s_toolWnd->addParts(*s_toolPasteB);
		s_toolWnd->addParts(*s_toolInitMPB);
		//s_toolWnd->addParts(*s_toolMarkB);
		s_toolWnd->addParts(*s_toolMotPropB);
		s_toolWnd->addParts(*s_toolFilterB);
		s_toolWnd->addParts(*s_toolInterpolateB);
		s_toolWnd->addParts(*s_toolZeroFrameB);
		s_toolWnd->addParts(*s_toolSkipRenderBoneMarkB);
		s_toolWnd->addParts(*s_toolSkipRenderBoneMarkB2);
		//s_toolWnd->addParts(*s_tool180deg);
		s_toolWnd->addParts(*s_toolScaleInitAllB);
		s_toolWnd->addParts(*s_toolCameraDollyB);
		s_toolWnd->addParts(*s_toolMaterialRateB);
		s_toolWnd->addParts(*s_toolModelWorldMatB);

		s_dstoolctrls.push_back(s_toolSelBoneB);
		s_dstoolctrls.push_back(s_toolCopyB);
		s_dstoolctrls.push_back(s_toolSymCopyB);
		s_dstoolctrls.push_back(s_toolPasteB);
		s_dstoolctrls.push_back(s_toolInitMPB);
		//s_dstoolctrls.push_back(s_toolMarkB);
		s_dstoolctrls.push_back(s_toolMotPropB);
		s_dstoolctrls.push_back(s_toolFilterB);
		s_dstoolctrls.push_back(s_toolInterpolateB);
		s_dstoolctrls.push_back(s_toolZeroFrameB);
		s_dstoolctrls.push_back(s_toolSkipRenderBoneMarkB);
		s_dstoolctrls.push_back(s_toolSkipRenderBoneMarkB2);
		//s_dstoolctrls.push_back(s_tool180deg);
		s_dstoolctrls.push_back(s_toolScaleInitAllB);
		s_dstoolctrls.push_back(s_toolCameraDollyB);
		s_dstoolctrls.push_back(s_toolMaterialRateB);
		s_dstoolctrls.push_back(s_toolModelWorldMatB);


		s_toolWnd->setCloseListener([]() {
			if (s_model) {
				if (s_closetoolFlag == false) {
					s_closetoolFlag = true;
				}
			}
			});
		//s_toolWnd->setHoverListener([]() { SetCapture(s_toolWnd->getHWnd()); });
		//s_toolWnd->setLeaveListener([]() { ReleaseCapture(); });
		s_toolSelectCopyFileName->setButtonListener([]() {
			if (s_model) {
				if (s_selCopyHisotryFlag == false) {
					s_selCopyHisotryFlag = true;
				}
			}
			});
		s_toolCopyB->setButtonListener([]() {
			if (s_model) {
				if (s_copyFlag == false) {
					s_copyFlag = true;
				}
			}
			});
		s_toolZeroFrameB->setButtonListener([]() {
			if (s_model) {
				if (s_owpLTimeline) {
					if (s_zeroFrameFlag == false) {
						s_LstopFlag = true;
						g_previewFlag = 0;
						s_LcursorFlag = true;
						s_zeroFrameFlag = true;
					}
				}
			}
			});

		s_toolSymCopyB->setButtonListener([]() {
			if (s_model) {
				if (s_symcopyFlag == false) {
					s_symcopyFlag = true;
				}
			}
			});
		s_toolPasteB->setButtonListener([]() {
			if (s_model) {
				if (s_pasteFlag == false) {
					s_pasteFlag = true;
				}
			}
			});
		s_toolMotPropB->setButtonListener([]() {
			if (s_model) {
				if (s_motpropFlag == false) {
					s_motpropFlag = true;
				}
			}
			});
		//s_toolMarkB->setButtonListener( [](){ s_markFlag = true; } );
		s_toolSelBoneB->setButtonListener([]() {
			if (s_model) {
				if (s_selboneFlag == false) {
					s_selboneFlag = true;
				}
			}
			});
		s_toolInitMPB->setButtonListener([]() {
			if (s_model) {
				if (s_initmpFlag == false) {
					s_initmpFlag = true;
				}
			}
			});
		s_toolFilterB->setButtonListener([]() {
			if (s_model) {
				if (s_filterFlag == false) {
					s_filterFlag = true;
				}
			}
			});
		s_toolInterpolateB->setButtonListener([]() {
			if (s_model && (s_interpolateFlag == false)) {
				s_interpolateFlag = true;
			}
			});
		s_toolSkipRenderBoneMarkB->setButtonListener([]() {
			if (s_model && (s_skipJointMark == 0)) {
				s_skipJointMark = 1;//deeper
			}
			});
		s_toolSkipRenderBoneMarkB2->setButtonListener([]() {
			if (s_model && (s_skipJointMark == 0)) {
				s_skipJointMark = 2;//deeper
			}
			});
		//s_tool180deg->setButtonListener([]() {
		//	if (s_model && (s_180DegFlag == false)) {
		//		s_180DegFlag = true;
		//	}
		//});
		s_toolScaleInitAllB->setButtonListener([]() {
			if (s_model && (s_scaleAllInitFlag == false)) {
				s_scaleAllInitFlag = true;
			}
			});
		s_toolCameraDollyB->setButtonListener([]() {
			if (s_model && (s_cameradollyFlag == false)) {
				s_cameradollyFlag = true;
			}
			});
		s_toolMaterialRateB->setButtonListener([]() {
			if (s_model && (s_materialrateFlag == false)) {
				s_materialrateFlag = true;
			}
			});
		s_toolModelWorldMatB->setButtonListener([]() {
			if (s_model && (s_modelworldmatFlag == false)) {
				s_modelworldmatFlag = true;
			}
			});


		s_rctoolwnd.top = 0;
		s_rctoolwnd.left = 0;
		s_toolWnd->setPos(WindowPos(0, s_2ndposy));
		s_rctoolwnd.bottom = s_toolheight;
		s_rctoolwnd.right = s_toolwidth;


		s_toolWnd->autoResizeAllParts();
		s_toolWnd->refreshPosAndSize();//これを呼ばないと1回目のクリック位置がずれることがある。

	}
	else {
		_ASSERT(0);
		return 1;
	}


	return 0;

}


int CreateLayerWnd()
{
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	if (s_layerWnd) {
		//_ASSERT(0);
		return 0;
	}

	WindowSize layersize;

	////
	// ウィンドウを作成
	if (g_4kresolution) {
		layersize = WindowSize(150 * 2, 200 * 2);
		s_layerWnd = new OrgWindow(
			1,
			_T("LayerTool"),		//ウィンドウクラス名
			GetModuleHandle(NULL),	//インスタンスハンドル
			//WindowPos(800, 500),		//位置
			//WindowPos(250, 645),		//位置
			//WindowPos(250, 660),		//位置
			WindowPos(2000, 660),		//位置
			layersize,		//サイズ
			_T("LayerTool"),	//タイトル
			//g_mainhwnd,					//親ウィンドウハンドル
			//s_3dwnd,
			NULL,//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 他所をクリックしても隠れないように
			true,					//表示・非表示状態
			//false,					//表示・非表示状態
			//70, 50, 70,				//カラー
			0, 0, 0,				//カラー
			true,					//閉じられるか否か
			true);					//サイズ変更の可否
	}
	else {
		layersize = WindowSize(150, 200);
		s_layerWnd = new OrgWindow(
			1,
			_T("LayerTool"),		//ウィンドウクラス名
			GetModuleHandle(NULL),	//インスタンスハンドル
			//WindowPos(800, 500),		//位置
			//WindowPos(250, 645),		//位置
			//WindowPos(250, 660),		//位置
			WindowPos(2000, 660),		//位置
			layersize,		//サイズ
			_T("LayerTool"),	//タイトル
			//g_mainhwnd,					//親ウィンドウハンドル
			//s_3dwnd,
			NULL,//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 他所をクリックしても隠れないように
			true,					//表示・非表示状態
			//false,					//表示・非表示状態
			//70, 50, 70,				//カラー
			0, 0, 0,				//カラー
			true,					//閉じられるか否か
			true);					//サイズ変更の可否
	}

	if (s_layerWnd) {
		s_layerWnd->setVisible(false);

		// レイヤーウィンドウパーツを作成
		s_owpLayerTable = new OWP_LayerTable(_T("レイヤーテーブル"));
		if (!s_owpLayerTable) {
			_ASSERT(0);
			return 1;
		}


		s_owpLayerTable->setSize(WindowSize(layersize.x - 30, layersize.y));
		s_layerWnd->addParts(*s_owpLayerTable);


		WCHAR label[256];
		wcscpy_s(label, 256, L"dummy name");
		s_owpLayerTable->newLine(label, 0);

		// ウィンドウにウィンドウパーツを登録
		//s_layerWnd->addParts(*s_owpLayerTable);


		s_layerWnd->setCloseListener([]() {
			if (s_model) {
				s_closeobjFlag = true;
			}
			});

		//レイヤーのカーソルリスナー
		s_owpLayerTable->setCursorListener([]() {
			//_tprintf_s( _T("CurrentLayer: Index=%3d Name=%s\n"),
			//			owpLayerTable->getCurrentLine(),
			//			owpLayerTable->getCurrentLineName().c_str() );
			});

		//レイヤーの移動リスナー
		s_owpLayerTable->setLineShiftListener([](int from, int to) {
			//_tprintf_s( _T("ShiftLayer: fromIndex=%3d toIndex=%3d\n"), from, to );
			});

		//レイヤーの可視状態変更リスナー
		s_owpLayerTable->setChangeVisibleListener([](int index) {
			if (s_model && s_owpLayerTable) {
				CMQOObject* curobj = (CMQOObject*)(s_owpLayerTable->getObj(index));
				if (curobj) {
					if (s_owpLayerTable->getVisible(index)) {
						curobj->SetDispFlag(1);
					}
					else {
						curobj->SetDispFlag(0);
					}
				}
			}
			});

		//レイヤーのロック状態変更リスナー
		s_owpLayerTable->setChangeLockListener([](int index) {
			//if( owpLayerTable->getLock(index) ){
			//	_tprintf_s( _T("ChangeLock: Index=%3d Lock='True'  Name=%s\n"),
			//				index,
			//				owpLayerTable->getName(index).c_str() );
			//}else{
			//	_tprintf_s( _T("ChangeLock: Index=%3d Lock='False' Name=%s\n"),
			//				index,
			//				owpLayerTable->getName(index).c_str() );
			//}
			});

		//レイヤーのプロパティコールリスナー
		s_owpLayerTable->setCallPropertyListener([](int index) {
			//_tprintf_s( _T("CallProperty: Index=%3d Name=%s\n"),
			//			index,
			//			owpLayerTable->getName(index).c_str() );
			});

		RECT wnd3drect;
		if (g_mainhwnd) {
			GetWindowRect(g_mainhwnd, &wnd3drect);
			s_layerWnd->setPos(WindowPos(wnd3drect.left + 750, wnd3drect.top + 500));
		}
		else {
			s_layerWnd->setPos(WindowPos(600, 200));
		}
		s_layerWnd->setVisible(false);

	}
	else {
		_ASSERT(0);
		return 1;
	}

	
	return 0;

}

//int OnRenderRefPos(RenderContext* pRenderContext, CModel* curmodel)
//{
//	if (!pRenderContext || !curmodel) {
//		return 0;
//	}
//
//	if (s_splod.state) {
//		if (curmodel == s_model) {
//
//			int keynum;
//			double startframe, endframe, applyframe;
//			double roundingstartframe, roundingendframe, roundingapplyframe;
//			s_editrange.GetRange(&keynum, &startframe, &endframe, &applyframe);
//			roundingstartframe = RoundingTime(startframe);
//			roundingendframe = RoundingTime(endframe);
//			roundingapplyframe = RoundingTime(applyframe);
//
//			//if (keynum >= 3) {
//				MOTINFO* curmi = s_model->GetCurMotInfo();
//				if (curmi) {
//					int curmotid = curmi->motid;
//					double currentframe = curmi->curframe;
//					CBone* curbone = s_model->GetBoneByID(s_curboneno);
//					if (curbone) {
//						std::vector<ChaVector3> vecbonepos;
//						vecbonepos.clear();
//						ChaVector3 curbonepos;
//
//						ChaMatrix modelwm = s_model->GetWorldMat();
//
//						int rendercount = 0;
//						double renderframe;
//						for (renderframe = roundingstartframe; renderframe <= roundingendframe; renderframe += 1.0) {
//							s_model->SetMotionFrame(renderframe);
//							//s_model->UpdateMatrix(&s_model->GetWorldMat(), &s_matVP);
//							//ChaMatrix tmpwm = s_model->GetWorldMat();
//							//s_model->HierarchyRouteUpdateMatrix(g_limitdegflag, curbone, &modelwm, &s_matVP);//高速化：関係ボーンルート限定アップデート
//							ChaVector3 tmpfpos = curbone->GetJointFPos();
//							//ChaMatrix tmpcurwm = curbone->GetCurMp().GetWorldMat() * s_matWorld;//2023/08/27 s_matWorldを掛ける
//							ChaMatrix tmpcurwm = curbone->GetWorldMat(g_limitdegflag, curmotid, renderframe, 0) * modelwm;
//							ChaVector3TransformCoord(&curbonepos, &tmpfpos, &tmpcurwm);
//							vecbonepos.push_back(curbonepos);
//
//							int lightflag = 0;//!!!!!!!透けるために必要!!!!!!!!!
//
//							if (renderframe != currentframe) {
//								if ((rendercount % g_refposstep) == 0) {
//									//refframeのポーズを表示
//									int btflag1 = 0;
//							
//									s_model->SetMotionFrame(renderframe);
//									s_model->UpdateMatrix(g_limitdegflag, &modelwm, &s_matVP, true, s_chascene->GetUpdateSlot());
//							
//							
//									//カレントフレームから離れるほど　透明度を薄くする
//									const double refstartalpha = 0.80f;
//									double rendernum;
//									double renderalpha0, renderalpha;
//									rendernum = endframe - startframe + 1.0;
//									renderalpha0 = (rendernum - fabs(currentframe - renderframe)) / rendernum;
//									renderalpha = refstartalpha * renderalpha0 * renderalpha0 * renderalpha0 * (double)g_refalpha * 0.01f;
//									ChaVector4 refdiffusemult = ChaVector4(1.0f, 1.0f, 1.0f, (float)renderalpha);
//							
//									bool withalpha = true;
//									bool calcslotflag = true;
//									s_model->OnRender(withalpha, pRenderContext, lightflag, refdiffusemult, 
//										btflag1, calcslotflag);//render model at reference pos
//								}
//							}
//							rendercount++;
//						}
//
//
//						{
//							////カレントフレームをレンダー
//							s_model->SetMotionFrame(currentframe);
//							s_model->UpdateMatrix(g_limitdegflag, &modelwm, &s_matVP, true, s_chascene->GetUpdateSlot());
//						
//							int lightflag2 = 0;//!!!!!!!透けるために必要!!!!!!!!!
//							//const float orgalpha = 0.8880f;
//							const float orgalpha = 1.0f;
//							ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, orgalpha);
//							int btflag2 = 0;
//							if ((g_previewFlag != 4) && (g_previewFlag != 5)) {
//								btflag2 = 0;
//							}
//							else {
//								if (g_previewFlag == 4) {
//									btflag2 = 1;
//								}
//								else {
//									//previewFlag == 5
//									if ((s_curboneno >= 0) && ((s_onragdollik != 0) || (s_physicskind == 0))) {
//										btflag2 = 2;//2022/07/09
//									}
//								}
//							}
//							bool withalpha = false;
//							bool calcslotflag = true;
//							s_model->OnRender(withalpha, pRenderContext, lightflag2, diffusemult, btflag2, calcslotflag);
//							withalpha = true;
//							s_model->OnRender(withalpha, pRenderContext, lightflag2, diffusemult, btflag2, calcslotflag);
//						}
//
//
//						////render arrow : selected bone : befpos --> aftpos arrow
//						//CBone* childbone = curbone->GetChild(false);
//						//if (childbone && childbone->IsSkeleton() && curbone->GetColDisp(childbone, COL_CONE_INDEX)) {
//						//	ChaVector4 arrowdiffusemult = ChaVector4(1.0f, 0.5f, 0.5f, 0.85f);
//
//						//	//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmpAlways, 1);//不透明の場合には手動で指定
//						//	g_zcmpalways = true;
//						//	curbone->GetColDisp(childbone, COL_CONE_INDEX)->RenderRefArrow(g_limitdegflag,
//						//		pRenderContext, curbone, arrowdiffusemult, 1, vecbonepos);
//						//	s_model->RenderBoneCircleOne(g_limitdegflag,
//						//		pRenderContext, s_bcircle, s_curboneno);
//
//						//	//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmp, 1);//元に戻す
//						//	g_zcmpalways = false;
//						//}
//					}
//				}
//			//}
//		}
//	}
//
//	return 0;
//}

int OnRenderModel(RenderContext* pRenderContext)
{
	if (!pRenderContext) {
		_ASSERT(0);
		return 1;
	}


	////if (g_bvh2fbxbatchflag || g_motioncachebatchflag || g_retargetbatchflag) {
	////if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	//	return 0;
	//}

	//if (s_nowloading == true) {
	//	return 0;
	//}

	//if (!s_model || !s_chascene) {
	//	return 0;
	//}


	//int lightflag = 1;
	//ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, 1.0f);
	//int btflag = 0;
	//if ((g_previewFlag != 4) && (g_previewFlag != 5)) {
	//	btflag = 0;
	//}
	//else {
	//	if (g_previewFlag == 4) {
	//		btflag = 1;
	//	}
	//	else {
	//		//previewFlag == 5
	//		if ((s_curboneno >= 0) && ((s_onragdollik != 0) || (s_physicskind == 0))) {
	//			btflag = 2;//2022/07/09
	//		}
	//	}
	//}

	//s_chascene->RenderModels(pRenderContext, lightflag, diffusemult, btflag);
	//if (s_splod.state) {
	//	OnRenderLOD(pRenderContext, s_model);
	//}

	return 0;
}

int OnRenderOnlyOneObj(RenderContext* pRenderContext)
{
	if (!pRenderContext) {
		_ASSERT(0);
		return 1;
	}


	//if (g_bvh2fbxbatchflag || g_motioncachebatchflag || g_retargetbatchflag) {
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	if (s_nowloading == true) {
		return 0;
	}

	if (!s_model) {
		return 0;
	}


	int rendercount;
	for (rendercount = 0; rendercount < 2; rendercount++) {
		bool withalpha;
		if (rendercount == 0) {
			withalpha = false;
		}
		else {
			withalpha = true;
		}

		CModel* curmodel = s_model;

		//if (curmodel && curmodel->GetLoadedFlag() && curmodel->GetModelDisp()){
		if (curmodel && curmodel->m_loadedflag && curmodel->m_modeldisp) {//curmodelが作成途中の場合を考えて、先頭から２つのpublicデータメンバーを参照する
			int lightflag = 1;
			ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, 1.0f);
			int btflag = 0;

			curmodel->RenderTest(withalpha, pRenderContext, g_lightflag, diffusemult, s_onlyoneobjno);
		}
	}

	return 0;
}


int OnRenderGround(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!re || !pRenderContext) {
		_ASSERT(0);
		return 1;
	}

	if (!s_chascene) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}

	if (s_ground && s_dispground) {
		//g_hmWorld->SetMatrix(s_matWorld.GetDataPtr());
		//g_pEffect->SetMatrix(g_hmWorld, &(s_matWorld.D3DX()));
		ChaMatrix initmat;
		initmat.SetIdentity();
		s_chascene->UpdateMatrixOneModel(s_ground, g_limitdegflag, &initmat, &s_matVP, 0.0);
		ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, 1.0f);
		bool forcewithalpha = false;
		int btflag = 0;
		bool zcmpalways = false;
		s_chascene->RenderOneModel(s_ground, forcewithalpha, re, 0, diffusemult, btflag, zcmpalways);
	}
	//if (s_gplane && s_bpWorld && s_bpWorld->m_gplanedisp) {
	//	ChaMatrix gpmat = s_inimat;
	//	gpmat.data[MATI_42] = s_bpWorld->m_gplaneh;
	//	g_hmWorld->SetMatrix(gpmat.GetDataPtr());
	//	//g_pEffect->SetMatrix(g_hmWorld, &(gpmat.D3DX()));
	//
	//	ChaVector4 diffusemult = ChaVector4(1.0f, 1.0f, 1.0f, 1.0f);
	//	bool withalpha = false;
	//	s_gplane->OnRender(withalpha, pRenderContext, 0, diffusemult);
	//}

	return 0;
}

int OnRenderBoneMark(myRenderer::RenderingEngine* re, RenderContext* rc)
{
	if (!re || !rc) {
		_ASSERT(0);
		return 1;
	}
	if (g_changeUpdateThreadsNum) {
		//アップデート用スレッド数を変更中
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetLoadedFlag() || (s_model->GetBoneForMotionSize() == 0) || 
		(s_model->GetBoneForMotionSize() >= RIGMULTINDEXMAX)) {
		//インスタンシング最大数を越えた場合にもリターン0
		return 0;
	}

	if (g_bonemarkflag || g_rigidmarkflag) {

		//if (s_allmodelbone == false) {
			//if ((g_previewFlag != 1) && (g_previewFlag != -1) && (g_previewFlag != 4)){
			if (s_model && s_model->GetModelDisp()) {
				//if (s_ikkind >= 3){
				s_model->RenderBoneMark(re,
					g_limitdegflag, &s_bcircle,
					s_curboneno, s_chascene, s_matVP);

				//}
				//else{
				//	s_model->RenderBoneMark(s_pdev, s_bmark, s_bcircle, 0, s_curboneno);
				//}
			}
			//}
		//}
		//else {
			//int modelnum = s_chascene->GetModelNum();
			//int modelcount;
			//for (modelcount = 0; modelcount < modelnum; modelcount++) {
			//	CModel* curmodel = s_chascene->GetModel(modelcount);
			//	if (curmodel) {
			//		curmodel->RenderBoneMark(g_limitdegflag,
			//			pRenderContext, s_bmark, s_bcircle, 0, s_curboneno);
			//		s_model->RenderBoneMark(re, rc, g_limitdegflag,
			//			s_bmark, s_bcircle, s_curboneno);

			//	}
			//}
		//}
	}

	return 0;
}
int OnRenderSelect(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!re || !pRenderContext) {
		_ASSERT(0);
		return 1;
	}


	if ((g_previewFlag != 4) && (g_previewFlag != 5)) {
		if (s_select && (s_curboneno >= 0) && (g_previewFlag == 0) && (s_model && s_model->GetModelDisp()) && (g_bonemarkflag != 0)) {//underchecking
			//SetSelectCol();
			SetSelectState();
			RenderSelectMark(re, pRenderContext, 1);
		}
	}
	//else if ((g_previewFlag == 5) && (s_oprigflag == 1)){
	else if (g_previewFlag == 5) {
		if (s_select && (s_curboneno >= 0) && (s_model && s_model->GetModelDisp())) {
			//SetSelectCol();
			SetSelectState();
			RenderSelectMark(re, pRenderContext, 1);
		}
	}


	//プレビュー中　物理中は　リグマークは表示しない
	if (g_previewFlag == 0) {
		if ((s_model && s_model->GetModelDisp()) && (s_oprigflag != 0)) {
			RenderRigMarkFunc(re, pRenderContext);
		}
	}

	return 0;
}

int OnRenderFontForTip(myRenderer::RenderingEngine* re, RenderContext* rc)
{
	if (!re || !rc) {
		_ASSERT(0);
		return 1;
	}


	if (s_dispfontfottip) {
	//if (s_strfortip[0] != 0L) {
		Vector4 fontcol = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
		Vector2 fontpivot = Vector2(0.0f, 0.0f);

		float fontscale = 0.5f;//フォントのスケール


		//表示文字列の　おおまかな長さを計算
		size_t szlen = wcslen(s_strfortip);
		int displen;
		if (szlen <= 511) {
			displen = (int)szlen * 14;
		}
		else {
			s_strfortip[511] = 0L;
			displen = 511 * 14;
		}


		Vector2 tmpfontpos = s_fontposfortip;
		tmpfontpos.y += 18;//ジョイント位置が隠れないように少し下に


		//スクリーンからはみ出さないように　フォントの位置をクランプする
		int winx = g_graphicsEngine->GetFrameBufferWidth();
		int winy = g_graphicsEngine->GetFrameBufferHeight();
		int tipposx = min((winx - (int)displen), (int)(tmpfontpos.x + 0.1f));
		int tipposy = min((winy - 18), (int)(tmpfontpos.y + 0.1f));


		//フォントの位置を　-0.5から0.5のスクリーン座標系に直す
		Vector2 disppos;
		float fontposx = ((float)tipposx - (float)winx / 2.0f);// *2.0f;
		float fontposy = -((float)tipposy - (float)winy / 2.0f);// *2.0f;
		disppos = Vector2(fontposx, fontposy);


		myRenderer::RENDERFONT renderfont;
		renderfont.Init();
		renderfont.pfont = &s_fontfortip;
		wcscpy_s(renderfont.strfont, 512, s_strfortip);
		renderfont.disppos = disppos;
		renderfont.color = fontcol;
		renderfont.rotation = 0.0f;
		renderfont.scale = fontscale;
		renderfont.pivot = fontpivot;
		re->AddFontToForwardRenderPass(renderfont);
	}

	//s_dispfontfottip = false;

	return 0;
}


int OnRenderSprite(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!re || !pRenderContext) {
		_ASSERT(0);
		return 1;
	}


	if (!s_model) {
		return 0;
	}

	if (s_model) {
		int dispfps = (int)(s_avrgfps + 0.5);
		//s_fpssprite.DrawScreen(pRenderContext, dispfps);

		myRenderer::RENDERSPRITE rendersprite;
		rendersprite.Init();
		rendersprite.pfpssprite = &s_fpssprite;
		rendersprite.userint1 = dispfps;
		re->AddSpriteToForwardRenderPass(rendersprite);
	}

	////Undoの読み込みポイントW と書き込みポイントR を表示
	if (s_model && (g_previewFlag == 0)) {
		//s_undosprite.DrawScreen(pRenderContext, s_model->GetCurrentUndoR(), s_model->GetCurrentUndoW());

		myRenderer::RENDERSPRITE rendersprite;
		rendersprite.Init();
		rendersprite.pundosprite = &s_undosprite;
		rendersprite.userint1 = s_model->GetCurrentUndoR();
		rendersprite.userint2 = s_model->GetCurrentUndoW();
		re->AddSpriteToForwardRenderPass(rendersprite);
	}


	//frog
	//s_spret2prev.sprite.DrawScreen(pRenderContext);
	myRenderer::RENDERSPRITE rendersprite;
	rendersprite.Init();
	rendersprite.psprite = &(s_spret2prev.sprite);
	re->AddSpriteToForwardRenderPass(rendersprite);


	//Mouse Middle Button Mark
	if (s_mbuttoncnt == 0) {
		//s_mousecenteron.sprite.DrawScreen(pRenderContext);
		myRenderer::RENDERSPRITE rendersprite;
		rendersprite.Init();
		rendersprite.psprite = &(s_mousecenteron.sprite);
		re->AddSpriteToForwardRenderPass(rendersprite);
	}

	//aimbar
	if (g_enableDS && (s_dsdeviceid >= 0)) {

		int platemenukind = s_platemenukind;
		int platenomax = 0;

		switch (platemenukind) {
		//case SPPLATEMENUKIND_GUI:
		//	platenomax = SPGUISWNUM;
		//	break;
		case SPPLATEMENUKIND_DISP:
			platenomax = SPDISPSWNUM;
			break;
		case SPPLATEMENUKIND_RIGID:
			platenomax = SPRIGIDSWNUM;
			break;
		case SPPLATEMENUKIND_RETARGET:
			platenomax = SPRETARGETSWNUM;
			break;
		default:
			platenomax = 0;
			break;
		}

		{
			if (s_spsel3d.state) {
				//s_spsel3d.spriteON.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spsel3d.spriteON);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}
			else {
				//s_spsel3d.spriteOFF.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spsel3d.spriteOFF);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}
		}
		//{
		//	int spgcnt;
		//	int chkplatenomax;
		//	chkplatenomax = min(SPAIMBARNUM, platenomax);
		//	for (spgcnt = 0; spgcnt < chkplatenomax; spgcnt++) {
		//		if (s_spaimbar[spgcnt].state) {
		//			s_spaimbar[spgcnt].spriteON.DrawScreen(pRenderContext);
		//		}
		//		else {
		//			s_spaimbar[spgcnt].spriteOFF.DrawScreen(pRenderContext);
		//		}
		//	}
		//}
		//{
		//	if (s_mainmenuaimbarWnd) {
		//		s_mainmenuaimbarWnd->callRewrite();
		//	}


		//	//int spgcnt;
		//	//for (spgcnt = 0; spgcnt < SPMENU_MAX; spgcnt++) {
		//	//	//MainMenuAimBarWndの背景色は、非選択時に茶色、選択時にオレンジ。オレンジはspriteONの色。よってスプライト表示のオンとオフを入れ替える。
		//	//	if (s_spmenuaimbar[spgcnt].state) {
		//	//		if (s_spmenuaimbar[spgcnt].spriteOFF) {//ONのときにOFF色
		//	//			s_spmenuaimbar[spgcnt].spriteOFF.DrawScreen(pRenderContext);
		//	//		}
		//	//		else {
		//	//			_ASSERT(0);
		//	//		}
		//	//	}
		//	//	else {
		//	//		if (s_spmenuaimbar[spgcnt].spriteON) {//OFFのときにON色
		//	//			s_spmenuaimbar[spgcnt].spriteON.DrawScreen(pRenderContext);
		//	//		}
		//	//		else {
		//	//			_ASSERT(0);
		//	//		}
		//	//	}
		//	//}
		//}

	}




	//if (s_platemenukind == SPPLATEMENUKIND_GUI) 
	if (g_previewFlag == 0) {
		if (s_guiswflag)
		{
			//menu 0 : Select 3DWindow GUI
			{

				//常時表示だが　２段目クリック時には１段目は全てOFFにする　１段目クリックに対してだけONを表示する

				//Plate Menu 0
				int spgcnt;
				for (spgcnt = 0; spgcnt < SPGUISWNUM; spgcnt++) {
					if (s_spguisw[spgcnt].state) {
						//s_spguisw[spgcnt].spriteON.DrawScreen(pRenderContext);
						myRenderer::RENDERSPRITE rendersprite;
						rendersprite.Init();
						rendersprite.psprite = &(s_spguisw[spgcnt].spriteON);
						re->AddSpriteToForwardRenderPass(rendersprite);
					}
					else {
						//s_spguisw[spgcnt].spriteOFF.DrawScreen(pRenderContext);
						myRenderer::RENDERSPRITE rendersprite;
						rendersprite.Init();
						rendersprite.psprite = &(s_spguisw[spgcnt].spriteOFF);
						re->AddSpriteToForwardRenderPass(rendersprite);
					}
				}
			}
		}
		else {
			//Plate Menu 0
			int spgcnt;
			for (spgcnt = SPGUISW_DISP_AND_LIMITS; spgcnt < SPGUISWNUM; spgcnt++) {

				//常時表示だが　２段目クリック時には１段目はCameraAndIK以外OFFにする　１段目クリックに対してだけONを表示する

				//s_spguisw[spgcnt].spriteOFF.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spguisw[spgcnt].spriteOFF);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}


			//CameraAndIKに関しては s_guiswflag==falseの場合にも　ONのときはON
			if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
				//s_spguisw[spgcnt].spriteON.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spguisw[SPGUISW_CAMERA_AND_IK].spriteON);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}
			else {
				//s_spguisw[spgcnt].spriteOFF.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spguisw[SPGUISW_CAMERA_AND_IK].spriteOFF);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

		}
		//else 

		if (s_platemenukind == SPPLATEMENUKIND_DISP) {
			//menu 1 : Select SideMenu 

			//Plate Menu 1
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPDISPSWNUM; spgcnt++) {
				if (s_spdispsw[spgcnt].state) {
					//s_spdispsw[spgcnt].spriteON.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spdispsw[spgcnt].spriteON);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
				else {
					//s_spdispsw[spgcnt].spriteOFF.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spdispsw[spgcnt].spriteOFF);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
		}
		else if (s_platemenukind == SPPLATEMENUKIND_RIGID) {
			//menu 1 : Select SideMenu 

			//Plate Menu 1
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPRIGIDSWNUM; spgcnt++) {
				if (s_sprigidsw[spgcnt].state) {
					//s_sprigidsw[spgcnt].spriteON.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_sprigidsw[spgcnt].spriteON);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
				else {
					//s_sprigidsw[spgcnt].spriteOFF.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_sprigidsw[spgcnt].spriteOFF);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
		}
		else if (s_platemenukind == SPPLATEMENUKIND_RETARGET) {

			//Plate Menu 2
			int sprcnt;
			for (sprcnt = 0; sprcnt < SPRETARGETSWNUM; sprcnt++) {
				if (s_spretargetsw[sprcnt].state) {
					//s_spretargetsw[sprcnt].spriteON.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spretargetsw[sprcnt].spriteON);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
				else {
					//s_spretargetsw[sprcnt].spriteOFF.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spretargetsw[sprcnt].spriteOFF);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
		}
	}

	//Sprites of Camera And IK Plate Menu Group
	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {

		if (g_previewFlag == 0) {

			//Axis
			int spacnt;
			for (spacnt = 0; spacnt < SPAXISNUM; spacnt++) {
				//s_spaxis[spacnt].sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spaxis[spacnt].sprite);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

			//IK Mode
			int spgcnt;
			for (spgcnt = 0; spgcnt < 3; spgcnt++) {
				if (s_spikmodesw[spgcnt].state) {
					//s_spikmodesw[spgcnt].spriteON.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spikmodesw[spgcnt].spriteON);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
				else {
					//s_spikmodesw[spgcnt].spriteOFF.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spikmodesw[spgcnt].spriteOFF);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
			}

			//lodsw
			if (s_splod.state) {
				//s_splod.spriteON.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_splod.spriteON);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}
			else {
				//s_splod.spriteOFF.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_splod.spriteOFF);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

			//limiteulsw
			if (s_splimiteul.state) {
				//s_splimiteul.spriteON.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_splimiteul.spriteON);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}
			else {
				//s_splimiteul.spriteOFF.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_splimiteul.spriteOFF);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

			//scrapingsw
			if (s_spscraping.state) {
				//s_spscraping.spriteON.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spscraping.spriteON);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}
			else {
				//s_spscraping.spriteOFF.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spscraping.spriteOFF);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//L2W button
				//s_spcplw2w.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spcplw2w.sprite);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}


			//Undo Redo
			int spucnt;
			for (spucnt = 0; spucnt < 2; spucnt++) {
				//s_spundo[spucnt].sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spundo[spucnt].sprite);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

			//Rig switch
			if ((s_oprigflag >= 0) && (s_oprigflag < SPRIGMAX)) {
				//s_sprig[s_oprigflag].sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_sprig[s_oprigflag].sprite);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//Smooth
				//s_spsmooth.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spsmooth.sprite);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//ConstExe
				//s_spconstexe.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spconstexe.sprite);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//ConstRefresh
				//s_spconstrefresh.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spconstrefresh.sprite);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//s_spret2prev2.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spret2prev2.sprite);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}


			if (s_toolspritemode == 0) {
				{
					//Copy
					//s_spcopy.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spcopy.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}

				{
					//SymCopy
					//s_spsymcopy.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spsymcopy.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}

				{
					//Paste
					//s_sppaste.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_sppaste.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}

				{
					//CopyHistory
					//s_spcopyhistory.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spcopyhistory.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
			else if (s_toolspritemode == 1) {
				{
					//Interpolate
					//s_spinterpolate.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spinterpolate.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}

				{
					//Init
					//s_spinit.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spinit.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//ScaleInit
					//s_spscaleinit.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spscaleinit.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//Property
					//s_spproperty.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spproperty.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
			else if (s_toolspritemode == 2) {
				{
					//Edit0Frame
					//s_spzeroframe.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spzeroframe.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//CameraDolly
					//s_spcameradolly.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spcameradolly.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);

				}
				{
					//ModelPosDir
					//s_spmodelposdir.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spmodelposdir.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);

				}
				{
					//MaterialRate
					//s_spmaterialrate.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = &(s_spmaterialrate.sprite);
					re->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
			else {
				_ASSERT(0);
			}

		}

		//カメラ操作スプライトは　プレビュー中も表示
		int spccnt;
		for (spccnt = 0; spccnt < SPR_CAM_MAX; spccnt++) {
			//s_spcam[spccnt].sprite.DrawScreen(pRenderContext);
			myRenderer::RENDERSPRITE rendersprite;
			rendersprite.Init();
			rendersprite.psprite = &(s_spcam[spccnt].sprite);
			re->AddSpriteToForwardRenderPass(rendersprite);
		}
		//cameramode
		if (s_spcameramode.state == true) {
			//s_spcameramode.spriteON.DrawScreen(pRenderContext);
			myRenderer::RENDERSPRITE rendersprite;
			rendersprite.Init();
			rendersprite.psprite = &(s_spcameramode.spriteON);
			re->AddSpriteToForwardRenderPass(rendersprite);
		}
		else {
			//s_spcameramode.spriteOFF.DrawScreen(pRenderContext);
			myRenderer::RENDERSPRITE rendersprite;
			rendersprite.Init();
			rendersprite.psprite = &(s_spcameramode.spriteOFF);
			re->AddSpriteToForwardRenderPass(rendersprite);
		}
		//camerainherit
		if (g_cameraanimmode != 0) {
			if (s_spcamerainherit.mode == 0) {
				//s_spcamerainherit.sprite1.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spcamerainherit.sprite1);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}
			else if (s_spcamerainherit.mode == 1) {
				//s_spcamerainherit.sprite2.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spcamerainherit.sprite2);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}
			else if (s_spcamerainherit.mode == 2) {
				//s_spcamerainherit.sprite3.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spcamerainherit.sprite3);
				re->AddSpriteToForwardRenderPass(rendersprite);
			}
		}
	}



	//UFO
	if (g_dsmousewait == 1) {
		//s_spmousehere.sprite.DrawScreen(pRenderContext);
		myRenderer::RENDERSPRITE rendersprite;
		rendersprite.Init();
		rendersprite.psprite = &(s_spmousehere.sprite);
		re->AddSpriteToForwardRenderPass(rendersprite);
	}


	return 0;
}

int SetLightDirection()
{
	if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
		_ASSERT(0);
		return 1;
	}


	ChaVector3 dirz = ChaVector3(0.0f, 0.0f, 1.0f);
	ChaVector3 lightdir0, nlightdir0;
	lightdir0 = g_camEye - g_camtargetpos;//2022/10/31
	ChaVector3Normalize(&nlightdir0, &lightdir0);
	//g_LightControl[0].SetLightDirection(nlightdir0.D3DX());

	bool rot180flag = false;
	float chkdot180 = ChaVector3Dot(&dirz, &nlightdir0);
	if (chkdot180 <= -0.9999f) {
		rot180flag = true;
	}
	else {
		rot180flag = false;
	}

	CQuaternion camrotq;
	camrotq.RotationArc(dirz, nlightdir0);

	ZeroMemory(g_lightNo, sizeof(int) * LIGHTNUMMAX);

	int lightindex;
	int activenum = 0;
	for (lightindex = 0; lightindex < LIGHTNUMMAX; lightindex++) {
		if (g_lightEnable[g_lightSlot][lightindex] == true) {
			if (g_lightDirWithView[g_lightSlot][lightindex] == true) {
				ChaVector3 nlightdir;
				ChaVector3Normalize(&nlightdir, &(g_lightDir[g_lightSlot][lightindex]));

				ChaVector3 rotdir, nrotdir;
				if (rot180flag == false) {
					camrotq.Rotate(&rotdir, nlightdir);
				}
				else {
					rotdir = ChaVector3(-nlightdir.x, nlightdir.y, -nlightdir.z);
				}
				ChaVector3Normalize(&nrotdir, &rotdir);
				g_lightdirforshader[activenum] = -ChaVector4(nrotdir, 0.0f);//-lightdir
				//g_lightdirforshader[lightindex] = -ChaVector4(nrotdir, 0.0f);//-lightdir
			}
			else {
				ChaVector3 nrotdir;
				ChaVector3Normalize(&nrotdir, &(g_lightDir[g_lightSlot][lightindex]));
				g_lightdirforshader[activenum] = -ChaVector4(nrotdir, 0.0f);//-lightdir
				//g_lightdirforshader[lightindex] = -ChaVector4(nrotdir, 0.0f);//-lightdir
			}

			ChaVector3 scaleddiffuse;
			scaleddiffuse = g_lightDiffuse[g_lightSlot][lightindex] * g_lightScale[g_lightSlot][lightindex] * g_fLightScale;
			g_lightdiffuseforshader[activenum] = ChaVector4(scaleddiffuse.x, scaleddiffuse.y, scaleddiffuse.z, 1.0f);
			//g_lightdiffuseforshader[lightindex] = ChaVector4(scaleddiffuse.x, scaleddiffuse.y, scaleddiffuse.z, 1.0f);
			
			g_lightNo[activenum] = lightindex;//2023/12/17必要分詰めて格納するので　ShaderのLightScale参照用のライト番号が必要
			
			activenum++;
		}


		//2023/12/17 最近のシェーダは　pixelshaderについてもuniform変数が使用出来てループ回数に使うことが可能
		//定数にuniform宣言を追加するだけで出来た
		// 
		//else {
		//	//シェーダ定数のintでfor分を回すことは出来ない　シェーダ引数のuniform intでなら可だがfxファイルのtechniqueを記述する必要有
		//	//shaderではif分でスキップするよりは配列分計算した方が速いので　計算結果が０になるようなデータを入れる
		//	g_lightdirforshader[lightindex] = ChaVector4(0.0f, 0.0f, 1.0f, 0.0f);
		//	g_lightdiffuseforshader[lightindex] = ChaVector4(0.0f, 0.0f, 0.0f, 1.0f);
		//}
	}

	g_nNumActiveLights = activenum;

	return 0;
}


int OnRenderUtDialog(RenderContext* pRenderContext, float fElapsedTime)
{
	if (!pRenderContext) {
		_ASSERT(0);
		return 1;
	}

	//if (g_previewFlag != 3) {
	//	//g_HUD.OnRender( fElapsedTime );
	//	g_SampleUI.OnRender(fElapsedTime);
	//}

	return 0;
}

void SkipJointMarkReq(int srcstate, CBone* srcbone, bool setbrotherflag)
{
	if (srcbone) {

		if (srcbone->IsSkeleton()) {
			if (srcstate == 1) {
				srcbone->SetSkipRenderBoneMark(true);
			}
			else if (srcstate == 2) {
				srcbone->SetSkipRenderBoneMark(false);
			}
		}


		if (setbrotherflag) {
			if (srcbone->GetBrother(false)) {
				SkipJointMarkReq(srcstate, srcbone->GetBrother(false), setbrotherflag);
			}
		}
		if (srcbone->GetChild(false)) {
			SkipJointMarkReq(srcstate, srcbone->GetChild(false), true);
		}
	}


}

int FilterFromTool()
{
	if (!s_chascene) {
		return 0;
	}
	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_owpTimeline || !s_owpLTimeline) {
		return 0;
	}
	MOTINFO* mi = s_model->GetCurMotInfo();
	if (!mi) {
		return 0;
	}


	HWND parwnd;
	//parwnd = s_3dwnd;
	parwnd = s_3dwnd;

	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_FILTERFROMTOOL);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();
	POINT pt;
	GetCursorPos(&pt);


	CRMenuMain* rsubmenu[3];
	ZeroMemory(rsubmenu, sizeof(CRMenuMain*) * 3);

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}
	//s_customrigmenuindex.clear();

	int subnum = 3;
	int setmenuid;

	WCHAR strinitmpsub[3][32] = { L"AllBones", L"SelectedOne", L"Deeper" };
	int subno;
	for (subno = 0; subno < 3; subno++) {
		setmenuid = ID_RMENU_0 + MENUOFFSET_FILTERFROMTOOL + subno;
		AppendMenu(submenu, MF_STRING, setmenuid, strinitmpsub[subno]);
	}

	/////////////
	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int initmode = -1;
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);

	for (subno = 0; subno < 3; subno++) {
		CRMenuMain* delsubmenu = rsubmenu[subno];
		if (delsubmenu) {
			delete delsubmenu;
		}
	}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	return 0;
}


int InterpolateFromTool()
{
	if (!s_chascene) {
		return 0;
	}
	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_owpTimeline || !s_owpLTimeline) {
		return 0;
	}
	MOTINFO* mi = s_model->GetCurMotInfo();
	if (!mi) {
		return 0;
	}


	HWND parwnd;
	//parwnd = s_3dwnd;
	parwnd = s_3dwnd;

	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_INTERPOLATEFROMTOOL);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();
	POINT pt;
	GetCursorPos(&pt);


	CRMenuMain* rsubmenu[3];
	ZeroMemory(rsubmenu, sizeof(CRMenuMain*) * 3);

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}
	//s_customrigmenuindex.clear();

	int subnum = 3;
	int setmenuid;

	WCHAR strinitmpsub[3][32] = { L"AllBones", L"SelectedOne", L"Deeper" };
	int subno;
	for (subno = 0; subno < 3; subno++) {
		setmenuid = ID_RMENU_0 + MENUOFFSET_INTERPOLATEFROMTOOL + subno;
		AppendMenu(submenu, MF_STRING, setmenuid, strinitmpsub[subno]);
	}

	/////////////
	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int initmode = -1;
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);

	for (subno = 0; subno < 3; subno++) {
		CRMenuMain* delsubmenu = rsubmenu[subno];
		if (delsubmenu) {
			delete delsubmenu;
		}
	}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	return 0;
}


int InitMpFromTool()
{
	if (!s_chascene) {
		return 0;
	}
	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_owpTimeline || !s_owpLTimeline) {
		return 0;
	}
	MOTINFO* mi = s_model->GetCurMotInfo();
	if (!mi) {
		return 0;
	}


	HWND parwnd;
	//parwnd = s_3dwnd;
	parwnd = s_3dwnd;

	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_INITMPFROMTOOL);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();
	POINT pt;
	GetCursorPos(&pt);


	CRMenuMain* rsubmenu[4];
	ZeroMemory(rsubmenu, sizeof(CRMenuMain*) * 4);

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}
	//s_customrigmenuindex.clear();

	int subnum = 4;
	int subsubnum = 4;
	int setmenuid;

	WCHAR strinitmpsub[4][32] = { L"AllBones", L"SelectedOne", L"Deeper", L"DeeperEndJoint"};
	WCHAR strinitmpsubsub[4][32] = { L"InitRotAndPosAndScale", L"InitRot", L"InitPos", L"InitScale" };

	int subno;
	for (subno = 0; subno < 4; subno++) {
		setmenuid = ID_RMENU_0 + subno * 4 + MENUOFFSET_INITMPFROMTOOL;

		rsubmenu[subno] = new CRMenuMain(IDR_RMENU);
		if (!rsubmenu[subno]) {
			return 1;
		}
		ret = rsubmenu[subno]->CreatePopupMenu(parwnd, submenu, strinitmpsub[subno]);
		if (ret) {
			return 1;
		}
		HMENU subsubmenu = rsubmenu[subno]->GetSubMenu();
		int subsubmenunum;
		subsubmenunum = GetMenuItemCount(subsubmenu);
		int subsubmenuno;
		for (subsubmenuno = 0; subsubmenuno < subsubmenunum; subsubmenuno++)
		{
			RemoveMenu(subsubmenu, 0, MF_BYPOSITION);
		}

		int subsubno;
		for (subsubno = 0; subsubno < 4; subsubno++) {
			int subsubid = setmenuid + subsubno;
			AppendMenu(subsubmenu, MF_STRING, subsubid, strinitmpsubsub[subsubno]);

		}
	}

	/////////////
	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int initmode = -1;
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);

	for (subno = 0; subno < 4; subno++) {
		CRMenuMain* delsubmenu = rsubmenu[subno];
		if (delsubmenu) {
			delete delsubmenu;
		}
	}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	return 0;
}

int InitMpByEul(int initmode, CBone* curbone, int srcmotid, double srcframe)
{
	double roundingframe = RoundingTime(srcframe);

	if (curbone && (curbone->IsSkeleton())) {
		//if (curbone->GetChild()){//2022/11/23 CommentOut なぜこのif文があったのか？ 不具合によりエンドジョイントにモーションポイントが無かったから？
		if (initmode == INITMP_ROTTRA) {
			ChaVector3 cureul = ChaVector3(0.0f, 0.0f, 0.0f);
			ChaVector3 traanim = ChaVector3(0.0f, 0.0f, 0.0f);
			//int inittraflag1 = 1;
			int setchildflag1 = 1;
			//int initscaleflag1 = 1;//!!!!!!!
			//curbone->SetWorldMatFromEul(inittraflag1, setchildflag1, cureul, srcmotid, roundingframe, initscaleflag1);
			ChaMatrix befwm = curbone->GetWorldMat(g_limitdegflag, srcmotid, roundingframe, 0);
			curbone->SetWorldMatFromEulAndTra(g_limitdegflag,
				setchildflag1, befwm, cureul, traanim, srcmotid, roundingframe);//scale計算無し
		}
		else if (initmode == INITMP_ROT) {
			ChaVector3 cureul = ChaVector3(0.0f, 0.0f, 0.0f);
			int inittraflag0 = 0;
			int setchildflag1 = 1;
			ChaMatrix befwm = curbone->GetWorldMat(g_limitdegflag, srcmotid, roundingframe, 0);
			curbone->SetWorldMatFromEul(g_limitdegflag,
				inittraflag0, setchildflag1, befwm, cureul, srcmotid, roundingframe);
		}
		else if (initmode == INITMP_TRA) {
			ChaVector3 cureul = ChaVector3(0.0f, 0.0f, 0.0f);
			int paraxsiflag1 = 1;
			//int isfirstbone = 0;
			cureul = curbone->CalcLocalEulXYZ(g_limitdegflag,
				paraxsiflag1, srcmotid, roundingframe, BEFEUL_BEFFRAME);

			int inittraflag1 = 1;
			int setchildflag1 = 1;
			ChaMatrix befwm = curbone->GetWorldMat(g_limitdegflag, srcmotid, roundingframe, 0);
			curbone->SetWorldMatFromEul(g_limitdegflag,
				inittraflag1, setchildflag1, befwm, cureul, srcmotid, roundingframe);
		}
		else if (initmode == INITMP_SCALE) {
			ChaVector3 cureul = ChaVector3(0.0f, 0.0f, 0.0f);
			int paraxsiflag1 = 1;
			//int isfirstbone = 0;
			cureul = curbone->CalcLocalEulXYZ(g_limitdegflag,
				paraxsiflag1, srcmotid, roundingframe, BEFEUL_BEFFRAME);

			ChaVector3 traanim = curbone->CalcLocalTraAnim(g_limitdegflag, srcmotid, roundingframe);

			//int inittraflag1 = 0;
			int setchildflag1 = 1;
			//int initscaleflag1 = 1;//!!!!!!!
			ChaMatrix befwm = curbone->GetWorldMat(g_limitdegflag, srcmotid, roundingframe, 0);
			curbone->SetWorldMatFromEulAndTra(g_limitdegflag,
				setchildflag1, befwm, cureul, traanim, srcmotid, roundingframe);//scale計算無し
		}
		//}
	}
	return 0;
}

void InitMpByEulReq(int initmode, CBone* curbone, int srcmotid, double srcframe, bool broflag)
{
	if (!curbone) {
		return;
	}

	if (curbone->IsSkeleton()) {
		InitMpByEul(initmode, curbone, srcmotid, srcframe);
	}

	if (curbone->GetChild(false)) {
		bool broflag2 = true;
		InitMpByEulReq(initmode, curbone->GetChild(false), srcmotid, srcframe, broflag2);
	}
	if (curbone->GetBrother(false) && (broflag == true)) {
		InitMpByEulReq(initmode, curbone->GetBrother(false), srcmotid, srcframe, broflag);
	}
}

void InitMpByEulEndJointReq(int initmode, CBone* curbone, int srcmotid, double srcframe, bool broflag)
{
	if (!curbone) {
		return;
	}

	//#################################
	//2023/10/22 DeeperEndJoint
	//子供階層の内　endjointだけをInit
	//#################################

	if (curbone->IsSkeleton() && !curbone->GetChild(false)) {
		InitMpByEul(initmode, curbone, srcmotid, srcframe);
	}

	if (curbone->GetChild(false)) {
		bool broflag2 = true;
		InitMpByEulEndJointReq(initmode, curbone->GetChild(false), srcmotid, srcframe, broflag2);
	}
	if (curbone->GetBrother(false) && (broflag == true)) {
		InitMpByEulEndJointReq(initmode, curbone->GetBrother(false), srcmotid, srcframe, broflag);
	}
}


/// CustomRigDlg
int DispCustomRigDlg(int rigno)
{
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}
	if (s_model->GetOldAxisFlagAtLoading() == 1) {
		::DSMessageBox(s_3dwnd, L"Work Only After Setting Of Axis.\nRetry After Saving Of FBX file.", L"error!!!", MB_OK);
		return 0;
	}

	//古いダイアログを閉じる
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}

	Bone2CustomRig(rigno);

	if (!s_customrigdlg) {
		//s_customrigdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_CUSTOMRIGDLG), s_3dwnd, (DLGPROC)CustomRigDlgProc);
		s_customrigdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_CUSTOMRIGDLG), g_mainhwnd, (DLGPROC)CustomRigDlgProc);
		if (!s_customrigdlg) {
			_ASSERT(0);
			return 1;
		}
	}
	else {
		CustomRig2Dlg(s_customrigdlg);
	}

	SetParent(s_customrigdlg, g_mainhwnd);

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetWindowPos(
		s_customrigdlg,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);


	ShowWindow(s_customrigdlg, SW_SHOW);
	UpdateWindow(s_customrigdlg);

	s_oprigflag = 1;

	return 0;
}

int InvalidateCustomRig(int rigno)
{
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}
	if (s_model->GetOldAxisFlagAtLoading() == 1) {
		::DSMessageBox(s_3dwnd, L"Work Only After Setting Of Axis.\nRetry After Saving Of FBX file.", L"error!!!", MB_OK);
		return 0;
	}

	s_customrigbone = s_model->GetBoneByID(s_curboneno);
	if (s_customrigbone) {
		if ((rigno >= 0) && (rigno < MAXRIGNUM)) {
			s_customrigbone->InvalidateCustomRig(rigno);
		}
	}

	//古いダイアログを閉じる
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}

	s_customrigbone = 0;
	s_oprigflag = 0;


	SetTimelineHasRigFlag();


	return 0;
}


int Bone2CustomRig(int rigno)
{
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	s_customrigbone = s_model->GetBoneByID(s_curboneno);
	if (s_customrigbone) {
		if ((rigno >= 0) && (rigno < MAXRIGNUM)) {
			s_customrig = s_customrigbone->GetCustomRig(rigno);
		}
		else {
			s_customrig = s_customrigbone->GetFreeCustomRig();
		}
		if (s_customrig.rigboneno <= 0) {
			_ASSERT(0);
		}
		s_customrigno = s_customrig.rigno;
	}
	else {
		_ASSERT(0);
		InitCustomRig(&s_customrig, 0, 0);
	}

	return 0;
}

int CustomRig2Bone()
{
	if (!s_model) {
		return 0;
	}
	if (!s_customrigbone) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}


	if (s_customrigbone) {
		int isvalid = IsValidCustomRig(s_model, s_customrig, s_customrigbone);
		if (isvalid == 0) {
			::DSMessageBox(s_3dwnd, L"Invalid Parameter", L"error!!!", MB_OK);
			return 0;
		}
		s_customrigbone->SetCustomRig(s_customrig);
	}
	else {
		_ASSERT(0);
	}

	return 0;
}

int GetCustomRigRateVal(HWND hDlgWnd, int resid, float* dstptr)
{
	WCHAR strval[256] = { 0L };
	GetDlgItemText(hDlgWnd, resid, strval, 256);
	float tmpval;
	tmpval = (float)_wtof(strval);
	if ((tmpval < -100.0f) || (tmpval > 100.0f)) {
		::DSMessageBox(hDlgWnd, L"Limit Range From -100.0 to 100.", L"Out Of Limit Error", MB_OK);
		*dstptr = 0.0f;
		return 1;
	}

	*dstptr = tmpval;
	return 0;
}

int CustomRig2Dlg(HWND hDlgWnd)
{
	if (s_customrigbone) {
		SetDlgItemText(hDlgWnd, IDC_RIGNAME, (LPCWSTR)s_customrig.rigname);
		SetDlgItemText(hDlgWnd, IDC_RIGBONENAME, (LPCWSTR)s_customrigbone->GetWBoneName());

		int elemnum = s_customrig.elemnum;
		SendMessage(GetDlgItem(hDlgWnd, IDC_CHILNUM), CB_RESETCONTENT, 0, 0);


		//dispaxis
		WCHAR strcomboda[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_RESETCONTENT, 0, 0);
		wcscpy_s(strcomboda, 256, L"X");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_ADDSTRING, 0, (LPARAM)strcomboda);
		wcscpy_s(strcomboda, 256, L"Y");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_ADDSTRING, 0, (LPARAM)strcomboda);
		wcscpy_s(strcomboda, 256, L"Z");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_ADDSTRING, 0, (LPARAM)strcomboda);
		if ((s_customrig.dispaxis >= 0) && (s_customrig.dispaxis <= 2)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_SETCURSEL, s_customrig.dispaxis, 0);
		}
		else {
			s_customrig.dispaxis = 0;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_SETCURSEL, s_customrig.dispaxis, 0);
		}

		//disporder
		WCHAR strcombodo[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_RESETCONTENT, 0, 0);
		int orderno;
		for (orderno = 0; orderno <= RIGPOSINDEXMAX; orderno++) {
			swprintf_s(strcombodo, 256, L"%d", orderno);
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_ADDSTRING, 0, (LPARAM)strcombodo);

		}
		if ((s_customrig.disporder >= 0) && (s_customrig.disporder <= RIGPOSINDEXMAX)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_SETCURSEL, s_customrig.disporder, 0);
		}
		else {
			s_customrig.disporder = 0;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_SETCURSEL, s_customrig.disporder, 0);
		}

		//posinverse
		if (s_customrig.posinverse) {
			CheckDlgButton(hDlgWnd, IDC_CHKINV, BST_CHECKED);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHKINV, BST_UNCHECKED);
		}


		//shapemult
		WCHAR strcombomult[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_RESETCONTENT, 0, 0);
		int shapemultno;
		for (shapemultno = 0; shapemultno <= RIGMULTINDEXMAX; shapemultno++) {
			swprintf_s(strcombomult, 256, L"%d", shapemultno);
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_ADDSTRING, 0, (LPARAM)strcombomult);

		}
		if ((s_customrig.shapemult >= 0) && (s_customrig.shapemult <= RIGMULTINDEXMAX)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_SETCURSEL, s_customrig.shapemult, 0);
		}
		else {
			s_customrig.shapemult = 0;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_SETCURSEL, s_customrig.shapemult, 0);
		}

		//shapekind
		WCHAR strcomboshape[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_RESETCONTENT, 0, 0);
		wcscpy_s(strcomboshape, 256, L"球");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_ADDSTRING, 0, (LPARAM)strcomboshape);
		wcscpy_s(strcomboshape, 256, L"円X");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_ADDSTRING, 0, (LPARAM)strcomboshape);
		wcscpy_s(strcomboshape, 256, L"円Y");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_ADDSTRING, 0, (LPARAM)strcomboshape);
		wcscpy_s(strcomboshape, 256, L"円Z");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_ADDSTRING, 0, (LPARAM)strcomboshape);
		if ((s_customrig.shapekind >= 0) && (s_customrig.shapekind < RIGSHAPE_MAX)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_SETCURSEL, s_customrig.shapekind, 0);
		}
		else {
			s_customrig.shapekind = 0;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_SETCURSEL, s_customrig.shapekind, 0);
		}

		//rigcolor
		WCHAR strcomborigcolor[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_RESETCONTENT, 0, 0);
		wcscpy_s(strcomborigcolor, 256, L"赤");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_ADDSTRING, 0, (LPARAM)strcomborigcolor);
		wcscpy_s(strcomborigcolor, 256, L"緑");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_ADDSTRING, 0, (LPARAM)strcomborigcolor);
		wcscpy_s(strcomborigcolor, 256, L"青");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_ADDSTRING, 0, (LPARAM)strcomborigcolor);
		if ((s_customrig.rigcolor >= 0) && (s_customrig.rigcolor < RIGCOLOR_MAX)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_SETCURSEL, s_customrig.rigcolor, 0);
		}
		else {
			s_customrig.rigcolor = RIGCOLOR_RED;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_SETCURSEL, s_customrig.rigcolor, 0);
		}


		WCHAR strcombo[256];
		WCHAR strval[256];

		int elemno;
		for (elemno = 0; elemno < MAXRIGELEMNUM; elemno++) {
			swprintf_s(strcombo, 256, L"%d", elemno + 1);//from 1 to MAXRIGELEMNUM
			SendMessage(GetDlgItem(hDlgWnd, IDC_CHILNUM), CB_ADDSTRING, 0, (LPARAM)strcombo);
		}
		if (elemnum < 1) {
			_ASSERT(0);
			elemnum = 1;
			s_customrig.rigelem[0].boneno = s_customrigbone->GetBoneNo();
		}
		SendMessage(GetDlgItem(hDlgWnd, IDC_CHILNUM), CB_SETCURSEL, elemnum - 1, 0);


		int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };
		int axisuid[5] = { IDC_AXIS_U1, IDC_AXIS_U2, IDC_AXIS_U3, IDC_AXIS_U4, IDC_AXIS_U5 };
		int axisvid[5] = { IDC_AXIS_V1, IDC_AXIS_V2, IDC_AXIS_V3, IDC_AXIS_V4, IDC_AXIS_V5 };
		int rateuid[5] = { IDC_RATE_U1, IDC_RATE_U2, IDC_RATE_U3, IDC_RATE_U4, IDC_RATE_U5 };
		int ratevid[5] = { IDC_RATE_V1, IDC_RATE_V2, IDC_RATE_V3, IDC_RATE_V4, IDC_RATE_V5 };
		int enableuid[5] = { IDC_ENABLEU1, IDC_ENABLEU2, IDC_ENABLEU3, IDC_ENABLEU4, IDC_ENABLEU5 };
		int enablevid[5] = { IDC_ENABLEV1, IDC_ENABLEV2, IDC_ENABLEV3, IDC_ENABLEV4, IDC_ENABLEV5 };
		int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };


		for (elemno = 0; elemno < MAXRIGELEMNUM; elemno++) {
			RIGELEM currigelem = s_customrig.rigelem[elemno];
			CBone* curbone = 0;
			if (elemno < elemnum) {
				curbone = s_model->GetBoneByID(currigelem.boneno);
				if (curbone) {
					SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)curbone->GetWBoneName());
				}
				else {
					_ASSERT(0);
					SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)L"None");
					//return 1;
				}
			}
			else {
				SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)L"None");
			}

			SetRigRigCombo(hDlgWnd, elemno);


			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_RESETCONTENT, 0, 0);
			wcscpy_s(strcombo, 256, L"CurrentX");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"CurrentY");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"CurrentZ");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentX");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentY");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentZ");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalX");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalY");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalZ");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeX");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeY");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeZ");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);

			if ((currigelem.transuv[0].axiskind >= 0) && (currigelem.transuv[0].axiskind < RIGAXIS_MAX)) {
				SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_SETCURSEL, currigelem.transuv[0].axiskind, 0);
			}
			swprintf_s(strval, 256, L"%f", currigelem.transuv[0].applyrate);
			SetDlgItemText(hDlgWnd, rateuid[elemno], (LPCWSTR)strval);


			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_RESETCONTENT, 0, 0);
			wcscpy_s(strcombo, 256, L"CurrentX");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"CurrentY");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"CurrentZ");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentX");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentY");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentZ");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalX");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalY");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalZ");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeX");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeY");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeZ");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);

			if ((currigelem.transuv[0].axiskind >= 0) && (currigelem.transuv[0].axiskind < RIGAXIS_MAX)) {
				SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_SETCURSEL, currigelem.transuv[1].axiskind, 0);
			}
			swprintf_s(strval, 256, L"%f", currigelem.transuv[1].applyrate);
			SetDlgItemText(hDlgWnd, ratevid[elemno], (LPCWSTR)strval);

			//int enableuid[5] = { IDC_ENABLEU1, IDC_ENABLEU2, IDC_ENABLEU3, IDC_ENABLEU4, IDC_ENABLEU5 };
			//int enablevid[5] = { IDC_ENABLEV1, IDC_ENABLEV2, IDC_ENABLEV3, IDC_ENABLEV4, IDC_ENABLEV5 };
			if (currigelem.transuv[0].enable == 1) {
				CheckDlgButton(hDlgWnd, enableuid[elemno], BST_CHECKED);
			}
			else {
				CheckDlgButton(hDlgWnd, enableuid[elemno], BST_UNCHECKED);
			}

			if (currigelem.transuv[1].enable == 1) {
				CheckDlgButton(hDlgWnd, enablevid[elemno], BST_CHECKED);
			}
			else {
				CheckDlgButton(hDlgWnd, enablevid[elemno], BST_UNCHECKED);
			}

		}
		EnableRigAxisUV(hDlgWnd);
	}
	else {
		_ASSERT(0);
	}

	return 0;
}

int CheckRigRigCombo(HWND hDlgWnd, int elemno)
{
	//_ASSERT(0);
	//初期化
	int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };
	int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };
	s_customrig.rigelem[elemno].rigrigboneno = -1;
	s_customrig.rigelem[elemno].rigrigno = -1;
	CBone* levelbone = s_model->GetBoneByID(s_customrig.rigelem[elemno].boneno);
	if (levelbone) {
		SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)levelbone->GetWBoneName());
	}
	else {
		SetDlgItemText(hDlgWnd, gpboxid[elemno], L"None");
	}


	//チェック　アンド　セット
	int combono;
	combono = (int)SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_GETCURSEL, 0, 0);
	s_customrig.rigelem[elemno].rigrigboneno = -1;
	s_customrig.rigelem[elemno].rigrigno = -1;
	if ((combono != 0) && (combono != CB_ERR)) {
		WCHAR combolabel[256];
		ZeroMemory(combolabel, sizeof(WCHAR) * 256);
		SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_GETLBTEXT, combono, (LPARAM)combolabel);
		//{
		//	WCHAR strdbg[256];
		//	swprintf_s(strdbg, 256, L"elemno %d, combolabel %s", elemno, combolabel);
		//	::DSMessageBox(hDlgWnd, strdbg, L"combolabel", MB_OK);
		//}
		combolabel[256 - 1] = 0L;
		size_t labellen = wcslen(combolabel);
		if ((labellen > 0) && (labellen < 256)) {
			//format    [rigrigno]rigrigbonename[|]rigname
			if (combolabel[0] == L'[') {
				WCHAR* prigrignoend = wcsstr(combolabel, L"]");
				if (prigrignoend) {
					WCHAR strrigrigno[256];
					ZeroMemory(strrigrigno, sizeof(WCHAR) * 256);
					wcsncpy_s(strrigrigno, 256, combolabel + 1, (size_t)(prigrignoend - (combolabel + 1)));
					int rigrigno = _wtoi(strrigrigno);
					//{
					//	WCHAR strdbg[256];
					//	swprintf_s(strdbg, 256, L"rigrigno %d", rigrigno);
					//	::DSMessageBox(hDlgWnd, strdbg, L"rigrigno", MB_OK);
					//}
					if ((rigrigno >= 0) && (rigrigno < MAXRIGNUM)) {
						s_customrig.rigelem[elemno].rigrigno = rigrigno;

						WCHAR* pbonenameend = wcsstr(combolabel, L"[|]");
						if (pbonenameend) {
							WCHAR rigrigbonename[256];
							ZeroMemory(rigrigbonename, sizeof(WCHAR) * 256);
							wcsncpy_s(rigrigbonename, 256, prigrignoend + 1, (size_t)(pbonenameend - (prigrignoend + 1)));
							//{
							//	WCHAR strdbg[256];
							//	swprintf_s(strdbg, 256, L"rigrigbonename %s", rigrigbonename);
							//	::DSMessageBox(hDlgWnd, strdbg, L"rigrigbonename", MB_OK);
							//}
							CBone* rigrigbone = s_model->GetBoneByWName(rigrigbonename);
							if (rigrigbone) {
								s_customrig.rigelem[elemno].rigrigboneno = rigrigbone->GetBoneNo();

								//{
								//	WCHAR strdbg[256];
								//	swprintf_s(strdbg, 256, L"rigrigboneno %d", s_customrig.rigelem[elemno].rigrigboneno);
								//	::DSMessageBox(hDlgWnd, strdbg, L"rigrigboneno", MB_OK);
								//}
																//int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };
								SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)rigrigbone->GetWBoneName());
							}
						}
					}
				}
			}
		}
	}

	EnableRigAxisUV(hDlgWnd);

	return 0;

}



LRESULT CALLBACK CustomRigDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };

	switch (msg) {
	case WM_INITDIALOG:
	{
		CustomRig2Dlg(hDlgWnd);
		s_customrighwnd = hDlgWnd;
		return FALSE;
	}
	break;
	case WM_COMMAND:
		if (HIWORD(wp) == CBN_SELCHANGE) {
			switch (LOWORD(wp)) {
			case IDC_COMBO1:
				CheckRigRigCombo(hDlgWnd, 0);
				break;
			case IDC_COMBO2:
				CheckRigRigCombo(hDlgWnd, 1);
				break;
			case IDC_COMBO3:
				CheckRigRigCombo(hDlgWnd, 2);
				break;
			case IDC_COMBO4:
				CheckRigRigCombo(hDlgWnd, 3);
				break;
			case IDC_COMBO5:
				CheckRigRigCombo(hDlgWnd, 4);
				break;
			case IDC_CHILNUM:
			{
				int combono = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_CHILNUM), CB_GETCURSEL, 0, 0);
				if ((combono >= 0) && (combono < MAXRIGELEMNUM)) {
					SetCustomRigDlgLevel(hDlgWnd, combono + 1);
				}
			}
			break;
			default:
				break;
			}
		}
		else {
			switch (LOWORD(wp)) {
			case IDOK:
			{
				s_customrighwnd = 0;

				WCHAR strrigname[256] = { 0L };
				GetDlgItemText(hDlgWnd, IDC_RIGNAME, strrigname, 256);
				wcscpy_s(s_customrig.rigname, 256, strrigname);

				int combonoda = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_GETCURSEL, 0, 0);
				if ((combonoda >= 0) && (combonoda <= 2)) {
					s_customrig.dispaxis = combonoda;
				}
				else {
					s_customrig.dispaxis = 0;
				}

				int combonodo = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_GETCURSEL, 0, 0);
				if ((combonodo >= 0) && (combonodo <= RIGPOSINDEXMAX)) {
					s_customrig.disporder = combonodo;
				}
				else {
					s_customrig.disporder = 0;
				}

				if (IsDlgButtonChecked(hDlgWnd, IDC_CHKINV) == BST_CHECKED) {
					s_customrig.posinverse = true;
				}
				else {
					s_customrig.posinverse = false;
				}

				int combonomult = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_GETCURSEL, 0, 0);
				if ((combonomult >= 0) && (combonomult <= RIGMULTINDEXMAX)) {
					s_customrig.shapemult = combonomult;
				}
				else {
					s_customrig.shapemult = 0;
				}

				int combonoshape = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_GETCURSEL, 0, 0);
				if ((combonoshape >= 0) && (combonoshape < RIGSHAPE_MAX)) {
					s_customrig.shapekind = combonoshape;
				}
				else {
					s_customrig.shapekind = 0;
				}

				int combonocolor = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_GETCURSEL, 0, 0);
				if ((combonocolor >= 0) && (combonocolor < RIGCOLOR_MAX)) {
					s_customrig.rigcolor = combonocolor;
				}
				else {
					s_customrig.rigcolor = RIGCOLOR_RED;
				}


				int axisuid[5] = { IDC_AXIS_U1, IDC_AXIS_U2, IDC_AXIS_U3, IDC_AXIS_U4, IDC_AXIS_U5 };
				int axisvid[5] = { IDC_AXIS_V1, IDC_AXIS_V2, IDC_AXIS_V3, IDC_AXIS_V4, IDC_AXIS_V5 };
				int rateuid[5] = { IDC_RATE_U1, IDC_RATE_U2, IDC_RATE_U3, IDC_RATE_U4, IDC_RATE_U5 };
				int ratevid[5] = { IDC_RATE_V1, IDC_RATE_V2, IDC_RATE_V3, IDC_RATE_V4, IDC_RATE_V5 };
				int enableuid[5] = { IDC_ENABLEU1, IDC_ENABLEU2, IDC_ENABLEU3, IDC_ENABLEU4, IDC_ENABLEU5 };
				int enablevid[5] = { IDC_ENABLEV1, IDC_ENABLEV2, IDC_ENABLEV3, IDC_ENABLEV4, IDC_ENABLEV5 };

				int elemno;
				for (elemno = 0; elemno < s_customrig.elemnum; elemno++) {

					CheckRigRigCombo(hDlgWnd, elemno);


					int combono = (int)SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_GETCURSEL, 0, 0);
					if ((combono >= 0) && (combono < RIGAXIS_MAX)) {
						s_customrig.rigelem[elemno].transuv[0].axiskind = combono;
					}
					combono = (int)SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_GETCURSEL, 0, 0);
					if ((combono >= 0) && (combono < RIGAXIS_MAX)) {
						s_customrig.rigelem[elemno].transuv[1].axiskind = combono;
					}

					int ret;
					float tmprate;
					ret = GetCustomRigRateVal(hDlgWnd, rateuid[elemno], &tmprate);
					if (ret) {
						::DSMessageBox(hDlgWnd, L"Invalid VerticalScale. Limit From -100.0 to 100.0.", L"error!!!", MB_OK);
						return 0;
					}
					s_customrig.rigelem[elemno].transuv[0].applyrate = tmprate;

					ret = GetCustomRigRateVal(hDlgWnd, ratevid[elemno], &tmprate);
					if (ret) {
						::DSMessageBox(hDlgWnd, L"Invalid HolizontalScale. Limit From -100.0 to 100.0.", L"error!!!", MB_OK);
						return 0;
					}
					s_customrig.rigelem[elemno].transuv[1].applyrate = tmprate;


					if (IsDlgButtonChecked(hDlgWnd, enableuid[elemno]) == BST_CHECKED) {
						s_customrig.rigelem[elemno].transuv[0].enable = 1;
					}
					else {
						s_customrig.rigelem[elemno].transuv[0].enable = 0;
					}

					if (IsDlgButtonChecked(hDlgWnd, enablevid[elemno]) == BST_CHECKED) {
						s_customrig.rigelem[elemno].transuv[1].enable = 1;
					}
					else {
						s_customrig.rigelem[elemno].transuv[1].enable = 0;
					}

				}


				int isvalid = IsValidCustomRig(s_model, s_customrig, s_customrigbone);
				if (isvalid == 0) {
					::DSMessageBox(hDlgWnd, L"Invalid Parameter", L"error!!!", MB_OK);
					return 0;
				}

				CustomRig2Bone();

				SetTimelineHasRigFlag();

				//EndDialog(hDlgWnd, IDOK);
			}
			break;
			case IDCANCEL:
				s_customrighwnd = 0;
				//EndDialog(hDlgWnd, IDCANCEL);
				SetTimelineHasRigFlag();

				break;
			default:
				return FALSE;
			}
		}
		break;
	case WM_CLOSE:
		if (s_customrigdlg) {
			DestroyWindow(s_customrigdlg);
			s_customrigdlg = 0;
		}

		GUIMenuSetVisible(s_platemenukind, s_platemenuno);

		break;
	default:
		return FALSE;
	}
	return TRUE;

}

int BoneRClick(int srcboneno)
{
	int pickflag = 0;//return value


	if (!s_model) {
		return pickflag;
	}
	if (!s_model->GetTopBone()) {
		return pickflag;
	}



	if (srcboneno < 0) {
		s_ikcnt = 0;
		//SetCapture(s_3dwnd);
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.clickpos = ptCursor;
		s_pickinfo.mousepos = ptCursor;
		s_pickinfo.mousebefpos = ptCursor;
		s_pickinfo.diffmouse = ChaVector2(0.0f, 0.0f);
		s_pickinfo.firstdiff = ChaVector2(0.0f, 0.0f);

		//s_pickinfo.winx = (int)DXUTGetWindowWidth();
		//s_pickinfo.winy = (int)DXUTGetWindowHeight();
		s_pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
		s_pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
		s_pickinfo.pickrange = PICKRANGE;

		s_pickinfo.pickobjno = -1;

		s_curboneno = -1;//2023/08/28 ジョイント以外を右クリックした場合には　メニューを出さない

		if (s_oprigflag == 0) {
			CallF(s_model->PickBone(&s_pickinfo), return pickflag);
			if (s_pickinfo.pickobjno >= 0) {
				s_curboneno = s_pickinfo.pickobjno;
				pickflag = 1;
			}
		}
		else {
			int pickrigboneno = PickRigBone(&s_pickinfo);
			if (pickrigboneno >= 0) {
				s_curboneno = s_pickinfo.pickobjno;
				pickflag = 1;
			}
		}
	}

	if (s_curboneno > 0) {
		if (s_owpTimeline) {
			s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
		}

		ChangeCurrentBone();

		if (s_curboneno >= 0) {
			CBone* curbone = s_model->GetBoneByID(s_curboneno);
			if (curbone) {
				HWND parwnd;
				//parwnd = s_3dwnd;
				parwnd = s_3dwnd;

				CRMenuMain* rmenu;
				rmenu = new CRMenuMain(IDR_RMENU);
				if (!rmenu) {
					return pickflag;
				}
				int ret;
				ret = rmenu->Create(parwnd, MENUOFFSET_BONERCLICK);
				if (ret) {
					return pickflag;
				}

				HMENU submenu = rmenu->GetSubMenu();

				CRMenuMain* rsubmenu[MAXRIGNUM];
				ZeroMemory(rsubmenu, sizeof(CRMenuMain*) * MAXRIGNUM);


				int menunum;
				menunum = GetMenuItemCount(submenu);
				int menuno;
				for (menuno = 0; menuno < menunum; menuno++)
				{
					RemoveMenu(submenu, 0, MF_BYPOSITION);
				}
				s_customrigmenuindex.clear();


				AppendMenu(submenu, MF_STRING,
					(ID_RMENU_COPY + MENUOFFSET_BONERCLICK),
					L"Copy Motion");
				AppendMenu(submenu, MF_STRING,
					(ID_RMENU_PASTE + MENUOFFSET_BONERCLICK),
					L"Paste Deeper");


				if (curbone->GetIKTargetFlag() == false){
					AppendMenu(submenu, MF_STRING, 
						(ID_RMENU_IKTARGET + MENUOFFSET_BONERCLICK), 
						L"Pos Constraint ON");
				}
				else{
					AppendMenu(submenu, MF_STRING, 
						(ID_RMENU_IKTARGET + MENUOFFSET_BONERCLICK), 
						L"Pos Constraint OFF");
				}

				if (curbone->GetIKStopFlag() == false) {
					AppendMenu(submenu, MF_STRING, 
						(ID_RMENU_IKSTOP + MENUOFFSET_BONERCLICK), 
						L"IK Stop ON");
				}
				else {
					AppendMenu(submenu, MF_STRING, 
						(ID_RMENU_IKSTOP + MENUOFFSET_BONERCLICK), 
						L"IK Stop OFF");
				}

				AppendMenu(submenu, MF_STRING, ID_RMENU_0 + MENUOFFSET_BONERCLICK, L"CreateNewRig");
				int setmenuno = 1;
				int rigno;
				for (rigno = 0; rigno < MAXRIGNUM; rigno++) {
					CUSTOMRIG currig = curbone->GetCustomRig(rigno);
					if (currig.useflag == 2) {
						int setmenuid = ID_RMENU_0 + setmenuno + MENUOFFSET_BONERCLICK;

						//AppendMenu(submenu, MF_STRING, setmenuid, currig.rigname);
						s_customrigmenuindex[setmenuno] = rigno;

						rsubmenu[rigno] = new CRMenuMain(IDR_RMENU);
						if (!rsubmenu[rigno]) {
							return pickflag;
						}
						ret = rsubmenu[rigno]->CreatePopupMenu(parwnd, submenu, currig.rigname);
						if (ret) {
							return pickflag;
						}
						HMENU subsubmenu = rsubmenu[rigno]->GetSubMenu();
						int subsubmenunum;
						subsubmenunum = GetMenuItemCount(subsubmenu);
						int subsubmenuno;
						for (subsubmenuno = 0; subsubmenuno < subsubmenunum; subsubmenuno++)
						{
							RemoveMenu(subsubmenu, 0, MF_BYPOSITION);
						}

						int subsubid1 = setmenuid + MAXRIGNUM;
						int subsubid2 = setmenuid + MAXRIGNUM * 2;
						int subsubid3 = setmenuid + MAXRIGNUM * 3;
						AppendMenu(subsubmenu, MF_STRING, subsubid1, L"SettingOfRig");
						AppendMenu(subsubmenu, MF_STRING, subsubid2, L"Execute Rig");
						AppendMenu(subsubmenu, MF_STRING, subsubid3, L"Invalidate Rig");

						setmenuno++;
					}
				}


				POINT pt;
				GetCursorPos(&pt);
				//::ScreenToClient(parwnd, &pt);

				s_cursubmenu = rmenu->GetSubMenu();

				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
				int currigno = -1;
				int menuid;
				menuid = rmenu->TrackPopupMenu(pt);


				for (rigno = 0; rigno < MAXRIGNUM; rigno++) {
					CRMenuMain* curmenu = rsubmenu[rigno];
					if (curmenu) {
						curmenu->Destroy();
						delete curmenu;
					}
				}

				rmenu->Destroy();
				delete rmenu;
				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			}
		}
	}

	return pickflag;
}

int EnableRigAxisUV(HWND hDlgWnd)
{
	int axisuid[5] = { IDC_AXIS_U1, IDC_AXIS_U2, IDC_AXIS_U3, IDC_AXIS_U4, IDC_AXIS_U5 };
	int axisvid[5] = { IDC_AXIS_V1, IDC_AXIS_V2, IDC_AXIS_V3, IDC_AXIS_V4, IDC_AXIS_V5 };
	int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };

	int elemno;
	for (elemno = 0; elemno < s_customrig.elemnum; elemno++) {
		RIGELEM currigelem = s_customrig.rigelem[elemno];
		if (currigelem.rigrigboneno >= 0) {
			EnableWindow(GetDlgItem(hDlgWnd, axisuid[elemno]), false);
			EnableWindow(GetDlgItem(hDlgWnd, axisvid[elemno]), false);
		}
		else {
			EnableWindow(GetDlgItem(hDlgWnd, axisuid[elemno]), true);
			EnableWindow(GetDlgItem(hDlgWnd, axisvid[elemno]), true);
		}
	}

	return 0;
}

int SetRigRigCombo(HWND hDlgWnd, int elemno)
{
	int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };
	int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };

	WCHAR strcombo[256];

	SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)L"NotSet");
	SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_RESETCONTENT, 0, 0);
	wcscpy_s(strcombo, 256, L"RegularBone");
	SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
	SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_SETCURSEL, 0, 0);


	if (elemno < s_customrig.elemnum) {
		RIGELEM currigelem = s_customrig.rigelem[elemno];
		int selrigrigcombono = 0;
		SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_RESETCONTENT, 0, 0);
		wcscpy_s(strcombo, 256, L"RegularBone");
		SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
		int setcombono = 1;

		CBone* rigrigbone = s_model->GetBoneByID(currigelem.rigrigboneno);
		CBone* currigrigbone;
		map<int, CBone*>::iterator itrcurrigrigbone;
		for (itrcurrigrigbone = s_model->GetBoneListBegin(); itrcurrigrigbone != s_model->GetBoneListEnd(); itrcurrigrigbone++) {
			currigrigbone = itrcurrigrigbone->second;
			if (currigrigbone && (currigrigbone->IsSkeleton())) {
				WCHAR rigrigbonename[256];
				ZeroMemory(rigrigbonename, sizeof(WCHAR) * 256);
				wcscpy_s(rigrigbonename, 256, currigrigbone->GetWBoneName());
				int rigrigno;
				for (rigrigno = 0; rigrigno < MAXRIGNUM; rigrigno++) {
					CUSTOMRIG rigrig = currigrigbone->GetCustomRig(rigrigno);
					if (rigrig.useflag == 2) {
						int isvalid = IsValidCustomRig(s_model, rigrig, currigrigbone);
						if (isvalid == 1) {
							swprintf_s(strcombo, 256, L"[%d]%s[|]%s", rigrigno, rigrigbonename, rigrig.rigname);
							SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
							if (rigrigbone && (currigrigbone == rigrigbone) && (rigrigno == currigelem.rigrigno)) {
								selrigrigcombono = setcombono;
								SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)rigrigbone->GetWBoneName());
							}
							setcombono++;
						}
					}
				}
			}
		}
		SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_SETCURSEL, selrigrigcombono, 0);
	}

	return 0;
}

int SetCustomRigDlgLevel(HWND hDlgWnd, int levelnum)
{
	if (!s_model) {
		return 0;
	}
	if (!s_customrigbone) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}
	if (!s_customrigdlg) {
		return 0;
	}

	if ((levelnum >= 1) && (levelnum <= MAXRIGELEMNUM)) {
		int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };

		int parno = 1;
		CBone* parentbone = s_customrigbone->GetParent(false);
		while (parentbone && parentbone->IsSkeleton() && (parno < MAXRIGELEMNUM) && (parno < levelnum)) {
			SetDlgItemText(s_customrigdlg, gpboxid[parno], (LPCWSTR)parentbone->GetWBoneName());
			s_customrig.rigelem[parno].boneno = parentbone->GetBoneNo();
			parentbone = parentbone->GetParent(false);
			parno++;
		}

		//int newlevelnum = parno;
		//s_customrig.elemnum = levelnum;
		//SendMessage(GetDlgItem(s_customrigdlg, IDC_CHILNUM), CB_SETCURSEL, newlevelnum - 1, 0);
		s_customrig.elemnum = levelnum;

		int elemno;
		for (elemno = 0; elemno < MAXRIGELEMNUM; elemno++) {
			SetRigRigCombo(hDlgWnd, elemno);
		}
	}

	EnableRigAxisUV(hDlgWnd);


	return 0;
}

int ToggleRig()
{
	//if (s_customrigbone){
	if (s_oprigflag == 0) {
		s_oprigflag = 1;

		//if (s_BoneMarkCheckBox) {
		//	s_savebonemarkflag = (int)s_BoneMarkCheckBox->GetChecked();
		//	s_BoneMarkCheckBox->SetChecked(false);
		//}
		//if (s_RigidMarkCheckBox) {
		//	s_saverigidmarkflag = (int)s_RigidMarkCheckBox->GetChecked();
		//	s_RigidMarkCheckBox->SetChecked(false);
		//}

		////s_curboneno = s_customrigbone->GetBoneNo();
		////s_pickinfo.buttonflag = PICK_CENTER;
	}
	else {
		s_oprigflag = 0;
		s_pickinfo.buttonflag = 0;

		//if (s_BoneMarkCheckBox) {
		//	s_BoneMarkCheckBox->SetChecked(s_savebonemarkflag == 1);
		//}
		//if (s_RigidMarkCheckBox) {
		//	s_RigidMarkCheckBox->SetChecked(s_saverigidmarkflag == 1);
		//}


		////if (s_customrigdlg){
		////	DestroyWindow(s_customrigdlg);
		////	s_customrigdlg = 0;
		////}

		////GUIMenuSetVisible(s_platemenukind, s_platemenuno);

	}
	//}
	//else{
	//	s_oprigflag = 0;
	//	if (s_customrigdlg){
	//		DestroyWindow(s_customrigdlg);
	//		s_customrigdlg = 0;
	//	}
	//	s_pickinfo.buttonflag = 0;

	//	//GUIMenuSetVisible(s_platemenukind, s_platemenuno);
	//}
	return 0;
}

int GetSymRootMode()
{
	/*
	enum
	{
		//for bit mask operation
		SYMROOTBONE_SAMEORG = 0,
		SYMROOTBONE_SYMDIR = 1,
		SYMROOTBONE_SYMPOS = 2
	};
	*/

	if (!s_chascene) {
		return 0;
	}
	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}

	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 0;
	}
	int ret;
	ret = rmenu->Create(s_3dwnd, MENUOFFSET_GETSYMROOTMODE);
	//ret = rmenu->Create(g_mainhwnd);
	if (ret) {
		return 0;
	}

	HMENU submenu = rmenu->GetSubMenu();

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}

	//scaleを変えるとtraanimも変わるのでscaleメニューを分けないでおく。
	int setmenuid;
	setmenuid = ID_RMENU_0 + MENUOFFSET_GETSYMROOTMODE;
	AppendMenu(submenu, MF_STRING, setmenuid, L"RootBone:SameToSource");
	setmenuid = ID_RMENU_0 + 1 + MENUOFFSET_GETSYMROOTMODE;
	AppendMenu(submenu, MF_STRING, setmenuid, L"RootBone:SymDirAndSymPosAndSymScale");
	setmenuid = ID_RMENU_0 + 2 + MENUOFFSET_GETSYMROOTMODE;
	AppendMenu(submenu, MF_STRING, setmenuid, L"RootBone:SymDirAndSymSale");
	setmenuid = ID_RMENU_0 + 3 + MENUOFFSET_GETSYMROOTMODE;
	AppendMenu(submenu, MF_STRING, setmenuid, L"RootBone:SymPos");


	//2024/01/20
	//実際に有効な使用方法としては　RootBone:SymDirAndSymPosAndSymScaleだけとも言えるので　他のメニューはグレーアウト
	//部分的にペーストしたい場合には　上段カエルショートカットボタンの中のペーストボタンを右クリックして　対象を絞って対称ペーストする
	MENUITEMINFO mii;
	ZeroMemory(&mii, sizeof(MENUITEMINFO));
	mii.cbSize = sizeof(MENUITEMINFO);
	mii.fMask = MIIM_STATE;
	mii.fState = MFS_GRAYED;
	SetMenuItemInfo(submenu, ID_RMENU_0 + MENUOFFSET_GETSYMROOTMODE, FALSE, &mii);
	SetMenuItemInfo(submenu, ID_RMENU_0 + 2 + MENUOFFSET_GETSYMROOTMODE, FALSE, &mii);
	SetMenuItemInfo(submenu, ID_RMENU_0 + 3 + MENUOFFSET_GETSYMROOTMODE, FALSE, &mii);


	POINT pt;
	GetCursorPos(&pt);

	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	s_getsym_retmode = 0;
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);
	//if ((menuid >= ID_RMENU_0) && (menuid <= (ID_RMENU_0 + 3))){
	//	switch(menuid){
	//	case (ID_RMENU_0) :
	//		retmode = SYMROOTBONE_SAMEORG;
	//		break;
	//	case (ID_RMENU_0 + 1) :
	//		retmode = SYMROOTBONE_SYMDIR | SYMROOTBONE_SYMPOS;
	//		break;
	//	case (ID_RMENU_0 + 2) :
	//		retmode = SYMROOTBONE_SYMDIR;
	//		break;
	//	case (ID_RMENU_0 + 3) :
	//		retmode = SYMROOTBONE_SYMPOS;
	//		break;
	//	default:
	//		retmode = SYMROOTBONE_SYMDIR | SYMROOTBONE_SYMPOS;
	//		break;
	//	}
	//}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	//return s_getsym_retmode;//この時点では s_getsym_retmodeは0のまま
	return 0;
}

void AutoCameraTarget()
{
	//s_camtargetflag = (int)s_CamTargetCheckBox->GetChecked();
	if (s_model && (s_curboneno >= 0) && s_camtargetflag) {
		CBone* curbone = s_model->GetBoneByID(s_curboneno);
		_ASSERT(curbone);
		if (curbone) {
			g_befcamtargetpos = g_camtargetpos;
			g_camtargetpos = curbone->GetChildWorld();

			//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));//!!!!!!!!!!!
			////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));//!!!!!!!!!!!

			//!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
			//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
			ChaVector3 diffv;
			diffv = g_camEye - g_camtargetpos;
			g_camdist = (float)ChaVector3LengthDbl(&diffv);

			////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
			////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

			SetCamera3DFromEyePos();
		}
	}
}


/////// for directx9

//--------------------------------------------------------------------------------------
// Rejects any D3D9 devices that aren't acceptable to the app by returning false
//--------------------------------------------------------------------------------------
//bool CALLBACK IsD3D9DeviceAcceptable(D3DCAPS9* pCaps, D3DFORMAT AdapterFormat,
//	D3DFORMAT BackBufferFormat, bool bWindowed, void* pUserContext)
//{
//	//// No fallback defined by this app, so reject any device that doesn't support at least ps2.0
//	//if (pCaps->PixelShaderVersion < D3DPS_VERSION(2, 0))
//	//	return false;
//
//	//// Skip backbuffer formats that don't support alpha blending
//	//IDirect3D9* pD3D = DXUTGetD3D9Object();
//	//if (FAILED(pD3D->CheckDeviceFormat(pCaps->AdapterOrdinal, pCaps->DeviceType,
//	//	AdapterFormat, D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING,
//	//	D3DRTYPE_TEXTURE, BackBufferFormat)))
//	//	return false;
//
//	//return true;
//	return false;
//}


//////////////////////////////////////////
int OnTimeLineSelectFromSelectedKey()
{
	if (g_previewFlag != 0) {
		return 0;
	}

	s_editrange.Clear();
	if (s_model && s_model->GetCurMotInfo()) {
		if (s_owpTimeline && s_owpLTimeline && s_owpEulerGraph) {
			s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
			CEditRange::SetApplyRate((double)g_applyrate);

			int keynum;
			double startframe, endframe, applyframe;
			s_editrange.GetRange(&keynum, &startframe, &endframe, &applyframe);

			if (g_underselectingframe != 0) {
				//if (s_buttonselecttothelast == 0) {//tothelastのときも同じ処理
				if (s_buttonselectstart <= s_buttonselectend) {
					s_owpLTimeline->setCurrentTime(endframe, true);
					s_owpEulerGraph->setCurrentTime(endframe, false);
				}
				else {
					s_owpLTimeline->setCurrentTime(startframe, true);
					s_owpEulerGraph->setCurrentTime(startframe, false);
				}
				//}
				//else {
				//	//to the last selectionの際にはカレントをアプライフレームへ
				//	s_owpLTimeline->setCurrentTime(applyframe, true);
				//	s_owpEulerGraph->setCurrentTime(applyframe, false);
				//}
			}
			else {
				s_owpLTimeline->setCurrentTime(applyframe, true);
				s_owpEulerGraph->setCurrentTime(applyframe, false);
				AddEditRangeHistory();
			}

			UpdateTopPosText();
		}
	}



	return 0;
}

int OnTimeLineButtonSelectFromSelectStartEnd(int tothelastflag)
{
	s_buttonselecttothelast = tothelastflag;

	if (s_owpLTimeline && (g_underselectingframe == 0) && s_timelinewheelFlag) {
		s_owpLTimeline->selectClear(false);
		return 0;
	}

	//if ((s_copyKeyInfoList.size() > 0) || tothelastflag) {//2021/11/09 選択済の場合にはそのまま　これがないと１フレーム長選択でOnButtonSelectがループする
	if (s_owpLTimeline) {
		s_owpLTimeline->selectClear(false);//フレームに色付選択していない場合には呼ばれないので再帰ループしない
		//if ((s_buttonselectstart != s_buttonselectend) || tothelastflag) {//tothelastの際には　範囲を指定していなくても実行
		//if ((s_buttonselectstart <= s_buttonselectend) || tothelastflag) {//2021/11/09
		double tmpmaxselectionframe;
		tmpmaxselectionframe = s_owpLTimeline->OnButtonSelect(s_buttonselectstart, s_buttonselectend, s_buttonselecttothelast);
		s_buttonselectend = tmpmaxselectionframe;//tothelast対応
	//}
	}

	OnTimeLineSelectFromSelectedKey();
	//}

	return 0;
}

int OnTimeLineCursorFunc()
{
	if (s_owpLTimeline && s_model && s_model->GetCurMotInfo()) {
		double curframe;
		curframe = s_owpLTimeline->getCurrentTime();// 選択時刻
		if (s_owpTimeline) {
			s_owpTimeline->setCurrentTime(curframe, false);
			//s_owpLTimeline->setCurrentTime(curframe, false);
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->setCurrentTime(curframe, false);
		}
	}

	return 0;
}

int OnTimeLineCursor()
{
	//s_tum.UpdateTimeline(OnTimeLineCursorFunc, mbuttonflag, newframe);//非ブロック

	if ((s_delmodelFlag == false) && (s_delallmodelFlag == false) && (s_delcurmotFlag == false) &&
		(s_opedelmodelcnt < 0) && (s_opedelmotioncnt < 0) && (s_opeselectmodelcnt < 0) && (s_opeselectmotioncnt < 0) && (s_opeselectcameracnt < 0) &&
		(s_underdelmotion == false) && (s_underdelmodel == false) 
		)// &&
		//s_model && (s_model->GetLoadedFlag() == true) && 
		//(g_underRetargetFlag == false))
	{
		OnTimeLineCursorFunc();
		//UpdateEditedEuler();
		//s_tum.UpdateTimeline(OnTimeLineCursorFunc, mbuttonflag, newframe);//非ブロック
		//if (s_updatetimeline) {
		//	s_updatetimeline->UpdateTimeline(OnTimeLineCursorFunc, mbuttonflag, newframe);
		//	while (s_updatetimeline->IsFinished() == false) {
		//		timeBeginPeriod(1);
		//		SleepEx(0, TRUE);
		//		//SleepEx(1, TRUE);
		//		timeEndPeriod(1);
		//	}
		//}
	}
	else {
		double curframe = 1.0;
		if (s_owpTimeline) {
			s_owpTimeline->setCurrentTime(curframe, false);
		}
		if (s_owpLTimeline) {
			s_owpLTimeline->setCurrentTime(curframe, false);
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->setCurrentTime(curframe, false);
		}
	}




	//if (g_previewFlag != 0){
	//	return 0;
	//}

	//if (s_owpLTimeline && s_model && s_model->GetCurMotInfo()) {
	//	double curframe;
	//	if (mbuttonflag != 2) {
	//		curframe = s_owpLTimeline->getCurrentTime();// 選択時刻
	//		s_owpTimeline->setCurrentTime(curframe, false);
	//		//s_owpLTimeline->setCurrentTime(curframe, false);
	//		s_owpEulerGraph->setCurrentTime(curframe, false);
	//	}
	//	else {
	//		curframe = newframe;
	//		s_owpTimeline->setCurrentTime(curframe, false);
	//		s_owpLTimeline->setCurrentTime(curframe, false);
	//		s_owpEulerGraph->setCurrentTime(curframe, false);
	//	}
	//}

	return 0;
}

int OnTimeLineMButtonDown(bool ctrlshiftflag)
{
	//if (g_underselectingframe == 0){
	if (s_mbuttoncnt == 1) {
		if (ctrlshiftflag == false) {
			g_underselectingframe = 1;
		}
		else {
			g_underselectingframe = 2;
		}
		if (g_previewFlag == 0) {
			if (s_owpLTimeline) {
				s_buttonselectstart = s_owpLTimeline->getCurrentTime();
				s_buttonselectend = s_buttonselectstart;
				s_mbuttonstart = s_buttonselectstart;//2021/11/10
				OnTimeLineCursor();
			}
		}
	}
	else {
		g_underselectingframe = 0;
		OnTimeLineButtonSelectFromSelectStartEnd(0);

		if (s_editmotionflag < 0) {
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}

			//2022/09/13
			if (s_owpLTimeline) {
				s_editmotionflag = s_curboneno;
				s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
				CEditRange::SetApplyRate((double)g_applyrate);
				PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
			}
		}

	}

	s_mbuttoncnt = (int)(!(s_mbuttoncnt == 1));
	//if (s_mbuttoncnt == 0) {
	//	s_mbuttoncnt = 1;
	//}
	//else {
	//	s_mbuttoncnt = 0;
	//}


	DbgOut(L"OnTimeLineMButtonDown : underselectingframe %d, start %lf, end %lf\r\n", g_underselectingframe, s_buttonselectstart, s_buttonselectend);

	return 0;
}


int OnTimeLineWheel()
{

	DbgOut(L"OnTimeLineWheel Called\r\n");

	if (s_owpLTimeline) {
		if ((g_underselectingframe == 1) || (g_underselectingframe == 2)) {
			int delta = 0;
			double delta2 = 0;

			int adkeyflag = 0;

			//A D key
			if (g_keybuf['A'] & 0x80) {
				adkeyflag = 1;
				if ((s_akeycnt % 5) == 0) {
					if (g_controlkey == false) {
						delta2 = -5;
					}
					else {
						delta2 = -1;
					}
				}
				else {
					delta2 = 0;
				}
			}
			else if (g_keybuf['D'] & 0x80) {
				adkeyflag = 1;
				if ((s_dkeycnt % 5) == 0) {
					if (g_controlkey == false) {
						delta2 = 5;
					}
					else {
						delta2 = 1;
					}
				}
				else {
					delta2 = 0;
				}
			}

			if (adkeyflag == 0) {//timelineのwheeldeltaはホイールを回していない間は更新されずに値が残るため、ホイールだけを扱うこと(キー処理中ではないこと)を明示的に確認する。
								 //マウス操作 MButton and Wheel, A D key
				delta = (int)(s_owpLTimeline->getMouseWheelDelta());
				if (g_controlkey == false) {
					delta2 = (double)delta / 20.0;
				}
				else {
					//delta2 = (double)delta / 100.0;//ctrlを押していたら[slowly]
					if (delta > 0) {
						delta2 = 1;
					}
					else if (delta < 0) {
						delta2 = -1;
					}
					else {
						delta2 = 0;
					}
				}
			}

			//timeline
			if (delta2 != 0.0) {
				if (s_buttonselectstart == s_mbuttonstart) {
					s_buttonselectend += delta2;
				}
				else {
					s_buttonselectstart += delta2;
				}
				if (s_buttonselectstart > s_buttonselectend) {
					double tmp;
					tmp = s_buttonselectstart;
					s_buttonselectstart = s_buttonselectend;
					s_buttonselectend = tmp;
				}

				DbgOut(L"OnTimeLineWheel 0 : start %lf, end %lf, delta %lf\r\n", s_buttonselectstart, s_buttonselectend, delta2);

				OnTimeLineButtonSelectFromSelectStartEnd(0);

				if (s_editmotionflag < 0) {
					int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
					if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
						_ASSERT(0);
						::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
						PostQuitMessage(result);
					}
				}

			}
		}
		else {
			DbgOut(L"OnTimeLineWheel 1 : start %lf, end %lf\r\n", s_buttonselectstart, s_buttonselectend);

			int delta = 0;
			double delta2 = 0;
			delta = (int)(s_owpLTimeline->getMouseWheelDelta());
			if (g_controlkey == false) {
				delta2 = (double)delta / 20.0;
			}
			else {
				//delta2 = (double)delta / 100.0;//ctrlを押していたら[slowly]
				if (delta > 0) {
					delta2 = 1;
				}
				else if (delta < 0) {
					delta2 = -1;
				}
				else {
					delta2 = 0;
				}
			}
			if (delta2 != 0.0) {
				double curframe = s_owpLTimeline->getCurrentTime();
				double newframe = curframe + delta2;
				s_buttonselectstart = newframe;
				s_buttonselectend = newframe;
				//s_editrange.Clear();
				//s_owpLTimeline->selectClear();
				//OnTimeLineCursor(2, newframe);

				OnTimeLineButtonSelectFromSelectStartEnd(0);

				if (s_editmotionflag < 0) {
					int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
					if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
						_ASSERT(0);
						::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
						PostQuitMessage(result);
					}
				}

			}

		}

		UpdateTopPosText();
	}

	return 0;
}




LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	WORD menuid;
	menuid = LOWORD(wParam);

	LRESULT lret = 0;

	switch (uMsg)
	{
		//case WM_TIMER:
		//	OnTimerFunc(wParam);
		//	break;

		//case WM_LBUTTONDOWN:
		//case WM_RBUTTONDOWN:
		//	SetCapture(g_mainhwnd);
		//	break;
		//case WM_LBUTTONUP:
		//case WM_RBUTTONUP:
		//	ReleaseCapture();
		//	break;
		//case WM_MOUSEMOVE:
		//	OnMouseMoveFunc();
		//	break;


	case WM_DESTROY:
		//ここでOnDestroyDevice()を呼ぶと　何回もOnDestroyDevice()が呼ばれる
		//WM_QUITでメッセージループを抜けて　ループを出たところでOnDestroyDevice()を呼ぶ
		PostQuitMessage(0);
		return 0;
		//DXUTShutdown(0);//2023/09/23 ここで解放処理を呼んでも　DirectX11の遅延解放のため？VisualStudioのログにデバイスのAlive情報は出る
		break;
	case WM_CREATE:
		break;

	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:
		SetCapture(g_mainhwnd);
		break;
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
		ReleaseCapture();
		break;

	case WM_COMMAND:
	{
		if ((menuid >= 59900) && (menuid <= (59900 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 59900;
			OnAnimMenu(true, selindex);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 61000) && (menuid <= (61000 + MAXMODELNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 61000;
			OnModelMenu(true, selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 62000) && (menuid <= (62000 + MAXRENUM))) {
			ActivatePanel(0);
			int selindex = menuid - 62000;
			OnREMenu(selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 63000) && (menuid <= (63000 + MAXRENUM))) {
			ActivatePanel(0);
			int selindex = menuid - 63000;
			OnRgdMenu(selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 64000) && (menuid <= (64000 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 64000;
			OnRgdMorphMenu(selindex);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 64500) && (menuid <= (64500 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 64500;
			OnImpMenu(selindex);
			ActivatePanel(1);
			//return 0;
		}
		else {
			switch (menuid) {
			case ID_40047:
				// "編集・変換"
				// "ボーン軸をXに再計算"
				ActivatePanel(0);
				//RecalcBoneAxisX(0);
				RecalcAxisX_All();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_CAMERADOLLY:
				ActivatePanel(0);
				ShowCameraDollyDlg();
				ActivatePanel(1);
				break;
			case 29800:
				ActivatePanel(0);
				//RegistKey();
				AboutMotionBrush();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_EXPORTBNT:
				ActivatePanel(0);
				ExportBntFile();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_OPEN40001:
				ActivatePanel(0);
				OpenFile();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_BVH2FBX:
				if (s_registflag == 1) {
					ActivatePanel(0);
					BVH2FBX();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_FILE_BVH2FBXBATCH:
				if (s_registflag == 1) {
					ActivatePanel(0);
					BVH2FBXBatch();
					ActivatePanel(1);
				}
				//return 0;
				break;
				//case ID_FILE_MOTIONCACHE:
				//	if (s_registflag == 1) {
				//		ActivatePanel(0);
				//		MotionCacheBatch();
				//		ActivatePanel(1);
				//	}
				//	//return 0;
				//	break;
			case ID_FILE_RETARGETBATCH:
				if (s_registflag == 1) {
					ActivatePanel(0);
					RetargetBatch();
					ActivatePanel(1);
				}
				//return 0;
				break;

			case ID_SAVE_FBX40039:
				if (s_registflag == 1) {
					ActivatePanel(0);
					ExportFBXFile();
					ActivatePanel(1);
				}
				break;
			case ID_SAVEPROJ_40035:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveProject();
					ActivatePanel(1);
				}
				break;
			case ID_RESAVE_40028:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveREFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_IMPSAVE_40030:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveImpFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_SAVEGCOLI_40033:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveGcoFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_SAVE_MOTIONNAMELIST:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveMotionNameListFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_DISPMW40002:
				DispMotionWindow();
				//return 0;
				break;
			case 4007:
				DispToolWindow();
				//return 0;
				break;
			case 40012:
			{
				bool savedispflag = s_dispobj;
				s_dispobj = !savedispflag;
				DispObjPanel();
				//return 0;
			}
			break;
			case ID_40048:
				//DispConvBoneWindow();
				s_platemenukind = SPPLATEMENUKIND_RETARGET;
				GUIMenuSetVisible(s_platemenukind, 1);
				//return 0;
				break;
			case ID_40049:
				GUIMenuSetVisible(-1, -1);
				DispAngleLimitDlg();
				//return 0;
				break;
			case ID_40050:
				GUIMenuSetVisible(-1, -1);
				DispRotAxisDlg();
				//return 0;
				break;
			case ID_DISPMODELPANEL:
			{
				bool savedispflag = s_dispmodel;
				s_dispmodel = !savedispflag;
				DispModelPanel();
				//return 0;
			}
			break;
			case ID_MOTIONPANEL:
			{
				bool savedispflag = s_dispmotion;
				s_dispmotion = !savedispflag;
				DispMotionPanel();
				//return 0;
			}
			break;
			case ID_CAMERAPANEL:
			{
				bool savedispflag = s_dispcamera;
				s_dispcamera = !savedispflag;
				DispCameraPanel();
				//return 0;
			}
			break;
			case ID_SETTINGS:
			{
				CSettingsDlg dlg;
				dlg.DoModal();
			}
			break;

			case ID_DISPGROUND:
				s_dispground = !s_dispground;
				//return 0;
				break;
			case ID_NEWMOT:
				s_newmotFlag = true;
				//AddMotion(0);
				//InitCurMotion(0, 0);
				//return 0;
				break;
			case ID_DELCURMOT:
				if (s_model) {
					s_delcurmotFlag = true;
					//OnDelMotion(s_motmenuindexmap[s_model]);
				}
				//return 0;
				break;
			case ID_DELMODEL:
				s_delmodelFlag = true;
				//OnDelModel(s_curmodelmenuindex);
				//return 0;
				break;
			case ID_DELALLMODEL:
				s_delallmodelFlag = true;
				//OnDelAllModel();
				//return 0;
				break;
			default:
				break;
			}
		}
	}
	break;

	case WM_MOUSEWHEEL:
	{
		if ((g_keybuf['T'] & 0x80) != 0) {
			if (s_model && (s_curboneno > 0)) {
				s_tkeyflag = 1;

				int delta;
				delta = GET_WHEEL_DELTA_WPARAM(wParam);
				s_ikselectmat = s_selm;
				//s_editmotionflag = s_model->TwistBoneAxisDelta(&s_editrange, s_curboneno, (float)delta, g_iklevel, s_ikcnt, s_ikselectmat);
				s_editmotionflag = s_model->IKRotateAxisDelta(g_limitdegflag,
					&s_editrange, PICK_X, s_curboneno, (float)delta, g_iklevel, s_ikcnt, s_ikselectmat);

				//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
				//UpdateEditedEuler();
			}
		}
	}
	break;

	default:
		//if (uMsg != WM_SETCURSOR) {
		lret = DefWindowProc(hwnd, uMsg, wParam, lParam);
		//}
		break;
	}

	return lret;
}


BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lp) {
	WCHAR strWindowText[1024];
	GetWindowTextW(hwnd, strWindowText, 1024);
	if (wcsstr(strWindowText, L"AdditiveIKC4") != 0) {
		if (lp) {
			*((HWND*)lp) = hwnd;
		}
		return FALSE;
	}
	else {
		return TRUE;
	}
}


HWND CreateMainWindow()
{
	if (g_mainhwnd && IsWindow(g_mainhwnd)) {
		DestroyWindow(g_mainhwnd);
		g_mainhwnd = 0;
	}
	g_mainhwnd = 0;


	//AdditiveIKC4.exeが起動していればそのウインドウを親にする
	HWND parenthwnd = 0;
	if (s_launchbyc4 != 0) {
		EnumWindows(EnumWindowsProc, (LPARAM)&parenthwnd);
	}


	HWND window;
	WNDCLASSEX wcx;
	ZeroMemory(&wcx, sizeof(WNDCLASSEX));
	int returnCode = 0;

	HICON appicon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_ICON1));
	HBRUSH blkbrush = CreateSolidBrush(RGB(0, 0, 0));//自分で削除しない　DestroyWindow時に解放される

	wcx.cbSize = sizeof(WNDCLASSEX);
	wcx.style = CS_HREDRAW | CS_VREDRAW;
	wcx.lpfnWndProc = MainWindowProc;
	wcx.cbClsExtra = 0;
	wcx.cbWndExtra = 0;
	wcx.hInstance = (HINSTANCE)GetModuleHandle(NULL);
	//wcx.hIcon = NULL;
	wcx.hIcon = appicon;
	wcx.hCursor = NULL;
	wcx.hbrBackground = blkbrush;// (HBRUSH)COLOR_BACKGROUND + 1;
	wcx.lpszMenuName = NULL;
	wcx.lpszClassName = WINDOWS_CLASS_NAME;
	wcx.hIconSm = NULL;

	if (!RegisterClassEx(&wcx))
	{
		OutputDebugString(TEXT("Error: ウィンドウクラスの登録ができません。\n"));
		return NULL;
	}

	//HICON appicon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_ICON1));

	s_mainmenu = LoadMenuW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_MENU1));
	if (s_mainmenu == NULL) {
		_ASSERT(0);
		return NULL;
	}

	//animmenu
	HMENU motmenu;
	motmenu = GetSubMenu(s_mainmenu, 2);
	s_animmenu = GetSubMenu(motmenu, 3);
	_ASSERT(s_animmenu);

	HMENU mdlmenu = GetSubMenu(s_mainmenu, 3);
	s_modelmenu = GetSubMenu(mdlmenu, 3);
	_ASSERT(s_modelmenu);

	//編集メニュー　4

	s_remenu = GetSubMenu(s_mainmenu, 5);
	_ASSERT(s_remenu);

	s_rgdmenu = GetSubMenu(s_mainmenu, 6);
	_ASSERT(s_rgdmenu);

	s_morphmenu = GetSubMenu(s_mainmenu, 7);
	_ASSERT(s_morphmenu);

	s_impmenu = GetSubMenu(s_mainmenu, 8);
	_ASSERT(s_impmenu);




	WCHAR strwindowname[MAX_PATH] = { 0L };
	swprintf_s(strwindowname, MAX_PATH, L"AdditiveIK Ver1.0.0.6 : No.%d : ", s_appcnt);

	s_rcmainwnd.top = 0;
	s_rcmainwnd.left = 0;



	window = CreateWindowEx(
		WS_EX_LEFT, WINDOWS_CLASS_NAME, strwindowname,
		WS_OVERLAPPEDWINDOW | WS_VISIBLE,
		//CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
		0, 0, s_totalwndwidth, s_totalwndheight,
		parenthwnd, s_mainmenu, (HINSTANCE)GetModuleHandle(NULL), NULL
	);

	s_rcmainwnd.right = s_totalwndwidth;
	s_rcmainwnd.bottom = s_totalwndheight;

	if (!window)
	{
		OutputDebugString(TEXT("Error: ウィンドウが作成できません。\n"));
		return NULL;
	}




	g_mainhwnd = window;

	if ((s_launchbyc4 != 0) && parenthwnd) {
		SetParent(g_mainhwnd, parenthwnd);
		//::MessageBox(g_mainhwnd, L"setparent", L"check!!!", MB_OK);
	}


	HWND desktopwnd;
	desktopwnd = ::GetDesktopWindow();
	if (desktopwnd) {
		RECT desktoprect;
		::GetClientRect(desktopwnd, &desktoprect);
		//if ((s_appcnt == 0) && (desktoprect.right >= 3840) && (desktoprect.bottom >= 2160)) {
		if (s_appcnt == 0) {
			//if (g_4kresolution) {
			//	SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE);
			//}
			//else {
			//	if (s_launchbyc4 == 0) {
			//		SetWindowPos(g_mainhwnd, HWND_TOP, 1100, 1000, 0, 0, SWP_NOSIZE);
			//	}
			//	else {
			//		SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE);
			//	}
			//}
			if (s_launchbyc4 == 0) {

				//desktopの中心にメインウインドウの中心が来るように移動

				int desktopcenterx, desktopcentery;
				desktopcenterx = (desktoprect.left + desktoprect.right) / 2;
				desktopcentery = (desktoprect.top + desktoprect.bottom) / 2;

				int currentcenterx, currentcentery;
				currentcenterx = s_totalwndwidth / 2;
				currentcentery = s_totalwndheight / 2;

				int diffx, diffy;
				diffx = desktopcenterx - currentcenterx;
				diffy = desktopcentery - currentcentery;

				SetWindowPos(g_mainhwnd, HWND_TOP, diffx, diffy, 0, 0, SWP_NOSIZE);

			}
			else {
				SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE);
			}

		}
		else if (s_appcnt == 1) {
			SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE);
		}
		else if (s_appcnt == 2) {
			SetWindowPos(g_mainhwnd, HWND_TOP, s_totalwndwidth, 0, 0, 0, SWP_NOSIZE);
		}
		else if (s_appcnt == 3) {
			SetWindowPos(g_mainhwnd, HWND_TOP, 0, s_totalwndheight, 0, 0, SWP_NOSIZE);
		}
		else if (s_appcnt == 4) {
			SetWindowPos(g_mainhwnd, HWND_TOP, s_totalwndwidth, s_totalwndheight, 0, 0, SWP_NOSIZE);
		}
	}

	return window;

}

HWND Create3DWnd(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
{
	//HRESULT hr;

	if (s_3dwnd && IsWindow(s_3dwnd)) {
		DestroyWindow(s_3dwnd);
		s_3dwnd = 0;
	}
	s_3dwnd = 0;

	RECT rc;
	ZeroMemory(&rc, sizeof(RECT));
	if (g_4kresolution) {
		rc = InitGame(hInstance, hPrevInstance, lpCmdLine, nShowCmd, TEXT("AdditiveIK"),
			g_mainhwnd,
			s_timelinewidth + s_modelwindowwidth, MAINMENUAIMBARH,
			s_mainwidth, s_mainheight);
	}
	else {
		rc = InitGame(hInstance, hPrevInstance, lpCmdLine, nShowCmd, TEXT("AdditiveIK"),
			g_mainhwnd,
			s_timelinewidth, MAINMENUAIMBARH,
			s_mainwidth, s_mainheight);
	}

	//s_mainwidth = rc.right - rc.left;
	//s_mainheight = rc.bottom - rc.top;

	s_3dwnd = g_hWnd;//g_hWndはsystem.cpp, system.hで定義

	//if (g_4kresolution) {
	//	hr = DXUTCreateWindow(L"AdditiveIK", 0, 0, 0, 450 * 2, 0);
	//}
	//else {
	//	hr = DXUTCreateWindow(L"AdditiveIK", 0, 0, 0, 450, 0);
	//}



	//if (g_4kresolution) {
	//	//hr = DXUTCreateWindow(L"AdditiveIK", 0, 0, 0, s_toolwidth + s_modelwindowwidth, 0);
	//	hr = DXUTCreateWindow(L"AdditiveIK", g_mainhwnd, (HINSTANCE)GetModuleHandle(NULL),
	//		0, 0,
	//		(s_timelinewidth + s_modelwindowwidth), MAINMENUAIMBARH,
	//		s_mainwidth, s_mainheight);
	//}
	//else {
	//	//hr = DXUTCreateWindow(L"AdditiveIK", 0, 0, 0, s_timelinewidth, 0);
	//	hr = DXUTCreateWindow(L"AdditiveIK", g_mainhwnd, (HINSTANCE)GetModuleHandle(NULL),
	//		0, 0, 
	//		s_timelinewidth, MAINMENUAIMBARH,
	//		s_mainwidth, s_mainheight);
	//}

	//if (FAILED(hr)) {
	//	_ASSERT(0);
	//	return 0;
	//}

	//s_3dwnd = DXUTGetHWND();
	//_ASSERT(s_3dwnd);
	////RECT clientrect;
	////GetClientRect(s_3dwnd, &clientrect);
	////s_bufwidth = clientrect.right;
	////s_bufheight = clientrect.bottom;


	//LONG winstyle = ::GetWindowLong(s_3dwnd, GWL_STYLE);
	//winstyle &= ~WS_CAPTION;
	//winstyle |= WS_CHILD;//2023/02/14
	//::SetWindowLong(s_3dwnd, GWL_STYLE, winstyle);
	//SetParent(s_3dwnd, g_mainhwnd);


	//int cycaption = GetSystemMetrics(SM_CYCAPTION);
	//int cymenu = GetSystemMetrics(SM_CYMENU);
	//int cyborder = GetSystemMetrics(SM_CYBORDER);
	//int bufwidth = s_mainwidth;
	//int bufheight = s_mainheight - cycaption - cymenu - cyborder;


	////hr = DXUTCreateDevice(true);//mac + VM Fusionの場合はこっち
	////hr = DXUTCreateDevice(true, bufwidth, bufheight);
	////hr = DXUTCreateDevice(D3D_FEATURE_LEVEL_11_0, true, s_mainwidth, s_mainheight);
	//hr = DXUTCreateDevice(D3D_FEATURE_LEVEL_11_1, true, s_mainwidth, s_mainheight);
	////hr = DXUTCreateDevice(D3D_FEATURE_LEVEL_11_1, true);
	//if (FAILED(hr)) {
	//	_ASSERT(0);
	//	return 0;
	//}
	
	
	//s_3dwnd = DXUTGetHWND();
	//_ASSERT(s_3dwnd);
	RECT clientrect2;
	GetClientRect(s_3dwnd, &clientrect2);
	//s_bufwidth = clientrect2.right;
	//s_bufheight = clientrect2.bottom;


	////RECT clientrect;
	////GetClientRect(s_3dwnd, &clientrect);
	////s_mainwidth = clientrect.right;
	////s_mainheight = clientrect.bottom;
	////ShowWindow( s_3dwnd, SW_SHOW );
	////SetWindowPos( s_3dwnd, HWND_TOP, 450, 0, s_mainwidth, s_mainheight, SWP_NOSIZE ); 

	RECT winrect;
	::GetWindowRect(s_3dwnd, &winrect);
	//::MoveWindow(s_3dwnd, 400, 0, winrect.right - winrect.left, winrect.bottom - winrect.top, TRUE);
	//::MoveWindow(s_3dwnd, 400, 0, s_mainwidth, s_mainheight, TRUE);
	if (g_4kresolution) {
		::MoveWindow(s_3dwnd, s_timelinewidth + s_modelwindowwidth, MAINMENUAIMBARH, s_mainwidth, s_mainheight, TRUE);
		//::SetWindowPos(s_3dwnd, HWND_NOTOPMOST, 
		//	s_toolwidth + s_modelwindowwidth, MAINMENUAIMBARH, s_mainwidth, s_mainheight, SWP_NOSIZE);
	}
	else {
		::MoveWindow(s_3dwnd, s_timelinewidth, MAINMENUAIMBARH, s_mainwidth, s_mainheight, TRUE);
		//::SetWindowPos(s_3dwnd, HWND_NOTOPMOST, 
		//	s_timelinewidth, MAINMENUAIMBARH, s_mainwidth, s_mainheight, SWP_NOSIZE);
	}

	s_rc3dwnd.top = MAINMENUAIMBARH;
	s_rc3dwnd.bottom = (s_mainheight + MAINMENUAIMBARH);
	//s_rc3dwnd.left = 0;
	//s_rc3dwnd.right = s_mainwidth;
	s_rc3dwnd.left = s_timelinewidth + s_modelwindowwidth;
	s_rc3dwnd.right = s_rc3dwnd.left + s_mainwidth;


	////#############################################################################
	////次のコメントアウトブロックはDXUTのウインドウにメニューを付けるときに使用する。
	////#############################################################################
	////最大化してから元に戻すことにより
	////バックバッファの大きさ問題（メニューやキャプションがあるときのずれ）が解消される。
	////::ShowWindow(s_3dwnd, SW_MAXIMIZE);
	////::ShowWindow(s_3dwnd, SW_SHOWNORMAL);


	return s_3dwnd;
}

CInfoWindow* CreateInfoWnd()
{
	if (g_infownd) {
		delete g_infownd;
		g_infownd = 0;
	}

	int cxframe = GetSystemMetrics(SM_CXFRAME);
	int cyframe = GetSystemMetrics(SM_CYFRAME);

	//s_rcinfownd.top = s_mainheight + 3 * cyframe + MAINMENUAIMBARH;
	//s_rcinfownd.bottom = (s_infowinheight + 2 * cyframe);
	//s_rcinfownd.right = s_infowinwidth;
	//s_rcinfownd.left = 400;
	s_rcinfownd.top = s_mainheight + MAINMENUAIMBARH;
	s_rcinfownd.bottom = s_rcinfownd.top + s_infowinheight + 2 * cyframe;
	s_rcinfownd.right = s_infowinwidth;
	s_rcinfownd.left = 400;



	CInfoWindow* newinfownd = new CInfoWindow();
	if (newinfownd) {

		int ret;
		//if (g_4kresolution) {
		//	ret = newinfownd->CreateInfoWindow(g_mainhwnd,
		//		400 * 2, s_mainheight + 3 * cyframe + MAINMENUAIMBARH,
		//		s_infowinwidth, s_infowinheight + 2 * cyframe);

		//	s_rcinfownd.left = 400 * 2;
		//}
		//else {
		//	ret = newinfownd->CreateInfoWindow(g_mainhwnd,
		//		400, s_mainheight + 3 * cyframe + MAINMENUAIMBARH,
		//		s_infowinwidth, s_infowinheight + 2 * cyframe);

		//	s_rcinfownd.left = 400;
		//}

		if (g_4kresolution) {
			ret = newinfownd->CreateInfoWindow(g_mainhwnd,
				//s_timelinewidth + s_modelwindowwidth, s_mainheight + 3 * cyframe + MAINMENUAIMBARH,
				s_timelinewidth + s_modelwindowwidth, s_mainheight + MAINMENUAIMBARH,
				s_infowinwidth, s_infowinheight + 2 * cyframe);

			s_rcinfownd.left = s_timelinewidth;
		}
		else {
			ret = newinfownd->CreateInfoWindow(g_mainhwnd,
				//s_timelinewidth, s_mainheight + 3 * cyframe + MAINMENUAIMBARH,
				s_timelinewidth, s_mainheight + MAINMENUAIMBARH,
				s_infowinwidth, s_infowinheight + 2 * cyframe);

			s_rcinfownd.left = s_timelinewidth;
		}


		if (ret == 0) {
			g_infownd = newinfownd;

			//OutputToInfoWnd(L"InfoWindow initialized 1");
			OutputToInfoWnd(L"Upper to lower, older to newer. Limit to 6,000 lines.");
			OutputToInfoWnd(L"Scroll is enable by mouse wheel.");
			OutputToInfoWnd(L"If the most newest line is shown at lowest position, AutoScroll works.Save to info_(date).txt on exit.");
			OutputToInfoWnd(L"上：古,下：新。6,000行。ホイールでスクロール。一番新しいものを表示している時AutoScroll。終了時にinfo_日時.txtにセーブ。");
		}

	}



	return newinfownd;
}


int RecalcBoneAxisX(CBone* srcbone)
{
	if (s_model && (s_model->GetOldAxisFlagAtLoading() == 1)) {
		::DSMessageBox(s_3dwnd, L"Retry After Saving And Loading.", L"error!!!", MB_OK);
		return 0;
	}

	s_model->RecalcBoneAxisX(srcbone);

	return 0;
}

void RecalcAxisX_All()
{
	if (s_model) {
		if (s_model && (s_model->GetOldAxisFlagAtLoading() == 1)) {
			::DSMessageBox(s_3dwnd, L"Retry After Saving And Loding.", L"error!!!", MB_OK);
			return;
		}

		if (s_owpLTimeline) {
			s_owpLTimeline->setCurrentTime(0.0, true);
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->setCurrentTime(0.0, false);
		}
		s_model->SetMotionFrame(0.0);
		ChaMatrix tmpwm = s_model->GetWorldMat();
		s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);

		//ここでAxisMatXの初期化
		s_model->CreateBtObject(g_limitdegflag, 1);
		s_model->CalcBtAxismat(2);//2
		s_model->SetInitAxisMatX(1);
	}
}


int OnMouseMoveFunc()
{
	static bool s_doingflag = false;
	if (s_doingflag == true) {
		return 0;
	}
	s_doingflag = true;

	if (g_graphicsEngine) {
		s_pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
		s_pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
		s_pickinfo.pickrange = PICKRANGE;
	}


	//2024/01/19
	if (g_fpsforce30) {
		double difftime = s_fTime - s_mousemoveBefTime;//s_fElapsedTimeは表示に関する時間なのでここでは使わない
		if (difftime < (1.0 / 33.0)) {
			s_doingflag = false;
			return 0;//!!!!!!!!!!!!!! 強制30fpsフラグが経っている場合には 30fps以上の計算(IK計算)はしない
		}
		s_mousemoveBefTime = s_fTime;
	}



	if (s_rbuttonSelectFlag) {
		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		float deltax = (float)((s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y)) * 0.5f;
		if (deltax > 0.0f) {
			if (g_controlkey == true) {
				s_selectuserscale += 1;
			}
			else {
				s_selectuserscale += 5;
			}
			s_selectuserscale = min(300, s_selectuserscale);
			s_selectuserscale = max(30, s_selectuserscale);
		}
		else if (deltax < 0.0f) {
			if (g_controlkey == true) {
				s_selectuserscale -= 1;
			}
			else {
				s_selectuserscale -= 5;
			}
			s_selectuserscale = min(300, s_selectuserscale);
			s_selectuserscale = max(30, s_selectuserscale);
		}
		else {

		}
	}
	else if (s_pickinfo.buttonflag == PICK_CENTER) {
		if (s_model) {
			if (g_previewFlag == 0) {

				s_pickinfo.mousebefpos = s_pickinfo.mousepos;
				POINT ptCursor;
				GetCursorPos(&ptCursor);
				::ScreenToClient(s_3dwnd, &ptCursor);
				s_pickinfo.mousepos = ptCursor;

				ChaVector3 tmpsc;
				s_model->TransformBone(s_pickinfo.winx, s_pickinfo.winy, s_curboneno, &s_pickinfo.objworld, &tmpsc, &s_pickinfo.objscreen);

				if (s_model) {
					if (s_oprigflag == 0) {
						ChaVector3 targetpos(0.0f, 0.0f, 0.0f);
						//CallF(CalcTargetPos(&targetpos), return 1);
						CalcTargetPos(&targetpos);
						if (s_ikkind == 0) {
							s_editmotionflag = s_model->IKRotateUnderIK(g_limitdegflag,
								&s_editrange, s_pickinfo.pickobjno, targetpos, g_iklevel);

							//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
							//UpdateEditedEuler();
						}
						else if (s_ikkind == 1) {
							//ChaVector3 diffvec = targetpos - s_pickinfo.objworld;

							ChaVector3 modelobjworld;
							ChaMatrix invmodelwm = ChaMatrixInv(s_model->GetWorldMat());
							ChaVector3TransformCoord(&modelobjworld, &s_pickinfo.objworld, &invmodelwm);
							ChaVector3 diffvec = targetpos - modelobjworld;
							AddBoneTra2(diffvec);
							s_editmotionflag = s_curboneno;
						}
						else if (s_ikkind == 2) {
							//ChaVector3 diffvec = targetpos - s_pickinfo.objworld;

							ChaVector3 modelobjworld;
							ChaMatrix invmodelwm = ChaMatrixInv(s_model->GetWorldMat());
							ChaVector3TransformCoord(&modelobjworld, &s_pickinfo.objworld, &invmodelwm);
							ChaVector3 diffvec = targetpos - modelobjworld;
							AddBoneScale2(diffvec);
							s_editmotionflag = s_curboneno;
						}

					}
					else {
						if (s_customrigbone) {
							float deltau = (float)(s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) * 0.5f;
							float deltav = (float)(s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y) * 0.5f;
							if (g_controlkey == true) {
								deltau *= 0.250f;
								deltav *= 0.250f;
							}

							s_ikcustomrig = s_customrigbone->GetCustomRig(s_customrigno);
							s_model->RigControlUnderRig(g_limitdegflag,
								0, &s_editrange, s_pickinfo.pickobjno,
								0, deltau, 
								s_ikcustomrig, s_pickinfo.buttonflag);
							ChaMatrix tmpwm = s_model->GetWorldMat();
							s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
							s_model->RigControlUnderRig(g_limitdegflag, 
								0, &s_editrange, s_pickinfo.pickobjno, 
								1, deltav, 
								s_ikcustomrig, s_pickinfo.buttonflag);
							s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
							s_editmotionflag = s_curboneno;
							//s_editmotionflag = 0;//これを０にすると　oprigflag == 1の状態でアンドゥした時に　アンドゥ用の保存が走って　保存が増えて状態が戻らない
						}
					}
					s_ikcnt++;
				}
			}
			else if (g_previewFlag == 5) {
				if (s_model) {
					//if (s_onragdollik == 0){
					//	StartBt(1, 1);
					//}
					s_onragdollik = 1;
				}
			}
		}
	}
	else if ((s_pickinfo.buttonflag == PICK_X) || (s_pickinfo.buttonflag == PICK_Y) || (s_pickinfo.buttonflag == PICK_Z)) {
		if (s_model) {
			if (g_previewFlag == 0) {
				s_pickinfo.mousebefpos = s_pickinfo.mousepos;
				POINT ptCursor;
				GetCursorPos(&ptCursor);
				::ScreenToClient(s_3dwnd, &ptCursor);
				s_pickinfo.mousepos = ptCursor;

				ChaVector3 tmpsc;
				s_model->TransformBone(s_pickinfo.winx, s_pickinfo.winy, s_curboneno, &s_pickinfo.objworld, &tmpsc, &s_pickinfo.objscreen);

				if (g_previewFlag == 0) {
					float deltax = (float)((s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y)) * 0.5f;
					if (g_controlkey == true) {
						deltax *= 0.250f;
					}

					if ((s_befdeltax * deltax) > 0.0f) {
						if (s_ikkind == 0) {
							s_editmotionflag = s_model->IKRotateAxisDeltaUnderIK(
								g_limitdegflag,
								&s_editrange, s_pickinfo.buttonflag, s_pickinfo.pickobjno,
								deltax, g_iklevel, s_ikcnt, s_ikselectmat);

							//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
							//UpdateEditedEuler();
						}
						else if (s_ikkind == 1) {
							AddBoneTra(s_pickinfo.buttonflag - PICK_X, deltax * 0.1f);
							s_editmotionflag = s_curboneno;
						}
						else if (s_ikkind == 2) {
							if (g_shiftkey == false) {
								AddBoneScale(s_pickinfo.buttonflag - PICK_X, deltax);
								s_editmotionflag = s_curboneno;
							}
							else {
								//2024/01/30 
								//shiftキーを押しながらX,Y,ZどれかのスプライトドラッグでPICK_CENTER
								AddBoneScale(-1, deltax);
								s_editmotionflag = s_curboneno;
							}
						}
					}
					s_befdeltax = deltax;

					s_ikcnt++;
				}
			}
			else if (g_previewFlag == 5) {
				if (s_model) {
					s_onragdollik = 2;
				}
			}
		}
	}
	else if ((s_pickinfo.buttonflag == PICK_SPA_X) || (s_pickinfo.buttonflag == PICK_SPA_Y) || (s_pickinfo.buttonflag == PICK_SPA_Z)) {
		if (s_model) {
			if (g_previewFlag == 0) {
				s_pickinfo.buttonflag = s_pickinfo.buttonflag - PICK_SPA_X + PICK_X;//!!!!!!!!!

				s_pickinfo.mousebefpos = s_pickinfo.mousepos;
				POINT ptCursor;
				GetCursorPos(&ptCursor);
				::ScreenToClient(s_3dwnd, &ptCursor);
				s_pickinfo.mousepos = ptCursor;

				ChaVector3 tmpsc;
				s_model->TransformBone(s_pickinfo.winx, s_pickinfo.winy, s_curboneno, &s_pickinfo.objworld, &tmpsc, &s_pickinfo.objscreen);

				if (g_previewFlag == 0) {
					float deltax = (float)((s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y)) * 0.5f;
					if (g_controlkey == true) {
						deltax *= 0.250f;
					}

					if ((s_befdeltax * deltax) > 0.0f) {
						if (s_ikkind == 0) {
							s_editmotionflag = s_model->IKRotateAxisDeltaUnderIK(
								g_limitdegflag,
								&s_editrange, s_pickinfo.buttonflag, s_pickinfo.pickobjno,
								deltax, g_iklevel, s_ikcnt, s_ikselectmat);

							//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
							//UpdateEditedEuler();
						}
						else if (s_ikkind == 1) {
							AddBoneTra(s_pickinfo.buttonflag, deltax * 0.1f);
							s_editmotionflag = s_curboneno;
						}
						else if (s_ikkind == 2) {
							if (g_shiftkey) {
								AddBoneScale(s_pickinfo.buttonflag, deltax);
								s_editmotionflag = s_curboneno;
							}
							else {
								//2024/01/30 
								//shiftキーを押しながらX,Y,ZどれかのスプライトドラッグでPICK_CENTER
								AddBoneScale(-1, deltax);
								s_editmotionflag = s_curboneno;
							}

						}
					}
					s_befdeltax = deltax;
					s_ikcnt++;
				}
			}
			else if (g_previewFlag == 5) {
				if (s_model) {
					s_onragdollik = 3;
				}
			}
		}
	}
	else if (s_pickinfo.buttonflag == PICK_CAMMOVE) {

		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		ChaVector3 cammv;
		cammv.x = ((float)s_pickinfo.mousepos.x - (float)s_pickinfo.mousebefpos.x) / (float)s_pickinfo.winx * -s_cammvstep;
		cammv.y = ((float)s_pickinfo.mousepos.y - (float)s_pickinfo.mousebefpos.y) / (float)s_pickinfo.winy * s_cammvstep;
		cammv.z = 0.0f;
		if (g_controlkey == true) {
			cammv *= 0.250f;
		}
		cammv *= g_physicsmvrate;//2024/01/30 DispAndLimitsPlateMenu : EditRateSlider

		ChaMatrix invmatView;
		invmatView = ChaMatrixInv(s_matView);
		ChaVector3 camdirx, camdiry;
		camdirx = ChaVector3(invmatView.data[MATI_11], invmatView.data[MATI_12], invmatView.data[MATI_13]);
		camdiry = ChaVector3(invmatView.data[MATI_21], invmatView.data[MATI_22], invmatView.data[MATI_23]);
		ChaVector3Normalize(&camdirx, &camdirx);
		ChaVector3Normalize(&camdiry, &camdiry);
		ChaVector3 movevec = camdirx * cammv.x + camdiry * cammv.y;

		g_befcamEye = g_camEye;
		g_befcamtargetpos = g_camtargetpos;

		g_camEye = g_camEye + movevec;
		g_camtargetpos = g_camtargetpos + movevec;

		ChaVector3 diffv;
		diffv = g_camtargetpos - g_camEye;
		g_camdist = (float)ChaVector3LengthDbl(&diffv);

		SetCamera3DFromEyePos();
	}
	else if (s_twistcameraFlag) {
		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		float deltax;
		deltax = -((float)s_pickinfo.mousepos.x - (float)s_pickinfo.mousebefpos.x) / (float)s_pickinfo.winx * 250.0f * (float)DEG2PAI;
		if (g_controlkey == true) {
			deltax *= 0.250f;
		}


		ChaVector3 twistaxis;
		CQuaternion twistq;
		twistaxis = g_camtargetpos - g_camEye;
		ChaVector3Normalize(&twistaxis, &twistaxis);
		twistq.SetAxisAndRot(twistaxis, deltax);
		ChaVector3 newupvec;
		twistq.Rotate(&newupvec, g_cameraupdir);
		ChaVector3Normalize(&newupvec, &newupvec);
		g_cameraupdir = newupvec;

		g_befcamEye = g_camEye;
		ChaVector3 diffv;
		diffv = g_camEye - g_camtargetpos;
		g_camdist = (float)ChaVector3LengthDbl(&diffv);

		SetCamera3DFromEyePos();
	}
	else if (s_pickinfo.buttonflag == PICK_CAMROT) {

		//not use quaternion yet in this part, so ジンバルロック未回避.

		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		float roty, rotxz;
		rotxz = -((float)s_pickinfo.mousepos.x - (float)s_pickinfo.mousebefpos.x) / (float)s_pickinfo.winx * 250.0f;
		roty = ((float)s_pickinfo.mousepos.y - (float)s_pickinfo.mousebefpos.y) / (float)s_pickinfo.winy * 250.0f;
		if (g_controlkey == true) {
			rotxz *= 0.250f;
			roty *= 0.250f;
		}

		ChaMatrix matview;
		ChaVector3 weye, wat;
		weye = g_camEye;
		wat = g_camtargetpos;

		ChaVector3 viewvec, upvec, rotaxisy, rotaxisxz;
		viewvec = wat - weye;
		ChaVector3Normalize(&viewvec, &viewvec);
		upvec = ChaVector3(0.000001f, 1.0f, 0.0f);

		float chkdot;
		chkdot = ChaVector3Dot(&viewvec, &upvec);
		if (fabs(chkdot) < 0.99965f) {
			ChaVector3Cross(&rotaxisxz, (const ChaVector3*)&upvec, (const ChaVector3*)&viewvec);
			ChaVector3Normalize(&rotaxisxz, &rotaxisxz);

			ChaVector3Cross(&rotaxisy, (const ChaVector3*)&viewvec, (const ChaVector3*)&rotaxisxz);
			ChaVector3Normalize(&rotaxisy, &rotaxisy);
			//}
			//else if (chkdot >= 0.99965f) {
			//	rotaxisxz = upvec;
			//	ChaVector3Cross(&rotaxisy, (const ChaVector3*)&viewvec, (const ChaVector3*)&rotaxisxz);
			//	ChaVector3Normalize(&rotaxisy, &rotaxisy);
			//	//rotxz = 0.0f;
			//	//if (roty < 0.0f) {
			//	//	roty = 0.0f;
			//	//}
			//	//else {
			//	//}
			//}
			//else {
			//	rotaxisxz = upvec;
			//	ChaVector3Cross(&rotaxisy, (const ChaVector3*)&viewvec, (const ChaVector3*)&rotaxisxz);
			//	ChaVector3Normalize(&rotaxisy, &rotaxisy);
			//	//rotxz = 0.0f;
			//	//if (roty > 0.0f) {
			//	//	roty = 0.0f;
			//	//}
			//	//else {
			//	//	//rotyだけ回す。
			//	//}
			//}


			if (s_model && (s_curboneno >= 0) && s_camtargetflag) {
				CBone* curbone = s_model->GetBoneByID(s_curboneno);
				_ASSERT(curbone);
				if (curbone) {
					g_befcamtargetpos = g_camtargetpos;
					g_camtargetpos = curbone->GetChildWorld();
				}
			}


			ChaMatrix befrotmat, rotmaty, rotmatxz, aftrotmat;
			befrotmat.SetIdentity();//2023/02/12
			aftrotmat.SetIdentity();//2023/02/12
			rotmaty.SetIdentity();//2023/02/12
			rotmatxz.SetIdentity();//2023/02/12
			ChaMatrixTranslation(&befrotmat, -g_camtargetpos.x, -g_camtargetpos.y, -g_camtargetpos.z);
			ChaMatrixTranslation(&aftrotmat, g_camtargetpos.x, g_camtargetpos.y, g_camtargetpos.z);
			ChaMatrixRotationAxis(&rotmaty, &rotaxisy, rotxz * (float)DEG2PAI);
			ChaMatrixRotationAxis(&rotmatxz, &rotaxisxz, roty * (float)DEG2PAI);

			ChaMatrix mat;
			mat = befrotmat * rotmatxz * rotmaty * aftrotmat;
			ChaVector3 neweye;
			ChaVector3TransformCoord(&neweye, &weye, &mat);

			//float chkdot2;
			//ChaVector3 newviewvec = weye - neweye;
			//ChaVector3Normalize(&newviewvec, &newviewvec);
			//chkdot2 = ChaVector3Dot(&newviewvec, &upvec);
			//if (fabs(chkdot2) < 0.99965f) {
			//	ChaVector3Cross(&rotaxisxz, (const ChaVector3*)&upvec, (const ChaVector3*)&viewvec);
			//	ChaVector3Normalize(&rotaxisxz, &rotaxisxz);

			//	ChaVector3Cross(&rotaxisy, (const ChaVector3*)&viewvec, (const ChaVector3*)&rotaxisxz);
			//	ChaVector3Normalize(&rotaxisy, &rotaxisy);
			//}
			//else {
			//	roty = 0.0f;
			//	rotaxisxz = upvec;
			//	ChaVector3Cross(&rotaxisy, (const ChaVector3*)&viewvec, (const ChaVector3*)&rotaxisxz);
			//	ChaVector3Normalize(&rotaxisy, &rotaxisy);
			//}
			//ChaMatrixRotationAxis(&rotmaty, &rotaxisy, rotxz * (float)DEG2PAI);
			//ChaMatrixRotationAxis(&rotmatxz, &rotaxisxz, roty * (float)DEG2PAI);
			//mat = befrotmat * rotmatxz * rotmaty * aftrotmat;
			//ChaVector3TransformCoord(&neweye, &weye, &mat);

			//#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
			//#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
			//#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

			g_befcamEye = g_camEye;
			g_camEye = neweye;
			//!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
			//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);

			ChaVector3 diffv;
			diffv = neweye - g_camtargetpos;
			g_camdist = (float)ChaVector3LengthDbl(&diffv);

		}
		else {
			g_camEye = g_befcamEye;
			g_camtargetpos = g_befcamtargetpos;
		}

		SetCamera3DFromEyePos();
	}
	else if (s_pickinfo.buttonflag == PICK_CAMDIST) {
		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		float deltadist = (float)(s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y) * 0.5f;
		//float mdelta = (float)GET_WHEEL_DELTA_WPARAM(wParam);
		//float deltadist = mdelta * g_camdist * 0.0010f;
		if (g_controlkey == true) {
			deltadist *= 0.250f;
		}
		deltadist *= g_physicsmvrate;//2024/01/30 DispAndLimitsPlateMenu : EditRateSlider

		float savecamdist = g_camdist;

		g_camdist += deltadist;
		//if (g_camdist < 0.0001f) {
		//	g_camdist = 0.0001f;
		//}
		if (g_camdist >= 0.01f) {//2022/10/29 0.0001では近づきすぎたときに固まるので0.01に変更
			ChaVector3 camvec = g_camEye - g_camtargetpos;
			ChaVector3Normalize(&camvec, &camvec);
			g_befcamEye = g_camEye;
			g_camEye = g_camtargetpos + camvec * g_camdist;
		}
		else {

			//2023/03/23
			//カメラ位置がターゲットに近づきすぎた場合　止めないで　ターゲット位置を視線方向に延長するように

			ChaVector3 camvec2 = g_camtargetpos - g_camEye;
			ChaVector3Normalize(&camvec2, &camvec2);
			g_camtargetpos = g_camEye + camvec2 * savecamdist * 3.0f;
			g_befcamEye = g_camEye;
			g_camEye = g_camtargetpos - camvec2 * savecamdist * 3.0f;

			g_camdist = savecamdist * 3.0f;
		}

		//!!!!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);

		//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		//#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		//#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		SetCamera3DFromEyePos();
	}

	s_doingflag = false;

	return 0;
}

void GUIRetargetSetVisible(int srcplateno)
{
	if (srcplateno == 1) {
		ShowRetargetWnd(true);
		ShowLimitEulerWnd(false);
	}
	else if (srcplateno == 2) {
		ShowRetargetWnd(false);
		ShowLimitEulerWnd(true);
	}
	else if (srcplateno == -2) {
		ShowRetargetWnd(false);
		ShowLimitEulerWnd(false);
	}
	else {
		_ASSERT(0);
	}
}

void GUIDispSetVisible(int srcplateno)
{
	if (srcplateno == 1) {
		ShowLightsWnd(true);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(false);
	}
	else if (srcplateno == 2) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(true);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(false);
	}
	else if (srcplateno == 3) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(true);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(false);
	}
	else if (srcplateno == 4) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(true);
		ShowShadowParamsWnd(false);
	}
	else if (srcplateno == 5) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(true);
	}
	else if (srcplateno == -2) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(false);
	}
	else {
		_ASSERT(0);
	}
}



void GUIRigidSetVisible(int srcplateno)
{
	if (srcplateno == 1) {
		ShowRigidWnd(true);
		ShowImpulseWnd(false);
		ShowGroundWnd(false);
		ShowDampAnimWnd(false);
	}
	else if (srcplateno == 2) {
		ShowRigidWnd(false);
		ShowImpulseWnd(true);
		ShowGroundWnd(false);
		ShowDampAnimWnd(false);
	}
	else if (srcplateno == 3) {
		ShowRigidWnd(false);
		ShowImpulseWnd(false);
		ShowGroundWnd(true);
		ShowDampAnimWnd(false);
	}
	else if (srcplateno == 4) {
		ShowRigidWnd(false);
		ShowImpulseWnd(false);
		ShowGroundWnd(false);
		ShowDampAnimWnd(true);
	}
	else if (srcplateno == -2) {
		ShowRigidWnd(false);
		ShowImpulseWnd(false);
		ShowGroundWnd(false);
		ShowDampAnimWnd(false);
	}
	else {
		_ASSERT(0);
	}
}



void GUISetVisible(int srcplateno)
{
	if (srcplateno == 1) {
		//srcplateno == 1 --> PlaceFolderWnd visible
	}
	else if (srcplateno == 2) {
		GUISetVisible_CameraAndIK();
	}
	else if (srcplateno == 3) {
		GUISetVisible_DispAndLimits();
	}
	else if (srcplateno == 4) {
		GUISetVisible_BrushParams();
	}
	else if (srcplateno == 5) {
		GUISetVisible_Bullet();
	}
	else if (srcplateno == 6) {
		GUISetVisible_LOD();
	}
	else {
		_ASSERT(0);
	}
}

void GUISetVisible_Sel3D()
{
	if (s_currentwndid == 1) {
		s_spsel3d.state = true;
	}
	else {
		s_spsel3d.state = false;
	}
}


// g_currentsubmenuid
void GUISetVisible_MenuAimBar()
{
	////static int s_curaimbarno
	//if ((g_currentsubmenuid >= 0) && (g_currentsubmenuid < SPMENU_MAX)) {
	//	int aimno;
	//	for (aimno = 0; aimno < SPMENU_MAX; aimno++) {
	//		s_spmenuaimbar[aimno].state = false;
	//	}

	//	s_spmenuaimbar[g_currentsubmenuid].state = true;

	//}
}

void GUISetVisible_AimBar()
{
	////static int s_curaimbarno
	//if ((s_curaimbarno >= 0) && (s_curaimbarno < SPAIMBARNUM)) {
	//	int aimno;
	//	for (aimno = 0; aimno < SPAIMBARNUM; aimno++) {
	//		s_spaimbar[aimno].state = false;
	//	}

	//	s_spaimbar[s_curaimbarno].state = true;

	//}
}

void GUISetVisible_CameraAndIK()
{

	//１段目のCameraAndIKだけは　SPGUISWの他のボタンと連動しないで　オンオフ

	bool newstate = !s_spguisw[SPGUISW_CAMERA_AND_IK].state;

	//選択プレートをオンにする
	s_spguisw[SPGUISW_CAMERA_AND_IK].state = newstate;

	//ShowGUIDlgDispParams(false);
	//ShowGUIDlgBrushes(false);
	//ShowGUIDlgBullet(false);
	//ShowGUIDlgLOD(false);

	//SPGUISWの他のものが全てOFFの場合　placefolderWndを表示
	if ((s_spguisw[SPGUISW_DISP_AND_LIMITS].state == false) &&
		(s_spguisw[SPGUISW_BRUSHPARAMS].state == false) &&
		(s_spguisw[SPGUISW_BULLETPHYSICS].state == false) &&
		(s_spguisw[SPGUISW_PROJ_AND_LOD].state == false)) {
		if (s_placefolderWnd) {
			s_placefolderWnd->setVisible(true);
		}
	}
}

void GUISetVisible_DispAndLimits()
{
	//CameraAndIK以外は　いったん全部オフにする
	int plateno;
	for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
		s_spguisw[plateno].state = false;
	}

	//選択プレートをオンにする
	s_spguisw[SPGUISW_DISP_AND_LIMITS].state = true;
	ShowGUIDlgDispParams(true);
	ShowGUIDlgBrushes(false);
	ShowGUIDlgBullet(false);
	ShowGUIDlgLOD(false);
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}
}
void GUISetVisible_BrushParams()
{
	//CameraAndIK以外は　いったん全部オフにする
	int plateno;
	for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
		s_spguisw[plateno].state = false;
	}

	//選択プレートをオンにする
	s_spguisw[SPGUISW_BRUSHPARAMS].state = true;
	ShowGUIDlgDispParams(false);
	ShowGUIDlgBrushes(true);
	ShowGUIDlgBullet(false);
	ShowGUIDlgLOD(false);
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}

}
void GUISetVisible_Bullet()
{
	//CameraAndIK以外は　いったん全部オフにする
	int plateno;
	for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
		s_spguisw[plateno].state = false;
	}

	//選択プレートをオンにする
	s_spguisw[SPGUISW_BULLETPHYSICS].state = true;
	ShowGUIDlgDispParams(false);
	ShowGUIDlgBrushes(false);
	ShowGUIDlgBullet(true);
	ShowGUIDlgLOD(false);
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}

}
void GUISetVisible_LOD()
{
	//CameraAndIK以外は　いったん全部オフにする
	int plateno;
	for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
		s_spguisw[plateno].state = false;
	}

	//選択プレートをオンにする
	s_spguisw[SPGUISW_PROJ_AND_LOD].state = true;
	ShowGUIDlgDispParams(false);
	ShowGUIDlgBrushes(false);
	ShowGUIDlgBullet(false);
	ShowGUIDlgLOD(true);
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}
}

void ShowRetargetWnd(bool srcflag)
{
	if (s_model && (s_curboneno >= 0)) {
		if (s_bpWorld) {
			if (srcflag == true) {
				//if (!s_convboneWnd) {
				CreateConvBoneWnd();
				//}
				if (s_convboneWnd) {
					s_convboneWnd->setListenMouse(true);
					s_convboneWnd->setVisible(true);
				}
				s_spretargetsw[SPRETARGETSW_RETARGET].state = true;
				s_dispconvbone = true;
			}
			else {
				if (s_convboneWnd) {
					s_convboneWnd->setListenMouse(false);
					s_convboneWnd->setVisible(false);
				}
				s_spretargetsw[SPRETARGETSW_RETARGET].state = false;
				s_dispconvbone = false;
			}
		}
	}
}

void ShowLimitEulerWnd(bool srcflag)
{
	if (s_model && (s_curboneno >= 0)) {
		if (s_bpWorld) {
			if (srcflag == true) {
				if (s_anglelimitdlg) {
					s_underanglelimithscroll = 0;
					DestroyWindow(s_anglelimitdlg);
					s_anglelimitdlg = 0;
				}

				DispAngleLimitDlg();

				s_spretargetsw[SPRETARGETSW_LIMITEULER].state = true;
			}
			else {
				if (s_anglelimitdlg) {
					s_underanglelimithscroll = 0;
					DestroyWindow(s_anglelimitdlg);
					s_anglelimitdlg = 0;
				}
				s_spretargetsw[SPRETARGETSW_LIMITEULER].state = false;
			}
		}
	}
}

void ShowGUIDlgDispParams(bool srcflag)
{
	if (s_guidlg[GUIDLG_DISP_AND_LIMITS] != 0) {
		if (srcflag == true) {
			ShowWindow(s_guidlg[GUIDLG_DISP_AND_LIMITS], SW_SHOW);
			UpdateWindow(s_guidlg[GUIDLG_DISP_AND_LIMITS]);
		}
		else {
			ShowWindow(s_guidlg[GUIDLG_DISP_AND_LIMITS], SW_HIDE);
			UpdateWindow(s_guidlg[GUIDLG_DISP_AND_LIMITS]);
		}
	}

	s_spguisw[SPGUISW_DISP_AND_LIMITS].state = srcflag;
}
void ShowGUIDlgBrushes(bool srcflag)
{
	if (s_guidlg[GUIDLG_BRUSHPARAMS] != 0) {
		if (srcflag == true) {
			ShowWindow(s_guidlg[GUIDLG_BRUSHPARAMS], SW_SHOW);
			UpdateWindow(s_guidlg[GUIDLG_BRUSHPARAMS]);
		}
		else {
			ShowWindow(s_guidlg[GUIDLG_BRUSHPARAMS], SW_HIDE);
			UpdateWindow(s_guidlg[GUIDLG_BRUSHPARAMS]);
		}
	}

	s_spguisw[SPGUISW_BRUSHPARAMS].state = srcflag;
}
void ShowGUIDlgBullet(bool srcflag)
{
	if (s_guidlg[GUIDLG_BULLETPHYSICS] != 0) {
		if (srcflag == true) {
			ShowWindow(s_guidlg[GUIDLG_BULLETPHYSICS], SW_SHOW);
			UpdateWindow(s_guidlg[GUIDLG_BULLETPHYSICS]);
		}
		else {
			ShowWindow(s_guidlg[GUIDLG_BULLETPHYSICS], SW_HIDE);
			UpdateWindow(s_guidlg[GUIDLG_BULLETPHYSICS]);
		}
	}

	s_spguisw[SPGUISW_BULLETPHYSICS].state = srcflag;
}
void ShowGUIDlgLOD(bool srcflag)
{
	if (s_guidlg[GUIDLG_PROJ_AND_LOD] != 0) {
		if (srcflag == true) {
			ShowWindow(s_guidlg[GUIDLG_PROJ_AND_LOD], SW_SHOW);
			LODParams2Dlg(s_guidlg[GUIDLG_PROJ_AND_LOD]);
			UpdateWindow(s_guidlg[GUIDLG_PROJ_AND_LOD]);
		}
		else {
			ShowWindow(s_guidlg[GUIDLG_PROJ_AND_LOD], SW_HIDE);
			UpdateWindow(s_guidlg[GUIDLG_PROJ_AND_LOD]);
		}
	}

	s_spguisw[SPGUISW_PROJ_AND_LOD].state = srcflag;
}



void ShowLightsWnd(bool srcflag)
{
	if (s_lightsforeditdlg != 0) {
		if (srcflag == true) {
			ShowWindow(s_lightsforeditdlg, SW_SHOW);
			UpdateWindow(s_lightsforeditdlg);
		}
		else {
			ShowWindow(s_lightsforeditdlg, SW_HIDE);
			UpdateWindow(s_lightsforeditdlg);
		}
	}

	s_spdispsw[SPDISPSW_LIGHTS].state = srcflag;
}

void ShowLaterTransparentWnd(bool srcflag)
{
	if (srcflag == true) {
		if (s_latertransparentdlg) {
			DestroyWindow(s_latertransparentdlg);
			s_latertransparentdlg = 0;
		}

		int result = CreateLaterTransparentWnd();
		if ((result == 0) && s_latertransparentdlg) {
			ShowWindow(s_latertransparentdlg, SW_SHOW);
			UpdateWindow(s_latertransparentdlg);
		}
	}
	else {
		if (s_latertransparentdlg) {
			DestroyWindow(s_latertransparentdlg);
			s_latertransparentdlg = 0;
		}
	}

	s_spdispsw[SPDISPSW_LATERTRANSPARENT].state = srcflag;
}


void ShowDispGroupWnd(bool srcflag)
{
	if (s_model) {
		//s_rigidWnd->setVisible(srcflag);

	}

	if (s_model) {

		s_spdispsw[SPDISPSW_DISPGROUP].state = srcflag;

		if (srcflag == true) {

			CreateDispGroupWnd();

			if (s_groupWnd) {
				s_groupWnd->setListenMouse(true);
				s_groupWnd->setVisible(true);
			}
		}
		else {
			if (s_groupWnd) {
				s_groupWnd->setListenMouse(false);
				s_groupWnd->setVisible(false);
			}
		}
	}

}


void ShowRigidWnd(bool srcflag)
{
	if (s_model && (s_curboneno >= 0)) {
		//if (s_model) {
		if (s_bpWorld) {
			s_model->SetCurrentRigidElem(s_reindexmap[s_model]);

			//CallF(s_model->CreateBtObject(0), return);
			CallF(s_model->CreateBtObject(g_limitdegflag, 1), return);


			//s_impWnd->setVisible(0);
			//s_gpWnd->setVisible(0);
			//s_dmpanimWnd->setVisible(0);

			//s_ikkind = 3;
			s_rigidWnd->setVisible(srcflag);
			SetRigidLeng();
			RigidElem2WndParam();

			s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].state = srcflag;
			//s_sprigidsw[1].state = false;
			//s_sprigidsw[2].state = false;
			//s_sprigidsw[3].state = false;
		}
	}
}


void ShowShaderTypeWnd(bool srcflag)
{
	//if (s_model) {
	//	s_shadertypeWnd->setVisible(srcflag);
	//	s_spdispsw[SPDISPSW_SHADERTYPE].state = srcflag;
	//}

	if (s_model) {
		if (srcflag == true) {
			//if (!s_convboneWnd) {
			CreateShaderTypeWnd();
			//}
			if (s_shadertypeWnd) {
				s_shadertypeWnd->setListenMouse(true);
				s_shadertypeWnd->setVisible(true);
			}
			s_spdispsw[SPDISPSW_SHADERTYPE].state = true;
		}
		else {
			if (s_shadertypeWnd) {
				s_shadertypeWnd->setListenMouse(false);
				s_shadertypeWnd->setVisible(false);
			}
			s_spdispsw[SPDISPSW_SHADERTYPE].state = false;


			//############################
			//2023/12/22 ParamsDlgも閉じる
			//############################
			if (s_shadertypeparamsdlgwnd) {
				ShowWindow(s_shadertypeparamsdlgwnd, SW_HIDE);
			}

			//2023/12/30 以下２行　ここで呼び出すと２回目にSW_SHOWしても表示されないことがあるので　コメントアウト
			// WindowProcを回す必要があるため
			//s_shadertypeparamsindex = -1;
			//s_shadertypeparamsFlag = false;
		}
	}

}

void ShowShadowParamsWnd(bool srcflag)
{
	if (srcflag == true) {
		if (s_shadowparamsdlg) {
			DestroyWindow(s_shadowparamsdlg);
			s_shadowparamsdlg = 0;
		}

		int result = CreateShadowParamsWnd();
		if ((result == 0) && s_shadowparamsdlg) {
			ShowWindow(s_shadowparamsdlg, SW_SHOW);
			UpdateWindow(s_shadowparamsdlg);
		}
	}
	else {
		if (s_shadowparamsdlg) {
			DestroyWindow(s_shadowparamsdlg);
			s_shadowparamsdlg = 0;
		}
	}

	s_spdispsw[SPDISPSW_SHADOWPARAMS].state = srcflag;
}


int ModalShaderTypeDlg()
{
	//IDD_MODALSHADERTYPEDLG


	return 0;
}


void ShowImpulseWnd(bool srcflag)
{
	//if (s_model && (s_curboneno >= 0)) {
	if (s_model) {
		if (s_bpWorld) {
			CallF(s_model->CreateBtObject(g_limitdegflag, 0), return);

			//s_rigidWnd->setVisible(0);
			//s_gpWnd->setVisible(0);
			//s_dmpanimWnd->setVisible(0);

			//s_ikkind = 4;
			s_impWnd->setVisible(srcflag);

			SetImpWndParams();
			s_impWnd->callRewrite();

			//s_sprigidsw[0].state = false;
			s_sprigidsw[SPRIGIDSW_IMPULSE].state = srcflag;
			//s_sprigidsw[2].state = false;
			//s_sprigidsw[3].state = false;

		}
	}
}
void ShowGroundWnd(bool srcflag)
{
	//if (s_model && (s_curboneno >= 0)) {
	if (s_model) {
		if (s_bpWorld) {
			CallF(s_model->CreateBtObject(g_limitdegflag, 0), return);

			//s_rigidWnd->setVisible(0);
			//s_impWnd->setVisible(0);
			//s_dmpanimWnd->setVisible(0);


			//s_ikkind = 5;
			s_gpWnd->setVisible(srcflag);

			SetGpWndParams();
			s_gpWnd->callRewrite();

			//s_sprigidsw[0].state = false;
			//s_sprigidsw[1].state = false;
			s_sprigidsw[SPRIGIDSW_GROUNDPLANE].state = srcflag;
			//s_sprigidsw[3].state = false;
		}
	}
}
void ShowDampAnimWnd(bool srcflag)
{
	//if (s_model && (s_curboneno >= 0)) {
	if (s_model) {
		if (s_bpWorld) {
			CallF(s_model->CreateBtObject(g_limitdegflag, 0), return);

			//s_rigidWnd->setVisible(0);
			//s_impWnd->setVisible(0);
			//s_gpWnd->setVisible(0);

			//s_ikkind = 6;
			s_dmpanimWnd->setVisible(srcflag);

			SetDmpWndParams();
			s_dmpanimWnd->callRewrite();

			//s_sprigidsw[0].state = false;
			//s_sprigidsw[1].state = false;
			//s_sprigidsw[2].state = false;
			s_sprigidsw[SPRIGIDSW_DAMPANIM].state = srcflag;
		}
	}
}

void GUIMenuSetVisible(int srcmenukind, int srcplateno)
{
	CloseAllRightPainWindow();

	if ((srcmenukind >= SPPLATEMENUKIND_DISP) && (srcmenukind <= SPPLATEMENUKIND_RETARGET)) {
		//#####################
		//プレートメニュー更新
		//#####################
		s_platemenukind = srcmenukind;


		if (s_guiswflag) {
			//１段目メニュー
			if ((s_guiswplateno > 1) && (s_guiswplateno < (SPGUISWNUM + 2))) {
				GUISetVisible(s_guiswplateno);//((spgno == 0) && (spgno < SPGUISWNUM))でGUISetVisible(spgno + 2)でGUISetVisible(1)はPlaceFolderWindow用
				SelectNextWindow(MB3D_WND_3D);
			}
			else {
				if (s_placefolderWnd) {
					s_placefolderWnd->setVisible(true);
				}
				SelectNextWindow(MB3D_WND_SIDE);
			}
		}
		else {
			//２段目プレートクリック時には　１段目のCameraAndIK以外の選択状態をオフにする
			int plateno;
			for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
				s_spguisw[plateno].state = false;
			}


			//###########################
			//新しいプレートメニュー表示
			//###########################
			switch (s_platemenukind) {
				//case SPPLATEMENUKIND_GUI:
				//	if ((srcplateno >= 1) && (srcplateno < (SPGUISWNUM + 2))) {
				//		GUISetVisible(srcplateno);//((spgno == 0) && (spgno < SPGUISWNUM))でGUISetVisible(spgno + 2)でGUISetVisible(1)はPlaceFolderWindow用
				//		if (s_placefolderWnd) {
				//			s_placefolderWnd->setVisible(true);
				//		}
				//		SelectNextWindow(MB3D_WND_3D);
				//	}
				//	else {
				//		if (s_placefolderWnd) {
				//			s_placefolderWnd->setVisible(true);
				//		}
				//		SelectNextWindow(MB3D_WND_SIDE);
				//	}
				//	break;
			case SPPLATEMENUKIND_DISP:
				if ((srcplateno >= 1) && (srcplateno <= SPDISPSWNUM)) {
					if (s_customrigdlg) {
						DestroyWindow(s_customrigdlg);
						s_customrigdlg = 0;
					}
					if (s_placefolderWnd) {
						s_placefolderWnd->setVisible(false);
					}
					GUIDispSetVisible(srcplateno);
					SelectNextWindow(MB3D_WND_SIDE);
				}
				else {
					_ASSERT(0);
				}
				break;
			case SPPLATEMENUKIND_RIGID:
				if ((srcplateno >= 1) && (srcplateno <= SPRIGIDSWNUM)) {
					if (s_customrigdlg) {
						DestroyWindow(s_customrigdlg);
						s_customrigdlg = 0;
					}
					if (s_placefolderWnd) {
						s_placefolderWnd->setVisible(false);
					}
					GUIRigidSetVisible(srcplateno);
					SelectNextWindow(MB3D_WND_SIDE);
				}
				else {
					_ASSERT(0);
				}
				break;
			case SPPLATEMENUKIND_RETARGET:
				if ((srcplateno >= 1) && (srcplateno <= SPRETARGETSWNUM)) {
					if (s_customrigdlg) {
						DestroyWindow(s_customrigdlg);
						s_customrigdlg = 0;
					}
					if (s_placefolderWnd) {
						s_placefolderWnd->setVisible(false);
					}
					GUIRetargetSetVisible(srcplateno);
					SelectNextWindow(MB3D_WND_SIDE);
				}
				break;
			default:
				break;
			}
		}
	}

}

void ChangeToNextPlateMenuKind(int srcmenukind, int srcmenuno)
{
	//###############################################################
	//カエルボタンが押された場合　または　スペースキーが押された場合
	//###############################################################

	if (!s_model) {
		return;
	}


	int nextmenukind = -1;
	int nextplateno = 0;

	if ((srcmenukind >= 0) && (srcmenukind < SPPLATEMENUKINDNUM)) {
		//if (srcmenukind == SPPLATEMENUKIND_GUI) {
		//	nextmenukind = SPPLATEMENUKIND_DISP;
		//	nextplateno = 1;//最初のプレート
		//}
		//else 
		if (srcmenukind == SPPLATEMENUKIND_DISP) {
			nextmenukind = SPPLATEMENUKIND_RIGID;
			nextplateno = 1;//最初のプレート
		}
		else if (srcmenukind == SPPLATEMENUKIND_RIGID) {
			nextmenukind = SPPLATEMENUKIND_RETARGET;
			nextplateno = 1;//最初のプレート
		}
		else if (srcmenukind == SPPLATEMENUKIND_RETARGET) {
			//nextmenukind = SPPLATEMENUKIND_GUI;
			nextmenukind = SPPLATEMENUKIND_DISP;
			nextplateno = 1;//最初のプレート
		}
	}
	else {
		_ASSERT(0);
	}

	if ((nextmenukind >= 0) && (nextplateno != 0)) {
		s_platemenukind = nextmenukind;
		s_platemenuno = nextplateno;
		GUIMenuSetVisible(s_platemenukind, nextplateno);
	}

}

void ChangeToNextPlateMenuPlate(int srcmenukind, int srcmenuno)
{
	//Cキーを押し続けながらスペースキーが押された場合

	if (!s_model) {
		return;
	}





	//########################################################
	//nextplateno は　実際の値に+1したもの(最初のプレートは1)
	//########################################################
	int nextmenukind = -1;
	int nextplateno = 0;

	int currentkind = srcmenukind;
	int currentplate = srcmenuno;


	if ((currentkind >= 0) && (currentkind < SPPLATEMENUKINDNUM)) {
		//if (currentkind == SPPLATEMENUKIND_GUI) {
		//	nextmenukind = SPPLATEMENUKIND_GUI;
		//	nextplateno = currentplate + 1;//次のプレート
		//	if (nextplateno > (SPGUISWNUM + 1)) {//このkindだけplate == 1でplacefolderwnd表示するので１大きいところまで可
		//		nextplateno = 2;//最初のプレート
		//	}
		//}
		//else 
		if (currentkind == SPPLATEMENUKIND_DISP) {
			nextmenukind = SPPLATEMENUKIND_DISP;
			nextplateno = currentplate + 1;//次のプレート
			if (nextplateno > SPDISPSWNUM) {
				nextplateno = 1;//最初のプレート
			}
		}
		else if (currentkind == SPPLATEMENUKIND_RIGID) {
			nextmenukind = SPPLATEMENUKIND_RIGID;
			nextplateno = currentplate + 1;//次のプレート
			if (nextplateno > SPRIGIDSWNUM) {
				nextplateno = 1;//最初のプレート
			}
		}
		else if (currentkind == SPPLATEMENUKIND_RETARGET) {
			nextmenukind = SPPLATEMENUKIND_RETARGET;
			nextplateno = currentplate + 1;//次のプレート
			if (nextplateno > SPRETARGETSWNUM) {
				nextplateno = 1;//最初のプレート
			}
		}
	}
	else {
		_ASSERT(0);
	}

	if ((nextmenukind >= 0) && (nextplateno != 0)) {
		s_platemenukind = nextmenukind;
		s_platemenuno = nextplateno;
		GUIMenuSetVisible(s_platemenukind, nextplateno);
	}



}


void GUIGetNextMenu(POINT ptCursor, int srcmenukind, int* dstmenukind, int* dstplateno)
{
	if ((srcmenukind >= 0) && (srcmenukind < SPPLATEMENUKINDNUM)) {

		int nextmenukind = srcmenukind;
		int nextplateno = 1;

		//int spckind = 0;
		int pickguiplateno = 0;
		int pickdispplateno = 0;
		int pickrigidplateno = 0;
		int pickretargetplateno = 0;
		bool pickflag = false;
	
		//if (srcmenukind == SPPLATEMENUKIND_GUI) {
		// 
		//１段目は常時表示　常時クリック可能
		pickguiplateno = PickSpGUISW(ptCursor);//カエルボタンを押したときは -2, (SPGUISW_* + 2)が返る
		if (pickguiplateno >= 2) {
			s_guiswflag = true;
			s_guiswplateno = pickguiplateno;

			//２段目は前状態のまま
			*dstmenukind = s_platemenukind;
			*dstplateno = s_platemenuno;
		}
		else {
			if (srcmenukind == SPPLATEMENUKIND_DISP) {
				pickdispplateno = PickSpDispSW(ptCursor);//カエルボタンを押したときは -2
				if (pickdispplateno == -2) {
					nextmenukind = SPPLATEMENUKIND_RIGID;
					nextplateno = 1;//最初のプレート
					pickflag = true;
				}
				else if (pickdispplateno != 0) {
					nextmenukind = srcmenukind;
					nextplateno = pickdispplateno;
					pickflag = true;
				}
				else {
					nextmenukind = -1;
					nextplateno = 1;
				}
			}
			else if (srcmenukind == SPPLATEMENUKIND_RIGID) {
				pickrigidplateno = PickSpRigidSW(ptCursor);//カエルボタンを押したときは -2
				if (pickrigidplateno == -2) {
					nextmenukind = SPPLATEMENUKIND_RETARGET;
					nextplateno = 1;//最初のプレート
					pickflag = true;
				}
				else if (pickrigidplateno != 0) {
					nextmenukind = srcmenukind;
					nextplateno = pickrigidplateno;
					pickflag = true;
				}
				else {
					nextmenukind = -1;
					nextplateno = 1;
				}
			}
			else if (srcmenukind == SPPLATEMENUKIND_RETARGET) {
				pickretargetplateno = PickSpRetargetSW(ptCursor);//カエルボタンを押したときは -2
				if (pickretargetplateno == -2) {
					//nextmenukind = SPPLATEMENUKIND_GUI;
					nextmenukind = SPPLATEMENUKIND_DISP;
					nextplateno = 1;//最初のプレート
					pickflag = true;
				}
				else if (pickretargetplateno != 0) {
					nextmenukind = srcmenukind;
					nextplateno = pickretargetplateno;
					pickflag = true;
				}
				else {
					nextmenukind = -1;
					nextplateno = 1;
				}
			}

			*dstmenukind = nextmenukind;
			*dstplateno = nextplateno;

			if (pickflag == true) {
				s_guiswflag = false;
				//s_guiswplateno = 1;

				//２段目プレートクリック時には　１段目のCameraAndIK以外の選択状態をオフにする
				int plateno;
				for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
					s_spguisw[plateno].state = false;
				}
			}
		}
		
	}
	else {
		_ASSERT(0);
		*dstmenukind = -1;
		*dstplateno = 1;
	}


}

void InitDSValues()
{
	//static int s_currentwndid = 0;
	//static HWND s_currenthwnd = 0;
	//static int s_currentctrlid = -1;
	//static HWND s_currentctrlhwnd = 0;

	//static int s_dsbuttondown[MB3D_DSBUTTONNUM];
	//static int s_bef_dsbuttondown[MB3D_DSBUTTONNUM];
	//static int s_dsbuttonup[MB3D_DSBUTTONNUM];
	//static int s_bef_dsbuttonup[MB3D_DSBUTTONNUM];
	//static float s_dsaxisvalue[MB3D_DSAXISNUM];
	//static float s_bef_dsaxisvalue[MB3D_DSAXISNUM];
	//static int s_dsaxisOverSrh[MB3D_DSAXISNUM];
	//static int s_bef_dsaxisOverSrh[MB3D_DSAXISNUM];
	//static int s_dsaxisMOverSrh[MB3D_DSAXISNUM];
	//static int s_bef_dsaxisMOverSrh[MB3D_DSAXISNUM];

	g_enableDS = false;
	s_dsdeviceid = -1;
	s_curaimbarno = -1;

	s_wmlbuttonup = 0;
	s_dspushedOK = 0;
	s_dspushedL3 = 0;
	s_dspushedR3 = 0;
	g_dsmousewait = 0;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	s_firstmoveaimbar = true;

	s_mqodlghwnd = 0;
	s_underframecopydlg = false;
	s_pcolidlg = 0;
	s_undercolidlg = false;
	s_pgcolidlg = 0;
	s_undergcolidlg = false;
	s_motpropdlghwnd = 0;
	//s_cameradollydlgwnd = 0;
	s_savechadlghwnd = 0;
	s_bvhdlghwnd = 0;
	s_saveredlghwnd = 0;
	s_saveimpdlghwnd = 0;
	s_savegcodlghwnd = 0;
	s_rotzisdlghwnd = 0;
	s_customrighwnd = 0;
	s_exportxdlghwnd = 0;

	s_enumdist.clear();


	s_currentwndid = 0;
	s_currenthwnd = 0;
	s_restorewndid = 0;
	s_restorehwnd = 0;
	s_currentctrlid = -1;
	s_currentctrlhwnd = 0;
	s_wmlbuttonup = 0;
	s_restorecursorpos.x = 0;
	s_restorecursorpos.y = 0;

	s_ofhwnd = 0;
	s_messageboxhwnd = 0;
	s_messageboxpushcnt = 0;
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;

	s_curdsutguikind = 0;
	s_curdsutguino = 0;
	//s_dsutgui0.clear();
	//s_dsutgui1.clear();
	//s_dsutgui2.clear();
	//s_dsutgui3.clear();
	//s_dsutguiid0.clear();
	//s_dsutguiid1.clear();
	//s_dsutguiid2.clear();
	//s_dsutguiid3.clear();

	s_curdstoolctrlno = 0;
	s_dstoolctrls.clear();

	s_curdsplayerbtnno = 0;

	s_curdsrigidctrlno = 0;
	s_dsrigidctrls.clear();

	s_curdsimpulsectrlno = 0;
	s_dsimpulsectrls.clear();

	s_curdsgpctrlno = 0;
	s_dsgpctrls.clear();

	s_curdsdampctrlno = 0;
	s_dsdampctrls.clear();

	s_curdsretargetctrlno = 0;
	s_dsretargetctrls.clear();;

	s_curdseullimitctrlno = 0;
	s_dseullimitctrls.clear();

	g_currentsubmenuid = 0;
	s_currentsubmenuitemid = 0;

	ZeroMemory(s_dsbuttondown, sizeof(int) * MB3D_DSBUTTONNUM);
	ZeroMemory(s_bef_dsbuttondown, sizeof(int) * MB3D_DSBUTTONNUM);
	ZeroMemory(s_dsbuttonup, sizeof(int) * MB3D_DSBUTTONNUM);
	ZeroMemory(s_bef_dsbuttonup, sizeof(int) * MB3D_DSBUTTONNUM);

	ZeroMemory(s_dsaxisvalue, sizeof(float) * MB3D_DSAXISNUM);
	ZeroMemory(s_bef_dsaxisvalue, sizeof(float) * MB3D_DSAXISNUM);

	ZeroMemory(s_dsaxisOverSrh, sizeof(int) * MB3D_DSAXISNUM);
	ZeroMemory(s_bef_dsaxisOverSrh, sizeof(int) * MB3D_DSAXISNUM);
	ZeroMemory(s_dsaxisMOverSrh, sizeof(int) * MB3D_DSAXISNUM);
	ZeroMemory(s_bef_dsaxisMOverSrh, sizeof(int) * MB3D_DSAXISNUM);


}
void OnDSUpdate()
{

	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合にはDS関数でキーボードの矢印キーに対応

		OnArrowKey();

		return;
	}


	//GetDSValues();

	//ChangeMouseSetCapture();//処理前にキャプチャーをセット



	//DSColorAndVibration();

	//DSSelectWindowAndCtrl();//L1, square, triangle
	//DSSelectCharactor();//(L2 or R2) and L1

	//bool firstctrlselect = false;
	//DSCrossButton(firstctrlselect);


	////R1ボタン：３Dウインドウ選択、カレントボーン位置へマウスジャンプ
	//DSR1ButtonSelectCurrentBone();
	//DSR1ButtonSelectMotion();

	////L3, R3ボタンでマウス位置アピール
	//DSL3R3ButtonMouseHere();


	//if (g_undertrackingRMenu == 0) {
	//	//OK button popupmenuを出していないとき
	//	DSAimBarOK();

	//	//optionボタンは右クリック相当
	//	DSOptionButtonRightClick();
	//}
	//else if (g_undertrackingRMenu == 1) {
	//	//OK button popupmenuを出しているとき
	//	DSOButtonSelectedPopupMenu();
	//}

	////Cancel button : メニューのドロップダウンをキャンセルする　Cancel dropdown menu. L2 + X --> Undo, R2 + X --> Redo.
	//DSXButtonCancel();

	////Axis L Mouse Move
	//DSAxisLMouseMove();

	////Axis R MenuBar of MainWindow
	//DSAxisRMainMenuBar();


	//ChangeMouseReleaseCapture();//処理が終わってからキャプチャーを外す

	//OutputToInfoWnd(L"\n\n");
	//OutputToInfoWnd(L"Axis 0 : %1.4f\n", axisval0);
	//OutputToInfoWnd(L"Axis 1 : %1.4f\n", axisval1);
	//OutputToInfoWnd(L"Axis 2 : %1.4f\n", axisval2);
	//OutputToInfoWnd(L"Axis 3 : %1.4f\n", axisval3);
	//OutputToInfoWnd(L"Axis 4 : %1.4f\n", axisval4);
	//OutputToInfoWnd(L"Axis 5 : %1.4f\n", axisval5);

	//ChangeColor(int id, const UCHAR r, const UCHAR g, const UCHAR b);

}

void GetDSValues()
{
	//static int s_dsbuttondown[MB3D_DSBUTTONNUM];
	//static int s_bef_dsbuttondown[MB3D_DSBUTTONNUM];
	//static int s_dsbuttonup[MB3D_DSBUTTONNUM];
	//static int s_bef_dsbuttonup[MB3D_DSBUTTONNUM];
	//static float s_dsaxisvalue[MB3D_DSAXISNUM];
	//static float s_bef_dsaxisvalue[MB3D_DSAXISNUM];
	//static int s_dsaxisOverSrh[MB3D_DSAXISNUM];
	//static int s_bef_dsaxisOverSrh[MB3D_DSAXISNUM];
	//static int s_dsaxisMOverSrh[MB3D_DSAXISNUM];
	//static int s_bef_dsaxisMOverSrh[MB3D_DSAXISNUM];


	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合には何もせずにリターン
		return;
	}

	//UpdateInputReport();
	//SendOutput(0);

	////bool GetButtonDown(int id, UCHAR key);
	////bool GetButtonUp(int id, UCHAR key);

	//int buttonno;
	//for (buttonno = 0; buttonno < MB3D_DSBUTTONNUM; buttonno++) {
	//	s_bef_dsbuttondown[buttonno] = s_dsbuttondown[buttonno];
	//	s_bef_dsbuttonup[buttonno] = s_dsbuttonup[buttonno];

	//	if (GetButtonDown(s_dsdeviceid, buttonno)) {
	//		s_dsbuttondown[buttonno] = GetButtonDown(s_dsdeviceid, buttonno);
	//	}
	//	else {
	//		s_dsbuttondown[buttonno] = 0;
	//	}

	//	if (GetButtonUp(s_dsdeviceid, buttonno)) {
	//		s_dsbuttonup[buttonno] = GetButtonUp(s_dsdeviceid, buttonno);
	//	}
	//	else {
	//		s_dsbuttonup[buttonno] = 0;
	//	}

	//}

	//int axisno;
	//for (axisno = 0; axisno < MB3D_DSAXISNUM; axisno++) {

	//	////for debug
	//	//{
	//	//	if (s_dsbuttonup[4] >= 1) {
	//	//		_ASSERT(0);
	//	//	}
	//	//}


	//	s_bef_dsaxisvalue[axisno] = s_dsaxisvalue[axisno];
	//	s_bef_dsaxisOverSrh[axisno] = s_dsaxisOverSrh[axisno];
	//	s_bef_dsaxisMOverSrh[axisno] = s_dsaxisMOverSrh[axisno];

	//	s_dsaxisvalue[axisno] = GetAxis(s_dsdeviceid, axisno);

	//	s_dsaxisOverSrh[axisno] = (int)(s_dsaxisvalue[axisno] >= MB3D_DSAXISSRH);
	//	s_dsaxisMOverSrh[axisno] = (int)(s_dsaxisvalue[axisno] <= -(MB3D_DSAXISSRH));
	//}


	//if (s_dsbuttondown[2] >= 1) {
	//	s_dspushedOK = 1;
	//}
	//if (s_dsbuttonup[2] >= 1) {
	//	s_dspushedOK = 0;
	//}


	//if (s_dsbuttondown[12] >= 1) {
	//	s_dspushedL3 = 1;
	//}
	//if (s_dsbuttonup[12] >= 1) {
	//	s_dspushedL3 = 0;
	//}
	//if (s_dsbuttondown[13] >= 1) {
	//	s_dspushedR3 = 1;
	//}
	//if (s_dsbuttonup[13] >= 1) {
	//	s_dspushedR3 = 0;
	//}



}

void DSColorAndVibration()
{
	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合には何もせずにリターン
		return;
	}


	//int buttonno;
	////for (buttonno = 0; buttonno < MB3D_DSBUTTONNUM - 2; buttonno++) {//L3, R3は別処理！！！！！
	//for (buttonno = 0; buttonno < MB3D_DSBUTTONNUM; buttonno++) {//L3, R3は別処理！！！！！
	//	int curbuttondown = s_dsbuttondown[buttonno];
	//	int curbuttonup = s_dsbuttonup[buttonno];

	//	if (curbuttondown >= 1) {
	//		ChangeColor(s_dsdeviceid, 255, 0, 0);
	//		//ChangeVibration(s_dsdeviceid, 200, 200);
	//		//OutputToInfoWnd(L"Button Down %d", buttonno);
	//	}
	//	else if (curbuttonup >= 1) {
	//		ChangeColor(s_dsdeviceid, 0, 0, 255);
	//		//ChangeVibration(s_dsdeviceid, 0, 0);
	//		//OutputToInfoWnd(L"Button Up %d", buttonno);
	//	}
	//}

	//bool existon = false;
	//static bool s_bef_existon = false;


	//int axisno;
	//for (axisno = 0; axisno < MB3D_DSAXISNUM; axisno++) {
	//	bool curbuttondown = ((bool)s_dsaxisOverSrh[axisno] || (bool)s_dsaxisMOverSrh[axisno]);
	//	if (curbuttondown) {
	//		existon = true;
	//		break;
	//	}
	//}
	//if (existon) {
	//	ChangeColor(s_dsdeviceid, 255, 0, 0);
	//	//ChangeVibration(s_dsdeviceid, 200, 200);
	//	//OutputToInfoWnd(L"Axis On %d", axisno);
	//}
	//else if ((existon == false) && (s_bef_existon == true)) {
	//	ChangeColor(s_dsdeviceid, 0, 0, 255);
	//	//ChangeVibration(s_dsdeviceid, 0, 0);
	//	//OutputToInfoWnd(L"Axis Off %d", axisno);
	//}

	//s_bef_existon = existon;

}

void DSR1ButtonSelectMotion()
{
	//R1ボタン：３Dウインドウ選択、カレントボーン位置へマウスジャンプ
	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合には何もせずにリターン
		return;
	}

	if (!s_model) {
		//モデル読み込み前は処理しないでリターン
		return;
	}

	if (!s_3dwnd) {
		return;
	}


	//int buttonR1 = 9;
	//int curbuttondown = s_dsbuttondown[buttonR1];
	//int curbuttonup = s_dsbuttonup[buttonR1];

	//int accelaxisid1 = 4;//axisid
	//int accelaxisid2 = 5;//axisid
	//bool accelaxis1 = 0;
	//bool accelaxis2 = 0;
	//bool accelflag = false;
	//bool accelbothflag = false;
	//accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));
	//accelflag = accelaxis1 || accelaxis2;
	//accelbothflag = accelaxis1 && accelaxis2;

	//if ((accelflag != 0) && (curbuttonup >= 1)) {//アクセル有り
	//	int cAnimSets = (int)s_tlarray.size();
	//	int nextmotionindex;
	//	nextmotionindex = s_motmenuindexmap[s_model] + 1;

	//	if (nextmotionindex < 0) {
	//		nextmotionindex = cAnimSets - 1;
	//	}
	//	else if (nextmotionindex >= cAnimSets) {
	//		nextmotionindex = 0;
	//	}

	//	OnAnimMenu(true, nextmotionindex);
	//}

}


void DSR1ButtonSelectCurrentBone()
{
	//R1ボタン：３Dウインドウ選択、カレントボーン位置へマウスジャンプ
	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合には何もせずにリターン
		return;
	}

	if (!s_model) {
		//モデル読み込み前は処理しないでリターン
		return;
	}

	if (!s_3dwnd) {
		return;
	}

	////###################################################
	////R1ボタンを押して、jointとprev_selected_windowを往復する
	////###################################################

	//int buttonR1 = 9;
	//int curbuttondown = s_dsbuttondown[buttonR1];
	//int curbuttonup = s_dsbuttonup[buttonR1];

	//int accelaxisid1 = 4;//axisid
	//int accelaxisid2 = 5;//axisid
	//bool accelaxis1 = 0;
	//bool accelaxis2 = 0;
	//bool accelflag = false;
	//bool accelbothflag = false;
	//accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));
	//accelflag = accelaxis1 || accelaxis2;
	//accelbothflag = accelaxis1 && accelaxis2;

	//if ((accelflag == 0) && (curbuttonup >= 1)) {//アクセル無し

	//	::SetWindowPos(s_3dwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

	//	if (s_mainmenuaimbarWnd) {
	//		s_mainmenuaimbarWnd->setBackGroundColor(false);
	//	}

	//	if (s_timelineWnd) {
	//		s_timelineWnd->setBackGroundColor(false);
	//	}
	//	if (s_toolWnd) {
	//		s_toolWnd->setBackGroundColor(false);
	//	}
	//	if (s_LtimelineWnd) {
	//		s_LtimelineWnd->setBackGroundColor(false);
	//	}
	//	if (s_sidemenuWnd) {
	//		s_sidemenuWnd->setBackGroundColor(false);
	//	}


	//	if ((s_restorewndid <= 0) || !s_restorehwnd) {
	//		if (s_model && (s_curboneno >= 0)) {
	//			CBone* boneptr = s_model->GetBoneByID(s_curboneno);
	//			if (boneptr) {
	//				ChaVector3 jointpos;
	//				jointpos = s_selectmat.GetTranslation();

	//				ChaMatrix bcmat;
	//				bcmat = boneptr->GetCurMp().GetWorldMat();
	//				ChaMatrix transmat = bcmat * s_matVP;
	//				ChaVector3 scpos;
	//				ChaVector3 firstpos = boneptr->GetJointFPos();
	//				ChaVector3TransformCoord(&scpos, &firstpos, &transmat);
	//				scpos.z = 0.0f;
	//				POINT mousepos = { 0, 0 };
	//				mousepos.x = (LONG)((scpos.x + 1.0f) * 0.5f * s_mainwidth);
	//				mousepos.y = (LONG)((-scpos.y + 1.0f) * 0.5f * s_mainheight);

	//				s_restorewndid = s_currentwndid;
	//				s_restorehwnd = s_currenthwnd;
	//				::GetCursorPos(&s_restorecursorpos);
	//				s_currentwndid = MB3D_WND_3D;
	//				s_currenthwnd = s_3dwnd;

	//				GUISetVisible_Sel3D();//3DWindowを選択しているかどうかのマークを右上隅に表示

	//				::ClientToScreen(s_3dwnd, &mousepos);
	//				::SetCursorPos(mousepos.x, mousepos.y);

	//			}
	//		}
	//	}
	//	else {
	//		int nextwndid;
	//		nextwndid = s_restorewndid;

	//		SelectNextWindow(nextwndid);

	//		::SetCursorPos(s_restorecursorpos.x, s_restorecursorpos.y);

	//		//!!!!!!!!!!!!!!!!!!!!!!!!!!
	//		s_restorewndid = 0;
	//		s_restorehwnd = 0;
	//	}
	//}
}


void SelectNextWindow(int nextwndid)
{
	HWND tmptlwnd = 0;
	if (s_timelineWnd) {
		tmptlwnd = s_timelineWnd->getHWnd();
	}
	else {
		tmptlwnd = 0;
	}
	HWND tmptoolwnd = 0;
	if (s_toolWnd) {
		tmptoolwnd = s_toolWnd->getHWnd();
	}
	else {
		tmptoolwnd = 0;
	}
	HWND tmplongtlwnd = 0;
	if (s_LtimelineWnd) {
		tmplongtlwnd = s_LtimelineWnd->getHWnd();
	}
	else {
		tmplongtlwnd = 0;
	}
	HWND tmpsidewnd = 0;
	if (s_sidemenuWnd) {
		tmpsidewnd = s_sidemenuWnd->getHWnd();
	}
	else {
		tmpsidewnd = 0;
	}
	HWND tmpmainmenuaimbarwnd = 0;
	if (s_mainmenuaimbarWnd) {
		tmpmainmenuaimbarwnd = s_mainmenuaimbarWnd->getHWnd();
	}
	else {
		tmpmainmenuaimbarwnd = 0;
	}


	HWND hwnds[MB3D_WND_MAX];
	ZeroMemory(hwnds, sizeof(HWND) * MB3D_WND_MAX);
	//hwnds[MB3D_WND_MAIN] = g_mainhwnd;
	hwnds[MB3D_WND_MAIN] = tmpmainmenuaimbarwnd;
	hwnds[MB3D_WND_3D] = s_3dwnd;
	hwnds[MB3D_WND_TREE] = tmptlwnd;
	hwnds[MB3D_WND_TOOL] = tmptoolwnd;
	hwnds[MB3D_WND_TIMELINE] = tmplongtlwnd;
	hwnds[MB3D_WND_SIDE] = tmpsidewnd;

	int dbgcnt = 0;
	HWND nexthwnd = 0;
	nexthwnd = hwnds[nextwndid];
	//while (nexthwnd == 0) {
	//	nextwndid++;
	//	if (nextwndid >= MB3D_WND_MAX) {
	//		nextwndid = 0;
	//	}
	//	dbgcnt++;
	//	if (dbgcnt >= MB3D_WND_MAX) {
	//		nextwndid = 0;
	//		break;
	//	}
	//	nexthwnd = hwnds[nextwndid];
	//}

	if ((nextwndid >= 0) && (nextwndid < MB3D_WND_MAX) && nexthwnd) {

		BYTE selectR = 255;
		BYTE selectG = 128;
		BYTE selectB = 64;

		BYTE unselectR = 70;
		BYTE unselectG = 50;
		BYTE unselectB = 70;

		HBRUSH selectbrush = CreateSolidBrush(RGB(selectR, selectG, selectB));
		HBRUSH unselectbrush = CreateSolidBrush(RGB(unselectR, unselectG, unselectB));

		::SetFocus(nexthwnd);

		if (nextwndid == MB3D_WND_MAIN) {
			//:: SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)selectbrush);
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			//SetThemeAppProperties(STAP_ALLOW_NONCLIENT | STAP_ALLOW_CONTROLS | STAP_ALLOW_WEBCONTENT);//STAP_ALLOW_WEBCONTENT
			//SendMessage(hwnds[0], WM_THEMECHANGED, 0, 0);
			//RedrawWindow(hwnds[0], 0, 0, RDW_UPDATENOW);


			//::SetWindowPos(hwnds[0], HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			::SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			if (s_mainmenuaimbarWnd) {
				s_mainmenuaimbarWnd->setBackGroundColor(true);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_3D) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)selectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			//SetThemeAppProperties(STAP_ALLOW_NONCLIENT | STAP_ALLOW_CONTROLS | STAP_ALLOW_WEBCONTENT);//STAP_ALLOW_WEBCONTENT
			//SendMessage(hwnds[1], WM_THEMECHANGED, 0, 0);
			//RedrawWindow(hwnds[1], 0, 0, RDW_UPDATENOW);

			::SetWindowPos(hwnds[1], HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

			if (s_mainmenuaimbarWnd) {
				s_mainmenuaimbarWnd->setBackGroundColor(false);
			}


			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_TREE) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			if (s_mainmenuaimbarWnd) {
				s_mainmenuaimbarWnd->setBackGroundColor(false);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(true);
				::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_TOOL) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			if (s_mainmenuaimbarWnd) {
				s_mainmenuaimbarWnd->setBackGroundColor(false);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(true);
				::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_TIMELINE) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			if (s_mainmenuaimbarWnd) {
				s_mainmenuaimbarWnd->setBackGroundColor(false);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(true);
				::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_SIDE) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			if (s_mainmenuaimbarWnd) {
				s_mainmenuaimbarWnd->setBackGroundColor(false);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(true);
				::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			}
		}
		else {
			_ASSERT(0);
		}




		DeleteObject(selectbrush);
		DeleteObject(unselectbrush);


		//if (s_befactivehwnd) {
		//	ReleaseCapture();
		//}
		//SetCapture(nexthwnd);

		//SetForegroundWindow(nexthwnd);

		//if (s_befactivehwnd) {
		//	ReleaseCapture();
		//}
		//::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
		//HWND befactive;
		//befactive = ::SetActiveWindow(nexthwnd);
		//SetCapture(nexthwnd);


		//SetCaptureWindow !!!!!!!!!!!!!!!!!

		s_currentwndid = nextwndid;
		if ((s_currentwndid >= 0) && (s_currentwndid < MB3D_WND_MAX)) {
			s_currenthwnd = hwnds[s_currentwndid];
		}

		bool firstctrlselect = true;
		DSCrossButton(firstctrlselect);

		GUISetVisible_Sel3D();//3DWindowを選択しているかどうかのマークを右上隅に表示

	}
	//OutputToInfoWnd(L"Button Down %d", buttonL1);
}

void DSSelectCharactor()
{
	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合には何もせずにリターン
		return;
	}

	if (!s_model || !s_chascene) {
		//モデル読み込み前は処理しないでリターン
		return;
	}

	if (!s_3dwnd) {
		return;
	}

	int buttonL1 = 8;
	int curbuttondown = s_dsbuttondown[buttonL1];
	int curbuttonup = s_dsbuttonup[buttonL1];


	int accelaxisid1 = 4;//axisid
	int accelaxisid2 = 5;//axisid
	bool accelaxis1 = 0;
	bool accelaxis2 = 0;
	bool accelflag = false;
	bool accelbothflag = false;
	accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));
	accelflag = accelaxis1 || accelaxis2;
	accelbothflag = accelaxis1 && accelaxis2;

	//L1 Button Up（L2, R2 not pushed）
	if ((accelflag != 0) && (curbuttonup >= 1)) {
		int modelnum = s_chascene->GetModelNum();
		if (modelnum > 0) {
			int nextmodelindex;
			nextmodelindex = s_curmodelmenuindex + 1;
			if (nextmodelindex < 0) {
				nextmodelindex = modelnum - 1;
			}
			else if (nextmodelindex >= modelnum) {
				nextmodelindex = 0;
			}

			s_modelpanel.modelindex = nextmodelindex;
			OnModelMenu(true, s_modelpanel.modelindex, 1);
			s_modelpanel.panel->callRewrite();

		}
	}
}

void DSSelectWindowAndCtrl()
{

	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合には何もせずにリターン
		return;
	}

	if (!s_model) {
		//モデル読み込み前は処理しないでリターン
		return;
	}

	if (!s_3dwnd) {
		return;
	}

	//static HWND s_befactivehwnd = 0;


	bool doneflag = false;

	//ウインドウ選択ブロック
	{
		//static int s_currentwndid = 0;
		//s_currentwndid = 0;
		//s_currenthwnd = 0;
		//s_currentctrlid = 0;
		//s_currentctrlhwnd = 0;

		int buttonL1 = 8;
		int curbuttondown = s_dsbuttondown[buttonL1];
		int curbuttonup = s_dsbuttonup[buttonL1];


		int accelaxisid1 = 4;//axisid
		int accelaxisid2 = 5;//axisid
		bool accelaxis1 = 0;
		bool accelaxis2 = 0;
		bool accelflag = false;
		bool accelbothflag = false;
		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));
		accelflag = accelaxis1 || accelaxis2;
		accelbothflag = accelaxis1 && accelaxis2;

		//L1 Button Up（L2, R2 not pushed）
		if ((accelflag == 0) && (curbuttonup >= 1)) {
			int nextwndid = 0;
			nextwndid = s_currentwndid + 1;

			if (nextwndid >= MB3D_WND_MAX) {
				nextwndid = 0;
			}
			if (nextwndid < 0) {
				nextwndid = MB3D_WND_MAX - 1;
			}

			SelectNextWindow(nextwndid);//マウスカーソルをプレート位置に移動する前に呼ぶ（この関数ではコントロール位置にマウスは移動する）

			doneflag = true;
		}
	}

	//R1モードに関係なく
	//カエルボタン　プレートメニュー選択ブロック
	//R1モードによって機能が変わる場合には別関数にする
	if (!doneflag) {
		int frogbuttonid = 3;
		int platebuttonid = 0;
		int frogbutton;
		int platebutton;
		frogbutton = s_dsbuttonup[frogbuttonid];
		platebutton = s_dsbuttonup[platebuttonid];


		int platemenukind = s_platemenukind;
		int platemenuno = s_platemenuno;
		int nextplatemenukind = 0;
		int nextplateno = -1;

		//frogButton ret2prev
		if (frogbutton >= 1) {
			POINT frogbuttonpos;
			frogbuttonpos = s_spret2prev.dispcenter;

			GUIGetNextMenu(frogbuttonpos, platemenukind, &nextplatemenukind, &nextplateno);
			if ((nextplatemenukind >= 0) && (nextplateno >= 0)) {
				s_platemenukind = nextplatemenukind;
				s_platemenuno = nextplateno;
				GUIMenuSetVisible(s_platemenukind, nextplateno);

				s_curaimbarno = 0;
				GUISetVisible_AimBar();

				//if (s_platemenukind == SPPLATEMENUKIND_GUI) {
				//	SelectNextWindow(MB3D_WND_3D);
				//}
				//else 
				if (s_platemenukind == SPPLATEMENUKIND_DISP) {
					SelectNextWindow(MB3D_WND_SIDE);
				}
				else if (s_platemenukind == SPPLATEMENUKIND_RIGID) {
					SelectNextWindow(MB3D_WND_SIDE);
				}
				else if (s_platemenukind == SPPLATEMENUKIND_RETARGET) {
					SelectNextWindow(MB3D_WND_SIDE);
				}
				else {
					_ASSERT(0);
				}

				doneflag = true;
			}
		}

		/*
		#define SPAXISNUM	3
		//#define SPCAMNUM	3	//Coef.h : SPR_CAM_MAX
		#define SPRIGMAX	2
		#define SPGUISWNUM	5
		#define SPRIGIDSWNUM	4
		#define SPRETARGETSWNUM	2
		#define SPAIMBARNUM	5
		*/

		//move aimbar
		if ((platebutton >= 1) && (s_curaimbarno >= 0)) {
			if ((platemenukind >= 0) && (platemenuno >= 0)) {
				int nextaimbarno;
				if (s_firstmoveaimbar) {
					nextaimbarno = s_curaimbarno;
					s_firstmoveaimbar = false;
				}
				else {
					nextaimbarno = s_curaimbarno + 1;
				}

				//if (platemenukind == SPPLATEMENUKIND_GUI) {
				//	if (nextaimbarno >= SPGUISWNUM) {
				//		nextaimbarno = 0;
				//	}
				//}
				//else 
				if (platemenukind == SPPLATEMENUKIND_DISP) {
					if (nextaimbarno >= SPDISPSWNUM) {
						nextaimbarno = 0;
					}
				}
				else if (platemenukind == SPPLATEMENUKIND_RIGID) {
					if (nextaimbarno >= SPRIGIDSWNUM) {
						nextaimbarno = 0;
					}
				}
				else if (platemenukind == SPPLATEMENUKIND_RETARGET) {
					if (nextaimbarno >= SPRETARGETSWNUM) {
						nextaimbarno = 0;
					}
				}
				else {
					nextaimbarno = -1;
				}


				if ((nextaimbarno >= 0) && (nextaimbarno < SPAIMBARNUM)) {
					s_curaimbarno = nextaimbarno;


					SelectNextWindow(MB3D_WND_3D);//マウスカーソルをプレート位置に移動する前に呼ぶ（この関数ではコントロール位置にマウスは移動する）

					//POINT buttonpos;
					//buttonpos = s_spaimbar[s_curaimbarno].dispcenter;
					//buttonpos.y -= (28 / 2 + 6 / 2);
					//ClientToScreen(s_3dwnd, &buttonpos);
					//::SetCursorPos(buttonpos.x, buttonpos.y);

					//GUISetVisible_AimBar();
				}
			}
		}
	}


}

void DSCrossButton(bool firstctrlselect)
{

	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合には何もせずにリターン
		return;
	}

	//選択ウインドウ依存
	//十字キー処理
	{
		if (s_currentwndid == MB3D_WND_3D) {
			DSCrossButtonSelectUTGUI(firstctrlselect);
		}
		else if (s_currentwndid == MB3D_WND_TREE) {
			DSCrossButtonSelectTree(firstctrlselect);
		}
		else if (s_currentwndid == MB3D_WND_TOOL) {
			DSCrossButtonSelectToolCtrls(firstctrlselect);
		}
		else if (s_currentwndid == MB3D_WND_TIMELINE) {
			DSCrossButtonSelectPlayerBtns(firstctrlselect);
		}
		else if (s_currentwndid == MB3D_WND_SIDE) {
			if (s_platemenukind == SPPLATEMENUKIND_DISP) {
				switch (s_platemenuno) {
				case (SPDISPSW_LIGHTS + 1):
					//後で対応
					break;
				case (SPDISPSW_DISPGROUP + 1):
					//後で対応
					break;
				case (SPDISPSW_LATERTRANSPARENT + 1):
					//後で対応
					break;
				default:
					break;
				}
			}
			else if (s_platemenukind == SPPLATEMENUKIND_RIGID) {
				switch (s_platemenuno) {
				case (SPRIGIDSW_RIGIDPARAMS + 1):
					DSCrossButtonSelectRigidCtrls(firstctrlselect);
					break;
				case (SPRIGIDSW_IMPULSE + 1):
					DSCrossButtonSelectImpulseCtrls(firstctrlselect);
					break;
				case (SPRIGIDSW_GROUNDPLANE + 1):
					DSCrossButtonSelectGPCtrls(firstctrlselect);
					break;
				case (SPRIGIDSW_DAMPANIM + 1):
					DSCrossButtonSelectDampCtrls(firstctrlselect);
					break;
				default:
					break;
				}
			}
			else if (s_platemenukind == SPPLATEMENUKIND_RETARGET) {
				switch (s_platemenuno) {
				case (SPRETARGETSW_RETARGET + 1):
					DSCrossButtonSelectRetargetCtrls(firstctrlselect);
					break;
				case (SPRETARGETSW_LIMITEULER + 1):
					DSCrossButtonSelectEulLimitCtrls(firstctrlselect);
					break;
				default:
					break;
				}
			}
		}
	}
}



void DSCrossButtonSelectTree(bool firstctrlselect)
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}


	if (!s_owpTimeline) {
		return;
	}

	//select control
	//十字キー移動ブロック
	{
		if ((s_currentwndid >= 0) && (s_currenthwnd != 0)) {


			int parentbuttonid = 4;
			int sisterbuttonid = 5;
			int childbuttonid = 6;
			int brotherbuttonid = 7;
			int accelaxisid1 = 4;//axisid
			int accelaxisid2 = 5;//axisid

			int parentbutton = 0;
			int sisterbutton = 0;
			int childbutton = 0;
			int brotherbutton = 0;
			int accelaxis1 = 0;
			int accelaxis2 = 0;

			parentbutton = s_dsbuttonup[parentbuttonid];
			sisterbutton = s_dsbuttonup[sisterbuttonid];
			childbutton = s_dsbuttonup[childbuttonid];
			brotherbutton = s_dsbuttonup[brotherbuttonid];

			accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
			accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

			bool changeflag = false;

			//WS_TABSTOP
			//VK_TAB
			//WS_GROUP
			//または
			//HWND SetFocus(HWND hWnd);


			if (firstctrlselect) {
				parentbutton = 0;
				sisterbutton = 0;
				childbutton = 0;
				brotherbutton = 0;

				accelaxis1 = 0;
				accelaxis2 = 0;
				changeflag = true;
			}


			if (s_currentwndid == MB3D_WND_TREE) {
				if (s_model && (s_curboneno >= 0)) {
					CBone* curbone = s_model->GetBoneByID(s_curboneno);
					if (curbone) {
						if (parentbutton >= 1) {
							if ((accelaxis1 >= 1) || (accelaxis2 >= 1)) {
								//アクセル　L2またはL3がオンのとき　
								CBone* upperbranchbone = curbone->GetUpperBranchBone();
								if (upperbranchbone) {
									int upperbranchboneno = upperbranchbone->GetBoneNo();
									if (upperbranchboneno >= 0) {
										s_curboneno = upperbranchboneno;
										changeflag = true;
									}
								}
							}
							else {
								CBone* parbone = curbone->GetParent(false);
								if (parbone && parbone->IsSkeleton()) {
									int parboneno = parbone->GetBoneNo();
									if (parboneno >= 0) {
										s_curboneno = parboneno;
										changeflag = true;
									}
								}
							}
						}
						else if (sisterbutton >= 1) {
							CBone* sisterbone = curbone->GetSister(true);
							if (sisterbone) {
								int sisterboneno = sisterbone->GetBoneNo();
								if (sisterboneno >= 0) {
									s_curboneno = sisterboneno;
									changeflag = true;
								}
							}
							else {
								//sister loop
								//brotherがある場合　末端のbrotherに移動
								CBone* brotherbone = curbone->GetBrother(false);
								while (brotherbone && brotherbone->GetBrother(false) && brotherbone->GetBrother(false)->IsSkeleton()) {
									brotherbone = brotherbone->GetBrother(false);
								}
								if (brotherbone) {
									int nextboneno = brotherbone->GetBoneNo();
									if (nextboneno >= 0) {
										s_curboneno = nextboneno;
										changeflag = true;
									}
								}

								//階層的としてのsister, brotherが無い場合には名前としてのsister, brotherをチェックする
								if (changeflag != true) {
									string strcurbonename = curbone->GetBoneName();
									string strLeft = "Left";
									string strRight = "Right";

									string chkLeft = strcurbonename;
									string chkRight = strcurbonename;


									std::string::size_type leftpos = chkLeft.find(strLeft);
									if (leftpos != std::string::npos) {
										//Leftの部分をRightに変えてボーンが存在すればそのボーンに移動
										chkLeft.replace(leftpos, strLeft.length(), strRight);
										CBone* rightbone = s_model->FindBoneByName(chkLeft.c_str());
										if (rightbone) {
											int nextboneno = rightbone->GetBoneNo();
											if (nextboneno >= 0) {
												s_curboneno = nextboneno;
												changeflag = true;
											}
										}
									}
									else {
										std::string::size_type rightpos = chkRight.find(strRight);
										if (rightpos != std::string::npos) {
											//Rightの部分をLeftに変えてボーンが存在すればそのボーンに移動
											chkRight.replace(rightpos, strRight.length(), strLeft);
											CBone* leftbone = s_model->FindBoneByName(chkRight.c_str());
											if (leftbone) {
												int nextboneno = leftbone->GetBoneNo();
												if (nextboneno >= 0) {
													s_curboneno = nextboneno;
													changeflag = true;
												}
											}
										}
									}

								}
							}
						}
						else if (childbutton >= 1) {
							if ((accelaxis1 >= 1) || (accelaxis2 >= 1)) {
								//アクセル　L2またはL3がオンのとき　
								CBone* lowerbranchbone = curbone->GetLowerBranchBone();
								if (lowerbranchbone) {
									int lowerbranchboneno = lowerbranchbone->GetBoneNo();
									if (lowerbranchboneno >= 0) {
										s_curboneno = lowerbranchboneno;
										changeflag = true;
									}
								}
							}
							else {
								CBone* childbone = curbone->GetChild(false);
								if (childbone && childbone->IsSkeleton()) {
									int childboneno = childbone->GetBoneNo();
									if (childboneno >= 0) {
										s_curboneno = childboneno;
										changeflag = true;
									}
								}
							}
						}
						else if (brotherbutton >= 1) {
							CBone* brotherbone = curbone->GetBrother(false);
							if (brotherbone && brotherbone->IsSkeleton()) {
								int brotherboneno = brotherbone->GetBoneNo();
								if (brotherboneno >= 0) {
									s_curboneno = brotherboneno;
									changeflag = true;
								}
							}
							else {
								//brother loop
								//sisterとparentのchildがある場合　parentのchildに移動
								CBone* sisterbone = curbone->GetSister(true);
								if (sisterbone) {
									CBone* parentbone = curbone->GetParent(false);
									if (parentbone && parentbone->IsSkeleton()) {
										CBone* childbone = parentbone->GetChild(false);
										if (childbone && childbone->IsSkeleton()) {
											int nextboneno = childbone->GetBoneNo();
											if (nextboneno >= 0) {
												s_curboneno = nextboneno;
												changeflag = true;
											}
										}
									}
								}
							}

							//階層的としてのsister, brotherが無い場合には名前としてのsister, brotherをチェックする
							if (changeflag != true) {
								string strcurbonename = curbone->GetBoneName();
								string strLeft = "Left";
								string strRight = "Right";

								string chkLeft = strcurbonename;
								string chkRight = strcurbonename;


								std::string::size_type leftpos = chkLeft.find(strLeft);
								if (leftpos != std::string::npos) {
									//Leftの部分をRightに変えてボーンが存在すればそのボーンに移動
									chkLeft.replace(leftpos, strLeft.length(), strRight);
									CBone* rightbone = s_model->FindBoneByName(chkLeft.c_str());
									if (rightbone) {
										int nextboneno = rightbone->GetBoneNo();
										if (nextboneno >= 0) {
											s_curboneno = nextboneno;
											changeflag = true;
										}
									}
								}
								else {
									std::string::size_type rightpos = chkRight.find(strRight);
									if (rightpos != std::string::npos) {
										//Rightの部分をLeftに変えてボーンが存在すればそのボーンに移動
										chkRight.replace(rightpos, strRight.length(), strLeft);
										CBone* leftbone = s_model->GetBoneByName(chkRight.c_str());
										if (leftbone) {
											int nextboneno = leftbone->GetBoneNo();
											if (nextboneno >= 0) {
												s_curboneno = nextboneno;
												changeflag = true;
											}
										}
									}
								}
							}
						}

						if (changeflag && (s_curboneno >= 0)) {
							if (s_owpTimeline) {
								s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);


								//マウスがタイムライン上にあった場合にだけマウスの位置を選択位置へ移動
								//他のダイアログなどを設定中にカーソルがタイムラインに飛ばないように。

								POINT cursorpos;
								GetCursorPos(&cursorpos);
								ScreenToClient(s_timelineWnd->getHWnd(), &cursorpos);
								RECT timelinerect;
								GetClientRect(s_timelineWnd->getHWnd(), &timelinerect);
								if ((cursorpos.x >= timelinerect.left) && (cursorpos.x <= timelinerect.right) &&
									(cursorpos.y >= timelinerect.top) && (cursorpos.y <= timelinerect.bottom)) {

									WindowPos currentpos = s_owpTimeline->getCurrentLinePos();
									POINT mousepos = { 0, 0 };
									mousepos.x = currentpos.x;
									mousepos.y = currentpos.y;

									::ClientToScreen(s_timelineWnd->getHWnd(), &mousepos);
									::SetCursorPos(mousepos.x, mousepos.y);
								}



							}
							ChangeCurrentBone();
						}

					}
				}
			}
		}
	}


}




void DSCrossButtonSelectUTGUI(bool firstctrlselect)
{


	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!s_3dwnd) {
		return;
	}
	if (!IsWindow(s_3dwnd)) {
		return;
	}

	////select control
	////十字キー移動ブロック
	//{
	//	if ((s_currentwndid == 1) && (s_currenthwnd != 0)) {


	//		int parentbuttonid = 4;
	//		int sisterbuttonid = 5;
	//		int childbuttonid = 6;
	//		int brotherbuttonid = 7;
	//		int accelaxisid1 = 4;//axisid
	//		int accelaxisid2 = 5;//axisid

	//		int parentbutton = 0;
	//		int sisterbutton = 0;
	//		int childbutton = 0;
	//		int brotherbutton = 0;
	//		int accelaxis1 = 0;
	//		int accelaxis2 = 0;

	//		parentbutton = s_dsbuttonup[parentbuttonid];
	//		sisterbutton = s_dsbuttonup[sisterbuttonid];
	//		childbutton = s_dsbuttonup[childbuttonid];
	//		brotherbutton = s_dsbuttonup[brotherbuttonid];

	//		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	//		bool changeflag = false;
	//		bool chkflag = false;

	//		//WS_TABSTOP
	//		//VK_TAB
	//		//WS_GROUP
	//		//または
	//		//HWND SetFocus(HWND hWnd);

	//		//static int s_curdsutguikind = 0;
	//		//static int s_curdsutguino = 0;




	//		if (s_currentwndid == MB3D_WND_3D) {
	//			if (s_model && (s_curboneno >= 0)) {
	//				CBone* curbone = s_model->GetBoneByID(s_curboneno);
	//				int curdsutguikind = s_curdsutguikind;
	//				int curdsutguino = s_curdsutguino;


	//				if (firstctrlselect) {
	//					parentbutton = 0;
	//					sisterbutton = 0;
	//					childbutton = 0;
	//					brotherbutton = 0;

	//					accelaxis1 = 0;
	//					accelaxis2 = 0;

	//					changeflag = true;
	//					chkflag = true;
	//				}



	//				//############################################################################################################################
	//				//STL.size()の返り値はunsigned。-1との比較の際には0xFFFFFFFFとsize()との比較になり、意図しない結果を招きやすい。signedに代入してから-1と比較する。
	//				//############################################################################################################################
	//				int guisize0 = (int)s_dsutgui0.size();
	//				int guisize1 = (int)s_dsutgui1.size();
	//				int guisize2 = (int)s_dsutgui2.size();
	//				int guisize3 = (int)s_dsutgui3.size();

	//				if (curbone) {


	//					if (parentbutton >= 1) {
	//						curdsutguino--;
	//						int guigroupid = curdsutguikind;//guikindからSPGUISW?_*への変換。guikind(1)がSPGUISW_DISP_AND_LIMITS(1)で、guikind(3)がSPGUISW_PROJ_AND_LOD(3)
	//						switch (guigroupid) {
	//						case SPGUISW_CAMERA_AND_IK:
	//						{
	//							if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
	//								if (curdsutguino >= SPR_CAM_MAX) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認　ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = SPR_CAM_MAX - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;
	//						case SPGUISW_DISP_AND_LIMITS:
	//						{
	//							if (s_spguisw[SPGUISW_DISP_AND_LIMITS].state) {
	//								if (curdsutguino >= guisize0) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認　ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = guisize0 - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;

	//						case SPGUISW_BRUSHPARAMS:
	//						{
	//							if (s_spguisw[SPGUISW_BRUSHPARAMS].state) {
	//								if (curdsutguino >= guisize1) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認　ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = guisize1 - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;

	//						case SPGUISW_BULLETPHYSICS:
	//						{
	//							if (s_spguisw[SPGUISW_BULLETPHYSICS].state) {
	//								if (curdsutguino >= guisize2) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認　ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = guisize2 - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;

	//						case SPGUISW_PROJ_AND_LOD:
	//						{
	//							if (s_spguisw[SPGUISW_PROJ_AND_LOD].state) {
	//								if (curdsutguino >= guisize3) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認 ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = guisize3 - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;

	//						default:
	//							_ASSERT(0);
	//							changeflag = false;
	//							chkflag = true;
	//							break;
	//						}
	//					}
	//					else if (sisterbutton >= 1) {
	//						curdsutguikind++;
	//						curdsutguino = 0;
	//						int dbgcnt = 0;
	//						while (chkflag == false) {
	//							int curgroupid = curdsutguikind;
	//							if ((curgroupid >= SPGUISW_CAMERA_AND_IK) && (curgroupid <= SPGUISW_PROJ_AND_LOD)) {
	//								if (s_spguisw[curgroupid].state) {
	//									changeflag = true;
	//									chkflag = true;
	//									break;
	//								}
	//								else {
	//									curdsutguikind++;//!!!!!!!!!!!
	//								}
	//							}
	//							else {
	//								curdsutguikind = 0;//ring
	//								//changeflag = false;
	//								//chkflag = true;
	//								//break;
	//							}
	//							dbgcnt++;
	//							if (dbgcnt >= (SPGUISW_PROJ_AND_LOD - SPGUISW_CAMERA_AND_IK + 1)) {//1周分チェックしたら抜ける
	//								changeflag = false;
	//								chkflag = true;
	//								break;
	//							}
	//						}
	//					}
	//					else if (childbutton >= 1) {
	//						//if ((accelaxis1 >= 1) || (accelaxis2 >= 1)) {
	//						//	//アクセル　L2またはL3がオンのとき　

	//						//}
	//						//else {

	//						//}
	//						curdsutguino++;
	//						int guigroupid = curdsutguikind;//guikindからSPGUISW?_*への変換。
	//						switch (guigroupid) {
	//						case SPGUISW_CAMERA_AND_IK:
	//						{
	//							if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
	//								if (curdsutguino >= SPR_CAM_MAX) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認 ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = SPR_CAM_MAX - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;

	//						case SPGUISW_DISP_AND_LIMITS:
	//						{
	//							if (s_spguisw[SPGUISW_DISP_AND_LIMITS].state) {
	//								if (curdsutguino >= guisize0) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認　ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = guisize0 - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;

	//						case SPGUISW_BRUSHPARAMS:
	//						{
	//							if (s_spguisw[SPGUISW_BRUSHPARAMS].state) {
	//								if (curdsutguino >= guisize1) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認　ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = guisize1 - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;

	//						case SPGUISW_BULLETPHYSICS:
	//						{
	//							if (s_spguisw[SPGUISW_BULLETPHYSICS].state) {
	//								if (curdsutguino >= guisize2) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認　ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = guisize2 - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;

	//						case SPGUISW_PROJ_AND_LOD:
	//						{
	//							if (s_spguisw[SPGUISW_PROJ_AND_LOD].state) {
	//								if (curdsutguino >= guisize3) {
	//									curdsutguino = 0;//size >= 1は関数先頭で確認　ring
	//								}
	//								else if (curdsutguino < 0) {
	//									curdsutguino = guisize3 - 1;//ring
	//								}
	//								changeflag = true;
	//								chkflag = true;
	//							}
	//							else {
	//								changeflag = false;
	//								chkflag = true;
	//							}
	//						}
	//						break;

	//						default:
	//							_ASSERT(0);
	//							changeflag = false;
	//							chkflag = true;
	//							break;
	//						}

	//					}
	//					else if (brotherbutton >= 1) {
	//						curdsutguikind--;
	//						curdsutguino = 0;
	//						int dbgcnt = 0;
	//						while (chkflag == false) {
	//							int curgroupid = curdsutguikind;
	//							if ((curgroupid >= SPGUISW_CAMERA_AND_IK) && (curgroupid <= SPGUISW_PROJ_AND_LOD)) {
	//								if (s_spguisw[curgroupid].state) {
	//									changeflag = true;
	//									chkflag = true;
	//									break;
	//								}
	//								else {
	//									curdsutguikind--;//!!!!!!!!!!!
	//								}
	//							}
	//							else {
	//								curdsutguikind = SPGUISW_PROJ_AND_LOD;//ring
	//								//changeflag = false;
	//								//chkflag = true;
	//								//break;
	//							}
	//							dbgcnt++;
	//							if (dbgcnt >= (SPGUISW_PROJ_AND_LOD - SPGUISW_CAMERA_AND_IK + 1)) {//1周分チェックしたら抜ける
	//								changeflag = false;
	//								chkflag = true;
	//								break;
	//							}
	//						}
	//					}


	//					/*
	//					enum DXUT_CONTROL_TYPE
	//					{
	//						DXUT_CONTROL_BUTTON,
	//						DXUT_CONTROL_STATIC,
	//						DXUT_CONTROL_CHECKBOX,
	//						DXUT_CONTROL_RADIOBUTTON,
	//						DXUT_CONTROL_COMBOBOX,
	//						DXUT_CONTROL_SLIDER,
	//						DXUT_CONTROL_EDITBOX,
	//						DXUT_CONTROL_IMEEDITBOX,
	//						DXUT_CONTROL_LISTBOX,
	//						DXUT_CONTROL_SCROLLBAR,
	//					};
	//					*/

	//					/*
	//					//#####################################################################################################
	//					//プレート上で〇ボタンを押したときにマウスがコントロールへ飛ぶ。プレート上にマウスが残った方が便利だったのでコメントアウト
	//					//#####################################################################################################
	//					*
	//					*
	//											if (chkflag && changeflag && (s_curboneno >= 0)) {
	//												if ((curdsutguikind >= SPGUISW_CAMERA_AND_IK) && (curdsutguikind <= SPGUISW_PROJ_AND_LOD)) {

	//													s_curdsutguikind = curdsutguikind;
	//													s_curdsutguino = curdsutguino;
	//													int guigroupid = s_curdsutguikind;
	//													switch (guigroupid) {
	//													case SPGUISW_CAMERA_AND_IK:
	//													{
	//														if ((s_curdsutguino >= 0) && (s_curdsutguino < SPR_CAM_MAX)) {
	//															POINT ctrlpos;
	//															ctrlpos.x = s_spcam[s_curdsutguino].dispcenter.x;
	//															ctrlpos.y = s_spcam[s_curdsutguino].dispcenter.y;

	//															ClientToScreen(s_3dwnd, &ctrlpos);
	//															::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//														}
	//													}
	//													break;

	//													case SPGUISW_DISP_AND_LIMITS:
	//														if ((s_curdsutguino >= 0) && (s_curdsutguino < guisize0) && s_dsutgui0[s_curdsutguino]) {
	//															//s_dsutgui0[s_curdsutguino]->SetTextColor(0xFF0000FF);
	//															//s_dsutgui0[s_curdsutguino]->OnFocusIn();
	//															POINT ctrlpos;
	//															s_dsutgui0[s_curdsutguino]->GetLocation(&ctrlpos);
	//															//s_dsutgui0[s_curdsutguino]->GetLocation(&ctrlpos);
	//															UINT type = s_dsutgui0[s_curdsutguino]->GetType();
	//															switch (type) {
	//															case DXUT_CONTROL_CHECKBOX:
	//															case DXUT_CONTROL_RADIOBUTTON:
	//																ctrlpos.x += 6;
	//																ctrlpos.y += 6;
	//																break;
	//															case DXUT_CONTROL_BUTTON:
	//															case DXUT_CONTROL_COMBOBOX:
	//																ctrlpos.x += (100 / 2);
	//																ctrlpos.y += (25 / 2);
	//																break;
	//															case DXUT_CONTROL_STATIC:
	//																break;

	//															case DXUT_CONTROL_SLIDER:
	//															{
	//																int slmin = 0;
	//																int slmax = 0;
	//																int slvalue = 0;
	//																((CDXUTSlider*)s_dsutgui0[s_curdsutguino])->GetRange(slmin, slmax);
	//																slvalue = ((CDXUTSlider*)s_dsutgui0[s_curdsutguino])->GetValue();
	//																float rate = 0.0f;
	//																int length = slmax - slmin;
	//																if (length != 0) {
	//																	rate = (float)(slvalue - slmin) / (float)length;
	//																}
	//																else {
	//																	rate = 0.0f;
	//																}

	//																ctrlpos.x += (int)(100.0f * rate);//100.0f : ctrl width
	//																ctrlpos.y += (25 / 2);
	//															}
	//															break;
	//															case DXUT_CONTROL_EDITBOX:
	//															case DXUT_CONTROL_IMEEDITBOX:
	//															case DXUT_CONTROL_LISTBOX:
	//															case DXUT_CONTROL_SCROLLBAR:
	//																break;
	//															}
	//															ClientToScreen(s_3dwnd, &ctrlpos);
	//															::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//														}
	//														break;

	//													case SPGUISW_BRUSHPARAMS:
	//														if ((s_curdsutguino >= 0) && (s_curdsutguino < guisize1) && s_dsutgui1[s_curdsutguino]) {
	//															//s_dsutgui1[s_curdsutguino]->SetTextColor(0xFF0000FF);
	//															//s_dsutgui1[s_curdsutguino]->OnFocusIn();
	//															POINT ctrlpos;
	//															s_dsutgui1[s_curdsutguino]->GetLocation(&ctrlpos);
	//															UINT type = s_dsutgui1[s_curdsutguino]->GetType();
	//															switch (type) {
	//															case DXUT_CONTROL_CHECKBOX:
	//															case DXUT_CONTROL_RADIOBUTTON:
	//																ctrlpos.x += 6;
	//																ctrlpos.y += 6;
	//																break;
	//															case DXUT_CONTROL_BUTTON:
	//															case DXUT_CONTROL_COMBOBOX:
	//																ctrlpos.x += (100 / 2);
	//																ctrlpos.y += (25 / 2);
	//																break;
	//															case DXUT_CONTROL_STATIC:
	//																break;

	//															case DXUT_CONTROL_SLIDER:
	//															{
	//																int slmin = 0;
	//																int slmax = 0;
	//																int slvalue = 0;
	//																((CDXUTSlider*)s_dsutgui1[s_curdsutguino])->GetRange(slmin, slmax);
	//																slvalue = ((CDXUTSlider*)s_dsutgui1[s_curdsutguino])->GetValue();
	//																float rate = 0.0f;
	//																int length = slmax - slmin;
	//																if (length != 0) {
	//																	rate = (float)(slvalue - slmin) / (float)length;
	//																}
	//																else {
	//																	rate = 0.0f;
	//																}

	//																ctrlpos.x += (int)(100.0f * rate);
	//																ctrlpos.y += (25 / 2);
	//															}
	//															break;
	//															case DXUT_CONTROL_EDITBOX:
	//															case DXUT_CONTROL_IMEEDITBOX:
	//															case DXUT_CONTROL_LISTBOX:
	//															case DXUT_CONTROL_SCROLLBAR:
	//																break;
	//															}
	//															ClientToScreen(s_3dwnd, &ctrlpos);
	//															::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//														}
	//														break;

	//													case SPGUISW_BULLETPHYSICS:
	//														if ((s_curdsutguino >= 0) && (s_curdsutguino < guisize2) && s_dsutgui2[s_curdsutguino]) {
	//															//s_dsutgui2[s_curdsutguino]->SetTextColor(0xFF0000FF);
	//															//s_dsutgui2[s_curdsutguino]->OnFocusIn();
	//															POINT ctrlpos;
	//															s_dsutgui2[s_curdsutguino]->GetLocation(&ctrlpos);
	//															UINT type = s_dsutgui2[s_curdsutguino]->GetType();
	//															switch (type) {
	//															case DXUT_CONTROL_CHECKBOX:
	//															case DXUT_CONTROL_RADIOBUTTON:
	//																ctrlpos.x += 6;
	//																ctrlpos.y += 6;
	//																break;
	//															case DXUT_CONTROL_BUTTON:
	//															case DXUT_CONTROL_COMBOBOX:
	//																ctrlpos.x += (100 / 2);
	//																ctrlpos.y += (25 / 2);
	//																break;
	//															case DXUT_CONTROL_STATIC:
	//																break;

	//															case DXUT_CONTROL_SLIDER:
	//															{
	//																int slmin = 0;
	//																int slmax = 0;
	//																int slvalue = 0;
	//																((CDXUTSlider*)s_dsutgui2[s_curdsutguino])->GetRange(slmin, slmax);
	//																slvalue = ((CDXUTSlider*)s_dsutgui2[s_curdsutguino])->GetValue();
	//																float rate = 0.0f;
	//																int length = slmax - slmin;
	//																if (length != 0) {
	//																	rate = (float)(slvalue - slmin) / (float)length;
	//																}
	//																else {
	//																	rate = 0.0f;
	//																}

	//																ctrlpos.x += (int)(100.0f * rate);
	//																ctrlpos.y += (25 / 2);
	//															}
	//															break;
	//															case DXUT_CONTROL_EDITBOX:
	//															case DXUT_CONTROL_IMEEDITBOX:
	//															case DXUT_CONTROL_LISTBOX:
	//															case DXUT_CONTROL_SCROLLBAR:
	//																break;
	//															}
	//															ClientToScreen(s_3dwnd, &ctrlpos);
	//															::SetCursorPos(ctrlpos.x, ctrlpos.y);

	//														}
	//														break;

	//													case SPGUISW_PROJ_AND_LOD:
	//														if ((s_curdsutguino >= 0) && (s_curdsutguino < guisize3) && s_dsutgui3[s_curdsutguino]) {
	//															//s_dsutgui3[s_curdsutguino]->SetTextColor(0xFF0000FF);
	//															//s_dsutgui3[s_curdsutguino]->OnFocusIn();
	//															POINT ctrlpos;
	//															s_dsutgui3[s_curdsutguino]->GetLocation(&ctrlpos);
	//															UINT type = s_dsutgui3[s_curdsutguino]->GetType();
	//															switch (type) {
	//															case DXUT_CONTROL_CHECKBOX:
	//															case DXUT_CONTROL_RADIOBUTTON:
	//																ctrlpos.x += 6;
	//																ctrlpos.y += 6;
	//																break;
	//															case DXUT_CONTROL_BUTTON:
	//															case DXUT_CONTROL_COMBOBOX:
	//																ctrlpos.x += (100 / 2);
	//																ctrlpos.y += (25 / 2);
	//																break;
	//															case DXUT_CONTROL_STATIC:
	//																break;

	//															case DXUT_CONTROL_SLIDER:
	//															{
	//																int slmin = 0;
	//																int slmax = 0;
	//																int slvalue = 0;
	//																((CDXUTSlider*)s_dsutgui3[s_curdsutguino])->GetRange(slmin, slmax);
	//																slvalue = ((CDXUTSlider*)s_dsutgui3[s_curdsutguino])->GetValue();
	//																float rate = 0.0f;
	//																int length = slmax - slmin;
	//																if (length != 0) {
	//																	rate = (float)(slvalue - slmin) / (float)length;
	//																}
	//																else {
	//																	rate = 0.0f;
	//																}

	//																ctrlpos.x += (int)(100.0f * rate);
	//																ctrlpos.y += (25 / 2);
	//															}
	//															break;
	//															case DXUT_CONTROL_EDITBOX:
	//															case DXUT_CONTROL_IMEEDITBOX:
	//															case DXUT_CONTROL_LISTBOX:
	//															case DXUT_CONTROL_SCROLLBAR:
	//																break;
	//															}
	//															ClientToScreen(s_3dwnd, &ctrlpos);
	//															::SetCursorPos(ctrlpos.x, ctrlpos.y);

	//														}
	//														break;


	//													default:
	//														break;
	//													}
	//												}

	//												//if (s_owpTimeline) {
	//												//	s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
	//												//}
	//												//ChangeCurrentBone();
	//											}
	//					*/
	//				}
	//			}
	//		}
	//	}
	//}

}


void DSCrossButtonSelectEulLimitCtrls(bool firstctrlselect)
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!s_anglelimitdlg || !IsWindow(s_anglelimitdlg)) {
		return;
	}

	////select control
	////十字キー移動ブロック
	//{
	//	if ((s_currentwndid == MB3D_WND_SIDE) && (s_currenthwnd != 0)) {


	//		int parentbuttonid = 4;
	//		int sisterbuttonid = 5;
	//		int childbuttonid = 6;
	//		int brotherbuttonid = 7;
	//		int accelaxisid1 = 4;//axisid
	//		int accelaxisid2 = 5;//axisid

	//		int parentbutton = 0;
	//		int sisterbutton = 0;
	//		int childbutton = 0;
	//		int brotherbutton = 0;
	//		int accelaxis1 = 0;
	//		int accelaxis2 = 0;

	//		parentbutton = s_dsbuttonup[parentbuttonid];
	//		sisterbutton = s_dsbuttonup[sisterbuttonid];
	//		childbutton = s_dsbuttonup[childbuttonid];
	//		brotherbutton = s_dsbuttonup[brotherbuttonid];

	//		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	//		bool changeflag = false;
	//		bool chkflag = false;

	//		//WS_TABSTOP
	//		//VK_TAB
	//		//WS_GROUP
	//		//または
	//		//HWND SetFocus(HWND hWnd);

	//		//static int s_curdsutguikind = 0;
	//		//static int s_curdsutguino = 0;


	//		if (firstctrlselect) {
	//			parentbutton = 0;
	//			sisterbutton = 0;
	//			childbutton = 0;
	//			brotherbutton = 0;

	//			accelaxis1 = 0;
	//			accelaxis2 = 0;

	//			changeflag = true;
	//			chkflag = true;
	//		}


	//		if (s_currentwndid == MB3D_WND_SIDE) {
	//			if (s_model && (s_curboneno >= 0)) {
	//				CBone* curbone = s_model->GetBoneByID(s_curboneno);
	//				int curdsctrlno = s_curdseullimitctrlno;
	//				if (curbone) {

	//					if (parentbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dseullimitctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (sisterbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dseullimitctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (childbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dseullimitctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (brotherbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dseullimitctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}


	//					/*
	//					enum DXUT_CONTROL_TYPE
	//					{
	//						DXUT_CONTROL_BUTTON,
	//						DXUT_CONTROL_STATIC,
	//						DXUT_CONTROL_CHECKBOX,
	//						DXUT_CONTROL_RADIOBUTTON,
	//						DXUT_CONTROL_COMBOBOX,
	//						DXUT_CONTROL_SLIDER,
	//						DXUT_CONTROL_EDITBOX,
	//						DXUT_CONTROL_IMEEDITBOX,
	//						DXUT_CONTROL_LISTBOX,
	//						DXUT_CONTROL_SCROLLBAR,
	//					};
	//					*/
	//					if (chkflag && changeflag && (s_curboneno >= 0)) {
	//						if (((curdsctrlno) >= 0) && ((curdsctrlno) < s_dseullimitctrls.size())) {

	//							s_curdseullimitctrlno = curdsctrlno;


	//							if (s_anglelimitdlg && IsWindow(s_anglelimitdlg) &&
	//								(s_curdseullimitctrlno >= 0) && (s_curdseullimitctrlno < s_dseullimitctrls.size()) && (s_dseullimitctrls[s_curdseullimitctrlno])) {


	//								POINT ctrlpos = { 0, 0 };

	//								HWND ctrlwnd = ::GetDlgItem(s_anglelimitdlg, s_dseullimitctrls[s_curdseullimitctrlno]);
	//								if (ctrlwnd) {
	//									RECT ctrlrect;
	//									::GetWindowRect(ctrlwnd, &ctrlrect);
	//									if (s_curdseullimitctrlno == 0) {
	//										ctrlpos.x = ctrlrect.left + 175;
	//										ctrlpos.y = ctrlrect.top + 20 / 2;
	//									}
	//									else if (s_curdseullimitctrlno == (s_dseullimitctrls.size() - 1)) {
	//										ctrlpos.x = ctrlrect.left + 100 / 2;
	//										ctrlpos.y = ctrlrect.top + 20 / 2;
	//									}
	//									else {
	//										int slidervalue;
	//										slidervalue = (int)::SendMessage(ctrlwnd, TBM_GETPOS, 0, 0);
	//										int sliderposx = (int)((float)(slidervalue + 180) / 360.0f * 274.0f);
	//										ctrlpos.x = ctrlrect.left + sliderposx + 12;
	//										ctrlpos.y = ctrlrect.top + 20 / 2;
	//									}

	//									//ClientToScreen(s_anglelimitdlg, &ctrlpos);

	//									::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//								}
	//							}
	//						}

	//						//if (s_owpTimeline) {
	//						//	s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
	//						//}
	//						//ChangeCurrentBone();
	//					}

	//				}
	//			}
	//		}
	//	}
	//}

}

void DSCrossButtonSelectRetargetCtrls(bool firstctrlselect)
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!s_convboneWnd) {
		return;
	}

	////select control
	////十字キー移動ブロック
	//{
	//	if ((s_currentwndid == MB3D_WND_SIDE) && (s_currenthwnd != 0)) {


	//		int parentbuttonid = 4;
	//		int sisterbuttonid = 5;
	//		int childbuttonid = 6;
	//		int brotherbuttonid = 7;
	//		int accelaxisid1 = 4;//axisid
	//		int accelaxisid2 = 5;//axisid

	//		int parentbutton = 0;
	//		int sisterbutton = 0;
	//		int childbutton = 0;
	//		int brotherbutton = 0;
	//		int accelaxis1 = 0;
	//		int accelaxis2 = 0;

	//		parentbutton = s_dsbuttonup[parentbuttonid];
	//		sisterbutton = s_dsbuttonup[sisterbuttonid];
	//		childbutton = s_dsbuttonup[childbuttonid];
	//		brotherbutton = s_dsbuttonup[brotherbuttonid];

	//		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	//		bool changeflag = false;
	//		bool chkflag = false;

	//		//WS_TABSTOP
	//		//VK_TAB
	//		//WS_GROUP
	//		//または
	//		//HWND SetFocus(HWND hWnd);

	//		//static int s_curdsutguikind = 0;
	//		//static int s_curdsutguino = 0;

	//		if (firstctrlselect) {
	//			parentbutton = 0;
	//			sisterbutton = 0;
	//			childbutton = 0;
	//			brotherbutton = 0;

	//			accelaxis1 = 0;
	//			accelaxis2 = 0;

	//			changeflag = true;
	//			chkflag = true;
	//		}

	//		if (s_currentwndid == MB3D_WND_SIDE) {
	//			if (s_model && (s_curboneno >= 0)) {
	//				CBone* curbone = s_model->GetBoneByID(s_curboneno);
	//				int curdsctrlno = s_curdsretargetctrlno;
	//				if (curbone) {

	//					if (parentbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsretargetctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (sisterbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsretargetctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (childbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsretargetctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (brotherbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsretargetctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}


	//					/*
	//					enum DXUT_CONTROL_TYPE
	//					{
	//						DXUT_CONTROL_BUTTON,
	//						DXUT_CONTROL_STATIC,
	//						DXUT_CONTROL_CHECKBOX,
	//						DXUT_CONTROL_RADIOBUTTON,
	//						DXUT_CONTROL_COMBOBOX,
	//						DXUT_CONTROL_SLIDER,
	//						DXUT_CONTROL_EDITBOX,
	//						DXUT_CONTROL_IMEEDITBOX,
	//						DXUT_CONTROL_LISTBOX,
	//						DXUT_CONTROL_SCROLLBAR,
	//					};
	//					*/
	//					if (chkflag && changeflag && (s_curboneno >= 0)) {
	//						if (((curdsctrlno) >= 0) && ((curdsctrlno) < s_dsretargetctrls.size())) {
	//							s_curdsretargetctrlno = curdsctrlno;

	//							OrgWinGUI::WindowPos ctrlwinpos;
	//							POINT ctrlpos = { 0, 0 };
	//							ctrlwinpos = s_dsretargetctrls[s_curdsretargetctrlno]->getPos();
	//							ctrlpos.x = ctrlwinpos.x;
	//							ctrlpos.y = ctrlwinpos.y;

	//							//s_dsutgui0[s_curdsutguino]->GetLocation(&ctrlpos);
	//							//UINT type = s_dsutgui0[s_curdsutguino]->GetType();
	//							if (s_convboneWnd && IsWindow(s_convboneWnd->getHWnd()) &&
	//								(s_curdsretargetctrlno >= 0) && (s_curdsretargetctrlno < s_dsretargetctrls.size()) && (s_dsretargetctrls[s_curdsretargetctrlno])) {

	//								bool isslider;
	//								isslider = ((OrgWinGUI::OrgWindowParts*)s_dsretargetctrls[s_curdsretargetctrlno])->getIsSlider();
	//								if (isslider) {
	//									//sizex : 350, sizey : 20, window with 450

	//									double minval;
	//									double maxval;
	//									double curval;
	//									double length;
	//									minval = ((OrgWinGUI::OWP_Slider*)s_dsretargetctrls[s_curdsretargetctrlno])->getMinValue();
	//									maxval = ((OrgWinGUI::OWP_Slider*)s_dsretargetctrls[s_curdsretargetctrlno])->getMaxValue();
	//									curval = ((OrgWinGUI::OWP_Slider*)s_dsretargetctrls[s_curdsretargetctrlno])->getValue();
	//									length = maxval - minval;
	//									if (length != 0.0) {
	//										double rate;
	//										rate = (curval - minval) / length;
	//										//ctrlpos.x += (LONG)(350.0 * rate);
	//										//pos1x+ (int)((value - minValue) * (float)(pos2x - pos1x) / (maxValue - minValue) + 0.5f);
	//										int pos2xpos1x = 450 - 6 - 65 - 5;
	//										ctrlpos.x += (5 + (int)((curval - minval) * (float)(pos2xpos1x) / (maxval - minval) + 0.5f));//LABEL_SIZE_X : 65.0, AXIS_POS_X : 5.0
	//										ctrlpos.y += (int)(20.0 / 2.0);
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//									else {
	//										//if button
	//										ctrlpos.x += 6;
	//										ctrlpos.y += 6;
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//								}
	//								else {
	//									//if button
	//									ctrlpos.x += 6;
	//									ctrlpos.y += 6;
	//									//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//								}

	//								WindowPos retargetpos;
	//								retargetpos = s_convboneWnd->getPos();
	//								ctrlpos.x += retargetpos.x;
	//								ctrlpos.y += retargetpos.y;
	//								::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//							}
	//						}

	//						//if (s_owpTimeline) {
	//						//	s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
	//						//}
	//						//ChangeCurrentBone();
	//					}

	//				}
	//			}
	//		}
	//	}
	//}

}

void DSCrossButtonSelectDampCtrls(bool firstctrlselect)
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!s_dmpanimWnd) {
		return;
	}

	////select control
	////十字キー移動ブロック
	//{
	//	if ((s_currentwndid == MB3D_WND_SIDE) && (s_currenthwnd != 0)) {


	//		int parentbuttonid = 4;
	//		int sisterbuttonid = 5;
	//		int childbuttonid = 6;
	//		int brotherbuttonid = 7;
	//		int accelaxisid1 = 4;//axisid
	//		int accelaxisid2 = 5;//axisid

	//		int parentbutton = 0;
	//		int sisterbutton = 0;
	//		int childbutton = 0;
	//		int brotherbutton = 0;
	//		int accelaxis1 = 0;
	//		int accelaxis2 = 0;

	//		parentbutton = s_dsbuttonup[parentbuttonid];
	//		sisterbutton = s_dsbuttonup[sisterbuttonid];
	//		childbutton = s_dsbuttonup[childbuttonid];
	//		brotherbutton = s_dsbuttonup[brotherbuttonid];

	//		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	//		bool changeflag = false;
	//		bool chkflag = false;

	//		//WS_TABSTOP
	//		//VK_TAB
	//		//WS_GROUP
	//		//または
	//		//HWND SetFocus(HWND hWnd);

	//		//static int s_curdsutguikind = 0;
	//		//static int s_curdsutguino = 0;

	//		if (firstctrlselect) {
	//			parentbutton = 0;
	//			sisterbutton = 0;
	//			childbutton = 0;
	//			brotherbutton = 0;

	//			accelaxis1 = 0;
	//			accelaxis2 = 0;

	//			changeflag = true;
	//			chkflag = true;
	//		}


	//		if (s_currentwndid == MB3D_WND_SIDE) {
	//			if (s_model && (s_curboneno >= 0)) {
	//				CBone* curbone = s_model->GetBoneByID(s_curboneno);
	//				int curdsctrlno = s_curdsdampctrlno;
	//				if (curbone) {

	//					if (parentbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsdampctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (sisterbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsdampctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (childbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsdampctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (brotherbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsdampctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}


	//					/*
	//					enum DXUT_CONTROL_TYPE
	//					{
	//						DXUT_CONTROL_BUTTON,
	//						DXUT_CONTROL_STATIC,
	//						DXUT_CONTROL_CHECKBOX,
	//						DXUT_CONTROL_RADIOBUTTON,
	//						DXUT_CONTROL_COMBOBOX,
	//						DXUT_CONTROL_SLIDER,
	//						DXUT_CONTROL_EDITBOX,
	//						DXUT_CONTROL_IMEEDITBOX,
	//						DXUT_CONTROL_LISTBOX,
	//						DXUT_CONTROL_SCROLLBAR,
	//					};
	//					*/
	//					if (chkflag && changeflag && (s_curboneno >= 0)) {
	//						if (((curdsctrlno) >= 0) && ((curdsctrlno) < s_dsdampctrls.size())) {
	//							s_curdsdampctrlno = curdsctrlno;

	//							OrgWinGUI::WindowPos ctrlwinpos;
	//							POINT ctrlpos = { 0, 0 };
	//							ctrlwinpos = s_dsdampctrls[s_curdsdampctrlno]->getPos();
	//							ctrlpos.x = ctrlwinpos.x;
	//							ctrlpos.y = ctrlwinpos.y;

	//							//s_dsutgui0[s_curdsutguino]->GetLocation(&ctrlpos);
	//							//UINT type = s_dsutgui0[s_curdsutguino]->GetType();
	//							if (s_dmpanimWnd && IsWindow(s_dmpanimWnd->getHWnd()) &&
	//								(s_curdsdampctrlno >= 0) && (s_curdsdampctrlno < s_dsdampctrls.size()) && (s_dsdampctrls[s_curdsdampctrlno])) {

	//								bool isslider;
	//								isslider = ((OrgWinGUI::OrgWindowParts*)s_dsdampctrls[s_curdsdampctrlno])->getIsSlider();
	//								if (isslider) {
	//									//sizex : 350, sizey : 20, window with 450

	//									double minval;
	//									double maxval;
	//									double curval;
	//									double length;
	//									minval = ((OrgWinGUI::OWP_Slider*)s_dsdampctrls[s_curdsdampctrlno])->getMinValue();
	//									maxval = ((OrgWinGUI::OWP_Slider*)s_dsdampctrls[s_curdsdampctrlno])->getMaxValue();
	//									curval = ((OrgWinGUI::OWP_Slider*)s_dsdampctrls[s_curdsdampctrlno])->getValue();
	//									length = maxval - minval;
	//									if (length != 0.0) {
	//										double rate;
	//										rate = (curval - minval) / length;
	//										//ctrlpos.x += (LONG)(350.0 * rate);
	//										//pos1x+ (int)((value - minValue) * (float)(pos2x - pos1x) / (maxValue - minValue) + 0.5f);
	//										int pos2xpos1x = 450 - 6 - 65 - 5;
	//										ctrlpos.x += (5 + (int)((curval - minval) * (float)(pos2xpos1x) / (maxval - minval) + 0.5f));//LABEL_SIZE_X : 65.0, AXIS_POS_X : 5.0
	//										ctrlpos.y += (int)(20.0 / 2.0);
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//									else {
	//										//if button
	//										ctrlpos.x += 6;
	//										ctrlpos.y += 6;
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//								}
	//								else {
	//									//if button
	//									ctrlpos.x += 6;
	//									ctrlpos.y += 6;
	//									//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//								}

	//								WindowPos damppos;
	//								damppos = s_dmpanimWnd->getPos();
	//								ctrlpos.x += damppos.x;
	//								ctrlpos.y += damppos.y;
	//								::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//							}
	//						}

	//						//if (s_owpTimeline) {
	//						//	s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
	//						//}
	//						//ChangeCurrentBone();
	//					}

	//				}
	//			}
	//		}
	//	}
	//}

}

void DSCrossButtonSelectGPCtrls(bool firstctrlselect)
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!s_gpWnd) {
		return;
	}

	////select control
	////十字キー移動ブロック
	//{
	//	if ((s_currentwndid == MB3D_WND_SIDE) && (s_currenthwnd != 0)) {


	//		int parentbuttonid = 4;
	//		int sisterbuttonid = 5;
	//		int childbuttonid = 6;
	//		int brotherbuttonid = 7;
	//		int accelaxisid1 = 4;//axisid
	//		int accelaxisid2 = 5;//axisid

	//		int parentbutton = 0;
	//		int sisterbutton = 0;
	//		int childbutton = 0;
	//		int brotherbutton = 0;
	//		int accelaxis1 = 0;
	//		int accelaxis2 = 0;

	//		parentbutton = s_dsbuttonup[parentbuttonid];
	//		sisterbutton = s_dsbuttonup[sisterbuttonid];
	//		childbutton = s_dsbuttonup[childbuttonid];
	//		brotherbutton = s_dsbuttonup[brotherbuttonid];

	//		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	//		bool changeflag = false;
	//		bool chkflag = false;

	//		//WS_TABSTOP
	//		//VK_TAB
	//		//WS_GROUP
	//		//または
	//		//HWND SetFocus(HWND hWnd);

	//		//static int s_curdsutguikind = 0;
	//		//static int s_curdsutguino = 0;

	//		if (firstctrlselect) {
	//			parentbutton = 0;
	//			sisterbutton = 0;
	//			childbutton = 0;
	//			brotherbutton = 0;

	//			accelaxis1 = 0;
	//			accelaxis2 = 0;

	//			changeflag = true;
	//			chkflag = true;
	//		}


	//		if (s_currentwndid == MB3D_WND_SIDE) {
	//			if (s_model && (s_curboneno >= 0)) {
	//				CBone* curbone = s_model->GetBoneByID(s_curboneno);
	//				int curdsctrlno = s_curdsgpctrlno;
	//				if (curbone) {

	//					if (parentbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsgpctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (sisterbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsgpctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (childbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsgpctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (brotherbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsgpctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}


	//					/*
	//					enum DXUT_CONTROL_TYPE
	//					{
	//						DXUT_CONTROL_BUTTON,
	//						DXUT_CONTROL_STATIC,
	//						DXUT_CONTROL_CHECKBOX,
	//						DXUT_CONTROL_RADIOBUTTON,
	//						DXUT_CONTROL_COMBOBOX,
	//						DXUT_CONTROL_SLIDER,
	//						DXUT_CONTROL_EDITBOX,
	//						DXUT_CONTROL_IMEEDITBOX,
	//						DXUT_CONTROL_LISTBOX,
	//						DXUT_CONTROL_SCROLLBAR,
	//					};
	//					*/
	//					if (chkflag && changeflag && (s_curboneno >= 0)) {
	//						if (((curdsctrlno) >= 0) && ((curdsctrlno) < s_dsgpctrls.size())) {
	//							s_curdsgpctrlno = curdsctrlno;

	//							OrgWinGUI::WindowPos ctrlwinpos;
	//							POINT ctrlpos = { 0, 0 };
	//							ctrlwinpos = s_dsgpctrls[s_curdsgpctrlno]->getPos();
	//							ctrlpos.x = ctrlwinpos.x;
	//							ctrlpos.y = ctrlwinpos.y;

	//							//s_dsutgui0[s_curdsutguino]->GetLocation(&ctrlpos);
	//							//UINT type = s_dsutgui0[s_curdsutguino]->GetType();
	//							if (s_gpWnd && IsWindow(s_gpWnd->getHWnd()) &&
	//								(s_curdsgpctrlno >= 0) && (s_curdsgpctrlno < s_dsgpctrls.size()) && (s_dsgpctrls[s_curdsgpctrlno])) {

	//								bool isslider;
	//								isslider = ((OrgWinGUI::OrgWindowParts*)s_dsgpctrls[s_curdsgpctrlno])->getIsSlider();
	//								if (isslider) {
	//									//sizex : 350, sizey : 20, window with 450

	//									double minval;
	//									double maxval;
	//									double curval;
	//									double length;
	//									minval = ((OrgWinGUI::OWP_Slider*)s_dsgpctrls[s_curdsgpctrlno])->getMinValue();
	//									maxval = ((OrgWinGUI::OWP_Slider*)s_dsgpctrls[s_curdsgpctrlno])->getMaxValue();
	//									curval = ((OrgWinGUI::OWP_Slider*)s_dsgpctrls[s_curdsgpctrlno])->getValue();
	//									length = maxval - minval;
	//									if (length != 0.0) {
	//										double rate;
	//										rate = (curval - minval) / length;
	//										//ctrlpos.x += (LONG)(350.0 * rate);
	//										//pos1x+ (int)((value - minValue) * (float)(pos2x - pos1x) / (maxValue - minValue) + 0.5f);
	//										int pos2xpos1x = 450 - 6 - 65 - 5;
	//										ctrlpos.x += (5 + (int)((curval - minval) * (float)(pos2xpos1x) / (maxval - minval) + 0.5f));//LABEL_SIZE_X : 65.0, AXIS_POS_X : 5.0
	//										ctrlpos.y += (int)(20.0 / 2.0);
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//									else {
	//										//if button
	//										ctrlpos.x += 6;
	//										ctrlpos.y += 6;
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//								}
	//								else {
	//									//if button
	//									ctrlpos.x += 6;
	//									ctrlpos.y += 6;
	//									//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//								}

	//								WindowPos gppos;
	//								gppos = s_gpWnd->getPos();
	//								ctrlpos.x += gppos.x;
	//								ctrlpos.y += gppos.y;
	//								::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//							}
	//						}

	//						//if (s_owpTimeline) {
	//						//	s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
	//						//}
	//						//ChangeCurrentBone();
	//					}

	//				}
	//			}
	//		}
	//	}
	//}

}
void DSCrossButtonSelectImpulseCtrls(bool firstctrlselect)
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!s_impWnd) {
		return;
	}

	////select control
	////十字キー移動ブロック
	//{
	//	if ((s_currentwndid == MB3D_WND_SIDE) && (s_currenthwnd != 0)) {


	//		int parentbuttonid = 4;
	//		int sisterbuttonid = 5;
	//		int childbuttonid = 6;
	//		int brotherbuttonid = 7;
	//		int accelaxisid1 = 4;//axisid
	//		int accelaxisid2 = 5;//axisid

	//		int parentbutton = 0;
	//		int sisterbutton = 0;
	//		int childbutton = 0;
	//		int brotherbutton = 0;
	//		int accelaxis1 = 0;
	//		int accelaxis2 = 0;

	//		parentbutton = s_dsbuttonup[parentbuttonid];
	//		sisterbutton = s_dsbuttonup[sisterbuttonid];
	//		childbutton = s_dsbuttonup[childbuttonid];
	//		brotherbutton = s_dsbuttonup[brotherbuttonid];

	//		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	//		bool changeflag = false;
	//		bool chkflag = false;

	//		//WS_TABSTOP
	//		//VK_TAB
	//		//WS_GROUP
	//		//または
	//		//HWND SetFocus(HWND hWnd);

	//		//static int s_curdsutguikind = 0;
	//		//static int s_curdsutguino = 0;

	//		if (firstctrlselect) {
	//			parentbutton = 0;
	//			sisterbutton = 0;
	//			childbutton = 0;
	//			brotherbutton = 0;

	//			accelaxis1 = 0;
	//			accelaxis2 = 0;

	//			changeflag = true;
	//			chkflag = true;
	//		}


	//		if (s_currentwndid == MB3D_WND_SIDE) {
	//			if (s_model && (s_curboneno >= 0)) {
	//				CBone* curbone = s_model->GetBoneByID(s_curboneno);
	//				int curdsctrlno = s_curdsimpulsectrlno;
	//				if (curbone) {

	//					if (parentbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsimpulsectrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (sisterbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsimpulsectrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (childbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsimpulsectrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (brotherbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsimpulsectrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}


	//					/*
	//					enum DXUT_CONTROL_TYPE
	//					{
	//						DXUT_CONTROL_BUTTON,
	//						DXUT_CONTROL_STATIC,
	//						DXUT_CONTROL_CHECKBOX,
	//						DXUT_CONTROL_RADIOBUTTON,
	//						DXUT_CONTROL_COMBOBOX,
	//						DXUT_CONTROL_SLIDER,
	//						DXUT_CONTROL_EDITBOX,
	//						DXUT_CONTROL_IMEEDITBOX,
	//						DXUT_CONTROL_LISTBOX,
	//						DXUT_CONTROL_SCROLLBAR,
	//					};
	//					*/
	//					if (chkflag && changeflag && (s_curboneno >= 0)) {
	//						if (((curdsctrlno) >= 0) && ((curdsctrlno) < s_dsimpulsectrls.size())) {
	//							s_curdsimpulsectrlno = curdsctrlno;

	//							OrgWinGUI::WindowPos ctrlwinpos;
	//							POINT ctrlpos = { 0, 0 };
	//							ctrlwinpos = s_dsimpulsectrls[s_curdsimpulsectrlno]->getPos();
	//							ctrlpos.x = ctrlwinpos.x;
	//							ctrlpos.y = ctrlwinpos.y;

	//							//s_dsutgui0[s_curdsutguino]->GetLocation(&ctrlpos);
	//							//UINT type = s_dsutgui0[s_curdsutguino]->GetType();
	//							if (s_impWnd && IsWindow(s_impWnd->getHWnd()) &&
	//								(s_curdsimpulsectrlno >= 0) && (s_curdsimpulsectrlno < s_dsimpulsectrls.size()) && (s_dsimpulsectrls[s_curdsimpulsectrlno])) {

	//								bool isslider;
	//								isslider = ((OrgWinGUI::OrgWindowParts*)s_dsimpulsectrls[s_curdsimpulsectrlno])->getIsSlider();
	//								if (isslider) {
	//									//sizex : 350, sizey : 20, window with 450

	//									double minval;
	//									double maxval;
	//									double curval;
	//									double length;
	//									minval = ((OrgWinGUI::OWP_Slider*)s_dsimpulsectrls[s_curdsimpulsectrlno])->getMinValue();
	//									maxval = ((OrgWinGUI::OWP_Slider*)s_dsimpulsectrls[s_curdsimpulsectrlno])->getMaxValue();
	//									curval = ((OrgWinGUI::OWP_Slider*)s_dsimpulsectrls[s_curdsimpulsectrlno])->getValue();
	//									length = maxval - minval;
	//									if (length != 0.0) {
	//										double rate;
	//										rate = (curval - minval) / length;
	//										//ctrlpos.x += (LONG)(350.0 * rate);
	//										//pos1x+ (int)((value - minValue) * (float)(pos2x - pos1x) / (maxValue - minValue) + 0.5f);
	//										int pos2xpos1x = 450 - 6 - 65 - 5;
	//										ctrlpos.x += (5 + (int)((curval - minval) * (float)(pos2xpos1x) / (maxval - minval) + 0.5f));//LABEL_SIZE_X : 65.0, AXIS_POS_X : 5.0
	//										ctrlpos.y += (int)(20.0 / 2.0);
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//									else {
	//										//if button
	//										ctrlpos.x += 6;
	//										ctrlpos.y += 6;
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//								}
	//								else {
	//									//if button
	//									ctrlpos.x += 6;
	//									ctrlpos.y += 6;
	//									//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//								}

	//								WindowPos impulsepos;
	//								impulsepos = s_impWnd->getPos();
	//								ctrlpos.x += impulsepos.x;
	//								ctrlpos.y += impulsepos.y;
	//								::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//							}
	//						}

	//						//if (s_owpTimeline) {
	//						//	s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
	//						//}
	//						//ChangeCurrentBone();
	//					}

	//				}
	//			}
	//		}
	//	}
	//}

}

void DSCrossButtonSelectRigidCtrls(bool firstctrlselect)
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!s_rigidWnd) {
		return;
	}

	////select control
	////十字キー移動ブロック
	//{
	//	if ((s_currentwndid == MB3D_WND_SIDE) && (s_currenthwnd != 0)) {


	//		int parentbuttonid = 4;
	//		int sisterbuttonid = 5;
	//		int childbuttonid = 6;
	//		int brotherbuttonid = 7;
	//		int accelaxisid1 = 4;//axisid
	//		int accelaxisid2 = 5;//axisid

	//		int parentbutton = 0;
	//		int sisterbutton = 0;
	//		int childbutton = 0;
	//		int brotherbutton = 0;
	//		int accelaxis1 = 0;
	//		int accelaxis2 = 0;

	//		parentbutton = s_dsbuttonup[parentbuttonid];
	//		sisterbutton = s_dsbuttonup[sisterbuttonid];
	//		childbutton = s_dsbuttonup[childbuttonid];
	//		brotherbutton = s_dsbuttonup[brotherbuttonid];

	//		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	//		bool changeflag = false;
	//		bool chkflag = false;

	//		//WS_TABSTOP
	//		//VK_TAB
	//		//WS_GROUP
	//		//または
	//		//HWND SetFocus(HWND hWnd);

	//		//static int s_curdsutguikind = 0;
	//		//static int s_curdsutguino = 0;

	//		if (firstctrlselect) {
	//			parentbutton = 0;
	//			sisterbutton = 0;
	//			childbutton = 0;
	//			brotherbutton = 0;

	//			accelaxis1 = 0;
	//			accelaxis2 = 0;

	//			changeflag = true;
	//			chkflag = true;
	//		}



	//		if (s_currentwndid == MB3D_WND_SIDE) {
	//			if (s_model && (s_curboneno >= 0)) {
	//				CBone* curbone = s_model->GetBoneByID(s_curboneno);
	//				int curdsctrlno = s_curdsrigidctrlno;
	//				if (curbone) {

	//					if (parentbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsrigidctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (sisterbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsrigidctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (childbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dsrigidctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (brotherbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dsrigidctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}


	//					/*
	//					enum DXUT_CONTROL_TYPE
	//					{
	//						DXUT_CONTROL_BUTTON,
	//						DXUT_CONTROL_STATIC,
	//						DXUT_CONTROL_CHECKBOX,
	//						DXUT_CONTROL_RADIOBUTTON,
	//						DXUT_CONTROL_COMBOBOX,
	//						DXUT_CONTROL_SLIDER,
	//						DXUT_CONTROL_EDITBOX,
	//						DXUT_CONTROL_IMEEDITBOX,
	//						DXUT_CONTROL_LISTBOX,
	//						DXUT_CONTROL_SCROLLBAR,
	//					};
	//					*/
	//					if (chkflag && changeflag && (s_curboneno >= 0)) {
	//						if (((curdsctrlno) >= 0) && ((curdsctrlno) < s_dsrigidctrls.size())) {
	//							s_curdsrigidctrlno = curdsctrlno;

	//							OrgWinGUI::WindowPos ctrlwinpos;
	//							POINT ctrlpos = { 0, 0 };
	//							ctrlwinpos = s_dsrigidctrls[s_curdsrigidctrlno]->getPos();
	//							ctrlpos.x = ctrlwinpos.x;
	//							ctrlpos.y = ctrlwinpos.y;

	//							//s_dsutgui0[s_curdsutguino]->GetLocation(&ctrlpos);
	//							//UINT type = s_dsutgui0[s_curdsutguino]->GetType();
	//							if (s_rigidWnd && IsWindow(s_rigidWnd->getHWnd()) &&
	//								(s_curdsrigidctrlno >= 0) && (s_curdsrigidctrlno < s_dsrigidctrls.size()) && (s_dsrigidctrls[s_curdsrigidctrlno])) {

	//								bool isslider;
	//								isslider = ((OrgWinGUI::OrgWindowParts*)s_dsrigidctrls[s_curdsrigidctrlno])->getIsSlider();
	//								if (isslider) {
	//									//sizex : 350, sizey : 20, window with 450

	//									double minval;
	//									double maxval;
	//									double curval;
	//									double length;
	//									minval = ((OrgWinGUI::OWP_Slider*)s_dsrigidctrls[s_curdsrigidctrlno])->getMinValue();
	//									maxval = ((OrgWinGUI::OWP_Slider*)s_dsrigidctrls[s_curdsrigidctrlno])->getMaxValue();
	//									curval = ((OrgWinGUI::OWP_Slider*)s_dsrigidctrls[s_curdsrigidctrlno])->getValue();
	//									length = maxval - minval;
	//									if (length != 0.0) {
	//										double rate;
	//										rate = (curval - minval) / length;
	//										//ctrlpos.x += (LONG)(350.0 * rate);
	//										//pos1x+ (int)((value - minValue) * (float)(pos2x - pos1x) / (maxValue - minValue) + 0.5f);
	//										int pos2xpos1x = 450 - 6 - 65 - 5;
	//										ctrlpos.x += (5 + (int)((curval - minval) * (float)(pos2xpos1x) / (maxval - minval) + 0.5f));//LABEL_SIZE_X : 65.0, AXIS_POS_X : 5.0
	//										ctrlpos.y += (int)(20.0 / 2.0);
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//									else {
	//										//if button
	//										ctrlpos.x += 6;
	//										ctrlpos.y += 6;
	//										//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//									}
	//								}
	//								else {
	//									//if button
	//									ctrlpos.x += 6;
	//									ctrlpos.y += 6;
	//									//ClientToScreen(s_rigidWnd->getHWnd(), &ctrlpos);
	//								}

	//								WindowPos rigidpos;
	//								rigidpos = s_rigidWnd->getPos();
	//								ctrlpos.x += rigidpos.x;
	//								ctrlpos.y += rigidpos.y;
	//								::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//							}
	//						}

	//						//if (s_owpTimeline) {
	//						//	s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
	//						//}
	//						//ChangeCurrentBone();
	//					}

	//				}
	//			}
	//		}
	//	}
	//}

}

void DSCrossButtonSelectToolCtrls(bool firstctrlselect)
{


	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!s_toolWnd) {
		return;
	}

	////select control
	////十字キー移動ブロック
	//{
	//	if ((s_currentwndid == MB3D_WND_TOOL) && (s_currenthwnd != 0)) {


	//		int parentbuttonid = 4;
	//		int sisterbuttonid = 5;
	//		int childbuttonid = 6;
	//		int brotherbuttonid = 7;
	//		int accelaxisid1 = 4;//axisid
	//		int accelaxisid2 = 5;//axisid

	//		int parentbutton = 0;
	//		int sisterbutton = 0;
	//		int childbutton = 0;
	//		int brotherbutton = 0;
	//		int accelaxis1 = 0;
	//		int accelaxis2 = 0;

	//		parentbutton = s_dsbuttonup[parentbuttonid];
	//		sisterbutton = s_dsbuttonup[sisterbuttonid];
	//		childbutton = s_dsbuttonup[childbuttonid];
	//		brotherbutton = s_dsbuttonup[brotherbuttonid];

	//		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	//		bool changeflag = false;
	//		bool chkflag = false;

	//		//WS_TABSTOP
	//		//VK_TAB
	//		//WS_GROUP
	//		//または
	//		//HWND SetFocus(HWND hWnd);

	//		//static int s_curdsutguikind = 0;
	//		//static int s_curdsutguino = 0;

	//		if (firstctrlselect) {
	//			parentbutton = 0;
	//			sisterbutton = 0;
	//			childbutton = 0;
	//			brotherbutton = 0;

	//			accelaxis1 = 0;
	//			accelaxis2 = 0;

	//			changeflag = true;
	//			chkflag = true;
	//		}


	//		if (s_currentwndid == MB3D_WND_TOOL) {
	//			if (s_model && (s_curboneno >= 0)) {
	//				CBone* curbone = s_model->GetBoneByID(s_curboneno);
	//				int curdsctrlno = s_curdstoolctrlno;
	//				if (curbone) {

	//					if (parentbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dstoolctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (sisterbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dstoolctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (childbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= (int)s_dstoolctrls.size()) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (brotherbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = (int)s_dstoolctrls.size() - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}


	//					/*
	//					enum DXUT_CONTROL_TYPE
	//					{
	//						DXUT_CONTROL_BUTTON,
	//						DXUT_CONTROL_STATIC,
	//						DXUT_CONTROL_CHECKBOX,
	//						DXUT_CONTROL_RADIOBUTTON,
	//						DXUT_CONTROL_COMBOBOX,
	//						DXUT_CONTROL_SLIDER,
	//						DXUT_CONTROL_EDITBOX,
	//						DXUT_CONTROL_IMEEDITBOX,
	//						DXUT_CONTROL_LISTBOX,
	//						DXUT_CONTROL_SCROLLBAR,
	//					};
	//					*/
	//					if (chkflag && changeflag && (s_curboneno >= 0)) {
	//						if (((curdsctrlno) >= 0) && ((curdsctrlno) < s_dstoolctrls.size())) {
	//							s_curdstoolctrlno = curdsctrlno;

	//							OrgWinGUI::WindowPos ctrlwinpos;
	//							POINT ctrlpos = { 0, 0 };
	//							ctrlwinpos = s_dstoolctrls[s_curdstoolctrlno]->getPos();
	//							ctrlpos.x = ctrlwinpos.x;
	//							ctrlpos.y = ctrlwinpos.y;


	//							//if button
	//							ctrlpos.x += 6;
	//							ctrlpos.y += 6;


	//							//s_dsutgui0[s_curdsutguino]->GetLocation(&ctrlpos);
	//							//UINT type = s_dsutgui0[s_curdsutguino]->GetType();
	//							if (s_toolWnd && IsWindow(s_toolWnd->getHWnd())) {
	//								ClientToScreen(s_toolWnd->getHWnd(), &ctrlpos);
	//								::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//							}
	//						}

	//						//if (s_owpTimeline) {
	//						//	s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
	//						//}
	//						//ChangeCurrentBone();
	//					}

	//				}
	//			}
	//		}
	//	}
	//}

}


void DSCrossButtonSelectPlayerBtns(bool firstctrlselect)
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!s_LtimelineWnd) {
		return;
	}

	if (!s_owpPlayerButton) {
		return;
	}


	////select control
	////十字キー移動ブロック
	//{
	//	if ((s_currentwndid == MB3D_WND_TIMELINE) && (s_currenthwnd != 0)) {


	//		int parentbuttonid = 4;
	//		int sisterbuttonid = 5;
	//		int childbuttonid = 6;
	//		int brotherbuttonid = 7;
	//		int accelaxisid1 = 4;//axisid
	//		int accelaxisid2 = 5;//axisid

	//		int parentbutton = 0;
	//		int sisterbutton = 0;
	//		int childbutton = 0;
	//		int brotherbutton = 0;
	//		int accelaxis1 = 0;
	//		int accelaxis2 = 0;

	//		parentbutton = s_dsbuttonup[parentbuttonid];
	//		sisterbutton = s_dsbuttonup[sisterbuttonid];
	//		childbutton = s_dsbuttonup[childbuttonid];
	//		brotherbutton = s_dsbuttonup[brotherbuttonid];

	//		accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//		accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	//		bool changeflag = false;
	//		bool chkflag = false;

	//		//WS_TABSTOP
	//		//VK_TAB
	//		//WS_GROUP
	//		//または
	//		//HWND SetFocus(HWND hWnd);

	//		//static int s_curdsutguikind = 0;
	//		//static int s_curdsutguino = 0;

	//		if (firstctrlselect) {
	//			parentbutton = 0;
	//			sisterbutton = 0;
	//			childbutton = 0;
	//			brotherbutton = 0;

	//			accelaxis1 = 0;
	//			accelaxis2 = 0;

	//			changeflag = true;
	//			chkflag = true;
	//		}


	//		if (s_currentwndid == MB3D_WND_TIMELINE) {
	//			if (s_model && (s_curboneno >= 0)) {
	//				CBone* curbone = s_model->GetBoneByID(s_curboneno);
	//				int curdsctrlno = s_curdsplayerbtnno;
	//				if (curbone) {

	//					if (parentbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = SPPLAYERBUTTONNUM - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (sisterbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= SPPLAYERBUTTONNUM) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (childbutton >= 1) {
	//						curdsctrlno++;
	//						if (curdsctrlno >= SPPLAYERBUTTONNUM) {
	//							curdsctrlno = 0;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}
	//					else if (brotherbutton >= 1) {
	//						curdsctrlno--;
	//						if (curdsctrlno < 0) {
	//							curdsctrlno = SPPLAYERBUTTONNUM - 1;//Ring
	//						}
	//						changeflag = true;
	//						chkflag = true;
	//					}


	//					/*
	//					enum DXUT_CONTROL_TYPE
	//					{
	//						DXUT_CONTROL_BUTTON,
	//						DXUT_CONTROL_STATIC,
	//						DXUT_CONTROL_CHECKBOX,
	//						DXUT_CONTROL_RADIOBUTTON,
	//						DXUT_CONTROL_COMBOBOX,
	//						DXUT_CONTROL_SLIDER,
	//						DXUT_CONTROL_EDITBOX,
	//						DXUT_CONTROL_IMEEDITBOX,
	//						DXUT_CONTROL_LISTBOX,
	//						DXUT_CONTROL_SCROLLBAR,
	//					};
	//					*/
	//					if (chkflag && changeflag && (s_curboneno >= 0)) {
	//						if (((curdsctrlno) >= 0) && ((curdsctrlno) < SPPLAYERBUTTONNUM)) {
	//							s_curdsplayerbtnno = curdsctrlno;

	//							OrgWinGUI::WindowPos ctrlwinpos;
	//							POINT ctrlpos = { 0, 0 };
	//							ctrlwinpos = s_owpPlayerButton->getButtonPos(s_curdsplayerbtnno);
	//							ctrlpos.x = ctrlwinpos.x;
	//							ctrlpos.y = ctrlwinpos.y;

	//							//if button
	//							//ctrlpos.x += 10;
	//							//ctrlpos.y += 10;


	//							//s_dsutgui0[s_curdsutguino]->GetLocation(&ctrlpos);
	//							//UINT type = s_dsutgui0[s_curdsutguino]->GetType();
	//							if (s_owpPlayerButton && s_LtimelineWnd && IsWindow(s_LtimelineWnd->getHWnd())) {
	//								ClientToScreen(s_LtimelineWnd->getHWnd(), &ctrlpos);
	//								::SetCursorPos(ctrlpos.x, ctrlpos.y);
	//							}
	//						}

	//						//if (s_owpTimeline) {
	//						//	s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
	//						//}
	//						//ChangeCurrentBone();
	//					}

	//				}
	//			}
	//		}
	//	}
	//}

}


void DSAxisRMainMenuBar()
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	//POINT cursorpos;
	//::GetCursorPos(&cursorpos);

	//int upbutton;
	//int downbutton;
	//int leftbutton;
	//int rightbutton;
	//int accelaxisid1 = 4;//axisid
	//int accelaxisid2 = 5;//axisid
	//bool accelaxis1 = 0;
	//bool accelaxis2 = 0;
	//bool accelflag = false;
	//bool accelbothflag = false;

	//upbutton = s_dsaxisMOverSrh[1];
	//downbutton = s_dsaxisOverSrh[1];
	//leftbutton = s_dsaxisMOverSrh[0];
	//rightbutton = s_dsaxisOverSrh[0];

	//accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));
	//accelflag = accelaxis1 || accelaxis2;
	//accelbothflag = accelaxis1 && accelaxis2;


	////if (s_undertrackingRMenu == 0) {
	//bool changeflag = false;

	//int delta = 1;
	////if (accelflag) {
	////	delta = 4;
	////}
	////else {
	////	delta = 2;
	////}



	//int nextsubmenuid;

	//nextsubmenuid = g_currentsubmenuid;

	//if (upbutton >= 1) {
	//	changeflag = true;
	//}
	//if (downbutton >= 1) {
	//	changeflag = true;
	//}
	//if (leftbutton >= 1) {
	//	nextsubmenuid -= delta;
	//	changeflag = true;
	//}
	//if (rightbutton >= 1) {
	//	nextsubmenuid += delta;
	//	changeflag = true;
	//}

	//if (nextsubmenuid >= SPMENU_MAX) {
	//	nextsubmenuid = 0;//ring
	//}
	//if (nextsubmenuid < 0) {
	//	nextsubmenuid = (SPMENU_MAX - 1);//ring
	//}

	//if (changeflag == true) {

	//	if (g_undertrackingRMenu == 1) {
	//		//多重トラックポップアップ禁止（多重ポップアップするとプログラムからマウス移動できなくなる）
	//		return;
	//	}


	//	SelectNextWindow(MB3D_WND_MAIN);//MainMenuAimBarWndをハイライト


	//	g_currentsubmenuid = nextsubmenuid;
	//	s_currentsubmenuitemid = 0;


	//	if ((g_currentsubmenuid >= 0) && (g_currentsubmenuid < SPMENU_MAX)) {

	//		HMENU mainmenu;
	//		mainmenu = GetMenu(g_mainhwnd);
	//		int menuno = g_currentsubmenuid;
	//		s_cursubmenu = GetSubMenu(mainmenu, menuno);
	//		if (s_cursubmenu) {
	//			int curmenuitemid;
	//			curmenuitemid = ::GetMenuItemID(s_cursubmenu, 0);
	//			if (curmenuitemid >= 0) {
	//				RECT rc;
	//				GetMenuItemRect(g_mainhwnd, mainmenu, menuno, &rc);//rcはスクリーン座標
	//				g_submenuwidth = rc.right - rc.left;//org:140

	//				::SetCursorPos(rc.left, rc.bottom + 22);
	//				g_currentsubmenupos.x = rc.left;
	//				g_currentsubmenupos.y = rc.bottom + 16;

	//				Sleep(200);
	//			}
	//		}
	//	}



	//	//HMENU mainmenu;
	//	////HMENU cursubmenu;
	//	//mainmenu = GetMenu(g_mainhwnd);
	//	//s_cursubmenu = GetSubMenu(mainmenu, g_currentsubmenuid);
	//	//if (s_cursubmenu) {
	//	//	int curmenuitemid;
	//	//	curmenuitemid = ::GetMenuItemID(s_cursubmenu, 0);
	//	//	if (curmenuitemid >= 0) {
	//	//		
	//	//		//::SendMessage(g_mainhwnd, WM_NOTIFY, 0, (LPARAM)&nmtoolbara);
	//	//		////::SendMessage(g_mainhwnd, WM_COMMAND, curmenuitemid, 0);//選択決定時のコマンド

	//	//		RECT rc;
	//	//		TPMPARAMS tpm;
	//	//		GetMenuItemRect(g_mainhwnd, mainmenu, g_currentsubmenuid, &rc);
	//	//		tpm.cbSize = sizeof(TPMPARAMS);//
	//	//		tpm.rcExclude = rc;//

	//	//		POINT mousepoint;
	//	//		mousepoint.x = rc.left + 30;
	//	//		mousepoint.y = rc.bottom + 10;
	//	//		::SetCursorPos(mousepoint.x, mousepoint.y);

	//	//		//HMENU hMenuLoaded = LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_MENU1));//
	//	//		//HMENU hPopupMenu = GetSubMenu(s_mainmenu, g_currentsubmenuid);//
	//	//		InterlockedExchange(&g_undertrackingRMenu, 1);

	//	//		//#################
	//	//		//選択決定成功例その２
	//	//		//#################
	//	//		//第2項目（インデックス値 = 1, ID = 0x2711）を選択したところ、
	//	//		//wParam = 0x00012711
	//	//		//のように、上位2バイトにインデックス値が、下位2バイトにIDが入ります。
	//	//		//WPARAM wparam;
	//	//		//wparam = (g_currentsubmenuid << 16) | curmenuitemid;
	//	//		//LPARAM lparam;
	//	//		//lparam = (LPARAM)mainmenu;
	//	//		//::SendMessage(g_mainhwnd, WM_COMMAND, wparam, lparam);



	//	//		//wparam = ((MF_POPUP | MF_MOUSESELECT) << 16) | (WORD)g_currentsubmenuid;//g_currentsubmenuid, curmenuitemid
	//	//		//::SendMessage(g_mainhwnd, WM_MENUSELECT, wparam, (LPARAM)mainmenu);//GetMenu(g_mainhwnd), cursubmenu




	//	//		//TrackPopupMenuEx(cursubmenu, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_VERTICAL,
	//	//		//	rc.left, rc.bottom, g_mainhwnd, &tpm);//
	//	//		//SetCapture(s_3dwnd);

	//	//		SetForegroundWindow(g_mainhwnd);//この処理をしないと範囲外クリックでPopupが閉じない

	//	//		int retmenuid = ::TrackPopupMenu(s_cursubmenu, TPM_RETURNCMD | TPM_LEFTALIGN, rc.left, rc.bottom, 0, g_mainhwnd, NULL);

	//	//		//ReleaseCapture();

	//	//		InterlockedExchange(&g_undertrackingRMenu, 0);

	//	//		//int retmenuid = ::TrackPopupMenu(hPopupMenu, TPM_RETURNCMD | TPM_LEFTALIGN, pt.x, pt.y, 0, m_menuwnd, NULL);
	//	//		//DestroyMenu(hMenuLoaded);//
	//	//	}
	//	//}

	//	//LPARAM lparam;
	//	//lparam = (cursorpos.y << 16) | cursorpos.x;

	//	//HWND desktopwnd;
	//	//desktopwnd = ::GetDesktopWindow();
	//	//if (desktopwnd) {
	//	//	RECT desktoprect;
	//	//	::GetClientRect(desktopwnd, &desktoprect);
	//	//	::ClipCursor(&desktoprect);


	//	//	::SetCursorPos(cursorpos.x, cursorpos.y);
	//	//	//::SetCursorPos(cursorpos.x, cursorpos.y);

	//	//	if (s_3dwnd) {
	//	//		POINT client3dpoint;
	//	//		client3dpoint = cursorpos;
	//	//		::ScreenToClient(s_3dwnd, &client3dpoint);
	//	//		LPARAM threelparam;
	//	//		threelparam = (client3dpoint.y << 16) | client3dpoint.x;
	//	//		::SendMessage(s_3dwnd, WM_MOUSEMOVE, 0, threelparam);
	//	//	}
	//	//	if (g_mainhwnd) {
	//	//		POINT clientpoint;
	//	//		clientpoint = cursorpos;
	//	//		::ScreenToClient(g_mainhwnd, &clientpoint);
	//	//		LPARAM mainlparam;
	//	//		mainlparam = (clientpoint.y << 16) | clientpoint.x;
	//	//		::SendMessage(g_mainhwnd, WM_MOUSEMOVE, 0, mainlparam);
	//	//	}
	//	//	HWND dlghwnd;
	//	//	dlghwnd = g_SampleUI.GetHWnd();
	//	//	if (dlghwnd) {
	//	//		POINT clientpoint;
	//	//		clientpoint = cursorpos;
	//	//		::ScreenToClient(dlghwnd, &clientpoint);
	//	//		LPARAM dlglparam;
	//	//		dlglparam = (clientpoint.y << 16) | clientpoint.x;
	//	//		::SendMessage(dlghwnd, WM_MOUSEMOVE, 0, dlglparam);
	//	//	}
	//	//
	//	//	//::SendMessage(desktopwnd, WM_MOUSEMOVE, 0, (LPARAM)lparam);
	//	//}
	//}

}

void DSAxisLSelectingPopupMenu()
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	//if (!s_cursubmenu) {
	//	return;
	//}

	//int upbutton;
	//int downbutton;
	//int leftbutton;
	//int rightbutton;
	//int accelaxisid1 = 4;//axisid
	//int accelaxisid2 = 5;//axisid
	//bool accelaxis1 = 0;
	//bool accelaxis2 = 0;
	//bool accelflag = false;
	//bool accelbothflag = false;

	//upbutton = s_dsaxisMOverSrh[3];
	//downbutton = s_dsaxisOverSrh[3];
	//leftbutton = s_dsaxisMOverSrh[2];
	//rightbutton = s_dsaxisOverSrh[2];

	//accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));
	//accelflag = accelaxis1 || accelaxis2;

	////if (s_undertrackingRMenu == 0) {
	//bool changeflag = false;
	//int currentsubmenuitemid;
	//currentsubmenuitemid = s_currentsubmenuitemid;

	//int delta = 0;

	//if (upbutton >= 1) {
	//	currentsubmenuitemid -= 1;
	//	changeflag = true;
	//}
	//if (downbutton >= 1) {
	//	currentsubmenuitemid += 1;
	//	changeflag = true;
	//}


	//int submenuitemnum;
	//submenuitemnum = GetMenuItemCount(s_cursubmenu);


	//if (currentsubmenuitemid >= submenuitemnum) {
	//	currentsubmenuitemid = 0;//ring
	//}
	//if (currentsubmenuitemid < 0) {
	//	currentsubmenuitemid = submenuitemnum - 1;//ring
	//}

	///*
	//typedef struct tagMENUITEMINFO {
	//	UINT    cbSize;
	//	UINT    fMask;
	//	UINT    fType;
	//	UINT    fState;
	//	UINT    wID;
	//	HMENU   hSubMenu;
	//	HBITMAP hbmpChecked;
	//	HBITMAP hbmpUnchecked;
	//	DWORD   dwItemData;
	//	LPTSTR  dwTypeData;
	//	UINT    cch;
	//} MENUITEMINFO, FAR* LPMENUITEMINFO;
	//cbSize は、この構造体のサイズをバイト単位


	//fState は、メニュー項目の状態を表す定数を組み合わせて指定します
	//定数は、次のものを指定できます
	//定数	解説
	//MFS_CHECKED	項目をチェックする
	//MFS_DEFAULT	項目はデフォルトである
	//MFS_DISABLED	項目を無効状態にする
	//MFS_ENABLED	項目を有効状態にする（デフォルト）
	//MFS_GRAYED	項目をグレー状態にする
	//MFS_HILITE	項目をハイライト状態にする//#################
	//MFS_UNCHECKED	項目のチェックを外す
	//MFS_UNHILITE	項目のハイライトを削除する

	//fByPosition が TRUE ならば uItem はインデックスだと判断し
	//FALSE ならば、uItem がメニューアイテムの ID であると判断されます

	//BOOL SetMenuItemInfo(
	//	HMENU hMenu , UINT uItem ,
	//	BOOL fByPosition , LPMENUITEMINFO lpmii
	//);

	//BOOL GetMenuItemInfo(
	//	HMENU hMenu , UINT uItem ,
	//	BOOL fByPosition , LPMENUITEMINFO lpmii
	//);

	//UINT GetMenuState(
	//  HMENU hMenu,
	//  UINT  uId,
	//  UINT  uFlags
	//);
	//*/

	////if (changeflag == true) {
	////	if (g_undertrackingRMenu == 1) {
	////		MENUITEMINFO menuiteminfo;
	////		ZeroMemory(&menuiteminfo, sizeof(MENUITEMINFO));
	////		menuiteminfo.cbSize = sizeof(MENUITEMINFO);


	////		//typedef struct tagMENUITEMINFO {
	////		//	UINT    cbSize;
	////		//	UINT    fMask;
	////		//	UINT    fType;
	////		//	UINT    fState;
	////		//	UINT    wID;
	////		//	HMENU   hSubMenu;
	////		//	HBITMAP hbmpChecked;
	////		//	HBITMAP hbmpUnchecked;
	////		//	DWORD   dwItemData;
	////		//	LPTSTR  dwTypeData;
	////		//	UINT    cch;
	////		//} MENUITEMINFO, FAR* LPMENUITEMINFO;


	////			/*
	////			IDR_MENU1 MENU
	////			BEGIN
	////				POPUP "File"
	////				BEGIN
	////					MENUITEM "Open",                        ID_FILE_OPEN40001
	////					POPUP "Save"
	////					BEGIN
	////						MENUITEM "Project(*.cha)",              ID_SAVEPROJ_40035
	////						MENUITEM "RigidParams(*ref)",           ID_RESAVE_40028
	////						MENUITEM "ImpulseParams(*.imp)",        ID_IMPSAVE_40030
	////						MENUITEM "GroundParams(*.gco)",         ID_SAVEGCOLI_40033
	////					END
	////					MENUITEM "bvh2FBX",                     ID_FILE_BVH2FBX
	////					MENUITEM "Export bnt",                  ID_FILE_EXPORTBNT
	////				END
	////				POPUP "表示(disp)"
	////				BEGIN
	////					MENUITEM "モーションウインドウ(motion)",          ID_DISPMW40002
	////					MENUITEM "ツールウインドウ(tool)",              4007
	////					MENUITEM "モデルパネル(model)",               40026
	////					MENUITEM "オブジェクトパネル(object)",           40012
	////					MENUITEM "地面オブジェクト(ground)",            ID_DISPGROUND
	////				END
	////				POPUP "モーション(motion)"
	////				BEGIN
	////					MENUITEM "新規空モーション(new empty)",         40004
	////					MENUITEM "編集中モーションの削除(del under editting)", 40006
	////					MENUITEM SEPARATOR
	////					POPUP "モーションの選択(select)"
	////					BEGIN
	////						MENUITEM "PlacingFolder",               ID_40062
	////					END
	////				END
	////				POPUP "モデル(model)"
	////				BEGIN
	////					MENUITEM "編集中のモデルを削除(del under editting)", ID_DELMODEL
	////					MENUITEM "全モデル削除(del all)",             ID_DELALLMODEL
	////					MENUITEM SEPARATOR
	////					POPUP "モデルの選択(select)"
	////					BEGIN
	////						MENUITEM "PlacingFolder",               0
	////					END
	////				END
	////				POPUP "編集・変換(edit, conv)"
	////				BEGIN
	////					MENUITEM "ボーン軸をXに再計算(RecalcAxisX)",     ID_40047
	////					MENUITEM "モーションのリターゲット(retarget)",      ID_40048
	////					MENUITEM "オイラー角　角度制限(limit euler)",     ID_40049
	////					MENUITEM "ボーン座標軸回転(rot axis)",          ID_40050
	////				END
	////				POPUP "剛体設定切り替え(select rigid)"
	////				BEGIN
	////					MENUITEM "PlacingFolder",               0
	////				END
	////				POPUP "ragdoll剛体選択(select ragdoll)"
	////				BEGIN
	////					MENUITEM "PlacingFolder",               0
	////				END
	////				POPUP "ragdollモーフ選択(ragdoll morph)"
	////				BEGIN
	////					MENUITEM "PlacingFolder",               0
	////				END
	////				POPUP "Imp選択(impulse)"
	////				BEGIN
	////					MENUITEM "PlacingFolder",               64500
	////				END
	////				POPUP "HELP"
	////				BEGIN
	////					MENUITEM "Regist",                      29800
	////				END
	////			END

	////			IDR_RMENU MENU
	////			BEGIN
	////				POPUP "RMenu"
	////				BEGIN
	////					MENUITEM "menutitle",                   ID_RMENU_0
	////				END
	////			END

	////			IDR_MENU3 MENU
	////			BEGIN
	////				POPUP "RMenu2"
	////				BEGIN
	////					MENUITEM "全ボーン(all bones)",             ID_RMENU2_40051
	////					MENUITEM "選択ボーン１つ(one bone)",           ID_RMENU2_40052
	////					MENUITEM "選択ボーンと子供ボーン(selected and children)", ID_RMENU2_40053
	////				END
	////			END

	////			IDR_MENU4 MENU
	////			BEGIN
	////				POPUP "RMenu3"
	////				BEGIN
	////					MENUITEM "Rigの設定(set)",                 ID_RMENU3_RIG40055
	////					MENUITEM "Rigの実行(run)",                 ID_RMENU3_RIG40056
	////				END
	////			END

	////			*/

	////		}
	////	}
	////}

}

void DSAxisLMouseMove()
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}


	////each of plate button
	////int okbuttonid = 2;
	////int okbuttondown;
	////int okbuttonup;

	////okbuttondown = s_dsbuttondown[okbuttonid];
	////okbuttonup = s_dsbuttonup[okbuttonid];


	//POINT cursorpos;
	//::GetCursorPos(&cursorpos);

	//float axisX;
	//float axisY;

	////int upbutton;
	////int downbutton;
	////int leftbutton;
	////int rightbutton;
	//int accelaxisid1 = 4;//axisid
	//int accelaxisid2 = 5;//axisid
	//bool accelaxis1 = 0;
	//bool accelaxis2 = 0;
	//bool accelflag = false;
	//bool accelbothflag = false;

	////upbutton = s_dsaxisMOverSrh[3];
	////downbutton = s_dsaxisOverSrh[3];
	////leftbutton = s_dsaxisMOverSrh[2];
	////rightbutton = s_dsaxisOverSrh[2];

	//axisX = s_dsaxisvalue[2];//float
	//axisY = s_dsaxisvalue[3];//float

	//accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));
	//accelflag = accelaxis1 || accelaxis2;
	//accelbothflag = accelaxis1 && accelaxis2;

	////if (g_undertrackingRMenu == 0) {
	//bool changeflag = false;

	//float deltascale = 1.0f;
	//int deltax = 0;
	//int deltay = 0;
	//if (accelbothflag) {
	//	deltascale = 10.0f;
	//}
	//else if (accelflag) {
	//	deltascale = 4.0f;
	//}
	//else {
	//	deltascale = 1.5f;
	//}



	//if (axisX != 0.0f) {
	//	deltax = (int)(axisX * deltascale);
	//	changeflag = true;
	//}
	//if (axisY != 0.0f) {
	//	deltay = (int)(axisY * deltascale);
	//	changeflag = true;
	//}


	////if (upbutton >= 1) {
	////	deltay = -deltascale;
	////	changeflag = true;
	////}
	////if (downbutton >= 1) {
	////	deltay = deltascale;
	////	changeflag = true;
	////}
	////if (leftbutton >= 1) {
	////	deltax = -deltascale;
	////	changeflag = true;
	////}
	////if (rightbutton >= 1) {
	////	deltax = deltascale;
	////	changeflag = true;
	////}


	//if (changeflag == true) {
	//	LPARAM lparam;
	//	lparam = (cursorpos.y << 16) | cursorpos.x;


	//	HWND desktopwnd;
	//	desktopwnd = ::GetDesktopWindow();
	//	if (desktopwnd) {
	//		RECT desktoprect;
	//		//::GetClientRect(desktopwnd, &desktoprect);
	//		::GetWindowRect(desktopwnd, &desktoprect);
	//		::ClipCursor(&desktoprect);

	//		//WM_MENUSELECT
	//		//MF_MOUSESELECT(上位)
	//		//下位はメニューID
	//		//WPARAM wparam = ((MF_MOUSESELECT | MF_SYSMENU) << 16) | 40026;
	//		//WPARAM wparam = (MF_SYSMENU << 16) | 40026;
	//		//WPARAM wparam = (MF_SYSMENU << 16) | 2;
	//		//WPARAM wparam = ((MF_MOUSESELECT | MF_SYSMENU) << 16) | 3;

	//		//HMENU motmenu = GetSubMenu(s_mainmenu, 2);
	//		//::SendMessage(g_mainhwnd, WM_MENUSELECT, wparam, (LPARAM)motmenu);
	//		//::SendMessage(g_mainhwnd, WM_MENUSELECT, wparam, (LPARAM)s_mainmenu);
	//		//::SendMessage(g_mainhwnd, WM_MENUSELECT, wparam, (LPARAM)40026);



	//		//::SetCursorPos(cursorpos.x, cursorpos.y);

	//		::SetCursorPos(cursorpos.x + deltax, cursorpos.y + deltay);



	//		//::SendMessage(g_mainhwnd, WM_KEYDOWN, VK_DOWN, 0);


	//		//const double ScaleX = 0xffff / GetSystemMetrics(SM_CXSCREEN);
	//		//const double ScaleY = 0xffff / GetSystemMetrics(SM_CYSCREEN);
	//		//const double ScaleX = (double)0xffff / (double)GetSystemMetrics(SM_CXSCREEN);
	//		//const double ScaleY = (double)0xffff / (double)GetSystemMetrics(SM_CYSCREEN);
	//		//const double ScaleX = (double)0xffff / (double)(desktoprect.right - desktoprect.left);
	//		//const double ScaleY = (double)0xffff / (double)(desktoprect.bottom - desktoprect.top);



	//		//WM_MOUSEMOVEはカメラ操作時などのときに画面が	MB3D_WND_3Dでドラッグする場合に必要
	//		if (s_3dwnd) {
	//			POINT client3dpoint;
	//			client3dpoint = cursorpos;
	//			::ScreenToClient(s_3dwnd, &client3dpoint);
	//			LPARAM threelparam;
	//			threelparam = (client3dpoint.y << 16) | client3dpoint.x;
	//			::SendMessage(s_3dwnd, WM_MOUSEMOVE, 0, threelparam);
	//		}
	//		if (g_mainhwnd) {
	//			POINT clientpoint;
	//			clientpoint = cursorpos;
	//			::ScreenToClient(g_mainhwnd, &clientpoint);
	//			LPARAM mainlparam;
	//			mainlparam = (clientpoint.y << 16) | clientpoint.x;
	//			::SendMessage(g_mainhwnd, WM_MOUSEMOVE, 0, mainlparam);
	//		}
	//		HWND dlghwnd;
	//		dlghwnd = g_SampleUI.GetHWnd();
	//		if (dlghwnd) {
	//			POINT clientpoint;
	//			clientpoint = cursorpos;
	//			::ScreenToClient(dlghwnd, &clientpoint);
	//			LPARAM dlglparam;
	//			dlglparam = (clientpoint.y << 16) | clientpoint.x;
	//			::SendMessage(dlghwnd, WM_MOUSEMOVE, 0, dlglparam);
	//		}


	//		//dialog ctrlのドラッグは　enter buttonを押している間だけ
	//		if (s_dspushedOK >= 1) {
	//			HWND ctrlwnd = GetOFWnd(cursorpos);
	//			if (ctrlwnd) {
	//				WCHAR wclassname[MAX_PATH] = { 0L };
	//				::GetClassNameW(ctrlwnd, wclassname, MAX_PATH);
	//				//::DSMessageBox(s_anglelimitdlg, wclassname, L"check!!!", MB_OK);
	//				if (wcscmp(L"msctls_trackbar32", wclassname) == 0) {
	//					//Slider
	//					RECT sliderloc;
	//					::GetWindowRect(ctrlwnd, &sliderloc);
	//					POINT cappoint = cursorpos;
	//					::ScreenToClient(ctrlwnd, &cappoint);

	//					float rangemin;
	//					float rangemax;
	//					rangemin = (float)::SendMessage(ctrlwnd, TBM_GETRANGEMIN, 0, 0);
	//					rangemax = (float)::SendMessage(ctrlwnd, TBM_GETRANGEMAX, 0, 0);

	//					float thumblength;
	//					thumblength = (float)::SendMessage(ctrlwnd, TBM_GETTHUMBLENGTH, 0, 0);

	//					//int sliderpos = (int)((float)(cappoint.x - 12 - 274 / 2) / 274.0f * 360.0f);
	//					int sliderpos = (int)((float)(cappoint.x - thumblength / 2.0f) / (float)(sliderloc.right - sliderloc.left - thumblength) * (float)(rangemax - rangemin) + rangemin);

	//					::SendMessage(ctrlwnd, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);
	//					::SendMessage(s_ofhwnd, WM_HSCROLL, 0, (LPARAM)ctrlwnd);
	//				}
	//				//else if (wcsstr(wclassname, L"ListBox") != 0) {
	//				else {
	//					POINT clientpoint;
	//					clientpoint = cursorpos;
	//					::ScreenToClient(ctrlwnd, &clientpoint);
	//					LPARAM dlglparam;
	//					dlglparam = (clientpoint.y << 16) | clientpoint.x;
	//					::SendMessage(ctrlwnd, WM_MOUSEMOVE, 0, dlglparam);

	//				}
	//			}
	//			else if (s_getfilenamehwnd) {

	//				//###############################################################################################################################################
	//				// GetOpenFileNameのダイアログの２つあるリストボックスの垂直スクロールバー(スクロールバーはFindWindowExで取得できず。EnumChildProcでもクライアントエリア内に入らなかった)
	//				//###############################################################################################################################################

	//				//ctrlwnd == 0
	//				//scrollwnd = FindWindowEx(s_getfilenamehwnd, 0, L"ScrollBar", 0);//   scrollwnd == 0
	//				//s_ofhwnd = 0;
	//				s_enumdist.clear();
	//				::EnumChildWindows(s_getfilenamehwnd, EnumTreeViewProc, (LPARAM)&ctrlwnd);
	//				//ctrlwnd = GetNearestEnumDist();
	//				std::vector<ENUMDIST>::iterator itrenumdist;
	//				for (itrenumdist = s_enumdist.begin(); itrenumdist != s_enumdist.end(); itrenumdist++) {
	//					HWND listboxwnd = itrenumdist->hwnd;

	//					//POINT clientpoint;
	//					//clientpoint = cursorpos;
	//					//::ScreenToClient(listboxwnd, &clientpoint);
	//					//LPARAM dlglparam;
	//					//dlglparam = (clientpoint.y << 16) | clientpoint.x;
	//					//::SendMessage(listboxwnd, WM_VSCROLL, SB_THUMBTRACK, (LPARAM)dlglparam);

	//					if (deltay > 0) {
	//						::SendMessage(listboxwnd, WM_VSCROLL, SB_LINEDOWN, (LPARAM)0);
	//					}
	//					else if (deltay < 0) {
	//						::SendMessage(listboxwnd, WM_VSCROLL, SB_LINEUP, (LPARAM)0);
	//					}
	//				}

	//			}
	//		}



	//		//::SendMessage(desktopwnd, WM_MOUSEMOVE, 0, (LPARAM)lparam);
	//	}
	//}

}

void DSL3R3ButtonMouseHere()
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	//static HCURSOR s_prevcursor = 0;

	//if ((s_dspushedL3 == 1) || (s_dspushedR3 == 1)) {
	//	if (g_dsmousewait == 0) {
	//		s_prevcursor = ::SetCursor(LoadCursor(NULL, IDC_WAIT));
	//		g_dsmousewait = 1;
	//	}
	//}
	//else if ((s_dspushedL3 == 0) && (s_dspushedR3 == 0)) {
	//	if (g_dsmousewait == 1) {
	//		if (s_prevcursor) {
	//			::SetCursor(s_prevcursor);
	//		}
	//		g_dsmousewait = 0;
	//	}
	//}


	//if (g_dsmousewait == 1) {
	//	if (s_timelineWnd) {
	//		s_timelineWnd->callRewrite();
	//	}
	//	if (s_toolWnd) {
	//		s_toolWnd->callRewrite();
	//	}
	//	if (s_LtimelineWnd) {
	//		s_LtimelineWnd->callRewrite();
	//	}
	//	if (s_placefolderWnd && s_placefolderWnd->getVisible()) {
	//		s_placefolderWnd->callRewrite();
	//	}
	//	if (s_rigidWnd && s_rigidWnd->getVisible()) {
	//		s_rigidWnd->callRewrite();
	//	}
	//	if (s_impWnd && s_impWnd->getVisible()) {
	//		s_impWnd->callRewrite();
	//	}
	//	if (s_gpWnd && s_gpWnd->getVisible()) {
	//		s_gpWnd->callRewrite();
	//	}
	//	if (s_dmpanimWnd && s_dmpanimWnd->getVisible()) {
	//		s_dmpanimWnd->callRewrite();
	//	}
	//	if (s_convboneWnd && s_convboneWnd->getVisible()) {
	//		s_convboneWnd->callRewrite();
	//	}
	//	if (s_anglelimitdlg && s_spretargetsw[SPRETARGETSW_LIMITEULER].state) {
	//		//POINT mousepoint;
	//		//::GetCursorPos(&mousepoint);			
	//		//::ScreenToClient(s_anglelimitdlg, &mousepoint);
	//		//PAINTSTRUCT ps;
	//		//HDC hdc = BeginPaint(s_anglelimitdlg, &ps);
	//		//// メモリデバイスコンテキストを作成する
	//		//HDC hCompatDC = CreateCompatibleDC(hdc);
	//		//// ロードしたビットマップを選択する
	//		//HBITMAP hPrevBitmap = (HBITMAP)SelectObject(hCompatDC, g_mouseherebmp);
	//		//BITMAP bmp;
	//		//GetObject(g_mouseherebmp, sizeof(BITMAP), &bmp);
	//		//int BMP_W = (int)bmp.bmWidth;
	//		//int BMP_H = (int)bmp.bmHeight;
	//		//BitBlt(hdc, mousepoint.x, mousepoint.y, BMP_W, BMP_H, hCompatDC, 0, 0, SRCCOPY);
	//		//DeleteDC(hCompatDC);
	//		////EndPaint(hWnd, &ps);
	//	}
	//}
}

void OnDSMouseHereApeal()
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	//if (!s_3dwnd) {
	//	return;
	//}

	//static float s_mousehereval = 0.0f;
	//static int s_mouseheredir = 0;

	////if (g_dsmousewait >= 1) {
	//POINT cursorpos;
	//::GetCursorPos(&cursorpos);
	//::ScreenToClient(s_3dwnd, &cursorpos);
	//if (s_spmousehere.sprite) {

	//	float spawidth = 52.0f;
	//	int spashift = 50;

	//	s_spmousehere.dispcenter.x = cursorpos.x + 52 / 2;
	//	s_spmousehere.dispcenter.y = cursorpos.y + 50 / 2;


	//	ChaVector3 disppos;
	//	disppos.x = (float)(s_spmousehere.dispcenter.x);
	//	disppos.y = (float)(s_spmousehere.dispcenter.y);
	//	disppos.z = 0.0f;
	//	ChaVector2 dispsize = ChaVector2(spawidth / (float)s_mainwidth * 2.0f, spawidth / (float)s_mainheight * 2.0f);
	//	if (s_spmousehere.sprite) {
	//		CallF(s_spmousehere.sprite->SetPos(disppos), return);
	//		CallF(s_spmousehere.sprite->SetSize(dispsize), return);

	//		if (s_mouseheredir == 0) {
	//			s_mousehereval += 0.08f;
	//		}
	//		else if (s_mouseheredir == 1) {
	//			s_mousehereval -= 0.08f;
	//		}

	//		if (s_mousehereval >= 1.0f) {
	//			s_mousehereval = 1.0;
	//			s_mouseheredir = 1;
	//		}
	//		else if (s_mousehereval <= 0.0f) {
	//			s_mousehereval = 0.0f;
	//			s_mouseheredir = 0;
	//		}
	//		g_mouseherealpha = s_mousehereval * s_mousehereval;

	//		ChaVector4 spritecol = ChaVector4(1.0f, 1.0f, 1.0f, g_mouseherealpha);
	//		CallF(s_spmousehere.sprite->SetColor(spritecol), return);
	//	}
	//	else {
	//		_ASSERT(0);
	//	}

	//}
	////}
}

void DSXButtonCancel()
{
	//Cancel button : メニューのドロップダウンをキャンセルする　Cancel dropdown menu. L2 + X --> Undo, R2 + X --> Redo.

	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	//if (!g_mainhwnd) {
	//	return;
	//}
	//if (!s_3dwnd) {
	//	return;
	//}

	//int cancelbuttonid = 1;
	//int accelaxisid1 = 4;//axisid
	//int accelaxisid2 = 5;//axisid

	//int cancelbuttondown;
	//int cancelbuttonup;
	//int accelaxis1 = 0;
	//int accelaxis2 = 0;

	//cancelbuttondown = s_dsbuttondown[cancelbuttonid];
	//cancelbuttonup = s_dsbuttonup[cancelbuttonid];
	//accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));


	//if (cancelbuttondown >= 1) {
	//	if (accelaxis1 >= 1) {
	//		//Undo
	//		OnFrameUndo(true, 0);//fromds, fromdskind
	//	}
	//	else if (accelaxis2 >= 1) {
	//		//Redo
	//		OnFrameUndo(true, 1);//fromds, fromdskind
	//	}
	//	else {
	//		//TrackPopupMenuの前でSetForegrandWindow(g_mainhwnd)をしている場合に次の関数でpopupを閉じることが出来る。
	//		PostMessage(g_mainhwnd, WM_KEYDOWN, VK_ESCAPE, 0);
	//		PostMessage(s_3dwnd, WM_KEYDOWN, VK_ESCAPE, 0);

	//	}
	//}
}


void GetHiLiteSubmenu(HMENU* pcommandsubmenu, int* pcommandsubmenunum, int* pcommandsubmenuno)
{
	if (!pcommandsubmenu || !pcommandsubmenunum || !pcommandsubmenuno) {
		return;
	}
	*pcommandsubmenu = 0;
	*pcommandsubmenunum = 0;
	*pcommandsubmenuno = 0;



	int selectedsubmenuitemno = -1;
	int submenuitemnum;
	submenuitemnum = GetMenuItemCount(s_cursubmenu);
	int submenuitemcnt;
	for (submenuitemcnt = 0; submenuitemcnt < submenuitemnum; submenuitemcnt++) {
		UINT submenuitemstate;
		submenuitemstate = GetMenuState(s_cursubmenu, submenuitemcnt, MF_BYPOSITION);
		if (submenuitemstate == MF_HILITE) {
			selectedsubmenuitemno = submenuitemcnt;
			break;
		}
		else {
			//submenu ２段階までは自動でチェック
			HMENU subsubmenu = 0;
			subsubmenu = GetSubMenu(s_cursubmenu, submenuitemcnt);
			if (subsubmenu) {
				int subsubmenuitemnum;
				subsubmenuitemnum = GetMenuItemCount(subsubmenu);
				int subsubmenuitemcnt;
				for (subsubmenuitemcnt = 0; subsubmenuitemcnt < subsubmenuitemnum; subsubmenuitemcnt++) {
					UINT subsubmenuitemstate;
					subsubmenuitemstate = GetMenuState(subsubmenu, subsubmenuitemcnt, MF_BYPOSITION);
					if (subsubmenuitemstate == MF_HILITE) {
						s_cursubmenu = subsubmenu;//!!!!!!!!!
						selectedsubmenuitemno = subsubmenuitemcnt;
						submenuitemnum = subsubmenuitemnum;
						break;//!!!!!!!!!!!!!!!!
					}
				}
			}
		}
	}

	if (selectedsubmenuitemno == -1) {
		HMENU submenu2 = 0;

		if (g_currentsubmenuid == 0) {
			submenu2 = GetSubMenu(s_cursubmenu, 1);
		}
		else if (g_currentsubmenuid == 2) {
			submenu2 = GetSubMenu(s_cursubmenu, 3);
		}
		else if (g_currentsubmenuid == 3) {
			submenu2 = GetSubMenu(s_cursubmenu, 3);
		}
		else if (g_currentsubmenuid == 4) {
			submenu2 = GetSubMenu(s_cursubmenu, 3);
		}
		else if ((g_currentsubmenuid >= 5) && (g_currentsubmenuid <= 8)) {
			submenu2 = GetSubMenu(s_cursubmenu, 0);
		}

		if (submenu2) {
			{
				int tmpselectedsubmenuitemno = -1;
				int tmpsubmenuitemnum;
				tmpsubmenuitemnum = GetMenuItemCount(submenu2);
				int tmpsubmenuitemcnt;
				for (tmpsubmenuitemcnt = 0; tmpsubmenuitemcnt < tmpsubmenuitemnum; tmpsubmenuitemcnt++) {
					UINT submenuitemstate;
					submenuitemstate = GetMenuState(submenu2, tmpsubmenuitemcnt, MF_BYPOSITION);
					if (submenuitemstate == MF_HILITE) {
						tmpselectedsubmenuitemno = tmpsubmenuitemcnt;
						break;
					}
				}
				if (tmpselectedsubmenuitemno >= 0) {
					*pcommandsubmenu = submenu2;
					*pcommandsubmenunum = tmpsubmenuitemnum;
					*pcommandsubmenuno = tmpselectedsubmenuitemno;
				}
			}
		}
	}
	else {
		*pcommandsubmenu = s_cursubmenu;
		*pcommandsubmenunum = submenuitemnum;
		*pcommandsubmenuno = selectedsubmenuitemno;

	}
}

void CALLBACK WinEventProc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread, DWORD dwmsEventTime)
{

	//if ((event >= EVENT_SYSTEM_DIALOGSTART) && (event <= EVENT_SYSTEM_DIALOGEND)) {
	//if((event == EVENT_OBJECT_INVOKED) || (event == EVENT_OBJECT_SELECTION) || (event == EVENT_OBJECT_SELECTIONWITHIN) || (event == EVENT_OBJECT_STATECHANGE)){
	//	WCHAR classname[MAX_PATH] = { 0L };
	//	WCHAR wintext[MAX_PATH] = { 0L };
	//	::GetClassName(hwnd, classname, MAX_PATH);
	//	::GetWindowText(hwnd, wintext, MAX_PATH);
	//	//if (wcscmp(L"Button", classname) == 0) {
	//		if (wcscmp(L"OK", wintext) == 0) {
	//			SendMessage(hwnd, BM_CLICK, 0, 0);
	//		}
	//	//}
	//}
	////::SendMessage(hwnd, WM_COMMAND, IDOK, 0);
	//HWND hwndChild = FindWindowEx(hwnd, 0, L"Button", L"OK");
	//if (hwndChild) {
	//	SendMessage(hwndChild, BM_CLICK, 0, 0);
	//	//::SendMessage(hwndChild, WM_COMMAND, IDOK, 0);
	//}

	//if ((event == EVENT_OBJECT_INVOKED) || (event == EVENT_OBJECT_SELECTION) || (event == EVENT_OBJECT_SELECTIONWITHIN) || (event == EVENT_OBJECT_STATECHANGE)) {
	//if (event == EVENT_SYSTEM_DIALOGSTART) {
	//if(event == EVENT_OBJECT_CREATE){

	if (event == EVENT_SYSTEM_FOREGROUND) {
		WCHAR classname[MAX_PATH] = { 0L };
		WCHAR wintext[MAX_PATH] = { 0L };
		::GetClassName(hwnd, classname, MAX_PATH);
		::GetWindowText(hwnd, wintext, MAX_PATH);


		HWND fgwnd = 0;

		//if (wcscmp(L"error!!!", wintext) == 0) {
		if (wcsstr(wintext, L"error!!!") != 0) {
			//::SendMessage(hwnd, WM_COMMAND, IDOK, 0);
			s_messageboxhwnd = hwnd;
			fgwnd = hwnd;
		}
		if (wcsstr(wintext, L"warning!!!") != 0) {
			s_messageboxhwnd = hwnd;
			fgwnd = hwnd;
		}
		if (wcsstr(wintext, L"check!!!") != 0) {
			s_messageboxhwnd = hwnd;
			fgwnd = hwnd;
		}
		if (wcsstr(wintext, L"GetFileNameDlg") != 0) {
			s_getfilenamehwnd = hwnd;
			fgwnd = hwnd;
		}
		if ((wcscmp(classname, L"#32770") == 0) || (wcsstr(wintext, L"フォルダーの参照") != 0)) {//SHGetSpecialFolderLocation
			s_getfilenamehwnd = hwnd;
			fgwnd = hwnd;
		}

		if (fgwnd) {

			SetDlgPosDesktopCenter(fgwnd, HWND_TOPMOST);

			//機能のボタンを押した際　マウスがアップする前に呼ばれることがある
			//マウスを動かすと　ボタンが機能しないことがあるので　SetCursorPosはコメントアウト
			//この関数の外で　ダイアログ表示時にSetCursorPosすることは大丈夫
			//RECT dlgrect;
			//GetWindowRect(fgwnd, &dlgrect);
			//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		}

		//HWND hwndChild = FindWindowExA(hwnd, 0, "Button", "OK");
		//if (hwndChild) {
		//	SendMessage(hwndChild, BM_CLICK, 0, 0);
		//	::SendMessage(hwndChild, WM_COMMAND, IDOK, 0);
		//}
		//else {
		//	HWND hwndChildW = FindWindowExW(hwnd, 0, L"Button", L"OK");
		//	if (hwndChildW) {
		//		SendMessage(hwndChildW, BM_CLICK, 0, 0);
		//		::SendMessage(hwndChild, WM_COMMAND, IDOK, 0);
		//	}
		//}

	}

	//}

	return;
}

void DSOButtonSelectedPopupMenu()
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	//if (!s_cursubmenu) {
	//	return;
	//}

	//static HWINEVENTHOOK s_eventhook = 0;

	//int okbuttonid = 2;
	//int okbuttondown;
	//int okbuttonup;

	//int cancelbuttonid = 1;
	//int cancelbuttondown;
	//int cancelbuttonup;

	//okbuttondown = s_dsbuttondown[okbuttonid];
	//okbuttonup = s_dsbuttonup[okbuttonid];

	//cancelbuttondown = s_dsbuttondown[cancelbuttonid];
	//cancelbuttonup = s_dsbuttonup[cancelbuttonid];


	//if (okbuttonup >= 1) {
	//	POINT cursorpos;
	//	::GetCursorPos(&cursorpos);
	//	LPARAM lparam;
	//	lparam = (cursorpos.y << 16) | cursorpos.x;

	//	//if (g_undertrackingRMenu == 1) {
	//	if (InterlockedAdd(&g_undertrackingRMenu, 0) == 1) {


	//		HMENU commandsubmenu = 0;
	//		int commandsubmenunum = 0;
	//		int	commandsubmenuno = -1;
	//		GetHiLiteSubmenu(&commandsubmenu, &commandsubmenunum, &commandsubmenuno);
	//		if (commandsubmenu && (commandsubmenunum >= 1) && (commandsubmenuno >= 0)) {


	//			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);//コマンド発行が決まったらトラッキングフラグ解除!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


	//			//::PostMessage(g_mainhwnd, WM_KEYDOWN, VK_RETURN, 0);


	//			//if (commandsubmenunum == 1) {
	//				//メニュー項目が１つだけの場合にはポップアップを解除してからWM_COMMANDを呼んでみる
	//				//TrackPopupMenuの前でSetForegrandWindow(g_mainhwnd)をしている場合に次の関数でpopupを閉じることが出来る。
	//			PostMessage(g_mainhwnd, WM_KEYDOWN, VK_ESCAPE, 0);
	//			PostMessage(s_3dwnd, WM_KEYDOWN, VK_ESCAPE, 0);
	//			//}

	//			int commandmenuid;
	//			commandmenuid = GetMenuItemID(commandsubmenu, commandsubmenuno);
	//			WPARAM wparam;
	//			//wparam = (selectedsubmenuitemno << 16) | selectedmenuid;
	//			//wparam = (commandsubmenuno << 16) | commandmenuid;
	//			wparam = commandmenuid;


	//			//LPARAM lparam;
	//			////lparam = (LPARAM)s_mainmenu;
	//			//lparam = (LPARAM)commandsubmenu;


	//			//::SendMessage(g_mainhwnd, WM_COMMAND, wparam, lparam);
	//			//::SendMessage(s_3dwnd, WM_COMMAND, wparam, lparam);//menuのMsgProcはs_3dwndのメッセージプロック
	//			::SendMessage(s_3dwnd, WM_COMMAND, wparam, 0);//menuのMsgProcはs_3dwndのメッセージプロック
	//		}
	//		else {

	//			if (s_messageboxhwnd) {
	//				HWND ctrlwnd = 0;
	//				::EnumChildWindows(s_messageboxhwnd, EnumIDOKProc, (LPARAM)&ctrlwnd);
	//				if (ctrlwnd) {
	//					s_messageboxpushcnt++;

	//					//一回目はダイアログを出すときのクリック。２回目でIDOKを押す。
	//					if (s_messageboxpushcnt >= 2) {
	//						//WPARAM wparam;
	//						//wparam = (BN_CLICKED << 16) | IDOK;
	//						//::SendMessage(s_messageboxhwnd, WM_COMMAND, wparam, (LPARAM)ctrlwnd);
	//						SendMessage(ctrlwnd, BM_CLICK, 0, 0);
	//					}
	//				}
	//				//::SendMessage(s_messageboxhwnd, WM_COMMAND, IDOK, 0);
	//				//	SendMessage(hwndChild, BM_CLICK, 0, 0);
	//			}
	//			else {
	//				HWND ctrlwnd = 0;
	//				ctrlwnd = GetOFWnd(cursorpos);
	//				//s_ofhwnd = 0;
	//				//s_enumdist.clear();
	//				//::EnumChildWindows(s_getfilenamehwnd, EnumTreeViewProc, (LPARAM)&ctrlwnd);
	//				//ctrlwnd = GetNearestEnumDist();
	//				if (ctrlwnd) {

	//					int ctrlid;
	//					ctrlid = GetDlgCtrlID(ctrlwnd);

	//					//::SendMessage(s_getfilenametreeview, WM_COMMAND, wparam, (LPARAM)ctrlwnd);

	//					POINT dlgpoint;
	//					dlgpoint = cursorpos;
	//					::ScreenToClient(s_ofhwnd, &dlgpoint);
	//					LPARAM dlglparam;
	//					dlglparam = (dlgpoint.y << 16) | dlgpoint.x;
	//					::SendMessage(s_ofhwnd, WM_LBUTTONUP, MK_LBUTTON, dlglparam);
	//					//::SendMessage(s_ofhwnd, WM_LBUTTONDBLCLK, MK_LBUTTON, dlglparam);//!!!!!!!!!!!!!!

	//					WPARAM wparam;
	//					wparam = (BN_CLICKED << 16) | ctrlid;
	//					::SendMessage(s_ofhwnd, WM_COMMAND, wparam, (LPARAM)ctrlwnd);

	//					POINT dlgpoint2;
	//					dlgpoint2 = cursorpos;
	//					::ScreenToClient(ctrlwnd, &dlgpoint2);
	//					LPARAM dlglparam2;
	//					dlglparam2 = (dlgpoint2.y << 16) | dlgpoint2.x;
	//					//::SendMessage(ctrlwnd, WM_LBUTTONDOWN, MK_LBUTTON, dlglparam2);
	//					::SendMessage(ctrlwnd, WM_LBUTTONUP, MK_LBUTTON, dlglparam2);
	//					//::SendMessage(ctrlwnd, WM_LBUTTONDOWN, MK_LBUTTON, dlglparam2);
	//					//::SendMessage(ctrlwnd, WM_LBUTTONUP, MK_LBUTTON, dlglparam2);
	//					//::SendMessage(ctrlwnd, WM_LBUTTONDBLCLK, MK_LBUTTON, dlglparam2);//!!!!!!!!!


	//					SendMessage(ctrlwnd, BM_CLICK, 0, 0);
	//					//SendMessage(ctrlwnd, BM_CLICK, 0, 0);


	//					WCHAR ctrlclassname[MAX_PATH] = { 0L };
	//					GetClassName(ctrlwnd, ctrlclassname, MAX_PATH);
	//					if (wcsstr(L"ListBox", ctrlclassname) != 0) {

	//						//WCHAR ctrlwintext[MAX_PATH] = { 0L };
	//						//GetWindowText(ctrlwnd, ctrlwintext, MAX_PATH);//L""

	//						POINT lbpoint;
	//						lbpoint = cursorpos;
	//						::ScreenToClient(ctrlwnd, &lbpoint);
	//						LPARAM lblparam;
	//						lblparam = (lbpoint.y << 16) | lbpoint.x;
	//						DWORD hitinfo = (DWORD)SendMessage(ctrlwnd, LB_ITEMFROMPOINT, 0, lblparam);
	//						WORD hitflag;
	//						WORD hitindex;
	//						hitflag = HIWORD(hitinfo);
	//						hitindex = LOWORD(hitinfo);
	//						if (hitflag == 0) {


	//							//ディレクトリ指定用のListBoxのときにはエンターキーを押して展開表示する。
	//							//int itrcnt = 0;
	//							//int findindex = 0;
	//							//if (s_enumdist.size() >= 2) {
	//							//	std::vector<ENUMDIST>::iterator itrenumdist;
	//							//	for (itrenumdist = s_enumdist.begin(); itrenumdist != s_enumdist.end(); itrenumdist++) {
	//							//		if (itrenumdist->hwnd == ctrlwnd) {
	//							//			findindex = itrcnt;
	//							//			break;
	//							//		}
	//							//		itrcnt++;
	//							//	}
	//							//}
	//							//if (findindex == 0) {
	//							//	::PostMessage(ctrlwnd, WM_KEYDOWN, VK_RETURN, 0);
	//							//}



	//							//ディレクトリ指定用のListBoxのときにはエンターキーを押して展開表示する。
	//							RECT ctrlrect;
	//							GetWindowRect(ctrlwnd, &ctrlrect);
	//							POINT ctrllefttop = { 0, 0 };
	//							ctrllefttop.x = ctrlrect.left;
	//							ctrllefttop.y = ctrlrect.top;
	//							ScreenToClient(s_getfilenamehwnd, &ctrllefttop);
	//							if (ctrllefttop.x > 150) {
	//								::PostMessage(ctrlwnd, WM_KEYDOWN, VK_RETURN, 0);
	//							}





	//							//SendMessage(ctrlwnd, WM_CHAR, VK_RETURN, 0);
	//							//SendMessage(s_ofhwnd, WM_CHAR, VK_RETURN, 0);
	//							//SendMessage(s_getfilenamehwnd, WM_CHAR, VK_RETURN, 0);

	//							//SendMessage(ctrlwnd, LB_SETSEL, (WPARAM)FALSE, (LPARAM)hitindex);
	//							//SendMessage(ctrlwnd, LB_SETSEL, (WPARAM)TRUE, (LPARAM)hitindex);




	//							//SendMessage(ctrlwnd, LB_SETCURSEL, (WPARAM)hitindex, (LPARAM)0);

	//							//::SendMessage(ctrlwnd, WM_LBUTTONDBLCLK, MK_LBUTTON, dlglparam2);//!!!!!!!!!

	//							//WCHAR itembuf[MAX_PATH] = { 0L };
	//							//LVITEM item;
	//							//ZeroMemory(&item, sizeof(LVITEM));
	//							//item.mask = LVIF_STATE | LVIF_TEXT;
	//							//item.state = 0;
	//							//item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
	//							//item.iItem = hitindex;
	//							//item.iSubItem = 0;          //取得するサブアイテムの番号
	//							//item.pszText = itembuf;         //格納するテキストバッファ
	//							//item.cchTextMax = MAX_PATH; //バッファ容量
	//							//ListView_GetItem(ctrlwnd, &item);
	//							//if (item.state & LVIS_SELECTED) {
	//							//	SendMessage(ctrlwnd, LB_SETSEL, (WPARAM)FALSE, (LPARAM)hitindex);
	//							//}
	//							//else if (item.state & LVIS_FOCUSED) {
	//							//	SendMessage(ctrlwnd, LB_SETSEL, (WPARAM)FALSE, (LPARAM)hitindex);
	//							//}
	//							//else {
	//							//	SendMessage(ctrlwnd, LB_SETSEL, (WPARAM)TRUE, (LPARAM)hitindex);
	//							//}


	//							//DWORD itemstate = ListView_GetItemState(ctrlwnd, hitindex, LVIS_SELECTED | LVIS_FOCUSED);
	//							//if ((itemstate & LVIS_SELECTED) != 0) {
	//							//	//ListView_SetItemState(ctrlwnd, hitindex, 0, LVIS_SELECTED);
	//							//	SendMessage(ctrlwnd, LB_SETSEL, (WPARAM)FALSE, (LPARAM)hitindex);
	//							//}
	//							//else if ((itemstate & LVIS_FOCUSED) != 0) {
	//							//	SendMessage(ctrlwnd, LB_SETSEL, (WPARAM)FALSE, (LPARAM)hitindex);
	//							//}
	//							//else {
	//							//	SendMessage(ctrlwnd, LB_SETSEL, (WPARAM)TRUE, (LPARAM)hitindex);
	//							//}
	//						}
	//					}
	//					else if ((wcsstr(L"TreeView", ctrlclassname) != 0) || (wcsstr(L"SysTreeView32", ctrlclassname) != 0)) {
	//						//for SHGetSpecialFolderLocation
	//						//select : click text
	//						//expand tree : click triangleMark

	//						POINT tvpoint;
	//						tvpoint = cursorpos;
	//						::ScreenToClient(ctrlwnd, &tvpoint);
	//						LPARAM tvlparam;
	//						tvlparam = (tvpoint.y << 16) | tvpoint.x;

	//						TVHITTESTINFO ht;
	//						ZeroMemory(&ht, sizeof(TVHITTESTINFO));
	//						ht.flags = TVHT_ONITEM;
	//						ht.hItem = NULL;
	//						ht.pt = tvpoint;
	//						HTREEITEM hItem = TreeView_HitTest(ctrlwnd, &ht);
	//						if (ht.flags & TVHT_ONITEM) {
	//							TreeView_SelectItem(ctrlwnd, ht.hItem);
	//						}
	//					}


	//					//WPARAM wparam;
	//					//wparam = (BN_CLICKED << 16) | ctrlid;
	//					////wparam = (BN_PUSHED << 16) | ctrlid;
	//					//::SendMessage(s_ofhwnd, WM_COMMAND, wparam, (LPARAM)ctrlwnd);
	//					//::SendMessage(ctrlwnd, BM_CLICK, 0, 0);

	//					//HWND hList = ctrlwnd;
	//					//LV_HITTESTINFO lvinfo;
	//					//WCHAR buf[MAX_PATH];
	//					//ZeroMemory(&lvinfo, sizeof(LV_HITTESTINFO));
	//					//GetCursorPos((LPPOINT)&lvinfo.pt);
	//					//ScreenToClient(hList, &lvinfo.pt);
	//					//ListView_HitTest(hList, &lvinfo);
	//					//if ((lvinfo.flags & LVHT_ONITEM) != 0)
	//					//{
	//					//	LVITEM item;
	//					//	ZeroMemory(&item, sizeof(LVITEM));
	//					//	item.mask = TVIF_HANDLE | TVIF_TEXT;
	//					//	item.iItem = lvinfo.iItem;
	//					//	item.iSubItem = 0;          //取得するサブアイテムの番号
	//					//	item.pszText = buf;         //格納するテキストバッファ
	//					//	item.cchTextMax = MAX_PATH; //バッファ容量
	//					//	ListView_GetItem(hList, &item);
	//					//	DSMessageBox(s_3dwnd, buf, L"選択したデータ", MB_OK);
	//					//}



	//					//dHWND treeviewhwnd = 0;
	//					//::EnumChildWindows(s_ofhwnd, EnumTreeViewProc, (LPARAM)&treeviewhwnd);
	//					//if (treeviewhwnd) {
	//					//	s_getfilenametreeview = treeviewhwnd;

	//					//	::SendMessage(s_getfilenametreeview, WM_COMMAND, wparam, (LPARAM)ctrlwnd);

	//					//	POINT dlgpoint;
	//					//	dlgpoint = cursorpos;
	//					//	::ScreenToClient(s_ofhwnd, &dlgpoint);
	//					//	LPARAM dlglparam;
	//					//	dlglparam = (dlgpoint.y << 16) | dlgpoint.x;
	//					//	::SendMessage(s_ofhwnd, WM_LBUTTONUP, MK_LBUTTON, dlglparam);

	//					//	POINT dlgpoint2;
	//					//	dlgpoint2 = cursorpos;
	//					//	::ScreenToClient(s_getfilenametreeview, &dlgpoint2);
	//					//	LPARAM dlglparam2;
	//					//	dlglparam2 = (dlgpoint2.y << 16) | dlgpoint2.x;
	//					//	::SendMessage(s_getfilenametreeview, WM_LBUTTONUP, MK_LBUTTON, dlglparam2);
	//					//}
	//				}
	//			}



	//			//if(s_eventhook){
	//			//	//UnhookWinEvent(s_eventhook);
	//			//	s_eventhook = 0;
	//			//}
	//			//m_event = nullptr;
	//		}
	//	}


	//	//int selectedsubmenuitemno = -1;
	//	//int submenuitemnum;
	//	//submenuitemnum = GetMenuItemCount(s_cursubmenu);
	//	//int submenuitemcnt;
	//	//for (submenuitemcnt = 0; submenuitemcnt < submenuitemnum; submenuitemcnt++) {
	//	//	UINT submenuitemstate;
	//	//	submenuitemstate = GetMenuState(s_cursubmenu, submenuitemcnt, MF_BYPOSITION);
	//	//	if (submenuitemstate == MF_HILITE) {
	//	//		selectedsubmenuitemno = submenuitemcnt;
	//	//		break;
	//	//	}
	//	//}
	//			//if (selectedmenuid >= 0) {
	//			//	//#################
	//			//	//選択決定成功例その２
	//			//	//#################
	//			//	//第2項目（インデックス値 = 1, ID = 0x2711）を選択したところ、
	//			//	//wParam = 0x00012711
	//			//	//のように、上位2バイトにインデックス値が、下位2バイトにIDが入ります。
	//			//	//WPARAM wparam;
	//			//	//wparam = (g_currentsubmenuid << 16) | curmenuitemid;
	//			//	//LPARAM lparam;
	//			//	//lparam = (LPARAM)mainmenu;
	//			//	//::SendMessage(g_mainhwnd, WM_COMMAND, wparam, lparam);

	//			//	if ((submenuitemnum == 1) && (selectedsubmenuitemno >= 0) && (g_currentsubmenuid >= 0)) {
	//			//		//メニュー項目が１つだけの場合にはポップアップを解除してからWM_COMMANDを呼んでみる
	//			//		//TrackPopupMenuの前でSetForegrandWindow(g_mainhwnd)をしている場合に次の関数でpopupを閉じることが出来る。
	//			//		PostMessage(g_mainhwnd, WM_KEYDOWN, VK_ESCAPE, 0);
	//			//		PostMessage(s_3dwnd, WM_KEYDOWN, VK_ESCAPE, 0);
	//			//	}
	//			//	
	//			//	int commandmenuid;
	//			//	commandmenuid = GetMenuItemID(s_cursubmenu, selectedsubmenuitemno);
	//			//	WPARAM wparam;
	//			//	//wparam = (selectedsubmenuitemno << 16) | selectedmenuid;
	//			//	wparam = (selectedsubmenuitemno << 16) | commandmenuid;
	//			//	LPARAM lparam;
	//			//	//lparam = (LPARAM)s_mainmenu;
	//			//	lparam = (LPARAM)s_cursubmenu;
	//			//	::SendMessage(g_mainhwnd, WM_COMMAND, wparam, lparam);
	//			//}
	//}


	//if (okbuttondown >= 1) {
	//	POINT cursorpos;
	//	::GetCursorPos(&cursorpos);
	//	LPARAM lparam;
	//	lparam = (cursorpos.y << 16) | cursorpos.x;

	//	//if (g_undertrackingRMenu == 1) {
	//	if (InterlockedAdd(&g_undertrackingRMenu, 0) == 1) {
	//		HMENU commandsubmenu = 0;
	//		int commandsubmenunum = 0;
	//		int	commandsubmenuno = -1;
	//		GetHiLiteSubmenu(&commandsubmenu, &commandsubmenunum, &commandsubmenuno);
	//		if (commandsubmenu && (commandsubmenunum >= 1) && (commandsubmenuno >= 0)) {
	//			//
	//		}
	//		else {
	//			HWND ctrlwnd = 0;
	//			ctrlwnd = GetOFWnd(cursorpos);
	//			//s_ofhwnd = 0;
	//			//s_enumdist.clear();
	//			//::EnumChildWindows(s_getfilenamehwnd, EnumTreeViewProc, (LPARAM)&ctrlwnd);
	//			//ctrlwnd = GetNearestEnumDist();
	//			if (ctrlwnd) {

	//				int ctrlid;
	//				ctrlid = GetDlgCtrlID(ctrlwnd);

	//				//::SendMessage(s_getfilenametreeview, WM_COMMAND, wparam, (LPARAM)ctrlwnd);

	//				POINT dlgpoint;
	//				dlgpoint = cursorpos;
	//				::ScreenToClient(s_ofhwnd, &dlgpoint);
	//				LPARAM dlglparam;
	//				dlglparam = (dlgpoint.y << 16) | dlgpoint.x;
	//				::SendMessage(s_ofhwnd, WM_LBUTTONDOWN, MK_LBUTTON, dlglparam);
	//				//::SendMessage(s_ofhwnd, WM_LBUTTONDBLCLK, MK_LBUTTON, dlglparam);//!!!!!!!!!!!!!!

	//				WPARAM wparam;
	//				wparam = (BN_CLICKED << 16) | ctrlid;
	//				//::SendMessage(s_ofhwnd, WM_COMMAND, wparam, (LPARAM)ctrlwnd);

	//				POINT dlgpoint2;
	//				dlgpoint2 = cursorpos;
	//				::ScreenToClient(ctrlwnd, &dlgpoint2);
	//				LPARAM dlglparam2;
	//				dlglparam2 = (dlgpoint2.y << 16) | dlgpoint2.x;
	//				//::SendMessage(ctrlwnd, WM_LBUTTONDOWN, MK_LBUTTON, dlglparam2);
	//				::SendMessage(ctrlwnd, WM_LBUTTONDOWN, MK_LBUTTON, dlglparam2);
	//			}








	//			//HWND treeviewhwnd = 0;
	//			//treeviewhwnd = FindWindowExW(s_getfilenamehwnd, 0, WC_LISTVIEW, 0);

	//			//WCHAR dlgclassname[MAX_PATH] = { 0L };
	//			//GetClassName(s_getfilenamehwnd, dlgclassname, MAX_PATH);
	//			//WCHAR dlgwintext[MAX_PATH] = { 0L };
	//			//GetWindowText(s_getfilenamehwnd, dlgwintext, MAX_PATH);



	//			//HWND ctrlwnd = 0;
	//			//ctrlwnd = GetOFWnd(cursorpos);
	//			//if (ctrlwnd) {
	//			//	WCHAR ctrlclassname[MAX_PATH] = { 0L };
	//			//	GetClassName(ctrlwnd, ctrlclassname, MAX_PATH);
	//			//	WCHAR ctrlwintext[MAX_PATH] = { 0L };
	//			//	GetWindowText(ctrlwnd, ctrlwintext, MAX_PATH);

	//			//	int ctrlid;
	//			//	ctrlid = GetDlgCtrlID(ctrlwnd);
	//			//	WPARAM wparam;
	//			//	wparam = (BN_CLICKED << 16) | ctrlid;
	//			//	//wparam = (BN_PUSHED << 16) | ctrlid;
	//			//	//::SendMessage(s_ofhwnd, WM_COMMAND, wparam, (LPARAM)ctrlwnd);
	//			//	//::SendMessage(ctrlwnd, BM_CLICK, 0, 0);

	//			//	//HWND parenthwnd = 0;
	//			//	//parenthwnd = GetParent(ctrlwnd);
	//			//	//if (parenthwnd) {
	//			//	//	WCHAR parentclassname[MAX_PATH] = { 0L };
	//			//	//	GetClassName(parenthwnd, parentclassname, MAX_PATH);
	//			//	//	WCHAR parentwintext[MAX_PATH] = { 0L };
	//			//	//	GetWindowText(parenthwnd, parentwintext, MAX_PATH);

	//			//	//	int dbgcnt;
	//			//	//	dbgcnt = 0;
	//			//	//	//{
	//			//	//	//	LVCOLUMN lvcol;
	//			//	//	//	LVITEM item;
	//			//	//	//	UINT i;
	//			//	//	//	//HWND hList = parenthwnd;
	//			//	//	//	//HWND hList = ctrlwnd;
	//			//	//	//	HWND hList = s_getfilenamehwnd;
	//			//	//	//	LV_HITTESTINFO lvinfo;
	//			//	//	//	WCHAR buf[MAX_PATH];

	//			//	//	//	ZeroMemory(&lvinfo, sizeof(LV_HITTESTINFO));

	//			//	//	//	GetCursorPos((LPPOINT)&lvinfo.pt);
	//			//	//	//	ScreenToClient(hList, &lvinfo.pt);
	//			//	//	//	ListView_HitTest(hList, &lvinfo);
	//			//	//	//	if ((lvinfo.flags & LVHT_ONITEM) != 0)
	//			//	//	//	{
	//			//	//	//		item.mask = TVIF_HANDLE | TVIF_TEXT;
	//			//	//	//		item.iItem = lvinfo.iItem;
	//			//	//	//		item.iSubItem = 0;          //取得するサブアイテムの番号
	//			//	//	//		item.pszText = buf;         //格納するテキストバッファ
	//			//	//	//		item.cchTextMax = MAX_PATH; //バッファ容量
	//			//	//	//		ListView_GetItem(hList, &item);
	//			//	//	//		DSMessageBox(s_3dwnd, buf, L"選択したデータ", MB_OK);
	//			//	//	//	}
	//			//	//	//}
	//			//	//	//int hotitem;
	//			//	//	//int parenthotitem;
	//			//	//	//hotitem = ListView_GetHotItem(ctrlwnd);
	//			//	//	//parenthotitem = ListView_GetHotItem(parenthwnd);
	//			//	//	//if (hotitem > 0) {
	//			//	//	//	_ASSERT(0);
	//			//	//	//}
	//			//	//	//if (parenthotitem > 0) {
	//			//	//	//	_ASSERT(0);
	//			//	//	//}

	//			//	//	//s_getfilenametreeview = parenthwnd;


	//			//	//	//POINT treepos;
	//			//	//	//treepos = cursorpos;
	//			//	//	////ScreenToClient(ctrlwnd, &treepos);
	//			//	//	////ScreenToClient(s_getfilenametreeview, &treepos);
	//			//	//	////ScreenToClient(s_ofhwnd, &treepos);
	//			//	//	//TVHITTESTINFO ht;
	//			//	//	//ZeroMemory(&ht, sizeof(TVHITTESTINFO));
	//			//	//	//ht.flags = TVHT_ONITEM;
	//			//	//	//ht.hItem = NULL;
	//			//	//	//ht.pt = treepos;
	//			//	//	////ht.pt.x = cursorpos.x;
	//			//	//	////ht.pt.y = cursorpos.y;
	//			//	//	////TreeView_HitTest(s_getfilenametreeview, &ht);
	//			//	//	//HTREEITEM hItem = TreeView_HitTest(ctrlwnd, &ht);
	//			//	//	//if (ht.flags & TVHT_ONITEM) {
	//			//	//	//	//TreeView_SelectItem(s_getfilenametreeview, hititem);

	//			//	//	//	//TVITEM ti;
	//			//	//	//	//ZeroMemory(&ti, sizeof(TVITEM));
	//			//	//	//	//ti.mask = TVIF_HANDLE | TVIF_PARAM;
	//			//	//	//	//ti.hItem = hititem;
	//			//	//	//	//TreeView_GetItem(s_getfilenametreeview, &ti);
	//			//	//	//	//int clickno = (int)tvi.lParam;

	//			//	//	//	//TreeView_Select(s_getfilenametreeview, ht.hItem, TVGN_CARET);
	//			//	//	//	TreeView_Select(ctrlwnd, ht.hItem, TVGN_CARET);


	//			//	//	//	int dbgcnt = 0;
	//			//	//	//}
	//			//	//}


	//			//	//s_ofhwnd = 0;
	//			//	//s_enumdist.clear();
	//			//	//::EnumChildWindows(s_getfilenamehwnd, EnumTreeViewProc, (LPARAM)&treeviewhwnd);
	//			//	//treeviewhwnd = GetNearestEnumDist();
	//			////if (treeviewhwnd) {
	//			//	//s_getfilenametreeview = treeviewhwnd;


	//			//	//POINT dlgpoint;
	//			//	//dlgpoint = cursorpos;
	//			//	//::ScreenToClient(s_ofhwnd, &dlgpoint);
	//			//	//LPARAM dlglparam;
	//			//	//dlglparam = (dlgpoint.y << 16) | dlgpoint.x;
	//			//	//::SendMessage(s_ofhwnd, WM_LBUTTONDOWN, MK_LBUTTON, dlglparam);

	//			//	//POINT dlgpoint2;
	//			//	//dlgpoint2 = cursorpos;
	//			//	//::ScreenToClient(s_getfilenametreeview, &dlgpoint2);
	//			//	//LPARAM dlglparam2;
	//			//	//dlglparam2 = (dlgpoint2.y << 16) | dlgpoint2.x;
	//			//	//::SendMessage(s_getfilenametreeview, WM_LBUTTONDOWN, MK_LBUTTON, dlglparam2);




	//			//}
	//			//}
	//				//if (!s_eventhook) {
	//				//	s_eventhook = SetWinEventHook(
	//				//		EVENT_SYSTEM_DIALOGSTART,
	//				//		//EVENT_SYSTEM_DIALOGSTART,
	//				//		EVENT_SYSTEM_DIALOGEND,
	//				//		NULL,
	//				//		WinEventProc,
	//				//		//GetDlgItemInt(IDC_PROCESSID),
	//				//		//GetProcessId(GetModuleHandle(NULL)),
	//				//		//GetThreadId(g_hUnderTrackingThread),
	//				//		//GetThreadId(s_messageboxthread),
	//				//		0,
	//				//		0,
	//				//		WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS
	//				//	);
	//				//}
	//				/*if (m_event != nullptr)
	//				{
	//					SetDlgItemText(IDOK, _T("停止"));
	//				}*/
	//		}
	//	}
	//}


	//if (cancelbuttonup >= 1) {
	//	POINT cursorpos;
	//	::GetCursorPos(&cursorpos);
	//	LPARAM lparam;
	//	lparam = (cursorpos.y << 16) | cursorpos.x;

	//	//if (g_undertrackingRMenu == 1) {
	//	if (InterlockedAdd(&g_undertrackingRMenu, 0) == 1) {
	//		if (s_messageboxhwnd) {
	//		}
	//		else {
	//			HWND ctrlwnd = 0;
	//			ctrlwnd = GetOFWnd(cursorpos);
	//			if (ctrlwnd) {
	//				int ctrlid;
	//				ctrlid = GetDlgCtrlID(ctrlwnd);
	//				WCHAR ctrlclassname[MAX_PATH] = { 0L };
	//				GetClassName(ctrlwnd, ctrlclassname, MAX_PATH);
	//				if (wcscmp(L"ListBox", ctrlclassname) == 0) {

	//					POINT lbpoint;
	//					lbpoint = cursorpos;
	//					::ScreenToClient(ctrlwnd, &lbpoint);
	//					LPARAM lblparam;
	//					lblparam = (lbpoint.y << 16) | lbpoint.x;
	//					DWORD hitinfo = (DWORD)SendMessage(ctrlwnd, LB_ITEMFROMPOINT, 0, lblparam);
	//					WORD hitflag;
	//					WORD hitindex;
	//					hitflag = HIWORD(hitinfo);
	//					hitindex = LOWORD(hitinfo);
	//					if (hitflag == 0) {
	//						//X buttonで  selectをCancel
	//						SendMessage(ctrlwnd, LB_SETSEL, (WPARAM)FALSE, (LPARAM)hitindex);
	//					}
	//				}
	//				/*else if (wcscmp(L"TreeView", ctrlclassname) == 0) {
	//					POINT tvpoint;
	//					tvpoint = cursorpos;
	//					::ScreenToClient(ctrlwnd, &tvpoint);
	//					LPARAM tvlparam;
	//					tvlparam = (tvpoint.y << 16) | tvpoint.x;

	//					TVHITTESTINFO ht;
	//					ZeroMemory(&ht, sizeof(TVHITTESTINFO));
	//					ht.flags = TVHT_ONITEM;
	//					ht.hItem = NULL;
	//					ht.pt = tvpoint;
	//					HTREEITEM hItem = TreeView_HitTest(ctrlwnd, &ht);
	//					if (ht.flags & TVHT_ONITEM) {
	//						TreeView_SelectItem(ctrlwnd, ht.hItem);
	//					}
	//				}*/
	//			}
	//		}
	//	}
	//}
}

BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam)
{
	if (!lParam) {
		return FALSE;
	}
	HWND* rethwnd = (HWND*)lParam;
	*rethwnd = 0;

	POINT mousepoint;
	::GetCursorPos(&mousepoint);
	::ScreenToClient(hwnd, &mousepoint);

	RECT ctrlrect;
	GetClientRect(hwnd, &ctrlrect);



	if ((mousepoint.x >= ctrlrect.left) && (mousepoint.x <= ctrlrect.right)
		&& (mousepoint.y >= ctrlrect.top) && (mousepoint.y <= ctrlrect.bottom)) {
		//if ((mousepoint.x >= 0) && (mousepoint.x <= (ctrlrect.right - ctrlrect.left))
		//	&& (mousepoint.y >= 0) && (mousepoint.y <= (ctrlrect.bottom - ctrlrect.top))) {

		//#################################################################################################################################################
		//groupboxのclassnameもButton。groupboxの中のコントロールを押すためには距離で判定する必要があった。マウス位置に一番近いコントロールを探すための情報をs_enumdistにpush_back
		//#################################################################################################################################################
		POINT ctrllefttop = { 0, 0 };
		//ctrlcenter.x = (ctrlrect.right - ctrlrect.left) / 2;//ラジオボタンなどはコントロール真ん中ではなく左側を押すことが多いので中央はやめる
		//ctrlcenter.y = (ctrlrect.bottom - ctrlrect.top) / 2;
		ctrllefttop.x = ctrlrect.left;
		ctrllefttop.y = ctrlrect.top;

		ENUMDIST enumdist;
		ZeroMemory(&enumdist, sizeof(ENUMDIST));
		enumdist.hwnd = hwnd;
		enumdist.dist = (float)(mousepoint.x - ctrllefttop.x) * (float)(mousepoint.x - ctrllefttop.x) + (float)(mousepoint.y - ctrllefttop.y) * (float)(mousepoint.y - ctrllefttop.y);
		s_enumdist.push_back(enumdist);


		//*rethwnd = hwnd;
		//return FALSE;//探索終了

		return TRUE;//探索続行
	}
	else {
		*rethwnd = 0;
		return TRUE;//探索続行
	}

}

BOOL CALLBACK EnumTreeViewProc(HWND hwnd, LPARAM lParam)
{
	if (!lParam) {
		return FALSE;
	}
	HWND* rethwnd = (HWND*)lParam;
	*rethwnd = 0;

	WCHAR classname[MAX_PATH] = { 0L };
	::GetClassName(hwnd, classname, MAX_PATH);

	//if ((wcscmp(L"SysListView32", classname) == 0) || (wcscmp(L"SysTreeView32", classname) == 0)) {
	if ((wcsstr(classname, L"ListBox") != 0) || (wcsstr(classname, L"TreeView") != 0)) {
		//*rethwnd = hwnd;
		//return FALSE;//探索終了

		POINT mousepoint;
		::GetCursorPos(&mousepoint);
		::ScreenToClient(hwnd, &mousepoint);
		//::ScreenToClient(s_getfilenamehwnd, &mousepoint);

		RECT ctrlrect;
		GetClientRect(hwnd, &ctrlrect);
		//GetWindowRect(hwnd, &ctrlrect);

		POINT ctrllefttop = { 0, 0 };
		//ctrlcenter.x = (ctrlrect.right - ctrlrect.left) / 2;//ラジオボタンなどはコントロール真ん中ではなく左側を押すことが多いので中央はやめる
		//ctrlcenter.y = (ctrlrect.bottom - ctrlrect.top) / 2;
		ctrllefttop.x = ctrlrect.left;
		ctrllefttop.y = ctrlrect.top;

		ENUMDIST enumdist;
		ZeroMemory(&enumdist, sizeof(ENUMDIST));
		enumdist.hwnd = hwnd;
		enumdist.dist = (float)(mousepoint.x - ctrllefttop.x) * (float)(mousepoint.x - ctrllefttop.x) + (float)(mousepoint.y - ctrllefttop.y) * (float)(mousepoint.y - ctrllefttop.y);
		s_enumdist.push_back(enumdist);

		*rethwnd = 0;
		return TRUE;//探索続行
	}
	else {
		*rethwnd = 0;
		return TRUE;//探索続行
	}
}



BOOL CALLBACK EnumIDOKProc(HWND hwnd, LPARAM lParam)
{
	if (!lParam) {
		return FALSE;
	}
	HWND* rethwnd = (HWND*)lParam;
	*rethwnd = 0;

	WCHAR wintext[MAX_PATH] = { 0L };
	::GetWindowText(hwnd, wintext, MAX_PATH);

	if (wcscmp(L"OK", wintext) == 0) {
		*rethwnd = hwnd;
		return FALSE;//探索終了
	}
	else {
		*rethwnd = 0;
		return TRUE;//探索続行
	}

}


//BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam)
//{
//	if (!lParam) {
//		return FALSE;
//	}
//	HWND* rethwnd = (HWND*)lParam;
//	//*rethwnd = 0;
//
//	WCHAR szBuff[512];
//	GetWindowTextW(hwnd, szBuff, 512);
//	int cmp;
//	cmp = wcscmp(L"OpenMqoDlg", szBuff);
//	if (cmp == 0) {
//		//HWND hbtn = NULL;
//		//::EnumChildWindows(hwnd, EnumChildProcOF, reinterpret_cast<LPARAM>(&hbtn));
//		//if (hbtn) {
//		*rethwnd = hwnd;
//		return FALSE;
//		//}
//		//else {
//		//	return TRUE;
//		//}
//	}
//	else {
//		//*rethwnd = 0;
//		return TRUE;
//	}
//}

HWND GetNearestEnumDist()
{
	if (s_enumdist.empty()) {
		return 0;
	}
	else {
		bool isfirst = true;
		float nearestdist = 1e20f;
		HWND nearesthwnd = 0;
		std::vector<ENUMDIST>::iterator itrenumdist;
		for (itrenumdist = s_enumdist.begin(); itrenumdist != s_enumdist.end(); itrenumdist++) {
			if (isfirst) {
				nearesthwnd = itrenumdist->hwnd;
				nearestdist = itrenumdist->dist;
				isfirst = false;
			}
			else {
				if (nearestdist > itrenumdist->dist) {
					nearesthwnd = itrenumdist->hwnd;
					nearestdist = itrenumdist->dist;
				}
			}
		}

		return nearesthwnd;
	}
}


HWND GetOFWnd(POINT srcpoint)
{
	HWND retctrlwnd = 0;

	s_ofhwnd = 0;
	s_enumdist.clear();

	CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg();


	if (!retctrlwnd && s_getfilenamehwnd) {
		::EnumChildWindows(s_getfilenamehwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_getfilenamehwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_mqodlghwnd) {
		::EnumChildWindows(s_mqodlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_mqodlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_underframecopydlg && curcpdlg && curcpdlg->m_hWnd) {
		::EnumChildWindows(curcpdlg->m_hWnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = curcpdlg->m_hWnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_undercolidlg && s_pcolidlg && s_pcolidlg->m_hWnd && IsWindow(s_pcolidlg->m_hWnd)) {
		::EnumChildWindows(s_pcolidlg->m_hWnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_pcolidlg->m_hWnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_undergcolidlg && s_pgcolidlg && s_pgcolidlg->m_hWnd && IsWindow(s_pgcolidlg->m_hWnd)) {
		::EnumChildWindows(s_pgcolidlg->m_hWnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_pgcolidlg->m_hWnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_motpropdlghwnd) {
		::EnumChildWindows(s_motpropdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_motpropdlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && g_filterdlghwnd) {
		::EnumChildWindows(g_filterdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = g_filterdlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && (s_currentwndid == MB3D_WND_SIDE) && s_anglelimitdlg && (s_platemenukind == SPPLATEMENUKIND_RETARGET) && (s_platemenuno == (SPRETARGETSW_LIMITEULER + 1))) {
		//if (s_anglelimitdlg && (s_platemenukind == SPPLATEMENUKIND_RETARGET) && (s_platemenuno == (SPRETARGETSW_LIMITEULER + 1))) {
		if ((s_curdseullimitctrlno >= 0) && (s_curdseullimitctrlno < s_dseullimitctrls.size()) && s_dseullimitctrls[s_curdseullimitctrlno]) {
			::EnumChildWindows(s_anglelimitdlg, EnumChildProc, (LPARAM)&retctrlwnd);
			retctrlwnd = GetNearestEnumDist();
			if (retctrlwnd) {
				s_ofhwnd = s_anglelimitdlg;
				return retctrlwnd;
			}
		}
	}
	else if (!retctrlwnd && s_savechadlghwnd) {
		::EnumChildWindows(s_savechadlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_savechadlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_bvhdlghwnd) {
		::EnumChildWindows(s_bvhdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_bvhdlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_saveredlghwnd) {
		::EnumChildWindows(s_saveredlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_saveredlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_savegcodlghwnd) {
		::EnumChildWindows(s_savegcodlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_savegcodlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_rotzisdlghwnd) {
		::EnumChildWindows(s_rotzisdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_rotzisdlghwnd;

			//WCHAR chkclassname[MAX_PATH] = { 0L };
			//::GetClassName(retctrlwnd, chkclassname, MAX_PATH);
			//::DSMessageBox(NULL, chkclassname, L"check!!!", MB_OK);

			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_customrighwnd) {
		::EnumChildWindows(s_customrighwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_customrighwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_mqodlghwnd) {
		::EnumChildWindows(s_exportxdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_exportxdlghwnd;
			return retctrlwnd;
		}
	}

	return 0;

}

void DSOptionButtonRightClick()
{
	////optionボタンは右クリック相当
	////カーソルがジョイント位置にあるときに右クリックするとコンテクストメニューが出る。

	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	//int optbuttonid = 11;
	//int optbuttondown;
	//int optbuttonup;

	//optbuttondown = s_dsbuttondown[optbuttonid];
	//optbuttonup = s_dsbuttonup[optbuttonid];

	//if (optbuttondown >= 1) {
	//	POINT cursorpos;
	//	::GetCursorPos(&cursorpos);
	//	LPARAM lparam;
	//	lparam = (cursorpos.y << 16) | cursorpos.x;

	//	if (g_undertrackingRMenu == 0) {
	//		if ((s_currentwndid == MB3D_WND_3D) && (s_curboneno >= 0)) {
	//			POINT cappoint;
	//			cappoint = cursorpos;
	//			::ScreenToClient(s_3dwnd, &cappoint);
	//			LPARAM caplparam;
	//			caplparam = (cappoint.y << 16) | cappoint.x;

	//			::SendMessage(s_3dwnd, WM_RBUTTONDOWN, MK_RBUTTON, caplparam);
	//		}
	//	}
	//}

	//if (optbuttonup >= 1) {
	//	POINT cursorpos;
	//	::GetCursorPos(&cursorpos);
	//	LPARAM lparam;
	//	lparam = (cursorpos.y << 16) | cursorpos.x;

	//	if (g_undertrackingRMenu == 0) {
	//		if ((s_currentwndid == MB3D_WND_3D) && (s_curboneno >= 0)) {
	//			POINT cappoint;
	//			cappoint = cursorpos;
	//			::ScreenToClient(s_3dwnd, &cappoint);
	//			LPARAM caplparam;
	//			caplparam = (cappoint.y << 16) | cappoint.x;

	//			::SendMessage(s_3dwnd, WM_RBUTTONUP, MK_RBUTTON, caplparam);
	//		}
	//	}
	//}

}


void DSAimBarOK()
{

	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	//int okbuttonid = 2;
	//int okbuttondown;
	//int okbuttonup;

	//okbuttondown = s_dsbuttondown[okbuttonid];
	//okbuttonup = s_dsbuttonup[okbuttonid];

	//if (okbuttondown >= 1) {
	//	POINT cursorpos;
	//	::GetCursorPos(&cursorpos);
	//	LPARAM lparam;
	//	lparam = (cursorpos.y << 16) | cursorpos.x;

	//	//if (g_undertrackingRMenu == 0) {
	//	if (InterlockedAdd(&g_undertrackingRMenu, 0) == 0) {
	//		{
	//			//dialog ctrl
	//			HWND ctrlwnd;
	//			ctrlwnd = GetOFWnd(cursorpos);
	//			if (ctrlwnd) {

	//				WCHAR wclassname[MAX_PATH] = { 0L };
	//				::GetClassNameW(ctrlwnd, wclassname, MAX_PATH);
	//				//::DSMessageBox(s_anglelimitdlg, wclassname, L"check!!!", MB_OK);
	//				if (wcscmp(L"ComboBox", wclassname) == 0) {
	//					//COMBOBOX
	//					::SendMessage(ctrlwnd, CB_SHOWDROPDOWN, TRUE, 0);

	//					//HWND caphwnd;
	//					//caphwnd = ::GetCapture();
	//					//if (caphwnd && IsWindow(caphwnd)) {
	//					//	::SendMessage(caphwnd, CB_SHOWDROPDOWN, TRUE, 0);
	//					//}
	//				}
	//				else if (wcscmp(L"msctls_trackbar32", wclassname) == 0) {
	//					//Slider
	//					RECT sliderloc;
	//					::GetWindowRect(ctrlwnd, &sliderloc);
	//					POINT cappoint = cursorpos;
	//					::ScreenToClient(ctrlwnd, &cappoint);

	//					float rangemin;
	//					float rangemax;
	//					rangemin = (float)::SendMessage(ctrlwnd, TBM_GETRANGEMIN, 0, 0);
	//					rangemax = (float)::SendMessage(ctrlwnd, TBM_GETRANGEMAX, 0, 0);

	//					float thumblength;
	//					thumblength = (float)::SendMessage(ctrlwnd, TBM_GETTHUMBLENGTH, 0, 0);

	//					//int sliderpos = (int)((float)(cappoint.x - 12 - 274 / 2) / 274.0f * 360.0f);
	//					int sliderpos = (int)((float)(cappoint.x - thumblength / 2.0f) / (float)(sliderloc.right - sliderloc.left - thumblength) * (float)(rangemax - rangemin) + rangemin);

	//					::SendMessage(ctrlwnd, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);
	//					::SendMessage(s_ofhwnd, WM_HSCROLL, 0, (LPARAM)ctrlwnd);
	//				}
	//				else {
	//					POINT dlgpoint;
	//					dlgpoint = cursorpos;
	//					::ScreenToClient(s_ofhwnd, &dlgpoint);
	//					LPARAM dlglparam;
	//					dlglparam = (dlgpoint.y << 16) | dlgpoint.x;
	//					::SendMessage(s_ofhwnd, WM_LBUTTONDOWN, MK_LBUTTON, dlglparam);

	//					POINT cappoint;
	//					cappoint = cursorpos;
	//					::ScreenToClient(ctrlwnd, &cappoint);
	//					LPARAM caplparam;
	//					caplparam = (cappoint.y << 16) | cappoint.x;
	//					::SendMessage(ctrlwnd, WM_LBUTTONDOWN, MK_LBUTTON, caplparam);
	//				}
	//			}
	//			else {
	//				bool doneflag1 = false;
	//				if (s_dispmodel && s_modelpanel.panel && s_modelpanel.panel->getHWnd()) {
	//					RECT panelrect;
	//					GetWindowRect(s_modelpanel.panel->getHWnd(), &panelrect);
	//					if ((cursorpos.x >= panelrect.left) && (cursorpos.x <= panelrect.right) &&
	//						(cursorpos.y >= panelrect.top) && (cursorpos.y <= panelrect.bottom)) {
	//						POINT cappoint;
	//						cappoint = cursorpos;
	//						::ScreenToClient(s_modelpanel.panel->getHWnd(), &cappoint);
	//						LPARAM caplparam;
	//						caplparam = (cappoint.y << 16) | cappoint.x;
	//						::SendMessage(s_modelpanel.panel->getHWnd(), WM_LBUTTONDOWN, MK_LBUTTON, caplparam);
	//						SetCapture(s_modelpanel.panel->getHWnd());
	//						doneflag1 = true;
	//					}
	//				}
	//				if (!doneflag1) {
	//					if (s_dispobj && s_layerWnd && s_layerWnd->getHWnd()) {
	//						RECT panelrect;
	//						GetWindowRect(s_layerWnd->getHWnd(), &panelrect);
	//						if ((cursorpos.x >= panelrect.left) && (cursorpos.x <= panelrect.right) &&
	//							(cursorpos.y >= panelrect.top) && (cursorpos.y <= panelrect.bottom)) {
	//							POINT cappoint;
	//							cappoint = cursorpos;
	//							::ScreenToClient(s_layerWnd->getHWnd(), &cappoint);
	//							LPARAM caplparam;
	//							caplparam = (cappoint.y << 16) | cappoint.x;
	//							::SendMessage(s_layerWnd->getHWnd(), WM_LBUTTONDOWN, MK_LBUTTON, caplparam);
	//							SetCapture(s_layerWnd->getHWnd());
	//							doneflag1 = true;
	//						}
	//					}
	//				}
	//				if (!doneflag1) {
	//					//aimbar
	//					HWND caphwnd;
	//					caphwnd = ::GetCapture();
	//					if (caphwnd && IsWindow(caphwnd)) {
	//						POINT cappoint;
	//						cappoint = cursorpos;
	//						::ScreenToClient(caphwnd, &cappoint);
	//						LPARAM caplparam;
	//						caplparam = (cappoint.y << 16) | cappoint.x;
	//						::SendMessage(caphwnd, WM_LBUTTONDOWN, MK_LBUTTON, caplparam);
	//					}
	//				}
	//			}
	//		}

	//	}
	//}

	////g_DialogResourceManager.MsgProc(hWnd, uMsg, wParam, lParam);


	//if (okbuttonup >= 1) {
	//	POINT cursorpos;
	//	::GetCursorPos(&cursorpos);
	//	LPARAM lparam;
	//	lparam = (cursorpos.y << 16) | cursorpos.x;

	//	//if (g_undertrackingRMenu == 0) {
	//	if (InterlockedAdd(&g_undertrackingRMenu, 0) == 0) {
	//		//dialog ctrl
	//		HWND ctrlwnd;
	//		ctrlwnd = GetOFWnd(cursorpos);
	//		if (ctrlwnd) {
	//			::SendMessage(ctrlwnd, WM_LBUTTONUP, 0, 0);
	//			if (s_ofhwnd) {
	//				POINT cappoint;
	//				cappoint = cursorpos;
	//				::ScreenToClient(ctrlwnd, &cappoint);
	//				LPARAM caplparam;
	//				caplparam = (cappoint.y << 16) | cappoint.x;

	//				//int ctrlid;
	//				//ctrlid = GetDlgCtrlID(ctrlwnd);
	//				//::SendMessage(s_ofhwnd, WM_COMMAND, ctrlid, 0);//WM_COMMANDはマウスのUPよりも後で呼ばないとUPでコマンドが終了してしまうことがある。


	//				WCHAR wclassname[MAX_PATH] = { 0L };
	//				::GetClassNameW(ctrlwnd, wclassname, MAX_PATH);
	//				//::DSMessageBox(s_anglelimitdlg, wclassname, L"check!!!", MB_OK);
	//				if (wcscmp(L"ComboBox", wclassname) == 0) {
	//					//	//COMBOBOX
	//					//	::SendMessage(ctrlwnd, CB_SHOWDROPDOWN, TRUE, 0);//DOWNのときに処理する
	//				}
	//				else if (wcscmp(L"msctls_trackbar32", wclassname) == 0) {
	//					//Slider
	//					RECT sliderloc;
	//					::GetWindowRect(ctrlwnd, &sliderloc);
	//					POINT cappoint2 = cursorpos;
	//					::ScreenToClient(ctrlwnd, &cappoint2);

	//					float rangemin;
	//					float rangemax;
	//					rangemin = (float)::SendMessage(ctrlwnd, TBM_GETRANGEMIN, 0, 0);
	//					rangemax = (float)::SendMessage(ctrlwnd, TBM_GETRANGEMAX, 0, 0);

	//					float thumblength;
	//					thumblength = (float)::SendMessage(ctrlwnd, TBM_GETTHUMBLENGTH, 0, 0);

	//					//int sliderpos = (int)((float)(cappoint2.x - 12 - 274 / 2) / 274.0f * 360.0f);
	//					int sliderpos = (int)((float)(cappoint2.x - thumblength / 2.0f) / (float)(sliderloc.right - sliderloc.left - thumblength) * (float)(rangemax - rangemin) + rangemin);

	//					::SendMessage(ctrlwnd, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);
	//					::SendMessage(s_ofhwnd, WM_HSCROLL, 0, (LPARAM)ctrlwnd);
	//				}
	//				else if (wcscmp(L"Button", wclassname) == 0) {
	//					POINT dlgpoint;
	//					dlgpoint = cursorpos;
	//					::ScreenToClient(s_ofhwnd, &dlgpoint);
	//					LPARAM dlglparam;
	//					dlglparam = (dlgpoint.y << 16) | dlgpoint.x;
	//					::SendMessage(s_ofhwnd, WM_LBUTTONUP, MK_LBUTTON, dlglparam);

	//					POINT cappoint2;
	//					cappoint2 = cursorpos;
	//					::ScreenToClient(ctrlwnd, &cappoint2);
	//					LPARAM caplparam2;
	//					caplparam2 = (cappoint2.y << 16) | cappoint2.x;
	//					::SendMessage(ctrlwnd, WM_LBUTTONUP, MK_LBUTTON, caplparam2);

	//					//::SendMessage(ctrlwnd, WM_LBUTTONUP, MK_LBUTTON, caplparam);

	//					//int check1 = SendMessage(ctrlwnd, BM_GETCHECK, 0, 0);
	//					//if (check1 == 0) {
	//					//	SendMessage(ctrlwnd,
	//					//		BM_SETCHECK,
	//					//		BST_CHECKED,    // チェックをつける
	//					//		0);
	//					//}
	//					//else if (check1 == 1) {
	//					//	SendMessage(ctrlwnd,
	//					//		BM_SETCHECK,
	//					//		BST_UNCHECKED,    // チェックをはずす
	//					//		0);
	//					//}
	//				}
	//				else {
	//					POINT dlgpoint;
	//					dlgpoint = cursorpos;
	//					::ScreenToClient(s_ofhwnd, &dlgpoint);
	//					LPARAM dlglparam;
	//					dlglparam = (dlgpoint.y << 16) | dlgpoint.x;
	//					::SendMessage(s_ofhwnd, WM_LBUTTONUP, MK_LBUTTON, dlglparam);

	//					POINT cappoint2;
	//					cappoint2 = cursorpos;
	//					::ScreenToClient(ctrlwnd, &cappoint2);
	//					LPARAM caplparam2;
	//					caplparam2 = (cappoint2.y << 16) | cappoint2.x;
	//					::SendMessage(ctrlwnd, WM_LBUTTONUP, MK_LBUTTON, caplparam2);

	//					//::SendMessage(ctrlwnd, WM_LBUTTONUP, MK_LBUTTON, caplparam);
	//				}

	//				int ctrlid;
	//				ctrlid = GetDlgCtrlID(ctrlwnd);
	//				::SendMessage(s_ofhwnd, WM_COMMAND, ctrlid, 0);//WM_COMMANDはマウスのUPよりも後で呼ばないとUPでコマンドが終了してしまうことがある。

	//			}
	//		}
	//		else {

	//			bool doneflag1 = false;
	//			if (s_dispmodel && s_modelpanel.panel && s_modelpanel.panel->getHWnd()) {
	//				RECT panelrect;
	//				GetWindowRect(s_modelpanel.panel->getHWnd(), &panelrect);
	//				if ((cursorpos.x >= panelrect.left) && (cursorpos.x <= panelrect.right) &&
	//					(cursorpos.y >= panelrect.top) && (cursorpos.y <= panelrect.bottom)) {
	//					POINT cappoint;
	//					cappoint = cursorpos;
	//					::ScreenToClient(s_modelpanel.panel->getHWnd(), &cappoint);
	//					LPARAM caplparam;
	//					caplparam = (cappoint.y << 16) | cappoint.x;
	//					::SendMessage(s_modelpanel.panel->getHWnd(), WM_LBUTTONUP, MK_LBUTTON, caplparam);
	//					ReleaseCapture();
	//					doneflag1 = true;
	//				}
	//			}
	//			if (!doneflag1) {
	//				if (s_dispobj && s_layerWnd && s_layerWnd->getHWnd()) {
	//					RECT panelrect;
	//					GetWindowRect(s_layerWnd->getHWnd(), &panelrect);
	//					if ((cursorpos.x >= panelrect.left) && (cursorpos.x <= panelrect.right) &&
	//						(cursorpos.y >= panelrect.top) && (cursorpos.y <= panelrect.bottom)) {
	//						POINT cappoint;
	//						cappoint = cursorpos;
	//						::ScreenToClient(s_layerWnd->getHWnd(), &cappoint);
	//						LPARAM caplparam;
	//						caplparam = (cappoint.y << 16) | cappoint.x;
	//						::SendMessage(s_layerWnd->getHWnd(), WM_LBUTTONUP, MK_LBUTTON, caplparam);
	//						ReleaseCapture();
	//						doneflag1 = true;
	//					}
	//				}
	//			}
	//			if (!doneflag1) {
	//				//aim bar
	//				HWND caphwnd;
	//				caphwnd = ::GetCapture();
	//				if (caphwnd && IsWindow(caphwnd)) {
	//					//WPARAM wparam = (0xFFFF << 16) | (WORD)g_currentsubmenuid;//g_currentsubmenuid, curmenuitemid
	//					//::SendMessage(g_mainhwnd, WM_MENUSELECT, wparam, (LPARAM)GetMenu(g_mainhwnd));//GetMenu(g_mainhwnd), cursubmenu
	//					POINT cappoint;
	//					cappoint = cursorpos;
	//					::ScreenToClient(caphwnd, &cappoint);
	//					LPARAM caplparam;
	//					caplparam = (cappoint.y << 16) | cappoint.x;
	//					::SendMessage(caphwnd, WM_LBUTTONUP, MK_LBUTTON, caplparam);
	//				}

	//				//MainMenuAimBar
	//				if ((s_currentwndid == MB3D_WND_MAIN) && s_cursubmenu && (g_currentsubmenuid >= 0) && (g_currentsubmenuid < SPMENU_MAX)) {
	//					//SelectNextWindow(MB3D_WND_3D);//続いて　O button を押したときにメニューが開かないように。//プレート選択時に該当ウインドウをハイライトするようにしたので必要ない。
	//					InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	//					//SetForegroundWindow(g_mainhwnd);//この処理をしないと範囲外クリックでPopupが閉じない
	//					SetForegroundWindow(s_3dwnd);//この処理をしないと範囲外クリックでPopupが閉じない
	//					//int retmenuid = ::TrackPopupMenu(s_cursubmenu, TPM_RETURNCMD | TPM_LEFTALIGN, g_currentsubmenupos.x, g_currentsubmenupos.y, 0, g_mainhwnd, NULL);
	//					int retmenuid = ::TrackPopupMenu(s_cursubmenu, TPM_RETURNCMD | TPM_LEFTALIGN, g_currentsubmenupos.x, g_currentsubmenupos.y, 0, s_3dwnd, NULL);
	//					InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	//				}
	//			}
	//		}

	//		//MainWindow MsgProc ; Prepair For Undo
	//		PrepairUndo();//メニューバーOK後の保存

	//		s_wmlbuttonup = 1;

	//	}

	//}

}



void ChangeMouseSetCapture()
{

	static bool s_firstflag = true;
	static int s_capwndid = -1;

	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}

	if (!g_mainhwnd) {
		return;
	}

	int dragbuttondown;
	int dragbuttonup;

	dragbuttondown = s_dsbuttondown[2];
	dragbuttonup = s_dsbuttonup[2];


	//〇ボタン押していないときには何もしないでリターン
	if (!dragbuttondown) {
		return;
	}


	POINT mousepoint;
	::GetCursorPos(&mousepoint);
	POINT clientpoint = mousepoint;
	::ScreenToClient(g_mainhwnd, &clientpoint);

	int chkx = clientpoint.x;
	int chky = clientpoint.y;


	//static RECT s_rcmainwnd;
	//static RECT s_rc3dwnd;
	//static RECT s_rctreewnd;
	//static RECT s_rctoolwnd;
	//static RECT s_rcltwnd;
	//static RECT s_rcsidemenuwnd;
	//static RECT s_rcrigidwnd;
	//static RECT s_rcinfownd;


	int nextcapwndid = -1;

	////check mainwnd
	{
		int wndtop = 0;
		int wndleft = 0;
		int wndbottom = s_rcmainwnd.bottom;
		int wndright = s_rcmainwnd.right;

		if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
			nextcapwndid = 0;
		}
	}

	//check 3dwnd
	{
		int wndtop = s_rc3dwnd.top;
		int wndleft = s_rctreewnd.right;
		int wndbottom = s_rc3dwnd.bottom;
		int wndright = wndleft + s_rc3dwnd.right;

		if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
			nextcapwndid = 1;
		}
	}

	//check treewnd
	{
		int wndtop = s_rctreewnd.top;
		int wndleft = 0;
		int wndbottom = s_rctreewnd.bottom;
		int wndright = s_rctreewnd.right;

		if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
			nextcapwndid = 2;
		}
	}

	//check toolwnd
	{
		int wndtop = s_rctreewnd.bottom;
		int wndleft = 0;
		int wndbottom = s_rctreewnd.bottom + s_rctoolwnd.bottom;
		int wndright = s_rctoolwnd.right;

		if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
			nextcapwndid = 3;
		}
	}

	//check ltwnd
	{
		int wndtop = s_rctreewnd.bottom;
		int wndleft = s_rctoolwnd.right;
		int wndbottom = s_rctreewnd.bottom + s_rcltwnd.bottom;
		int wndright = s_rctoolwnd.right + s_rcltwnd.right;

		if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
			nextcapwndid = 4;
		}
	}

	//check sidemenuwnd
	{
		int wndtop = 0;
		int wndleft = s_rctreewnd.right + s_rc3dwnd.right;
		int wndbottom = s_rcsidemenuwnd.bottom;
		int wndright = s_rctreewnd.right + s_rc3dwnd.right + s_rcsidemenuwnd.right;

		if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
			nextcapwndid = 5;
		}
	}

	//check rigidwnd
	{
		int wndtop = s_rcsidemenuwnd.bottom;
		int wndleft = s_rctreewnd.right + s_rc3dwnd.right;
		int wndbottom = s_rcsidemenuwnd.bottom + s_rcrigidwnd.bottom;
		int wndright = s_rctreewnd.right + s_rc3dwnd.right + s_rcrigidwnd.right;

		if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
			nextcapwndid = 6;
		}
	}

	//check infownd
	{
		int wndtop = s_rc3dwnd.bottom;
		int wndleft = s_rctreewnd.right;
		int wndbottom = s_rc3dwnd.bottom + s_rcinfownd.bottom;
		int wndright = s_rctreewnd.right + s_rcinfownd.right;

		if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
			nextcapwndid = 7;
		}
	}

	if (s_dispmodel) {
		//check modelpanel
		{
			int wndtop = s_rcmodelpanel.top;
			int wndleft = s_rcmodelpanel.left;
			int wndbottom = s_rcmodelpanel.bottom;
			int wndright = s_rcmodelpanel.right;

			if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
				nextcapwndid = 8;
			}
		}
	}
	if (s_dispmotion) {
		//check motionpanel
		{
			int wndtop = s_rcmotionpanel.top;
			int wndleft = s_rcmotionpanel.left;
			int wndbottom = s_rcmotionpanel.bottom;
			int wndright = s_rcmotionpanel.right;

			if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
				nextcapwndid = 9;
			}
		}
	}
	if (s_dispcamera) {
		//check camerapanel
		{
			int wndtop = s_rccamerapanel.top;
			int wndleft = s_rccamerapanel.left;
			int wndbottom = s_rccamerapanel.bottom;
			int wndright = s_rccamerapanel.right;

			if ((chkx >= wndleft) && (chkx <= wndright) && (chky >= wndtop) && (chky <= wndbottom)) {
				nextcapwndid = 10;
			}
		}
	}


	///////////////
	///////////////

	//if ((s_pickinfo.buttonflag == PICK_CAMMOVE) || (s_pickinfo.buttonflag == PICK_CAMROT) || (s_pickinfo.buttonflag == PICK_CAMDIST)) {
	//	//ここでは、カメラスプライトをドラッグ中はマウスキャプチャーをいじらない
	//}
	//if ((nextcapwndid != s_capwndid) || (s_wmlbuttonup == 1) || (s_dspushedOK == 0) || (g_undertrackingRMenu == 0)) {
	//else if ((nextcapwndid != s_capwndid) || (s_wmlbuttonup == 1) || (s_dspushedOK == 0)) {


	if (dragbuttondown >= 1) {//〇ボタンを押したときにキャプチャーオン

		//if ((nextcapwndid != s_capwndid) || (s_wmlbuttonup == 1)) {//常にではなく、〇ボタンを押したときだけ処理。同じウインドウでも必要なことがある。
		switch (nextcapwndid) {
		case 0:
			if (g_mainhwnd) {
				if (g_mainhwnd) {
					SetCapture(g_mainhwnd);
				}
			}
			break;

		case 1:
			//if (s_3dwnd) {
			//	//SetCapture(s_3dwnd);
			//	HWND dlghwnd;
			//	dlghwnd = g_SampleUI.GetHWnd();
			//	if (dlghwnd) {
			//		SetCapture(dlghwnd);
			//	}
			//}
			break;
		case 2:
			if (s_timelineWnd) {
				SetCapture(s_timelineWnd->getHWnd());
			}
			break;
		case 3:
			if (s_toolWnd) {
				SetCapture(s_toolWnd->getHWnd());
			}
			break;
		case 4:
			if (s_LtimelineWnd) {
				SetCapture(s_LtimelineWnd->getHWnd());
			}
			break;
		case 5:
			if (s_sidemenuWnd) {
				SetCapture(s_sidemenuWnd->getHWnd());
			}
			break;
		case 6:
			//plate menuで場合分け必要
			//if (s_platemenukind == SPPLATEMENUKIND_GUI) {
			//	if (g_mainhwnd) {
			//		SetCapture(g_mainhwnd);
			//	}
			//}
			//else 
			if (s_platemenukind == SPPLATEMENUKIND_DISP) {
				if (s_platemenuno == (SPDISPSW_LIGHTS + 1)) {
					if (s_lightsforeditdlg) {
						SetCapture(s_lightsforeditdlg);
					}
				}
				else if (s_platemenuno == (SPDISPSW_DISPGROUP + 1)) {
					if (s_groupWnd) {
						SetCapture(s_groupWnd->getHWnd());
					}
				}
				else if (s_platemenuno == (SPDISPSW_LATERTRANSPARENT + 1)) {
					if (s_latertransparentdlg) {
						SetCapture(s_latertransparentdlg);
					}
				}
				else if (s_platemenuno == (SPDISPSW_SHADERTYPE + 1)) {
					if (s_shadertypeWnd) {
						SetCapture(s_shadertypeWnd->getHWnd());
					}
				}
				else if (s_platemenuno == (SPDISPSW_SHADOWPARAMS + 1)) {
					if (s_shadowparamsdlg) {
						SetCapture(s_shadowparamsdlg);
					}
				}
			}
			else if (s_platemenukind == SPPLATEMENUKIND_RIGID) {
				if (s_platemenuno == (SPRIGIDSW_RIGIDPARAMS + 1)) {
					if (s_rigidWnd) {
						SetCapture(s_rigidWnd->getHWnd());
					}
				}
				else if (s_platemenuno == (SPRIGIDSW_IMPULSE + 1)) {
					if (s_impWnd) {
						SetCapture(s_impWnd->getHWnd());
					}
				}
				else if (s_platemenuno == (SPRIGIDSW_GROUNDPLANE + 1)) {
					if (s_gpWnd) {
						SetCapture(s_gpWnd->getHWnd());
					}
				}
				else if (s_platemenuno == (SPRIGIDSW_DAMPANIM + 1)) {
					if (s_dmpanimWnd) {
						SetCapture(s_dmpanimWnd->getHWnd());
					}
				}
			}
			else if (s_platemenukind == SPPLATEMENUKIND_RETARGET) {
				if (s_platemenuno == (SPRETARGETSW_RETARGET + 1)) {
					if (s_convboneWnd) {
						SetCapture(s_convboneWnd->getHWnd());
					}
				}
				else if (s_platemenuno == (SPRETARGETSW_LIMITEULER + 1)) {
					if (s_anglelimitdlg) {
						SetCapture(s_anglelimitdlg);
					}
				}
			}
			break;
		case 7:
			if (g_infownd) {
				SetCapture(g_infownd->GetHWnd());
			}
			break;
		case 8:
			if (s_modelpanel.panel) {
				SetCapture(s_modelpanel.panel->getHWnd());
			}
			break;
		case 9:
			if (s_motionpanel.panel) {
				SetCapture(s_motionpanel.panel->getHWnd());
			}
			break;
		case 10:
			if (s_camerapanel.panel) {
				SetCapture(s_camerapanel.panel->getHWnd());
			}
			break;

		default:
			if (g_mainhwnd) {
				SetCapture(g_mainhwnd);
			}
			//if (g_mainhwnd) {
			//	if (!s_firstflag) {
			//		ReleaseCapture();
			//		s_firstflag = false;
			//	}
			//	SetCapture(g_mainhwnd);
			//}
			break;
		}

		s_capwndid = nextcapwndid;
		s_wmlbuttonup = 0;
		//}
	}
}


void ChangeMouseReleaseCapture()
{
	//if (!g_mainhwnd) {
	//	return;
	//}

	//int dragbuttondown;
	//int dragbuttonup;

	//dragbuttondown = s_dsbuttondown[2];
	//dragbuttonup = s_dsbuttonup[2];


	////〇ボタンを話した時にリリースキャプチャしてリターン
	//if (dragbuttonup >= 1) {
	//	ReleaseCapture();
	//	return;
	//}
}

void OrgWindowListenMouse(bool srcflag)
{
	if (s_timelineWnd) {
		s_timelineWnd->setListenMouse(srcflag);
	}
	if (s_LtimelineWnd) {
		s_LtimelineWnd->setListenMouse(srcflag);
	}
	if (s_dmpanimWnd) {
		s_dmpanimWnd->setListenMouse(srcflag);
	}
	if (s_sidemenuWnd) {
		s_sidemenuWnd->setListenMouse(srcflag);
	}
	if (s_mainmenuaimbarWnd) {
		s_mainmenuaimbarWnd->setListenMouse(srcflag);
	}
	if (s_placefolderWnd) {
		s_placefolderWnd->setListenMouse(srcflag);
	}
	if (s_rigidWnd) {
		s_rigidWnd->setListenMouse(srcflag);
	}
	if (s_shadertypeWnd) {
		s_shadertypeWnd->setListenMouse(srcflag);
	}
	if (s_impWnd) {
		s_impWnd->setListenMouse(srcflag);
	}
	if (s_gpWnd) {
		s_gpWnd->setListenMouse(srcflag);
	}
	if (s_toolWnd) {
		s_toolWnd->setListenMouse(srcflag);
	}
	if (s_convboneWnd) {
		s_convboneWnd->setListenMouse(srcflag);
	}
	if (s_layerWnd) {
		s_layerWnd->setListenMouse(srcflag);
	}
	if (s_convboneWnd) {
		s_convboneWnd->setListenMouse(srcflag);
	}

	//anglelimitdlgはWindowsDialog

}

void DSMessageBox(HWND srcparenthwnd, const WCHAR* srcmessage, const WCHAR* srctitle, LONG srcok)
{
	if (!srcmessage || !srctitle) {
		return;
	}

	_ASSERT(srcok == MB_OK);

	int cmperror;
	int cmpwarning;
	int cmpcheck;
	cmperror = wcscmp(srctitle, L"error!!!");
	cmpwarning = wcscmp(srctitle, L"warning!!!");
	cmpcheck = wcscmp(srctitle, L"check!!!");
	_ASSERT((cmperror == 0) || (cmpwarning == 0) || (cmpcheck == 0));


	s_messageboxhwnd = 0;
	s_messageboxpushcnt = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

	::MessageBoxW(srcparenthwnd, srcmessage, srctitle, srcok);

	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	//UnhookWinEvent(hhook);
	s_messageboxhwnd = 0;
	s_messageboxpushcnt = 0;
}

void SetMainWindowTitle()
{
	if (!g_mainhwnd) {
		return;
	}



	WCHAR strmaintitle[MAX_PATH * 3] = { 0L };
	swprintf_s(strmaintitle, MAX_PATH * 3, L"AdditiveIK Ver1.0.0.6 : No.%d : ", s_appcnt);


	if (s_model && s_chascene) {
		//WCHAR strcharactor[MAX_PATH * 3] = { 0L };
		WCHAR strindexedcharactor[MAX_PATH * 3] = { 0L };
		char strmotionA[MAX_PATH * 3] = { 0 };
		WCHAR strmotionW[MAX_PATH * 3] = { 0 };
		WCHAR strrefW[MAX_PATH * 3] = { 0 };

		int modelnum = s_chascene->GetModelNum();

		if ((modelnum >= 1) && (s_curmodelmenuindex >= 0) && (s_curmodelmenuindex < modelnum)) {
			CModel* curmodel;
			curmodel = s_chascene->GetModel(s_curmodelmenuindex);
			if (curmodel) {
				swprintf_s(strindexedcharactor, MAX_PATH * 3, L"%d : %s", s_curmodelmenuindex, curmodel->GetFileName());
				wcscat_s(strmaintitle, (MAX_PATH * 3), strindexedcharactor);
				wcscat_s(strmaintitle, (MAX_PATH * 3), L" : ");

				MOTINFO* curmi;
				curmi = s_model->GetCurMotInfo();
				if (curmi) {
					strcpy_s(strmotionA, (MAX_PATH * 3), curmi->motname);
					MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, strmotionA, (MAX_PATH * 3), strmotionW, (MAX_PATH * 3));
					wcscat_s(strmaintitle, (MAX_PATH * 3), strmotionW);
					wcscat_s(strmaintitle, (MAX_PATH * 3), L" : ");
				}

				int retrefindex = -1;
				REINFO reinfo;
				reinfo = s_model->GetCurrentRigidElemInfo(&retrefindex);
				if (retrefindex >= 0) {
					MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, reinfo.filename, (MAX_PATH * 3), strrefW, (MAX_PATH * 3));
					wcscat_s(strmaintitle, (MAX_PATH * 3), strrefW);
				}
				else {
					wcscat_s(strmaintitle, (MAX_PATH * 3), L"reffile unknown");
				}
			}
		}
	}

	SetWindowText(g_mainhwnd, strmaintitle);

}


void OnGUIEventSpeed()
{
	//if (!s_chascene) {
	//	return;
	//}

	//RollbackCurBoneNo();
	//g_dspeed = (float)((double)g_SampleUI.GetSlider(IDC_SPEED)->GetValue() * 0.010);


	////for (modelno = 0; modelno < modelnum; modelno++) {
	////	s_modelindex[modelno].modelptr->SetMotionSpeed(g_dspeed);
	////}

	////SetMotionSpeed() : モーションごとのスピード
	////SetTmpMotSpeed() : モーションが変わってもスライダー指定のスピード

	//s_chascene->SetMotionSpeed(-1, g_dspeed);

	//WCHAR sz[100] = { 0L };
	//swprintf_s(sz, 100, L"Speed: %0.4f", g_dspeed);
	//g_SampleUI.GetStatic(IDC_SPEED_STATIC)->SetText(sz);
}

//void WaitRetargetThreads()
//{
//	//if ((g_retargetbatchflag == 2) || (g_retargetbatchflag == 3)) {//2はダイアログでのキャンセル
//	if ((InterlockedAdd(&g_retargetbatchflag, 0) == 2) || (InterlockedAdd(&g_retargetbatchflag, 0) == 3)) {//2はダイアログでのキャンセル
//		InterlockedExchange(&g_retargetbatchflag, (LONG)0);
//		if (s_retargetbatchwnd) {
//			SendMessage(s_retargetbatchwnd, WM_CLOSE, 0, 0);
//		}
//		s_retargetcnt = 0;
//		InterlockedExchange(&g_retargetbatchflag, (LONG)0);//WM_CLOSEで変わる可能性あり
//
//		ChangeLimitDegFlag(s_savelimitdegflag, true, true);
//		//g_limitdegflag = s_savelimitdegflag;
//		//if (s_LimitDegCheckBox) {
//		//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
//		//}
//
//		OnModelMenu(true, s_saveretargetmodel, 1);
//	}
//
//}

//void WaitMotionCacheThreads()
//{
//	//if ((g_motioncachebatchflag == 2) || (g_motioncachebatchflag == 3)) {//2はダイアログでのキャンセル
//	if ((InterlockedAdd(&g_motioncachebatchflag, 0) == 2) || (InterlockedAdd(&g_motioncachebatchflag, 0) == 3)) {//2はダイアログでのキャンセル
//		InterlockedExchange(&g_motioncachebatchflag, (LONG)0);
//		if (s_motioncachebatchwnd) {
//			SendMessage(s_motioncachebatchwnd, WM_CLOSE, 0, 0);
//		}
//		s_motioncachecnt = 0;
//		InterlockedExchange(&g_motioncachebatchflag, (LONG)0);//WM_CLOSEで変わる可能性あり
//	}
//
//}

//void WaitBvh2FbxThreads()
//{
//	//if ((g_bvh2fbxbatchflag == 2) || (g_bvh2fbxbatchflag == 3)) {//2はダイアログでのキャンセル
//	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 2) || (InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 3)) {//2はダイアログでのキャンセル
//		InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)0);
//		if (s_bvh2fbxbatchwnd) {
//			SendMessage(s_bvh2fbxbatchwnd, WM_CLOSE, 0, 0);
//		}
//		s_bvh2fbxcnt = 0;
//		InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)0);//WM_CLOSEで変わる可能性あり
//	}
//}

int SaveRtgHistory(WCHAR* selectname)
{
	WCHAR saveprojpath[MAX_PATH] = { 0L };
	wcscpy_s(saveprojpath, MAX_PATH, selectname);

	//書き込み処理が成功してから履歴を保存する。rtgファイル。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
	swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProjRtgDir_%04u%02u%02u%02u%02u%02u.txt",
		s_temppath,
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	HANDLE hfile;
	hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile != INVALID_HANDLE_VALUE) {
		//int pathlen;
		//pathlen = (int)wcslen(saveprojpath);
		if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
			DWORD writelen = 0;
			WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
			_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
		}
		CloseHandle(hfile);
	}

	return 0;
}



int Savebvh2FBXHistory(WCHAR* selectname)
{
	WCHAR saveprojpath[MAX_PATH] = { 0L };
	wcscpy_s(saveprojpath, MAX_PATH, selectname);


	//書き込み処理が成功してから履歴を保存する。chaファイルだけ。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
	swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProjBvhDir_%04u%02u%02u%02u%02u%02u.txt",
		s_temppath,
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	HANDLE hfile;
	hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile != INVALID_HANDLE_VALUE) {
		//int pathlen;
		//pathlen = (int)wcslen(saveprojpath);
		if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
			DWORD writelen = 0;
			WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
			_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
		}
		CloseHandle(hfile);
	}

	return 0;
}


int SaveBatchHistory(WCHAR* selectname)
{
	WCHAR saveprojpath[MAX_PATH] = { 0L };
	wcscpy_s(saveprojpath, MAX_PATH, selectname);


	//書き込み処理が成功してから履歴を保存する。chaファイルだけ。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
	swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProjBatchDir_%04u%02u%02u%02u%02u%02u.txt",
		s_temppath,
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	HANDLE hfile;
	hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile != INVALID_HANDLE_VALUE) {
		//int pathlen;
		//pathlen = (int)wcslen(saveprojpath);
		if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
			DWORD writelen = 0;
			WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
			_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
		}
		CloseHandle(hfile);
	}

	return 0;
}

bool FindAtTheLast(std::wstring const& strsource, std::wstring const& strpat) {
	if (strsource.length() < strpat.length()) {
		return false;
	}
	return (strsource.rfind(strpat) == (strsource.size() - strpat.size()));
}

int GetchaHistoryDir(std::vector<wstring>& dstvecopenfilename, int filter_cha)
{
	//##################################
	//2023/07/22 pagenumをリターンする
	//##################################


	dstvecopenfilename.clear();

	//MB3DOpenProj_20210410215628.txt
	WCHAR searchfilename[MAX_PATH] = { 0L };
	swprintf_s(searchfilename, MAX_PATH, L"%sMB3DOpenProj_*.txt", s_temppath);
	HANDLE hFind;
	WIN32_FIND_DATA win32fd;
	hFind = FindFirstFileW(searchfilename, &win32fd);

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	std::vector<wstring> vecopenfilename;//!!!!!!!! tmpファイル内に書いてあるopenfilename

	vechistory.clear();
	bool notfoundfirst = true;
	if (hFind != INVALID_HANDLE_VALUE) {
		notfoundfirst = false;
		do {
			if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

				HISTORYELEM curelem;
				curelem.Init();
				curelem.filetime = win32fd.ftCreationTime;

				//printf("%s\n", win32fd.cFileName);
				curelem.wfilename[MAX_PATH - 1] = { 0L };
				swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

				vechistory.push_back(curelem);
			}
		} while (FindNextFile(hFind, &win32fd));
		FindClose(hFind);
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		int numhistory = (int)vechistory.size();
		//int dispnum = min(OPENHISTORYMAXNUM, numhistory);

		int foundnum = 0;
		int historyno;
		for (historyno = 0; historyno < numhistory; historyno++) {
			WCHAR openfilename[MAX_PATH] = { 0L };
			wcscpy_s(openfilename, MAX_PATH, vechistory[historyno].wfilename);

			HANDLE hfile;
			hfile = CreateFileW(openfilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				WCHAR readwstr[MAX_PATH] = { 0L };
				DWORD readleng = 0;
				bool bsuccess;
				bsuccess = ReadFile(hfile, readwstr, (MAX_PATH * sizeof(WCHAR)), &readleng, NULL);
				if (bsuccess) {

					CloseHandle(hfile);//読み終わったら閉じる

					bool foundsame = false;
					wstring newwstr = readwstr;
					std::vector<wstring>::iterator itropenfilename;
					for (itropenfilename = vecopenfilename.begin(); itropenfilename != vecopenfilename.end(); itropenfilename++) {
						if (newwstr.compare(*itropenfilename) == 0) {
							foundsame = true;
						}
					}
					if (foundsame == false) {
						bool filtermatch = false;
						if (filter_cha == 1) {
							if (FindAtTheLast(newwstr, L".cha")) {
								filtermatch = true;
							}
							else {
								filtermatch = false;
							}
						}
						else {
							if (FindAtTheLast(newwstr, L".fbx")) {
								filtermatch = true;
							}
							else {
								filtermatch = false;
							}
						}


						if (filtermatch == true) {
							DWORD fattr;
							fattr = GetFileAttributes(readwstr);
							if ((fattr != INVALID_FILE_ATTRIBUTES) && 
								((fattr & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
								((fattr & FILE_ATTRIBUTE_SYSTEM) == 0)
								) {

								//ファイルが存在する場合
								vecopenfilename.push_back(readwstr);
								foundnum++;
							}
							else if (fattr == INVALID_FILE_ATTRIBUTES) {
								//2023/10/04
								//ファイルが存在しない場合　履歴を削除する
								DeleteFileW(openfilename);
							}
						}
						//if (foundnum >= dispnum) {
						if (foundnum >= numhistory) {
							break;
						}
					}
					else {
						//2023/10/04
						//重複する履歴は削除する(履歴が多すぎるとオープン処理が重くなるため)
						DeleteFileW(openfilename);
					}
				}
				else {
					CloseHandle(hfile);//読み終わったら閉じる
				}
			}
		}

		//重複を除いたヒストリー
		//ここではまだカレントページ番号が確定していないのでページングは無し
		int numhistory2 = (int)vecopenfilename.size();
		if (numhistory2 > 0) {
			int nameno;
			for (nameno = 0; nameno < numhistory2; nameno++) {
				wstring currentnanme = vecopenfilename[nameno];
				dstvecopenfilename.push_back(currentnanme);
			}

			//ページ総数は分かる
			int fullpagenum = numhistory2 / OPENHISTORYMAXNUM;//満たされているページの数
			int pagenum = fullpagenum;//端数込みのページ数
			if ((numhistory2 - fullpagenum * OPENHISTORYMAXNUM) > 0) {
				pagenum++;
			}
			return pagenum;

		}
		else {
			dstvecopenfilename.clear();
			return 0;
		}
	}
	else {
		dstvecopenfilename.clear();
		return 0;
	}

	return 0;

}

int GetRtgHistoryDir(std::vector<wstring>& dstvecopenfilename)
{
	//##################################
	//2023/07/22 pagenumをリターンする
	//##################################

	dstvecopenfilename.clear();
	//ZeroMemory(dstname, sizeof(WCHAR) * dstlen);


	//MB3DOpenProj_20210410215628.txt
	WCHAR searchfilename[MAX_PATH] = { 0L };
	swprintf_s(searchfilename, MAX_PATH, L"%sMB3DOpenProjRtgDir_*.txt", s_temppath);
	HANDLE hFind;
	WIN32_FIND_DATA win32fd;
	hFind = FindFirstFileW(searchfilename, &win32fd);

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	std::vector<wstring> vecopenfilename;//!!!!!!!! tmpファイル内に書いてあるopenfilename

	vechistory.clear();
	bool notfoundfirst = true;
	if (hFind != INVALID_HANDLE_VALUE) {
		notfoundfirst = false;
		do {
			if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
				HISTORYELEM curelem;
				curelem.Init();
				curelem.filetime = win32fd.ftCreationTime;

				//printf("%s\n", win32fd.cFileName);
				curelem.wfilename[0] = { 0L };
				curelem.wfilename[MAX_PATH - 1] = { 0L };
				swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

				vechistory.push_back(curelem);
			}
		} while (FindNextFile(hFind, &win32fd));
		FindClose(hFind);
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		int numhistory = (int)vechistory.size();
		//int dispnum = min(OPENHISTORYMAXNUM, numhistory);

		int foundnum = 0;
		int historyno;
		for (historyno = 0; historyno < numhistory; historyno++) {
			WCHAR openfilename[MAX_PATH] = { 0L };
			openfilename[0] = { 0L };
			wcscpy_s(openfilename, MAX_PATH, vechistory[historyno].wfilename);

			HANDLE hfile;
			hfile = CreateFileW(openfilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				WCHAR readwstr[MAX_PATH] = { 0L };
				readwstr[0L] = { 0L };
				DWORD readleng = 0;
				bool bsuccess;
				bsuccess = ReadFile(hfile, readwstr, (MAX_PATH * sizeof(WCHAR)), &readleng, NULL);
				if (bsuccess) {

					CloseHandle(hfile);//読み終わったら閉じる

					bool foundsame = false;
					wstring newwstr = readwstr;
					std::vector<wstring>::iterator itropenfilename;
					for (itropenfilename = vecopenfilename.begin(); itropenfilename != vecopenfilename.end(); itropenfilename++) {
						if (newwstr.compare(*itropenfilename) == 0) {
							foundsame = true;
						}
					}
					if (foundsame == false) {
						DWORD fattr;
						fattr = GetFileAttributes(readwstr);
						if ((fattr != INVALID_FILE_ATTRIBUTES) &&
							((fattr & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
							((fattr & FILE_ATTRIBUTE_SYSTEM) == 0)
							) {

							//ファイルが存在する場合
							vecopenfilename.push_back(readwstr);
							foundnum++;
						}
						else if (fattr == INVALID_FILE_ATTRIBUTES) {
							//2023/10/04
							//ファイルが存在しない場合　履歴を削除する
							DeleteFileW(openfilename);
						}


						//if (foundnum >= dispnum) {
						if (foundnum >= numhistory) {
							break;
						}
					}
					else {
						//2023/10/04
						//重複する履歴は削除する(履歴が多すぎるとオープン処理が重くなるため)
						DeleteFileW(openfilename);
					}

				}
				else {
					CloseHandle(hfile);//読み終わったら閉じる
				}
			}
		}


		//重複を除いたヒストリー
		//ここではまだカレントページ番号が確定していないのでページングは無し
		int numhistory2 = (int)vecopenfilename.size();
		if (numhistory2 > 0) {
			int nameno;
			for (nameno = 0; nameno < numhistory2; nameno++) {
				wstring currentnanme = vecopenfilename[nameno];
				dstvecopenfilename.push_back(currentnanme);
			}

			//ページ総数は分かる
			int fullpagenum = numhistory2 / OPENHISTORYMAXNUM;//満たされているページの数
			int pagenum = fullpagenum;//端数込みのページ数
			if ((numhistory2 - fullpagenum * OPENHISTORYMAXNUM) > 0) {
				pagenum++;
			}
			return pagenum;

		}
		else {
			dstvecopenfilename.clear();
			return 0;
		}
	}
	else {
		dstvecopenfilename.clear();
		return 0;
	}

	return 0;

}


int GetbvhHistoryDir(std::vector<wstring>& dstvecopenfilename)
{
	//##################################
	//2023/07/22 pagenumをリターンする
	//##################################

	dstvecopenfilename.clear();
	//ZeroMemory(dstname, sizeof(WCHAR) * dstlen);


	//MB3DOpenProj_20210410215628.txt
	WCHAR searchfilename[MAX_PATH] = { 0L };
	swprintf_s(searchfilename, MAX_PATH, L"%sMB3DOpenProjBvhDir_*.txt", s_temppath);
	HANDLE hFind;
	WIN32_FIND_DATA win32fd;
	hFind = FindFirstFileW(searchfilename, &win32fd);

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	std::vector<wstring> vecopenfilename;//!!!!!!!! tmpファイル内に書いてあるopenfilename

	vechistory.clear();
	bool notfoundfirst = true;
	if (hFind != INVALID_HANDLE_VALUE) {
		notfoundfirst = false;
		do {
			if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
				HISTORYELEM curelem;
				curelem.Init();
				curelem.filetime = win32fd.ftCreationTime;

				//printf("%s\n", win32fd.cFileName);
				curelem.wfilename[0] = { 0L };
				curelem.wfilename[MAX_PATH - 1] = { 0L };
				swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

				vechistory.push_back(curelem);
			}
		} while (FindNextFile(hFind, &win32fd));
		FindClose(hFind);
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		int numhistory = (int)vechistory.size();
		//int dispnum = min(OPENHISTORYMAXNUM, numhistory);

		int foundnum = 0;
		int historyno;
		for (historyno = 0; historyno < numhistory; historyno++) {
			WCHAR openfilename[MAX_PATH] = { 0L };
			openfilename[0] = { 0L };
			wcscpy_s(openfilename, MAX_PATH, vechistory[historyno].wfilename);

			HANDLE hfile;
			hfile = CreateFileW(openfilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				WCHAR readwstr[MAX_PATH] = { 0L };
				readwstr[0L] = { 0L };
				DWORD readleng = 0;
				bool bsuccess;
				bsuccess = ReadFile(hfile, readwstr, (MAX_PATH * sizeof(WCHAR)), &readleng, NULL);
				if (bsuccess) {

					CloseHandle(hfile);//読み終わったら閉じる

					bool foundsame = false;
					wstring newwstr = readwstr;
					std::vector<wstring>::iterator itropenfilename;
					for (itropenfilename = vecopenfilename.begin(); itropenfilename != vecopenfilename.end(); itropenfilename++) {
						if (newwstr.compare(*itropenfilename) == 0) {
							foundsame = true;
						}
					}
					if (foundsame == false) {
						DWORD fattr;
						fattr = GetFileAttributes(readwstr);
						if ((fattr != INVALID_FILE_ATTRIBUTES) &&
							((fattr & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
							((fattr & FILE_ATTRIBUTE_SYSTEM) == 0)
							) {

							//ファイルが存在する場合
							vecopenfilename.push_back(readwstr);
							foundnum++;
						}
						else if (fattr == INVALID_FILE_ATTRIBUTES) {
							//2023/10/04
							//ファイルが存在しない場合　履歴を削除する
							DeleteFileW(openfilename);
						}

						//if (foundnum >= dispnum) {
						if (foundnum >= numhistory) {
							break;
						}
					}
					else {
						//2023/10/04
						//重複する履歴は削除する(履歴が多すぎるとオープン処理が重くなるため)
						DeleteFileW(openfilename);
					}
				}
				else {
					CloseHandle(hfile);//読み終わったら閉じる
				}
			}
		}

		//重複を除いたヒストリー
		//ここではまだカレントページ番号が確定していないのでページングは無し
		int numhistory2 = (int)vecopenfilename.size();
		if (numhistory2 > 0) {
			int nameno;
			for (nameno = 0; nameno < numhistory2; nameno++) {
				wstring currentnanme = vecopenfilename[nameno];
				dstvecopenfilename.push_back(currentnanme);
			}

			//ページ総数は分かる
			int fullpagenum = numhistory2 / OPENHISTORYMAXNUM;//満たされているページの数
			int pagenum = fullpagenum;//端数込みのページ数
			if ((numhistory2 - fullpagenum * OPENHISTORYMAXNUM) > 0) {
				pagenum++;
			}
			return pagenum;

		}
		else {
			dstvecopenfilename.clear();
			return 0;
		}
	}
	else {
		dstvecopenfilename.clear();
		return 0;
	}

	return 0;
}

int GetCPTFileName(std::vector<HISTORYELEM>& dstvecopenfilename)
{

	dstvecopenfilename.clear();
	//ZeroMemory(dstname, sizeof(WCHAR) * dstlen);


	//MB3DOpenProj_20210410215628.txt
	WCHAR searchfilename[MAX_PATH] = { 0L };
	searchfilename[0] = { 0L };
	swprintf_s(searchfilename, MAX_PATH, L"%sMB3DTempCopyFrames_v1.0.0.18_*.cpt", s_temppath);
	HANDLE hFind;
	WIN32_FIND_DATA win32fd;
	hFind = FindFirstFileW(searchfilename, &win32fd);

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	//std::vector<wstring> vecopenfilename;//!!!!!!!! tmpファイル内に書いてあるopenfilename

	vechistory.clear();
	bool notfoundfirst = true;
	if (hFind != INVALID_HANDLE_VALUE) {
		notfoundfirst = false;
		do {
			if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
				HISTORYELEM curelem;
				curelem.Init();
				curelem.filetime = win32fd.ftCreationTime;

				//printf("%s\n", win32fd.cFileName);
				curelem.wfilename[MAX_PATH - 1] = { 0L };
				curelem.wfilename[0] = { 0L };
				swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

				vechistory.push_back(curelem);
			}
		} while (FindNextFile(hFind, &win32fd));
		FindClose(hFind);
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		std::vector<HISTORYELEM>::iterator itrhistoryelem;
		for (itrhistoryelem = vechistory.begin(); itrhistoryelem != vechistory.end(); itrhistoryelem++) {
			HISTORYELEM curelem;
			curelem.Init();
			curelem = *itrhistoryelem;
			int result = LoadCPIFile(&curelem);
			//_ASSERT(result == 0);
			*itrhistoryelem = curelem;//失敗した時にはnewelem.hascpinfo = 0がセットされている
		}
	}

	if (!vechistory.empty()) {
		dstvecopenfilename = vechistory;
	}

	//if (!vecopenfilename.empty()) {
	//	dstvecopenfilename = vecopenfilename;
	//}
	//else {
	//	dstvecopenfilename.clear();
	//}
	return 0;
}

int GetBatchHistoryDir(WCHAR* dstname, int dstlen)
{

	ZeroMemory(dstname, sizeof(WCHAR) * dstlen);


	//MB3DOpenProj_20210410215628.txt
	WCHAR searchfilename[MAX_PATH] = { 0L };
	swprintf_s(searchfilename, MAX_PATH, L"%sMB3DOpenProjBatchDir_*.txt", s_temppath);
	HANDLE hFind;
	WIN32_FIND_DATA win32fd;
	hFind = FindFirstFileW(searchfilename, &win32fd);

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	std::vector<wstring> vecopenfilename;//!!!!!!!! tmpファイル内に書いてあるopenfilename

	vechistory.clear();
	bool notfoundfirst = true;
	if (hFind != INVALID_HANDLE_VALUE) {
		notfoundfirst = false;
		do {
			if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
				HISTORYELEM curelem;
				curelem.Init();
				curelem.filetime = win32fd.ftCreationTime;

				//printf("%s\n", win32fd.cFileName);
				curelem.wfilename[MAX_PATH - 1] = { 0L };
				swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

				vechistory.push_back(curelem);
			}
		} while (FindNextFile(hFind, &win32fd));
		FindClose(hFind);
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		int numhistory = (int)vechistory.size();
		int dispnum = min(OPENHISTORYMAXNUM, numhistory);

		int foundnum = 0;
		int historyno;
		for (historyno = 0; historyno < numhistory; historyno++) {
			WCHAR openfilename[MAX_PATH] = { 0L };
			wcscpy_s(openfilename, MAX_PATH, vechistory[historyno].wfilename);

			HANDLE hfile;
			hfile = CreateFileW(openfilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				WCHAR readwstr[MAX_PATH] = { 0L };
				DWORD readleng = 0;
				bool bsuccess;
				bsuccess = ReadFile(hfile, readwstr, (MAX_PATH * sizeof(WCHAR)), &readleng, NULL);
				if (bsuccess) {

					CloseHandle(hfile);//読み終わったら閉じる

					bool foundsame = false;
					wstring newwstr = readwstr;
					std::vector<wstring>::iterator itropenfilename;
					for (itropenfilename = vecopenfilename.begin(); itropenfilename != vecopenfilename.end(); itropenfilename++) {
						if (newwstr.compare(*itropenfilename) == 0) {
							foundsame = true;
						}
					}
					if (foundsame == false) {
						vecopenfilename.push_back(readwstr);
						foundnum++;
						if (foundnum >= dispnum) {
							break;
						}
					}
					else {
						//2023/10/04
						//重複する履歴は削除する(履歴が多すぎるとオープン処理が重くなるため)
						DeleteFileW(openfilename);
					}
				}
				else {
					CloseHandle(hfile);
				}
				
			}
		}
	}

	if (!vecopenfilename.empty()) {
		wcscpy_s(dstname, dstlen, vecopenfilename[0].c_str());
	}
	else {
		*dstname = 0L;
	}

	return 0;
}


//int CopyToClipBoardData(int shdnum, int cpframenum, COPYELEM* cpELem, HGLOBAL* cbhgptr)
//{
//	int ret = 0;
//	HGLOBAL hGlobal = 0;
//	//int datasize;
//	int headerlen, shdnumlen, framenumlen, celen;
//	int dstcharsize;
//
//	headerlen = (int)strlen(clipboardheader2);
//	shdnumlen = sizeof(int);
//	framenumlen = sizeof(int);
//	celen = sizeof(COPYELEM) * shdnum * cpframenum;
//	//datasize = headerlen + numlen + celen;
//	dstcharsize = headerlen + (shdnumlen * 2) + (framenumlen * 2) + (celen * 2) + 1;// char以外の1byte --> 2文字、と終端ＮＵＬＬ
//
//
//	hGlobal = GlobalAlloc(GHND, dstcharsize);
//	if (hGlobal == NULL) {
//		DbgOut("motparamdlg : CopyToClipBoardData : GlobalAlloc error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//
//	char* dstptr;
//	dstptr = (char*)GlobalLock(hGlobal);
//	if (!dstptr) {
//		DbgOut("motparamdlg : CopyToClipBoardData : GlobalLock error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//
//	int dstpos = 0;
//	strcpy_s(dstptr, dstcharsize - dstpos, clipboardheader2);
//	dstpos += headerlen;
//
//	ret = Bin2Char((unsigned char*)&shdnum, dstptr + dstpos, shdnumlen);
//	if (ret) {
//		DbgOut("motparamdlg : CopyToClipBoardData : Bin2Char shdnum error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//	dstpos += shdnumlen * 2;
//
//
//	ret = Bin2Char((unsigned char*)&cpframenum, dstptr + dstpos, framenumlen);
//	if (ret) {
//		DbgOut("motparamdlg : CopyToClipBoardData : Bin2Char cpframenum error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//	dstpos += framenumlen * 2;
//
//
//	ret = Bin2Char((unsigned char*)srcce, dstptr + dstpos, celen);
//	if (ret) {
//		DbgOut("motparamdlg : CopyToClipBoardData : Bin2Char ce error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//	dstpos += celen * 2;
//
//	*(dstptr + dstpos) = 0;//!!!!!
//
//	if (dstpos > dstcharsize) {
//		DbgOut("motparamdlg : CopyToClipBoardData : dstpos error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//
//
//	goto cptocbexit;
//
//cptocbexit:
//	if (hGlobal)
//		GlobalUnlock(hGlobal);
//	if (ret && hGlobal)
//		GlobalFree(hGlobal);
//
//	*cbhgptr = hGlobal;
//	return ret;
//}
//
//int Bin2Char(unsigned char* srcptr, char* dstptr, int srclen)
//{
//	int srcpos;
//	int dstpos = 0;
//	//int ret;
//	unsigned char curuc;
//	unsigned char lowuc, hiuc;
//	char lowc, hic;
//	for (srcpos = 0; srcpos < srclen; srcpos++) {
//		curuc = *(srcptr + srcpos);
//
//		hiuc = curuc >> 4;
//		if (hiuc <= 9) {
//			hic = '0' + hiuc;
//		}
//		else {
//			hic = 'A' + hiuc - 10;
//		}
//
//		lowuc = curuc & 0x0F;
//		if (lowuc <= 9) {
//			lowc = '0' + lowuc;
//		}
//		else {
//			lowc = 'A' + lowuc - 10;
//		}
//
//		*(dstptr + dstpos) = hic;
//		*(dstptr + dstpos + 1) = lowc;
//		dstpos += 2;
//	}
//
//	return 0;
//}
//
//
//
//int PasteFromClipBoardData(COPYELEM* dstce, int* bufshdnum, int* bufframenum, HGLOBAL cbhg)
//{
//	*bufshdnum = 0;
//	*bufframenum = 0;
//
//	char* srcptr;
//
//	srcptr = (char*)GlobalLock(cbhg);
//	if (!srcptr) {
//		DbgOut("motparamdlg : PasteFromClipBoardData : GlobalLock error !!!\n");
//		_ASSERT(0);
//		return 1;
//	}
//
//	int headerleng;
//	headerleng = (int)strlen(clipboardheader2);
//
//	int srcleng;
//	srcleng = (int)strlen(srcptr);
//	int minimumleng = headerleng + sizeof(int) * 2 + sizeof(int) * 2;
//	if (srcleng <= minimumleng) {
//		DbgOut("motparamdlg : PasteFromClipBoardData : srcleng 0 error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードにデータがありませんでした。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//
//	int srcpos = 0;
//	int cmp0;
//	cmp0 = strncmp(srcptr, clipboardheader2, headerleng);
//	if (cmp0) {
//		DbgOut("motparamdlg : PasteFromClipBoardData : invalid data type error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードのデータの種類が違います。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//	srcpos += headerleng;
//
//
//	int ret;
//	int shdnum;
//	ret = Char2Hex(srcptr + srcpos, (unsigned char*)&shdnum, sizeof(int) * 2);
//	if (ret) {
//		DbgOut("motparamdlg : PasteFromClipBoard : Char2Hex shdnum error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードのデータが不正です。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//	srcpos += (sizeof(int) * 2);
//
//	int framenum;
//	ret = Char2Hex(srcptr + srcpos, (unsigned char*)&framenum, sizeof(int) * 2);
//	if (ret || (framenum <= 0) || (framenum > CPFRAMEMAX)) {
//		DbgOut("motparamdlg : PasteFromClipBoard : Char2Hex framenum error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードのデータが不正です。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//	srcpos += (sizeof(int) * 2);
//
//	int cesize;
//	cesize = shdnum * sizeof(COPYELEM) * framenum;
//	int sizeondata;
//	sizeondata = srcleng - headerleng - (sizeof(int) * 2) - (sizeof(int) * 2);
//	if (sizeondata != (cesize * 2)) {
//		DbgOut("motparamdlg : PasteFromClipBoard : data size error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードのデータ長が不正です。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//
//
//	InitCEBuff();//!!!!!!!!!!!!
//
//	int framecnt;
//	int ceno;
//	COPYELEM tempce;
//	for (framecnt = 0; framecnt < framenum; framecnt++) {
//		for (ceno = 0; ceno < shdnum; ceno++) {
//			ret = Char2Hex(srcptr + srcpos, (unsigned char*)&tempce, sizeof(COPYELEM) * 2);
//			if (ret) {
//				DbgOut("motparamdlg : PasteFromClipBoard : Char2Hex ce %d %d error !!!\n", ceno, shdnum);
//				::MessageBox(m_hWnd, "データ変換中にエラーが生じました。", "ペースト失敗", MB_OK);
//				_ASSERT(0);
//				GlobalUnlock(cbhg);
//				return 1;
//			}
//			srcpos += (sizeof(COPYELEM) * 2);
//
//			tempce.mp.m_spp = 0;//!!!!!!!!!!
//
//			if (tempce.mp.m_frameno >= 0) {
//
//				//tempceの名前に対応するserialnoを探し、そのmpにデータをコピーする。
//				int chkleng;
//				chkleng = (int)strlen(tempce.name);
//				if (chkleng >= 256) {
//					DbgOut("motparamdlg : PasteFromClipBoard : check tempce name error %d !!!\n", ceno);
//					::MessageBox(m_hWnd, "不正な名前が見つかりました。１", "ペースト失敗", MB_OK);
//					_ASSERT(0);
//					GlobalUnlock(cbhg);
//					return 1;
//				}
//
//				int findno;
//				//ret = m_thandler->GetPartNoByName( tempce.name, &findno );
//				ret = m_thandler->GetBoneNoByName(tempce.name, &findno, m_shandler, 0);
//				if (ret) {
//					DbgOut("motparamdlg : PasteFromClipBoard : GetPartNoByName error !!!\n");
//					::MessageBox(m_hWnd, "不正な名前が見つかりました。２", "ペースト失敗", MB_OK);
//					_ASSERT(0);
//					GlobalUnlock(cbhg);
//					return 1;
//				}
//
//				if (findno > 0) {
//					*(m_CEBuff + shdnum * framecnt + findno) = tempce;//!!!!!!!!
//				}
//			}
//		}
//	}
//
//	GlobalUnlock(cbhg);
//
//	*bufshdnum = shdnum;
//	*bufframenum = framenum;
//
//	return 0;
//}
//
//
//int Char2Hex(char* orgdata, unsigned char* donedata, DWORD charleng)
//{
//	int ret;
//	DWORD charno;
//	DWORD rest;
//
//	unsigned char ucval;
//	unsigned char* doneptr = 0;
//
//
//	rest = charleng % 2;
//	if (rest) {
//		_ASSERT(0);
//		return 1;
//	}
//
//	doneptr = donedata;
//	for (charno = 0; charno < charleng; charno += 2) {
//		ret = ConvData(orgdata + charno, &ucval, 0);
//		_ASSERT(!ret);
//
//		ret = ConvData(orgdata + charno + 1, &ucval, 1);
//		_ASSERT(!ret);
//
//		*doneptr = ucval;
//		doneptr++;
//	}
//
//	return 0;
//}
//
//int ConvData(char* charptr, unsigned char* ucptr, int pos)
//{
//	char charval;
//	unsigned char convval;
//
//	charval = *charptr;
//	if ((charval >= '0') && (charval <= '9')) {
//		convval = charval - '0';
//	}
//	else if ((charval >= 'A') && (charval <= 'F')) {
//		convval = charval - 'A' + 10;
//	}
//	else {
//		_ASSERT(0);
//		return 1;
//	}
//
//	if (pos == 0) {
//		*ucptr = convval << 4;
//	}
//	else {
//		*ucptr |= convval;
//	}
//
//	return 0;
//}


int WriteCPTFile(WCHAR* dstfilename)
{
	int cpelemnum;
	cpelemnum = (int)s_copymotvec.size();
	if (cpelemnum <= 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetCurMotInfo()) {
		return 0;
	}

	if (!dstfilename) {
		return 0;
	}

	*dstfilename = 0L;

	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	WCHAR cptfilename[MAX_PATH] = { 0L };
	swprintf_s(cptfilename, MAX_PATH, L"%s\\MB3DTempCopyFrames_v1.0.0.18_%04u%02u%02u%02u%02u%02u.cpt",
		s_temppath,
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);

	HANDLE hfile = CreateFile(cptfilename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile == INVALID_HANDLE_VALUE) {
		DbgOut(L"CPTFile : WriteCPTFile : file open error !!!\n");
		_ASSERT(0);
		return 1;
	}

	wcscpy_s(dstfilename, MAX_PATH, cptfilename);
	*(dstfilename + MAX_PATH - 1) = 0L;


	char CPTheader[256];
	::ZeroMemory(CPTheader, sizeof(char) * 256);
	strcpy_s(CPTheader, 256, "MB3DTempCopyFramesFile ver1.0.0.18");//本体ではない

	DWORD wleng = 0;
	WriteFile(hfile, CPTheader, sizeof(char) * 256, &wleng, NULL);
	if (wleng != (sizeof(char) * 256)) {
		_ASSERT(0);
		return 1;
	}


	wleng = 0;
	WriteFile(hfile, &cpelemnum, sizeof(int), &wleng, NULL);
	if (wleng != sizeof(int)) {
		_ASSERT(0);
		return 1;
	}



	int cpelemno;
	for (cpelemno = 0; cpelemno < cpelemnum; cpelemno++) {
		CPELEM2 curcpelem = s_copymotvec[cpelemno];
		if (curcpelem.bone) {
			char curbonename[MAX_PATH] = { 0 };
			strcpy_s(curbonename, MAX_PATH, curcpelem.bone->GetBoneName());

			wleng = 0;
			WriteFile(hfile, curbonename, sizeof(char) * MAX_PATH, &wleng, NULL);
			if (wleng != (sizeof(char) * MAX_PATH)) {
				_ASSERT(0);
				return 1;
			}

			double curframe;
			curframe = curcpelem.mp.GetFrame();
			wleng = 0;
			WriteFile(hfile, &curframe, sizeof(double), &wleng, NULL);
			if (wleng != (sizeof(double))) {
				_ASSERT(0);
				return 1;
			}

			ChaMatrix curlocalmat;
			curlocalmat = curcpelem.mp.GetWorldMat();
			wleng = 0;
			WriteFile(hfile, &curlocalmat, sizeof(ChaMatrix), &wleng, NULL);
			if (wleng != (sizeof(ChaMatrix))) {
				_ASSERT(0);
				return 1;
			}

			int localmatflag;
			localmatflag = curcpelem.mp.GetLocalMatFlag();
			wleng = 0;
			WriteFile(hfile, &localmatflag, sizeof(int), &wleng, NULL);
			if (wleng != (sizeof(int))) {
				_ASSERT(0);
				return 1;
			}
		}
		/*
			cpelem.bone = curbone;
			cpelem.mp.SetFrame(curframe);
			cpelem.mp.SetWorldMat(localmat);
			cpelem.mp.SetLocalMatFlag(1);//!!!!!!!!!!
		*/

	}

	FlushFileBuffers(hfile);
	SetEndOfFile(hfile);
	CloseHandle(hfile);


	return 0;
}

int WriteCPIFile(WCHAR* srccptfilename)
{


	int cpelemnum;
	cpelemnum = (int)s_copymotvec.size();
	if (cpelemnum <= 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetCurMotInfo()) {
		return 0;
	}
	if (!srccptfilename) {
		return 0;
	}

	CPMOTINFO cpinfo;
	ZeroMemory(&cpinfo, sizeof(CPMOTINFO));
	/*
		typedef struct tag_cpinfo
		{
			WCHAR fbxname[MAX_PATH];
			WCHAR motionname[MAX_PATH];
			double startframe;
			double framenum;
			int bvhtype;//0:undef, 1-144:bvh1 - bvh144, -1:bvh_other
			int importance;//0:undef, 1:tiny, 2:alittle, 3:normal, 4:noticed, 5:imortant, 6:very important
			WCHAR comment[32];//WCHAR * 31文字まで。３２文字目は終端記号

		}CPMOTINFO;
	*/
	cpinfo.startframe = s_copymotvec[0].mp.GetFrame();
	cpinfo.framenum = s_copymotvec[cpelemnum - 1].mp.GetFrame() - cpinfo.startframe + 1;
	wcscpy_s(cpinfo.fbxname, MAX_PATH, s_model->GetFileName());
	MOTINFO* curmi = s_model->GetCurMotInfo();
	if (!curmi) {
		return 1;
	}
	WCHAR wmotname[MAX_PATH] = { 0L };
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, curmi->motname, 256, wmotname, MAX_PATH);
	wcscpy_s(cpinfo.motionname, MAX_PATH, wmotname);

	CCpInfoDlg dlg;
	dlg.SetCpInfo(&cpinfo);
	int dlgret = (int)dlg.DoModal();
	if (dlgret != IDOK) {
		return 1;
	}


	*(srccptfilename + MAX_PATH - 1) = 0L;
	size_t cptfilenameleng = wcslen(srccptfilename);
	if ((cptfilenameleng <= 0) || (cptfilenameleng >= MAX_PATH)) {
		_ASSERT(0);
		return 1;
	}


	//cpiファイル名はcptファイルの拡張子をcpiに変えたもの
	WCHAR cpifilename[MAX_PATH] = { 0L };
	wcscpy_s(cpifilename, MAX_PATH, srccptfilename);
	WCHAR* pext;
	pext = wcsrchr(cpifilename, TEXT('.'));
	if (!pext) {
		return 1;
	}
	*pext = 0L;
	wcscat_s(cpifilename, MAX_PATH, L".cpi");


	HANDLE hfile = CreateFile(cpifilename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile == INVALID_HANDLE_VALUE) {
		DbgOut(L"CPTFile : WriteCPTFile : file open error !!!\n");
		_ASSERT(0);
		return 1;
	}


	char CPTheader[256];
	::ZeroMemory(CPTheader, sizeof(char) * 256);
	strcpy_s(CPTheader, 256, "MB3DTempCopyInfoFile ver1.0.0.18");//本体ではない

	DWORD wleng = 0;
	WriteFile(hfile, CPTheader, sizeof(char) * 256, &wleng, NULL);
	if (wleng != (sizeof(char) * 256)) {
		_ASSERT(0);
		return 1;
	}

	int datasize = sizeof(CPMOTINFO);
	wleng = 0;
	WriteFile(hfile, &datasize, sizeof(int), &wleng, NULL);
	if (wleng != sizeof(int)) {
		_ASSERT(0);
		return 1;
	}

	wleng = 0;
	WriteFile(hfile, &cpinfo, sizeof(CPMOTINFO), &wleng, NULL);
	if (wleng != (sizeof(CPMOTINFO))) {
		_ASSERT(0);
		return 1;
	}

	FlushFileBuffers(hfile);
	SetEndOfFile(hfile);
	CloseHandle(hfile);

	return 0;
}


bool ValidateCPIFile(char* dstCPIh, int* dstinfosize, char* srcbuf, DWORD bufleng)
{
	if (!dstCPIh || !dstinfosize || !srcbuf || (bufleng <= 0)) {
		_ASSERT(0);
		return false;
	}

	if (bufleng <= (sizeof(char) * 256 + sizeof(int))) {
		_ASSERT(0);
		return false;
	}

	MoveMemory(dstCPIh, srcbuf, sizeof(char) * 256);

	size_t magicstrlen;
	magicstrlen = strlen(dstCPIh);
	if ((magicstrlen <= 0) || (magicstrlen >= 256)) {
		_ASSERT(0);
		return false;
	}
	int cmp18;
	cmp18 = strcmp(dstCPIh, "MB3DTempCopyInfoFile ver1.0.0.18");//本体ではない
	if (cmp18 != 0) {
		_ASSERT(0);
		return false;
	}


	int infosize;
	MoveMemory(&infosize, srcbuf + sizeof(char) * 256, sizeof(int));

	DWORD datasize;
	datasize = (bufleng - sizeof(char) * 256 - sizeof(int));
	DWORD elemsize;
	elemsize = sizeof(CPMOTINFO);

	if ((infosize != elemsize) || (datasize != elemsize)) {
		_ASSERT(0);
		return false;
	}

	*dstinfosize = infosize;

	return true;

}


bool ValidateCPTFile(char* dstCPTh, int* dstcpelemnum, char* srcbuf, DWORD bufleng)
{
	if (!dstCPTh || !dstcpelemnum || !srcbuf || (bufleng <= 0)) {
		_ASSERT(0);
		return false;
	}

	if (bufleng <= (sizeof(char) * 256 + sizeof(int))) {
		_ASSERT(0);
		return false;
	}

	MoveMemory(dstCPTh, srcbuf, sizeof(char) * 256);

	//typedef struct tag_CPTheader
	//{
	//	char magicstr[32];//EvaluateGlobalPosition
	//	char version[16];
	//	char fbxdate[256];
	//	int animno;
	//	int jointnum;
	//	int framenum;
	//	int reserved;
	//}CPTHEADER;

	size_t magicstrlen;
	magicstrlen = strlen(dstCPTh);
	if ((magicstrlen <= 0) || (magicstrlen >= 256)) {
		_ASSERT(0);
		return false;
	}
	//int cmp7;
	//int cmp8;
	//int cmp9;
	//cmp7 = strcmp(dstCPTh, "MB3DTempCopyFramesFile ver1.0.0.7");//本体ではない
	//cmp8 = strcmp(dstCPTh, "MB3DTempCopyFramesFile ver1.0.0.8");//本体ではない
	//cmp9 = strcmp(dstCPTh, "MB3DTempCopyFramesFile ver1.0.0.9");//本体ではない
	//if ((cmp7 != 0) && (cmp8 != 0) && (cmp9 != 0)) {
	//	_ASSERT(0);
	//	return false;
	//}
	int cmp18;
	cmp18 = strcmp(dstCPTh, "MB3DTempCopyFramesFile ver1.0.0.18");//本体ではない
	if (cmp18 != 0) {
		_ASSERT(0);
		return false;
	}


	int cpelemnum;
	MoveMemory(&cpelemnum, srcbuf + sizeof(char) * 256, sizeof(int));

	DWORD datasize;
	datasize = (bufleng - sizeof(char) * 256 - sizeof(int));
	DWORD elemsize;
	elemsize = sizeof(char) * MAX_PATH + sizeof(double) + sizeof(ChaMatrix) + sizeof(int);

	if (datasize != (cpelemnum * elemsize)) {
		_ASSERT(0);
		return false;
	}

	*dstcpelemnum = cpelemnum;


	return true;
}

int LoadCPIFile(HISTORYELEM* srcdstelem)
{

	WCHAR cpifilename[MAX_PATH] = { 0L };
	cpifilename[0] = { 0L };
	wcscpy_s(cpifilename, MAX_PATH, srcdstelem->wfilename);

	WCHAR* pdot = wcsrchr(cpifilename, TEXT('.'));
	if (!pdot) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	*pdot = 0L;
	wcscat_s(cpifilename, MAX_PATH, L".cpi");

	HANDLE hfile;
	hfile = CreateFile(cpifilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile == INVALID_HANDLE_VALUE) {
		//_ASSERT(0);
		srcdstelem->hascpinfo = 0;
		return 1;
	}


	DWORD sizehigh;
	DWORD bufleng;
	bufleng = GetFileSize(hfile, &sizehigh);
	if (bufleng <= 0) {
		_ASSERT(0);
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	if (sizehigh != 0) {
		_ASSERT(0);
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	char* newbuf;
	newbuf = (char*)malloc(sizeof(char) * bufleng);//bufleng + 1
	if (!newbuf) {
		_ASSERT(0);
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	ZeroMemory(newbuf, sizeof(char) * bufleng);
	DWORD rleng, readleng;
	rleng = bufleng;
	BOOL bsuccess;
	bsuccess = ReadFile(hfile, (void*)newbuf, rleng, &readleng, NULL);
	if (!bsuccess || (rleng != readleng)) {
		_ASSERT(0);
		if (newbuf) {
			free(newbuf);
			newbuf = 0;
		}
		CloseHandle(hfile);
		srcdstelem->hascpinfo = 0;
		return 1;
	}

	int infosize = 0;
	char CPIheader[256];
	ZeroMemory(CPIheader, sizeof(char) * 256);
	bool isvalid;
	isvalid = ValidateCPIFile(CPIheader, &infosize, newbuf, bufleng);
	if (!isvalid) {
		_ASSERT(0);
		if (newbuf) {
			free(newbuf);
			newbuf = 0;
		}
		CloseHandle(hfile);
		srcdstelem->hascpinfo = 0;
		return 1;
	}

	DWORD curpos;
	curpos = sizeof(char) * 256 + sizeof(int);

	CPMOTINFO cpmotinfo;
	ZeroMemory(&cpmotinfo, sizeof(CPMOTINFO));
	::MoveMemory(&cpmotinfo, newbuf + curpos, sizeof(CPMOTINFO));

	cpmotinfo.fbxname[MAX_PATH - 1] = 0L;
	cpmotinfo.motionname[MAX_PATH - 1] = 0L;
	if (cpmotinfo.fbxname[0] == 0L) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	if (cpmotinfo.motionname[0] == 0L) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}

	if ((cpmotinfo.bvhtype < 0) || (cpmotinfo.bvhtype > 144)) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	if ((cpmotinfo.importance < 0) || (cpmotinfo.importance > 6)) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}

	srcdstelem->cpinfo = cpmotinfo;
	srcdstelem->hascpinfo = 1;

	if (newbuf) {
		free(newbuf);
		newbuf = 0;
	}
	CloseHandle(hfile);

	return 0;

}



bool LoadCPTFile()
{
	if (!s_model) {
		_ASSERT(0);
		return false;
	}
	if (!s_model->GetCurMotInfo()) {
		_ASSERT(0);
		return false;
	}

	if (s_copyhistorydlg.GetCreatedFlag() == false) {
		int result = CreateCopyHistoryDlg();
		if (result != 0) {
			_ASSERT(0);
			return false;
		}
	}

	s_pastemotvec.clear();

	//std::vector<HISTORYELEM> cptfilename;
	s_cptfilename.clear();
	GetCPTFileName(s_cptfilename);

	if (s_cptfilename.empty()) {
		_ASSERT(0);
		return false;
	}

	WCHAR infilename[MAX_PATH] = { 0L };
	int result = s_copyhistorydlg.GetSelectedFileName(s_model, infilename);
	infilename[MAX_PATH - 1] = 0L;
	if (result || (infilename[0] == 0L)) {
		//_ASSERT(0);
		//有効ではない履歴を選択時にはfalseをリターンしてペーストしない
		return false;
	}


	HANDLE hfile;
	hfile = CreateFile(infilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile == INVALID_HANDLE_VALUE) {
		_ASSERT(0);
		return false;
	}


	DWORD sizehigh;
	DWORD bufleng;
	bufleng = GetFileSize(hfile, &sizehigh);
	if (bufleng <= 0) {
		_ASSERT(0);
		return false;
	}
	if (sizehigh != 0) {
		_ASSERT(0);
		return false;
	}
	char* newbuf;
	newbuf = (char*)malloc(sizeof(char) * bufleng);//bufleng + 1
	if (!newbuf) {
		_ASSERT(0);
		return false;
	}
	ZeroMemory(newbuf, sizeof(char) * bufleng);
	DWORD rleng, readleng;
	rleng = bufleng;
	BOOL bsuccess;
	bsuccess = ReadFile(hfile, (void*)newbuf, rleng, &readleng, NULL);
	if (!bsuccess || (rleng != readleng)) {
		_ASSERT(0);
		if (newbuf) {
			free(newbuf);
			newbuf = 0;
		}
		CloseHandle(hfile);
		return false;
	}

	int cpelemnum = 0;
	char CPTheader[256];
	ZeroMemory(CPTheader, sizeof(char) * 256);
	bool isvalid;
	isvalid = ValidateCPTFile(CPTheader, &cpelemnum, newbuf, bufleng);
	if (!isvalid) {
		_ASSERT(0);
		if (newbuf) {
			free(newbuf);
			newbuf = 0;
		}
		CloseHandle(hfile);
		return false;
	}

	DWORD curpos;
	curpos = sizeof(char) * 256 + sizeof(int);

	int cpelemno;
	for (cpelemno = 0; cpelemno < cpelemnum; cpelemno++) {
		char curbonename[MAX_PATH] = { 0 };
		ZeroMemory(curbonename, sizeof(char) * MAX_PATH);
		if ((curpos + (sizeof(char) * MAX_PATH)) > bufleng) {
			_ASSERT(0);
			if (newbuf) {
				free(newbuf);
				newbuf = 0;
			}
			CloseHandle(hfile);
			return false;
		}
		::MoveMemory(curbonename, newbuf + curpos, sizeof(char) * MAX_PATH);
		curpos += (sizeof(char) * MAX_PATH);


		double curframe;
		if ((curpos + sizeof(double)) > bufleng) {
			_ASSERT(0);
			if (newbuf) {
				free(newbuf);
				newbuf = 0;
			}
			CloseHandle(hfile);
			return false;
		}
		::MoveMemory(&curframe, newbuf + curpos, sizeof(double));
		curpos += sizeof(double);



		ChaMatrix curlocalmat;
		if ((curpos + sizeof(ChaMatrix)) > bufleng) {
			_ASSERT(0);
			if (newbuf) {
				free(newbuf);
				newbuf = 0;
			}
			CloseHandle(hfile);
			return false;
		}
		::MoveMemory(&curlocalmat, newbuf + curpos, sizeof(ChaMatrix));
		curpos += sizeof(ChaMatrix);



		int localmatflag = 0;
		if ((curpos + sizeof(int)) > bufleng) {
			_ASSERT(0);
			if (newbuf) {
				free(newbuf);
				newbuf = 0;
			}
			CloseHandle(hfile);
			return false;
		}
		::MoveMemory(&localmatflag, newbuf + curpos, sizeof(int));
		curpos += sizeof(int);



		CBone* curbone;
		//curbone = s_model->GetBoneByName(curbonename);
		curbone = s_model->FindBoneByName(curbonename);//2023/08/14 _Joint有無対応
		if (curbone) {
			CPELEM2 curcpelem;
			ZeroMemory(&curcpelem, sizeof(CPELEM2));

			curcpelem.bone = curbone;
			curcpelem.mp.SetFrame(curframe);
			curcpelem.mp.SetWorldMat(curlocalmat);
			curcpelem.mp.SetLocalMatFlag(localmatflag);

			s_pastemotvec.push_back(curcpelem);
		}
		else {
			_ASSERT(0);
		}
	}

	if (newbuf) {
		free(newbuf);
		newbuf = 0;
	}
	CloseHandle(hfile);

	return true;
}

void ChangeCurDirFromMameMediaToTest()
{
	//CurrentDirectoryがMameMediaになっていたときにはTestディレクトリに変える
	WCHAR curdir[MAX_PATH] = { 0L };
	ZeroMemory(curdir, sizeof(WCHAR) * MAX_PATH);
	GetCurrentDirectory(MAX_PATH, curdir);
	WCHAR* findpat = wcsstr(curdir, L"\\MameMedia");
	if (findpat) {
		WCHAR initialdir[MAX_PATH] = { 0L };
		wcscpy_s(initialdir, MAX_PATH, g_basedir);
		wcscat_s(initialdir, MAX_PATH, L"..\\Test\\");
		SetCurrentDirectoryW(initialdir);
	}
}

void InitTimelineSelection()
{
	s_editrange.Clear();
	s_buttonselectstart = 1.0;
	s_buttonselectend = 1.0;

	if (g_motionbrush_value) {
		free(g_motionbrush_value);
		g_motionbrush_value = 0;
	}
	g_motionbrush_value = (float*)malloc(sizeof(float) * 1);
	if (g_motionbrush_value) {
		*g_motionbrush_value = 1.0f;
	}

	//g_motionbrush_method = 0;
	g_motionbrush_startframe = 1.0;
	g_motionbrush_endframe = 1.0;
	g_motionbrush_applyframe = 1.0;
	g_motionbrush_numframe = 1.0;
	g_motionbrush_frameleng = 1;

	if (s_owpTimeline) {
		s_owpTimeline->setCurrentTime(1.0, false);
	}
	if (s_owpLTimeline) {
		s_owpLTimeline->setCurrentTime(1.0, false);
	}

	//if (s_model) {
	//	MOTINFO* curmi;
	//	curmi = s_model->GetCurMotInfo();
	//	if (curmi) {
	//		s_model->SetMotionFrame(1.0);
	//	}
	//}

	int tothelastflag = 0;
	OnTimeLineButtonSelectFromSelectStartEnd(tothelastflag);

}


void OnArrowKey()
{

	//マウスカーソルが起動中ソフトのウインドウ内にある場合だけ処理
	//複数個のAdditiveIKを立ち上げたときに操作中のAdditiveIKだけに影響するように
	POINT cursorpoint;
	GetCursorPos(&cursorpoint);
	::ScreenToClient(g_mainhwnd, &cursorpoint);
	RECT appclientrect;
	GetClientRect(g_mainhwnd, &appclientrect);
	if ((cursorpoint.x < appclientrect.left) || (cursorpoint.x > appclientrect.right) ||
		(cursorpoint.y < appclientrect.top) || (cursorpoint.y > appclientrect.bottom)) {
		//MainWindow外につき処理しない
		return;
	}


	int parentbuttonid = 4;
	int sisterbuttonid = 5;
	int childbuttonid = 6;
	int brotherbuttonid = 7;
	int accelaxisid1 = 4;//axisid
	int accelaxisid2 = 5;//axisid

	//int parentbutton = 0;
	//int sisterbutton = 0;
	//int childbutton = 0;
	//int brotherbutton = 0;
	//int accelaxis1 = 0;
	//int accelaxis2 = 0;

	//parentbutton = s_dsbuttonup[parentbuttonid];
	//sisterbutton = s_dsbuttonup[sisterbuttonid];
	//childbutton = s_dsbuttonup[childbuttonid];
	//brotherbutton = s_dsbuttonup[brotherbuttonid];

	//accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	s_dsbuttonup[parentbuttonid] = 0;
	s_dsbuttonup[sisterbuttonid] = 0;
	s_dsbuttonup[childbuttonid] = 0;
	s_dsbuttonup[brotherbuttonid] = 0;

	s_currentwndid = MB3D_WND_TREE;


	bool arrowkeypushed = false;
	if (!FocusEditWnd()) {//2023/08/28 EditCtrl入力中は　矢印キーのショートカット機能を使わない
		if (((g_savekeybuf[VK_UP] & 0x80) == 0) && ((g_keybuf[VK_UP] & 0x80) != 0)) {
			s_dsbuttonup[parentbuttonid] = 1;
			s_dsbuttonup[sisterbuttonid] = 0;
			s_dsbuttonup[childbuttonid] = 0;
			s_dsbuttonup[brotherbuttonid] = 0;
			arrowkeypushed = true;
		}
		else if (((g_savekeybuf[VK_DOWN] & 0x80) == 0) && ((g_keybuf[VK_DOWN] & 0x80) != 0)) {
			s_dsbuttonup[parentbuttonid] = 0;
			s_dsbuttonup[sisterbuttonid] = 0;
			s_dsbuttonup[childbuttonid] = 1;
			s_dsbuttonup[brotherbuttonid] = 0;
			arrowkeypushed = true;
		}
		else if (((g_keybuf['H'] & 0x80) == 0) && ((g_keybuf['F'] & 0x80) == 0) && 
			((g_savekeybuf[VK_LEFT] & 0x80) == 0) && ((g_keybuf[VK_LEFT] & 0x80) != 0)) {
			s_dsbuttonup[parentbuttonid] = 0;
			s_dsbuttonup[sisterbuttonid] = 1;
			s_dsbuttonup[childbuttonid] = 0;
			s_dsbuttonup[brotherbuttonid] = 0;
			arrowkeypushed = true;
		}
		else if (((g_keybuf['H'] & 0x80) == 0) && ((g_keybuf['F'] & 0x80) == 0) && 
			((g_savekeybuf[VK_RIGHT] & 0x80) == 0) && ((g_keybuf[VK_RIGHT] & 0x80) != 0)) {
			s_dsbuttonup[parentbuttonid] = 0;
			s_dsbuttonup[sisterbuttonid] = 0;
			s_dsbuttonup[childbuttonid] = 0;
			s_dsbuttonup[brotherbuttonid] = 1;
			arrowkeypushed = true;
		}
	}

	if (arrowkeypushed == true) {
		bool firstctrlselect = false;
		DSCrossButtonSelectTree(firstctrlselect);

	}

}

//double CalcRefFrame()
//{
//	double startframe = s_editrange.GetStartFrame();
//	double endframe = s_editrange.GetEndFrame();
//	if (startframe != endframe) {
//		double offset = 0;
//		double refframe = (double)((int)(startframe + (endframe - startframe) * g_refpos / 100.0 + offset));
//
//		return refframe;
//	}
//	else {
//		return -1.0;
//	}
//
//}

ChaMatrix CalcRigMat(CUSTOMRIG* currig, CBone* curbone, int curmotid, double curframe, int dispaxis, int disporder, bool posinverse)
{

	ChaMatrix retmat;
	ChaMatrixIdentity(&retmat);
	if (!curbone) {
		_ASSERT(0);
		return retmat;
	}
	if (!curbone->GetParModel()) {
		_ASSERT(0);
		return retmat;
	}
	if (!currig) {
		_ASSERT(0);
		return retmat;
	}

	//int multworld = 1;
	ChaMatrix selm;
	selm.SetIdentity();
	//int multworld = 1;
	//ChaMatrix selm = curbone->CalcManipulatorMatrix(0, 0, multworld, curmotid, curframe);
	//ChaMatrix selm = curbone->CalcManipulatorMatrix(0, multworld, curmotid, curframe);
	if (curbone && curbone->GetParent(false) && curbone->GetParent(false)->IsSkeleton()) {

		//!!!!!! 軸の種類を変えた場合にも　リグの設定が保たれるように　BONEAXIS_CURRENTで統一
		//BONEAXIS_BINDPOSEはXフィットしないので　BONEAXIS_CURRENTを選んだ
		curbone->GetParent(false)->CalcAxisMatX_Manipulator(g_limitdegflag, BONEAXIS_CURRENT, 0, curbone, &selm, 0);
	}
	else {
		//selm.SetIdentity();
		selm = curbone->GetWorldMat(g_limitdegflag, curmotid, curframe, 0);
	}

	//selm.data[MATI_41] = 0.0f;
	//selm.data[MATI_42] = 0.0f;
	//selm.data[MATI_43] = 0.0f;

	CalcSelectScale(curbone);//s_selectscaleにセット

	ChaMatrix scalemat;
	ChaMatrixIdentity(&scalemat);
	//ChaMatrixScaling(&scalemat, s_selectscale, s_selectscale, s_selectscale);
	float rigmult;
	switch (currig->shapekind) {
	case RIGSHAPE_SPHERE:
		rigmult = 0.5f * s_selectscale * (float)(currig->shapemult + 1) * 0.5f;
		break;
	case RIGSHAPE_RINGX:
	case RIGSHAPE_RINGY:
	case RIGSHAPE_RINGZ:
		rigmult = s_selectscale * (float)(currig->shapemult + 1) * 0.5f;
		break;
	default:
		rigmult = s_selectscale;
		_ASSERT(0);
		break;
	}
	ChaMatrixScaling(&scalemat, rigmult, rigmult, rigmult);

	//ChaVector3 curbonepos = curbone->GetWorldPos(g_limitdegflag, curmotid, curframe);//world座標系
	//ChaMatrix invmodelwm = ChaMatrixInv(curbone->GetParModel()->GetWorldMat());
	//ChaVector3 curbonepos;
	//ChaVector3TransformCoord(&curbonepos, &curbonepos0, &invmodelwm);

	ChaVector3 jointpos = curbone->GetJointFPos();
	ChaMatrix curwm = curbone->GetWorldMat(g_limitdegflag, curmotid, curframe, 0);
	ChaVector3 curbonepos;
	ChaVector3TransformCoord(&curbonepos, &jointpos, &curwm);


	float curboneleng = (float)curbone->GetBoneLeng();
	float multoffset;
	if (curboneleng != 0.0f) {
		multoffset = curboneleng * 0.25f;
	}
	else {
		multoffset = 1.0f;
	}


	float rigorderoffset = 0.0f;
	rigorderoffset = (float)disporder * 0.25f * multoffset;
	if (posinverse) {
		rigorderoffset *= -1.0f;
	}


	//ChaVector3 offsetorgpos = ChaVector3(0.0f, 0.0f, 0.0f);
	//ChaVector3 offsetdisppos = ChaVector3(0.0f, 0.0f, 0.0f);

	//ChaMatrix curwm = curbone->GetWorldMat(g_limitdegflag, curmotid, curframe, 0);
	ChaMatrix curbonerotmat;
	//curbonerotmat = ChaMatrixRot(curwm);
	curbonerotmat = ChaMatrixRot(selm);
	ChaVector3 offsetvec;

	if (dispaxis == 0) {
		offsetvec = curbonerotmat.GetRow(0);
	}
	else if (dispaxis == 1) {
		offsetvec = curbonerotmat.GetRow(1);
	}
	else if (dispaxis == 2) {
		offsetvec = curbonerotmat.GetRow(2);
	}
	else {
		_ASSERT(0);
		offsetvec = ChaVector3(1.0f, 0.0f, 0.0f);
	}
	offsetvec *= rigorderoffset;
	//ChaVector3TransformCoord(&offsetdisppos, &offsetorgpos, &selm);

	ChaMatrix tramat;
	ChaMatrixIdentity(&tramat);
	ChaMatrixTranslation(&tramat, 
		curbonepos.x + offsetvec.x, curbonepos.y + offsetvec.y, curbonepos.z + offsetvec.z);

	//retmat = scalemat * tramat;
	//retmat = ChaMatrixFromSRT(true, true, curbone->GetNodeMat(), &scalemat, &curbonerotmat, &tramat);

	retmat = scalemat * curbonerotmat;
	retmat.SetTranslation(ChaVector3(curbonepos.x + offsetvec.x, curbonepos.y + offsetvec.y, curbonepos.z + offsetvec.z));
	retmat = retmat * curbone->GetParModel()->GetWorldMat();


	return retmat;
}

int PickRigBone(UIPICKINFO* ppickinfo, bool forrigtip, int* dstrigno)//default:forrigtip = false, dstrigno = 0
{
	if (!s_model || !ppickinfo) {
		return -1;
	}

	if (g_previewFlag != 0) {
		//プレビュー中はマウスでは選択しない
		return -1;
	}

	ResetRigModelNum();
	MOTINFO* curmi = s_model->GetCurMotInfo();
	if (curmi) {
		int curmotid = curmi->motid;
		double curframe = curmi->curframe;

		std::map<int, CBone*>::iterator itrbone;
		for (itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++) {
			CBone* curbone = (CBone*)itrbone->second;
			if (curbone && (curbone->IsSkeleton())) {
				int rigno;
				for (rigno = 0; rigno < MAXRIGNUM; rigno++) {
					CUSTOMRIG currig = curbone->GetCustomRig(rigno);
					if (currig.useflag == 2) {//0: free, 1: allocated, 2: valid
						//s_matrig->SetDif4F(s_matrigmat);

						CModel* currigmodel;
						int instancingno;
						ChaVector4 rigmaterial;
						currigmodel = GetCurRigModel(currig, &instancingno, &rigmaterial);
						if (currigmodel && (instancingno >= 0) && (instancingno < RIGMULTINDEXMAX)) {
							ChaMatrix rigmat;
							ChaMatrixIdentity(&rigmat);
							rigmat = CalcRigMat(&currig, curbone, curmotid, curframe, currig.dispaxis, currig.disporder, currig.posinverse);

							//g_hmWorld->SetMatrix(rigmat.GetDataPtr());
							currigmodel->UpdateMatrix(g_limitdegflag, &rigmat, &s_matVP);


							int chkboneno = curbone->GetBoneNo();

							UIPICKINFO chkpickinfo;
							chkpickinfo = *ppickinfo;

							chkpickinfo.buttonflag = PICK_CENTER;
							chkpickinfo.pickobjno = chkboneno;

							int colliobj;
							bool excludeinvface = true;
							colliobj = currigmodel->CollisionNoBoneObj_Mouse(&chkpickinfo, "obj1", excludeinvface);
							if (colliobj > 0) {
								RollbackCurBoneNo();

								if (forrigtip == false) {
									*ppickinfo = chkpickinfo;
									s_curboneno = chkboneno;

									CBone* chkbone = s_model->GetBoneByID(s_curboneno);
									if (chkbone != s_customrigbone) {
										//開いている設定ダイアログを閉じないと、設定ダイアログのrigboneと新たなrigboneが異なってしまい、Applyボタンで異なるリグを保存することがある
										if (s_customrigdlg) {
											DestroyWindow(s_customrigdlg);
											s_customrigdlg = 0;
										}
									}

									if (s_owpTimeline) {
										s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
										//WindowPos currentpos = s_owpTimeline->getCurrentLinePos();
										//POINT mousepos;
										//mousepos.x = currentpos.x;
										//mousepos.y = currentpos.y;
										//::ClientToScreen(s_timelineWnd->getHWnd(), &mousepos);
										//::SetCursorPos(mousepos.x, mousepos.y);
									}
									ChangeCurrentBone();//2021/11/19

									//Bone2CustomRig(rigno);
									GUIMenuSetVisible(-1, -1);
									DispCustomRigDlg(rigno);//2024/01/21 設定ダイアログ表示をピックしたリグの内容に更新
								}
								else {
									if (dstrigno) {
										*dstrigno = rigno;
									}
								}

								return chkboneno;//!!!!!!!!!!!!!!!!!!!!!!!!!!!! found !!!!!!!!!!!!!!!!!!
							}
							else {
								if (dstrigno) {
									*dstrigno = -1;
								}
							}
						}
					}
				}
			}
		}
	}
	else {
		return -1;
	}

	return -1;

}

int LoadLightsForEdit()
{
	int result = 0;

	int slotindex;
	for (slotindex = 0; slotindex < LIGHTSLOTNUM; slotindex++) {
		WCHAR lightfilepath[MAX_PATH] = { 0L };
		swprintf_s(lightfilepath, MAX_PATH, L"%s\\MB3DOpenProjLightsForEdit_%d.txt", s_temppath, slotindex);

		CLightsForEditFile lightfile;
		result += lightfile.LoadLightsForEditFile(lightfilepath, slotindex);

	}

	return result;
}

int LoadShadowParamsFile()
{
	int result = 0;

	WCHAR filepath[MAX_PATH] = { 0L };
	swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjShadowParams_0.txt", s_temppath);

	CShadowParamsFile shadowparamsfile;
	result = shadowparamsfile.LoadShadowParamsFile(filepath);

	return result;
}


int PickManipulator(UIPICKINFO* ppickinfo, bool pickring)
{
	if (!ppickinfo) {
		_ASSERT(0);
		return -1;
	}
	if (!s_select) {
		return 0;
	}

	if (s_dispselect) {
		bool excludeinvface = false;
		int colliobjx, colliobjy, colliobjz, colliringx, colliringy, colliringz;
		colliobjx = 0;
		colliobjy = 0;
		colliobjz = 0; 
		colliringx = 0; 
		colliringy = 0; 
		colliringz = 0;
		colliobjx = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "objX", excludeinvface);
		colliobjy = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "objY", excludeinvface);
		colliobjz = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "objZ", excludeinvface);
		if ((s_ikkind == 0) || (pickring == true)) {
			colliringx = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "ringX", excludeinvface);
			colliringy = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "ringY", excludeinvface);
			colliringz = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "ringZ", excludeinvface);
		}
		else {
			colliringx = 0;
			colliringy = 0;
			colliringz = 0;
		}

		if (colliobjx || colliringx || colliobjy || colliringy || colliobjz || colliringz) {
			RollbackCurBoneNo();
			ppickinfo->pickobjno = s_curboneno;
		}

		if (colliobjx || colliringx) {
			ppickinfo->buttonflag = PICK_X;
		}
		else if (colliobjy || colliringy) {
			ppickinfo->buttonflag = PICK_Y;
		}
		else if (colliobjz || colliringz) {
			ppickinfo->buttonflag = PICK_Z;
		}
		else {
			ZeroMemory(ppickinfo, sizeof(UIPICKINFO));
		}
	}
	else {
		ZeroMemory(ppickinfo, sizeof(UIPICKINFO));
		ppickinfo->pickobjno = -1;
	}

	return ppickinfo->pickobjno;
}




int LoadChooseColor()
{
	//s_temppathのセットよりも後

	COLORREF savedcolorref[16];
	ZeroMemory(&savedcolorref, sizeof(COLORREF) * 16);
	WCHAR colorfilepath[MAX_PATH] = { 0L };
	swprintf_s(colorfilepath, MAX_PATH, L"%s\\MB3DOpenProjChooseColor_0.txt", s_temppath);
	CChooseColorFile colorfile;
	int resultcolfile = colorfile.LoadChooseColorFile(colorfilepath, &(savedcolorref[0]));
	if (resultcolfile == 0) {
		s_coldlg.SetCustomColor(&(savedcolorref[0]));
	}

	return 0;
}


int LoadIniFile()
{
	WCHAR path[MAX_PATH] = { 0L };
	wcscpy_s(path, MAX_PATH, g_basedir);
	WCHAR* lasten = 0;
	WCHAR* last2en = 0;
	lasten = wcsrchr(path, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return 1;
	}
	*lasten = 0L;
	last2en = wcsrchr(path, TEXT('\\'));
	if (!last2en) {
		_ASSERT(0);
		return 1;
	}
	*last2en = 0L;

	WCHAR inifilepath[MAX_PATH] = { 0L };
	swprintf_s(inifilepath, MAX_PATH, L"%s\\AdditiveIK%d.ini", path, s_appcnt);

	CIniFile inifile;
	inifile.LoadIniFile(inifilepath);

	return 0;
}

int SaveLightsForEdit()
{
	int result = 0;

	int slotindex;
	for (slotindex = 0; slotindex < LIGHTSLOTNUM; slotindex++) {
		WCHAR lightfilepath[MAX_PATH] = { 0L };
		swprintf_s(lightfilepath, MAX_PATH, L"%s\\MB3DOpenProjLightsForEdit_%d.txt", s_temppath, slotindex);

		CLightsForEditFile lightfile;
		result += lightfile.WriteLightsForEditFile(lightfilepath, slotindex);
		_ASSERT(result == 0);
	}
	return result;
}

int SaveShadowParamsFile()
{
	int result = 0;

	WCHAR filepath[MAX_PATH] = { 0L };
	swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjShadowParams_0.txt", s_temppath);

	CShadowParamsFile shadowparamsfile;
	result = shadowparamsfile.WriteShadowParamsFile(filepath);
	_ASSERT(result == 0);

	return result;
}


int SaveChooseColor()
{
	COLORREF colforsave[16];
	ZeroMemory(colforsave, sizeof(COLORREF) * 16);
	int resultgetcol = s_coldlg.GetCustomColor(16, &(colforsave[0]));
	if (resultgetcol == 0) {
		WCHAR colorfilepath[MAX_PATH] = { 0L };
		swprintf_s(colorfilepath, MAX_PATH, L"%s\\MB3DOpenProjChooseColor_0.txt", s_temppath);
		CChooseColorFile colorfile;
		int resultcolfile = colorfile.WriteChooseColorFile(colorfilepath, colforsave);
		_ASSERT(resultcolfile == 0);
		return resultcolfile;
	}

	return 0;
}

int SaveIniFile()
{
	WCHAR path[MAX_PATH] = { 0L };
	wcscpy_s(path, MAX_PATH, g_basedir);
	WCHAR* lasten = 0;
	WCHAR* last2en = 0;
	lasten = wcsrchr(path, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return 1;
	}
	*lasten = 0L;
	last2en = wcsrchr(path, TEXT('\\'));
	if (!last2en) {
		_ASSERT(0);
		return 1;
	}
	*last2en = 0L;

	WCHAR inifilepath[MAX_PATH] = { 0L };
	swprintf_s(inifilepath, MAX_PATH, L"%s\\AdditiveIK%d.ini", path, s_appcnt);

	CIniFile inifile;
	inifile.WriteIniFile(inifilepath);

	return 0;
}

int SetTimelineHasRigFlag()
{
	if (!s_owpTimeline) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}


	std::map<int, CBone*>::iterator itrbone;
	for (itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++) {
		CBone* curbone = (CBone*)itrbone->second;
		if (curbone && (curbone->IsSkeleton())) {
			bool hasrigflag = s_model->ChkBoneHasRig(curbone);
			s_owpTimeline->setHasRigFlag(curbone->GetWBoneName(), hasrigflag);
		}
	}

	return 0;
}


int ClearLimitedWM(CModel* srcmodel)
{
	if (!srcmodel) {
		return 0;
	}

	if (srcmodel) {
		MOTINFO* curmi = srcmodel->GetCurMotInfo();
		if (!curmi) {
			return 0;
		}

		double frameleng = curmi->frameleng;

		double curframe;
		for (curframe = 0.0; curframe < frameleng; curframe += 1.0) {
			//for (curframe = 1.0; curframe < frameleng; curframe += 1.0) {
			srcmodel->ClearLimitedWM(curmi->motid, curframe);
		}
	}
	return 0;
}

int SetShowPosTime()
{
	if (s_owpTimeline && s_owpLTimeline && s_owpEulerGraph) {
		double startframe, endframe, applyframe;
		int selnum;
		s_editrange.GetRange(&selnum, &startframe, &endframe, &applyframe);

		double curframe = applyframe;
		double startedgeframe = max(1.0, (double)((int)(curframe - s_owpEulerGraph->getShowposWidth() / 2.0)));
		//double startedgeframe = max(1.0, (double)((int)(curframe - s_owpEulerGraph->getShowposWidth())));

		//s_owpTimeline->setShowPosTime(curframe);
		//s_owpLTimeline->setShowPosTime(curframe);
		//s_owpEulerGraph->setShowPosTime(curframe);

		s_owpTimeline->setShowPosTime(startedgeframe);
		s_owpLTimeline->setShowPosTime(startedgeframe);
		s_owpEulerGraph->setShowPosTime(startedgeframe);
		//s_owpTimeline->setShowPosTime(curframe);
		//s_owpLTimeline->setShowPosTime(curframe);
		//s_owpEulerGraph->setShowPosTime(curframe);


		s_owpTimeline->setCurrentTime(curframe, false);
		s_owpLTimeline->setCurrentTime(curframe, true);
		s_owpEulerGraph->setCurrentTime(curframe, false);
	}


	return 0;
}

int ChangeUpdateMatrixThreads()
{
	if (!s_chascene) {
		return 0;
	}

	StopBt();

	g_changeUpdateThreadsNum = true;

	//SleepEx(30, false);

	int modelnum = s_chascene->GetModelNum();
	int modelcount;
	for (modelcount = 0; modelcount < modelnum; modelcount++) {
		CModel* curmodel = s_chascene->GetModel(modelcount);
		if (curmodel) {
			curmodel->CreateBoneUpdateMatrix();
		}
	}

	g_changeUpdateThreadsNum = false;


	return 0;
}

int FindModelIndex(CModel* srcmodel)
{
	if (!srcmodel || !s_chascene) {
		return -1;
	}

	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return -1;
	}

	int modelno;
	for (modelno = 0; modelno < modelnum; modelno++) {
		MODELELEM curme = s_chascene->GetModelElem(modelno);
		if (curme.modelptr == srcmodel) {
			return modelno;//!!!!!!!!!!!!!!
		}
	}

	return -1;
}

void RollbackBrushState(BRUSHSTATE srcbrushstate)
{
	g_brushmirrorUflag = srcbrushstate.brushmirrorUflag;
	g_brushmirrorVflag = srcbrushstate.brushmirrorVflag;
	g_ifmirrorVDiv2flag = srcbrushstate.ifmirrorVDiv2flag;
	ChangeLimitDegFlag(srcbrushstate.limitdegflag, false, false);//RollbackBrushState呼び出し元の下方にてApplyNewLimitsToWM();を呼ぶので３番目の引数はfalse
	//g_limitdegflag = srcbrushstate.limitdegflag;
	g_motionbrush_method = srcbrushstate.motionbrush_method;
	g_wallscrapingikflag = srcbrushstate.wallscrapingikflag;
	g_brushrepeats = srcbrushstate.brushrepeats;

	//if (s_BrushMirrorUCheckBox) {
	//	s_BrushMirrorUCheckBox->SetChecked((bool)g_brushmirrorUflag);
	//}
	//if (s_BrushMirrorVCheckBox) {
	//	s_BrushMirrorVCheckBox->SetChecked((bool)g_brushmirrorVflag);
	//}
	//if (s_IfMirrorVDiv2CheckBox) {
	//	s_IfMirrorVDiv2CheckBox->SetChecked((bool)g_ifmirrorVDiv2flag);
	//}
	////if (s_LimitDegCheckBox) {
	////	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
	////}
	////if (s_WallScrapingIKCheckBox) {
	////	s_WallScrapingIKCheckBox->SetChecked((bool)g_wallscrapingikflag);
	////}
	s_splimiteul.state = g_limitdegflag;
	s_spscraping.state = (bool)g_wallscrapingikflag;


	//CDXUTComboBox* pComboBox = g_SampleUI.GetComboBox(IDC_COMBO_MOTIONBRUSH_METHOD);
	//if (pComboBox) {
	//	pComboBox->SetSelectedByData(ULongToPtr(g_motionbrush_method));
	//}

	//CDXUTSlider* pslider = g_SampleUI.GetSlider(IDC_SL_BRUSHREPEATS);
	//if (pslider) {
	//	pslider->SetValue(g_brushrepeats);
	//	CDXUTStatic* pstatic = g_SampleUI.GetStatic(IDC_STATIC_BRUSHREPEATS);
	//	if (pstatic) {
	//		WCHAR sz[100] = { 0L };
	//		swprintf_s(sz, 100, L"Brush Repeats : %d", g_brushrepeats);
	//		pstatic->SetText(sz);
	//	}
	//}

}

int DisplayApplyRateText()
{
	//if (s_spguisw[SPGUISW_BRUSHPARAMS].state) {
	//	CDXUTSlider* pslider = g_SampleUI.GetSlider(IDC_SL_APPLYRATE);
	//	if (pslider) {
	//		pslider->SetValue(g_applyrate);
	//		CDXUTStatic* pstatic = g_SampleUI.GetStatic(IDC_STATIC_APPLYRATE);
	//		if (pstatic) {
	//			WCHAR sz[100] = { 0L };
	//			swprintf_s(sz, 100, L"TopPos:%d%%:%d", g_applyrate, (int)(s_editrange.GetApplyFrame()));
	//			g_SampleUI.GetStatic(IDC_STATIC_APPLYRATE)->SetText(sz);
	//		}
	//	}
	//}

	return 0;
}

int FilterNoDlg(bool copylw2w)
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetCurMotInfo()) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	CMotFilter motfilter;

	bool edgesmp;
	if (s_constexeFlag) {
		edgesmp = true;
	}
	else {
		edgesmp = s_model->CheckIKTarget();
	}

	//s_filternodlg = true;


	//s_filterState = 3;//deeper//2023/08/09コメントアウト：前回の値を使用


	CBone* opebone = 0;
	if (s_filterState == 1) {
		//######
		//1:All
		//######
		opebone = s_model->GetTopBone(false);
	}
	else if ((s_filterState == 2) || (s_filterState == 3)) {
		//########################
		//2:selectedOne, 3:Deeper
		//########################
		CBone* curbone = s_model->GetBoneByID(s_curboneno);
		if (curbone) {
			if (curbone->GetParent(false)) {
				opebone = curbone->GetParent(false);
			}
			else {
				opebone = curbone;
			}
		}
		else {
			opebone = s_model->GetTopBone(false);
		}
	}
	else {
		//################################
		//the first time : default value
		//################################
		s_filterState = 3;
		CBone* curbone = s_model->GetBoneByID(s_curboneno);
		if (curbone) {
			if (curbone->GetParent(false)) {
				opebone = curbone->GetParent(false);
			}
			else {
				opebone = curbone;
			}
		}
		else {
			opebone = s_model->GetTopBone(false);
		}
	}

	motfilter.FilterNoDlg(edgesmp, g_limitdegflag, s_model, opebone,
		s_filterState,
		s_model->GetCurMotInfo()->motid,
		IntTime(s_buttonselectstart), IntTime(s_buttonselectend));

	//s_filterState = 0;//2023/08/09コメントアウト：前回の値を保持

	if (copylw2w) {
		if (g_limitdegflag == true) {
			bool allframeflag = false;
			bool setcursorflag = false;
			int operatingjointno = s_model->GetTopBone(false)->GetBoneNo();
			bool onpasteflag = false;
			CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);
		}
		refreshEulerGraph();
		PrepairUndo();
	}


	return 0;
}



int FilterFuncDlg()
{
	if ((s_filterState == 1) || (s_filterState == 2) || (s_filterState == 3)) {
		//if (s_model){
		//	s_model->SaveUndoMotion(s_curboneno, s_curbaseno, &s_editrange, (double)g_applyrate);
		//}

		//if (s_model && (s_filternodlg == false)) {
		//	PrepairUndo();
		//}

		if (s_model && s_model->GetCurMotInfo()) {
			if (s_owpTimeline && s_owpLTimeline) {
				s_editrange.Clear();
				//s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
				//CEditRange::SetApplyRate((double)g_applyrate);

				OnTimeLineButtonSelectFromSelectStartEnd(0);
				OnTimeLineSelectFromSelectedKey();
				int keynum;
				double startframe, endframe, applyframe;
				s_editrange.GetRange(&keynum, &startframe, &endframe, &applyframe);

				CBone* opebone = 0;
				if (s_curboneno >= 0) {
					CBone* curbone = 0;
					curbone = s_model->GetBoneByID(s_curboneno);
					if (curbone) {
						if ((s_ikkind == 0) && curbone->GetParent(false) && curbone->GetParent(false)->IsSkeleton()) {
							opebone = curbone->GetParent(false);
						}
						else {
							opebone = curbone;
						}
					}
					else {
						return 0;//!!!!!!!!
					}
				}
				else {
					return 0;//!!!!!!!!!!
				}


				if (opebone) {

					bool edgesmp;
					if (s_constexeFlag) {
						edgesmp = true;
					}
					else {
						edgesmp = s_model->CheckIKTarget();
					}

					if (keynum >= 2) {
						CMotFilter motfilter;
						motfilter.Filter(edgesmp, g_limitdegflag, s_model, opebone,
							s_filterState,
							s_model->GetCurMotInfo()->motid,
							IntTime(startframe), IntTime(endframe));


						if (g_limitdegflag == true) {
							bool allframeflag = false;
							bool setcursorflag = false;
							int operatingjointno = opebone->GetBoneNo();
							bool onpasteflag = false;
							CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);
						}
						refreshEulerGraph();
						PrepairUndo();
					}
					else {
						::DSMessageBox(s_3dwnd, L"Retry After Setting Of Selection MultiFrames.", L"error!!!", MB_OK);
					}
				}
				else {
					::DSMessageBox(s_3dwnd, L"Retry After Selectiong target joint.", L"error!!!", MB_OK);
				}
			}
		}
	}
	return 0;
}



//int CallFilterFunc(int callnum)
//{
//	if (s_model && s_model->GetCurMotInfo()) {
//
//		if (g_iklevel == 1) {
//			s_filterState = 2;//one
//		}
//		else {
//			s_filterState = 3;//deeper
//		}
//		s_filternodlg = true;
//
//		int callcount;
//		for (callcount = 0; callcount < callnum; callcount++) {
//			FilterFunc();
//		}
//
//
//		//limitedへの変更を　worldに反映
//		if (g_limitdegflag == true) {
//			bool allframeflag = false;
//			bool setcursorflag = false;
//			bool onpasteflag = false;
//
//			int operatingjointno = 0;
//			CBone* curbone = s_model->GetBoneByID(s_curboneno);
//			if (curbone) {
//				if (curbone->GetParent()) {
//					operatingjointno = curbone->GetParent()->GetBoneNo();
//				}
//				else {
//					operatingjointno = curbone->GetBoneNo();
//				}
//			}
//			else {
//				if (s_model->GetTopBone()) {
//					operatingjointno = s_model->GetTopBone()->GetBoneNo();
//				}
//			}
//			CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);
//		}
//
//
//		UpdateEditedEuler();
//	}
//
//
//	s_filterState = 0;
//	s_filternodlg = false;
//
//	return 0;
//}


int CreateToolTip(POINT ptCursor, WCHAR* srctext)
{
	//if (!srctext) {
	//	_ASSERT(0);
	//	return 1;
	//}
	//size_t textlen = wcslen(srctext);
	//if ((textlen == 0) || (textlen >= 512)) {
	//	_ASSERT(0);
	//	return 1;
	//}

	//int tipposx = ptCursor.x + 10;
	//int tipposy = ptCursor.y + 18;

	//if (s_TipText1 && s_TipText2 && s_TipText3 && s_TipText4 && s_TipText5) {
	//	const WCHAR* prevtext = s_TipText1->GetText();
	//	if (prevtext && (wcscmp(prevtext, srctext) == 0)) {
	//		//既に同じテキストを表示中なので位置だけ変更


	//		tipposx = min((s_mainwidth - (int)s_tooltiplen), tipposx);
	//		tipposy = min((s_mainheight - 18), tipposy);
	//		//s_TipText->SetLocation(tipposx, tipposy);
	//		s_TipText1->SetLocation(tipposx - 1, tipposy);
	//		s_TipText2->SetLocation(tipposx + 1, tipposy);
	//		s_TipText3->SetLocation(tipposx, tipposy - 1);
	//		s_TipText4->SetLocation(tipposx, tipposy + 1);
	//		s_TipText5->SetLocation(tipposx, tipposy);
	//	}
	//	else {
	//		//違うテキストを表示中　ToolTipの作り直し
	//		g_SampleUI.RemoveControl(IDC_TIPRIG1);
	//		g_SampleUI.RemoveControl(IDC_TIPRIG2);
	//		g_SampleUI.RemoveControl(IDC_TIPRIG3);
	//		g_SampleUI.RemoveControl(IDC_TIPRIG4);
	//		g_SampleUI.RemoveControl(IDC_TIPRIG5);
	//		s_TipText1 = 0;
	//		s_TipText2 = 0;
	//		s_TipText3 = 0;
	//		s_TipText4 = 0;
	//		s_TipText5 = 0;


	//		WCHAR sz512[512] = { 0L };
	//		swprintf_s(sz512, 512, L"%s", srctext);
	//		size_t szlen = wcslen(sz512);
	//		int displen;
	//		if (szlen <= 511) {
	//			displen = (int)szlen * 10;
	//		}
	//		else {
	//			sz512[511] = 0L;
	//			displen = 511 * 10;
	//		}
	//		s_tooltiplen = (size_t)displen;

	//		tipposx = min((s_mainwidth - (int)s_tooltiplen), tipposx);
	//		tipposy = min((s_mainheight - 18), tipposy);
	//		//g_SampleUI.AddStatic(IDC_TIPRIG, sz512, tipposx, tipposy, displen, 18);
	//		//s_TipText = g_SampleUI.GetStatic(IDC_TIPRIG);
	//		g_SampleUI.AddStatic(IDC_TIPRIG1, sz512, tipposx - 1, tipposy, displen, 18);
	//		g_SampleUI.AddStatic(IDC_TIPRIG2, sz512, tipposx + 1, tipposy, displen, 18);
	//		g_SampleUI.AddStatic(IDC_TIPRIG3, sz512, tipposx, tipposy - 1, displen, 18);
	//		g_SampleUI.AddStatic(IDC_TIPRIG4, sz512, tipposx, tipposy + 1, displen, 18);
	//		g_SampleUI.AddStatic(IDC_TIPRIG5, sz512, tipposx, tipposy, displen, 18);
	//		s_TipText1 = g_SampleUI.GetStatic(IDC_TIPRIG1);
	//		s_TipText2 = g_SampleUI.GetStatic(IDC_TIPRIG2);
	//		s_TipText3 = g_SampleUI.GetStatic(IDC_TIPRIG3);
	//		s_TipText4 = g_SampleUI.GetStatic(IDC_TIPRIG4);
	//		s_TipText5 = g_SampleUI.GetStatic(IDC_TIPRIG5);
	//		s_TipText1->SetTextColor(0xFF000F00);
	//		s_TipText2->SetTextColor(0xFF000F00);
	//		s_TipText3->SetTextColor(0xFF000F00);
	//		s_TipText4->SetTextColor(0xFF000F00);
	//		s_TipText5->SetTextColor(0xFFFFFFFF);
	//	}
	//}
	//else {
	//	//新規ToolTip作成

	//	WCHAR sz512[512] = { 0L };
	//	swprintf_s(sz512, 512, L"%s", srctext);
	//	size_t szlen = wcslen(sz512);
	//	int displen;
	//	if (szlen <= 511) {
	//		displen = (int)szlen * 10;
	//	}
	//	else {
	//		sz512[511] = 0L;
	//		displen = 511 * 10;
	//	}
	//	s_tooltiplen = (size_t)displen;

	//	tipposx = min((s_mainwidth - (int)s_tooltiplen), tipposx);
	//	tipposy = min((s_mainheight - 18), tipposy);
	//	//g_SampleUI.AddStatic(IDC_TIPRIG, sz512, tipposx, tipposy, displen, 18);
	//	//s_TipText = g_SampleUI.GetStatic(IDC_TIPRIG);
	//	g_SampleUI.AddStatic(IDC_TIPRIG1, sz512, tipposx - 1, tipposy, displen, 18);
	//	g_SampleUI.AddStatic(IDC_TIPRIG2, sz512, tipposx + 1, tipposy, displen, 18);
	//	g_SampleUI.AddStatic(IDC_TIPRIG3, sz512, tipposx, tipposy - 1, displen, 18);
	//	g_SampleUI.AddStatic(IDC_TIPRIG4, sz512, tipposx, tipposy + 1, displen, 18);
	//	g_SampleUI.AddStatic(IDC_TIPRIG5, sz512, tipposx, tipposy, displen, 18);
	//	s_TipText1 = g_SampleUI.GetStatic(IDC_TIPRIG1);
	//	s_TipText2 = g_SampleUI.GetStatic(IDC_TIPRIG2);
	//	s_TipText3 = g_SampleUI.GetStatic(IDC_TIPRIG3);
	//	s_TipText4 = g_SampleUI.GetStatic(IDC_TIPRIG4);
	//	s_TipText5 = g_SampleUI.GetStatic(IDC_TIPRIG5);
	//	if (s_TipText1) {
	//		s_TipText1->SetTextColor(0xFF000F00);
	//	}
	//	if (s_TipText2) {
	//		s_TipText2->SetTextColor(0xFF000F00);
	//	}
	//	if (s_TipText3) {
	//		s_TipText3->SetTextColor(0xFF000F00);
	//	}
	//	if (s_TipText4) {
	//		s_TipText4->SetTextColor(0xFF000F00);
	//	}
	//	if (s_TipText5) {
	//		s_TipText5->SetTextColor(0xFFFFFFFF);
	//	}
	//}

	return 0;
}


int CreateTipRig(CBone* currigbone, int currigno, POINT ptCursor)
{
	if (!currigbone || (currigno < 0)) {
		_ASSERT(0);
		return 1;
	}

	s_fontposfortip = Vector2((float)ptCursor.x, (float)ptCursor.y);


	CUSTOMRIG curcustomrig = currigbone->GetCustomRig(currigno);
	//WCHAR s_strfortip[512] = { 0L };
	swprintf_s(s_strfortip, 512, L"Rig %s : %s", currigbone->GetWBoneName(), curcustomrig.rigname);
	//CreateToolTip(ptCursor, s_strfortip);

	return 0;
}


int DispToolTip()
{
	if (!s_model) {
		return 0;
	}

	if (g_previewFlag != 0) {
		return 0;
	}



	UIPICKINFO tmppickinfo;
	ZeroMemory(&tmppickinfo, sizeof(UIPICKINFO));
	tmppickinfo.mousebefpos = s_pickinfo.mousepos;
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	tmppickinfo.mousepos = ptCursor;

	tmppickinfo.clickpos = ptCursor;
	tmppickinfo.diffmouse = ChaVector2(0.0f, 0.0f);
	tmppickinfo.firstdiff = ChaVector2(0.0f, 0.0f);
	//tmppickinfo.winx = (int)DXUTGetWindowWidth();
	//tmppickinfo.winy = (int)DXUTGetWindowHeight();
	tmppickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	tmppickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	tmppickinfo.pickrange = PICKRANGE;


	s_fontposfortip = Vector2((float)ptCursor.x, (float)ptCursor.y);


	WCHAR sz512[512];
	ZeroMemory(sz512, sizeof(WCHAR) * 512);

	//bool doneflag = false;

	s_dispfontfottip = false;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {


		int cameramode;
		cameramode = PickSpCam(ptCursor);
		switch (cameramode) {
		case PICK_CAMROT:
			s_dispfontfottip = true;
			wcscpy_s(sz512, 512, L"LDrag:CameraRot, RDrag:CameraTwist, RDBLCLK:TwistInit.");
			//CreateToolTip(ptCursor, s_strfortip);
			break;
		case PICK_CAMMOVE:
			s_dispfontfottip = true;
			wcscpy_s(sz512, 512, L"Drag Camera : Pan");
			//CreateToolTip(ptCursor, s_strfortip);
			break;
		case PICK_CAMDIST:
			s_dispfontfottip = true;
			wcscpy_s(sz512, 512, L"Drag Camera : Dolly");
			//CreateToolTip(ptCursor, s_strfortip);
			break;
		default:
			break;
		}

		if (s_dispfontfottip == false) {
			//IK Mode
			int pickikmodeflag = 0;
			pickikmodeflag = PickSpIkModeSW(ptCursor);
			if (pickikmodeflag == 1) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"IKMode : Rotation");
				//CreateToolTip(ptCursor, s_strfortip);
			}
			else if (pickikmodeflag == 2) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"IKMode : Move");
				//CreateToolTip(ptCursor, s_strfortip);
			}
			else if (pickikmodeflag == 3) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"IKMode : Scale");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}

		if (s_dispfontfottip == false) {
			int pickundo = 0;
			pickundo = PickSpUndo(ptCursor);
			if (pickundo == PICK_UNDO) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"Undo operation");
				//CreateToolTip(ptCursor, s_strfortip);
			}
			else if (pickundo == PICK_REDO) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"Redo operation");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}

		if (s_dispfontfottip == false) {
			//lod switch
			int picklodflag = 0;
			picklodflag = PickSpLODSW(ptCursor);
			if (picklodflag == 1) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"Disp ReferencePose");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}

		if (s_dispfontfottip == false) {
			//limiteul switch
			int picklimiteulflag = 0;
			picklimiteulflag = PickSpLimitEulSW(ptCursor);
			if (picklimiteulflag == 1) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"Angle Limit on IK Rot");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}

		if (s_dispfontfottip == false) {
			//cameramode switch
			int pickcameramodeflag = 0;
			pickcameramodeflag = PickSpCameraModeSW(ptCursor);
			if (pickcameramodeflag == 1) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"With or Without CameraAnim");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}

		if (s_dispfontfottip == false) {
			//camerainherit switch
			int pickcamerainheritflag = 0;
			pickcamerainheritflag = PickSpCameraInheritSW(ptCursor);
			if (pickcamerainheritflag == 1) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"CameraAnim InheritMode");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}

		if (s_dispfontfottip == false) {
			//wallscraping switch
			int pickscrapingflag = 0;
			pickscrapingflag = PickSpScrapingSW(ptCursor);
			if (pickscrapingflag == 1) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"WallScraping on Limited IK Rot");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}

		if (s_dispfontfottip == false) {
			if (PickSpCpLW2W(ptCursor) != 0) {
				if (s_copyLW2WFlag == false) {
					s_dispfontfottip = true;
					wcscpy_s(sz512, 512, L"Copy LimitedAngleMotion to UnLimitedAngleMotion");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (s_dispfontfottip == false) {
			if (PickSpSmooth(ptCursor) != 0) {
				if (s_smoothFlag == false) {
					s_dispfontfottip = true;
					wcscpy_s(sz512, 512, L"LBtn:Smooth, RBtn:SettingsAndSmooth");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (s_dispfontfottip == false) {
			if (PickSpConstExe(ptCursor) != 0) {
				if (s_constexeFlag == false) {
					s_dispfontfottip = true;
					wcscpy_s(sz512, 512, L"Execute Position Constraint");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}
		if (s_dispfontfottip == false) {
			if (PickSpConstRefresh(ptCursor) != 0) {
				if (s_constrefreshFlag == false) {
					s_dispfontfottip = true;
					wcscpy_s(sz512, 512, L"Update TargetPosition of Constraint");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}



		if (s_toolspritemode == 0) {//ToolShortCut : 0
			if (s_dispfontfottip == false) {
				if (PickSpCopy(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Copy Motion");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}

			if (s_dispfontfottip == false) {
				if (PickSpSymCopy(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"SymCopy Motion");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}

			if (s_dispfontfottip == false) {
				if (PickSpPaste(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"LBtn:Paste Motion, RBtn;Settings And Paste Motion");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}

			if (s_dispfontfottip == false) {
				if (PickSpCopyHistory(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Disp CopyHistory at Right Pain");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}
		}
		else if (s_toolspritemode == 1) {//ToolShortCut : 1
			if (s_dispfontfottip == false) {
				if (PickSpInterpolate(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Interpolate Motion");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}

			if (s_dispfontfottip == false) {
				if (PickSpInit(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Init MotionPoint");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}

			if (s_dispfontfottip == false) {
				if (PickSpScaleInit(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Init All Scale");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}

			if (s_dispfontfottip == false) {
				if (PickSpProperty(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Property of Motion");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}
		}
		else if (s_toolspritemode == 2) {//ToolShortCut : 2
			if (s_dispfontfottip == false) {
				if (PickSpZeroFrame(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Edit 0 Frame");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}

			if (s_dispfontfottip == false) {
				if (PickSpCameraDolly(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Camera Dolly History");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}

			if (s_dispfontfottip == false) {
				if (PickSpModelPosDir(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Model's Pos and Dir");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}

			if (s_dispfontfottip == false) {
				if (PickSpMaterialRate(ptCursor) != 0) {
					if (s_model) {
						s_dispfontfottip = true;
						wcscpy_s(sz512, 512, L"Material Rate");
						//CreateToolTip(ptCursor, s_strfortip);
					}
				}
			}
		}
		else {
			_ASSERT(0);
		}

		if (s_dispfontfottip == false) {
			int oprigs_dispfontfottip = 0;
			int pickrigflag = 0;
			pickrigflag = PickSpRig(ptCursor);
			if (pickrigflag == 1) {
				s_dispfontfottip = true;
				wcscpy_s(sz512, 512, L"Rig On or Off");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}

		if (s_dispfontfottip == false) {
			if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
				int spakind = PickSpAxis(ptCursor);
				if (spakind == PICK_SPA_X) {
					s_dispfontfottip = true;
					wcscpy_s(sz512, 512, L"Drag X Axis IK");
					//CreateToolTip(ptCursor, s_strfortip);
				}
				else if (spakind == PICK_SPA_Y) {
					s_dispfontfottip = true;
					wcscpy_s(sz512, 512, L"Drag Y Axis IK");
					//CreateToolTip(ptCursor, s_strfortip);
				}
				else if (spakind == PICK_SPA_Z) {
					s_dispfontfottip = true;
					wcscpy_s(sz512, 512, L"Drag Z Axis IK");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

	}

	if (s_dispfontfottip == false) {
		//ret2prev
		bool pickfrog = PickSpFrog(ptCursor);
		if (pickfrog == true) {
			s_dispfontfottip = true;
			wcscpy_s(sz512, 512, L"SpaceKey:Change MenuKind. C+SpaceKey:Change Plate.");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}
	if (s_dispfontfottip == false) {
		//ret2prev2
		bool pickfrog = PickSpFrog2(ptCursor);
		if (pickfrog == true) {
			s_dispfontfottip = true;
			wcscpy_s(sz512, 512, L"V + SpaceKey: Change ToolShortCutMenu.");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	
	if (s_dispfontfottip == false) {
		if (s_oprigflag == 0) {
			if (g_shiftkey == false) {
				s_model->PickBone(&tmppickinfo);
			}
			if (tmppickinfo.pickobjno >= 0) {
				int curboneno = tmppickinfo.pickobjno;
				CBone* curbone = s_model->GetBoneByID(curboneno);
				if (curbone) {
					s_dispfontfottip = true;
					swprintf_s(s_strfortip, 512, L"Joint : %s", curbone->GetWBoneName());
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}
	}

	if (sz512[0] != 0L) {
		wcscpy_s(s_strfortip, 512, sz512);
	}
	else {
		//s_customrigのツールチップ表示
		if ((s_oprigflag != 0) && (g_previewFlag == 0)) {
			s_dispfontfottip = DispTipRig();
		}
	}



	return 0;
}

bool DispTipRig()
{
	if (!s_model) {
		return false;
	}

	UIPICKINFO tmppickinfo;
	ZeroMemory(&tmppickinfo, sizeof(UIPICKINFO));
	tmppickinfo.mousebefpos = s_pickinfo.mousepos;
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	tmppickinfo.mousepos = ptCursor;

	tmppickinfo.clickpos = ptCursor;
	tmppickinfo.diffmouse = ChaVector2(0.0f, 0.0f);
	tmppickinfo.firstdiff = ChaVector2(0.0f, 0.0f);
	//tmppickinfo.winx = (int)DXUTGetWindowWidth();
	//tmppickinfo.winy = (int)DXUTGetWindowHeight();
	tmppickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	tmppickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	tmppickinfo.pickrange = PICKRANGE;


	//s_customrigのツールチップ表示
	if ((s_oprigflag != 0) && (g_previewFlag == 0)) {
		bool forrigtip = true;
		int currigno = -1;
		int pickrigboneno = PickRigBone(&tmppickinfo, forrigtip, &currigno);
		if ((pickrigboneno >= 0) && (currigno >= 0)) {
			CBone* currigbone = s_model->GetBoneByID(pickrigboneno);
			if (currigbone) {

				s_tiprigboneno = pickrigboneno;
				s_tiprigno = currigno;
				CreateTipRig(currigbone, currigno, ptCursor);
				return true;//!!!!!!
			}
		}
		//else {
		//	//チップ削除
		//	if (s_TipText) {
		//		g_SampleUI.RemoveControl(IDC_TIPRIG);
		//		s_TipText = 0;
		//	}
		//}
	}
	return false;
}

//int CreateCameraDollyWnd()
//{
//
//	//CCameraDollyDlg dlg(g_camEye);
//	//dlg.DoModal();
//	//g_camEye = dlg.GetCameraPos();
//
//	HWND hDlgWnd = CreateDialogW((HMODULE)GetModuleHandle(NULL), 
//		MAKEINTRESOURCE(IDD_DOLLYDLG), g_mainhwnd, (DLGPROC)CameraDollyDlgProc);
//	if (hDlgWnd == NULL) {
//		return 1;
//	}
//	s_cameradollydlgwnd = hDlgWnd;
//	ShowWindow(s_cameradollydlgwnd, SW_HIDE);
//
//	return 0;
//}

int CreateModelWorldMatWnd()
{

	//CCameraDollyDlg dlg(g_camEye);
	//dlg.DoModal();
	//g_camEye = dlg.GetCameraPos();

	HWND hDlgWnd = CreateDialogW((HMODULE)GetModuleHandle(NULL),
		//MAKEINTRESOURCE(IDD_MODELWORLDMATDLG), g_mainhwnd, (DLGPROC)ModelWorldMatDlgProc);
		MAKEINTRESOURCE(IDD_MODELWORLDMATDLG), s_3dwnd, (DLGPROC)ModelWorldMatDlgProc);
	if (hDlgWnd == NULL) {
		return 1;
	}
	s_modelworldmatdlgwnd = hDlgWnd;
	ShowWindow(s_modelworldmatdlgwnd, SW_HIDE);

	return 0;
}

int CreateShaderTypeParamsDlg()
{

	//CCameraDollyDlg dlg(g_camEye);
	//dlg.DoModal();
	//g_camEye = dlg.GetCameraPos();

	HWND hDlgWnd = CreateDialogW((HMODULE)GetModuleHandle(NULL),
		//MAKEINTRESOURCE(IDD_SHADERTYPEDLG2), g_mainhwnd, (DLGPROC)ShaderTypeParamsDlgProc);
		MAKEINTRESOURCE(IDD_SHADERTYPEDLG2), s_3dwnd, (DLGPROC)ShaderTypeParamsDlgProc);
	if (hDlgWnd == NULL) {
		return 1;
	}
	s_shadertypeparamsdlgwnd = hDlgWnd;
	ShowWindow(s_shadertypeparamsdlgwnd, SW_HIDE);
	s_shadertypeparamsindex = -1;
	s_shadertypeparamsFlag = false;

	return 0;
}


int SetModel2ModelWorldMatDlg(CModel* srcmodel)
{
	if (srcmodel) {
		WCHAR strname[256] = { 0L };
		ZeroMemory(strname, sizeof(WCHAR) * 256);
		size_t namelen = wcslen(srcmodel->GetFileName());
		if (namelen <= 255) {
			wcscpy_s(strname, 256, srcmodel->GetFileName());
		}
		else {
			wcsncpy_s(strname, 256, srcmodel->GetFileName(), 255);
		}
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_STATICMODELNAME, strname);


		ChaVector3 tmppos = srcmodel->GetModelPosition();
		ChaVector3 tmprot = srcmodel->GetModelRotation();

		WCHAR strval[256] = { 0L };
		swprintf_s(strval, 256, L"%.3f", tmppos.x);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_POSITIONX, strval);
		swprintf_s(strval, 256, L"%.3f", tmppos.y);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_POSITIONY, strval);
		swprintf_s(strval, 256, L"%.3f", tmppos.z);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_POSITIONZ, strval);

		swprintf_s(strval, 256, L"%.3f", tmprot.x);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_ROTATIONX, strval);
		swprintf_s(strval, 256, L"%.3f", tmprot.y);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_ROTATIONY, strval);
		swprintf_s(strval, 256, L"%.3f", tmprot.z);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_ROTATIONZ, strval);

	}

	return 0;
}

int SetMaterial2ShaderTypeParamsDlg(CMQOMaterial* srcmat)
{
	//############################################################
	//srcmat == nullptrの場合にはs_modelの最初のマテリアルシェーダを表示
	//############################################################

	if (!s_model || (s_shadertypeparamsdlgwnd == NULL)) {
		_ASSERT(0);
		return 1;
	}
	HWND hDlgWnd = s_shadertypeparamsdlgwnd;

	int materialnum = s_model->GetMQOMaterialSize();
	CMQOMaterial* curmqomat = srcmat;

	WCHAR wmaterialname[256] = { 0L };
	int curshadertype;
	float curmetalcoef;
	float cursmoothcoef;
	float curlightscale[LIGHTNUMMAX];
	bool enableEmission = false;
	float emissiveScale = 1.0f;
	if (curmqomat) {
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, 
			curmqomat->GetName(), -1, wmaterialname, 256);
		curshadertype = curmqomat->GetShaderType();
		curmetalcoef = curmqomat->GetMetalCoef();
		cursmoothcoef = curmqomat->GetSmoothCoef();
		int litno;
		for (litno = 0; litno < LIGHTNUMMAX; litno++) {
			curlightscale[litno] = curmqomat->GetLightScale(litno);
		}
		enableEmission = curmqomat->GetEnableEmission();
		emissiveScale = curmqomat->GetEmissiveScale();
	}
	else {
		//全てのマテリアルに対して設定するボタンを押した場合
		wcscpy_s(wmaterialname, 256, L"(All)");
		curshadertype = -1;
		curmetalcoef = 0.250f;
		cursmoothcoef = 0.250f;
		int litno;
		for (litno = 0; litno < LIGHTNUMMAX; litno++) {
			curlightscale[litno] = 1.0f;
		}
		enableEmission = false;
		emissiveScale = 1.0f;
	}

	int lightsliderid[LIGHTNUMMAX] = {
		IDC_SL_LITSCALE1, IDC_SL_LITSCALE2, IDC_SL_LITSCALE3, IDC_SL_LITSCALE4,
		IDC_SL_LITSCALE5, IDC_SL_LITSCALE6, IDC_SL_LITSCALE7, IDC_SL_LITSCALE8
	};
	int lighttextid[LIGHTNUMMAX] = {
		IDC_STATIC_LIGHTSCALE1, IDC_STATIC_LIGHTSCALE2, IDC_STATIC_LIGHTSCALE3, IDC_STATIC_LIGHTSCALE4,
		IDC_STATIC_LIGHTSCALE5, IDC_STATIC_LIGHTSCALE6, IDC_STATIC_LIGHTSCALE7, IDC_STATIC_LIGHTSCALE8
	};


	//#######
	//Button
	//#######
	CheckShaderTypeParamsButton(hDlgWnd, curshadertype);


	//#######
	//Slider
	//#######
	int sliderpos = (int)(curmetalcoef * 100.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_METALCOEF), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_METALCOEF), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_METALCOEF), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

	sliderpos = (int)(cursmoothcoef * 100.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_SMOOTHCOEF), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_SMOOTHCOEF), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_SMOOTHCOEF), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

	int litno2;
	for (litno2 = 0; litno2 < LIGHTNUMMAX; litno2++) {
		sliderpos = (int)(curlightscale[litno2] * 100.0f);;
		SendMessage(GetDlgItem(hDlgWnd, lightsliderid[litno2]), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
		SendMessage(GetDlgItem(hDlgWnd, lightsliderid[litno2]), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)500);
		SendMessage(GetDlgItem(hDlgWnd, lightsliderid[litno2]), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);
	}

	sliderpos = (int)(emissiveScale * 100.0f);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SL_EMISCALE), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)0);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SL_EMISCALE), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)100);
	SendMessage(GetDlgItem(hDlgWnd, IDC_SL_EMISCALE), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);


	//#####
	//Text
	//#####
	WCHAR strdlg[256] = { 0L };
	swprintf_s(strdlg, 256, L"Material:%s", wmaterialname);
	SetDlgItemText(hDlgWnd, IDC_MATERIALNAME, strdlg);


	swprintf_s(strdlg, 256, L"MetalCoef %.2f", curmetalcoef);
	SetDlgItemText(hDlgWnd, IDC_STATIC_METALCOEF, strdlg);

	swprintf_s(strdlg, 256, L"SmoothCoef %.2f", cursmoothcoef);
	SetDlgItemText(hDlgWnd, IDC_STATIC_SMOOTHCOEF, strdlg);


	int litno3;
	for (litno3 = 0; litno3 < LIGHTNUMMAX; litno3++) {
		swprintf_s(strdlg, 256, L"LightScale%d %.2f", (litno3 + 1), curlightscale[litno3]);
		SetDlgItemText(hDlgWnd, lighttextid[litno3], strdlg);
	}

	swprintf_s(strdlg, 256, L"Emission:%.2f", emissiveScale);
	SetDlgItemText(hDlgWnd, IDC_CHECK_EMISSION, strdlg);


	//#########
	//CheckBox
	//#########
	if ((bool)enableEmission == true) {
		CheckDlgButton(hDlgWnd, IDC_CHECK_EMISSION, true);
	}
	else {
		CheckDlgButton(hDlgWnd, IDC_CHECK_EMISSION, false);
	}


	return 0;
}


int ShowModelWorldMatDlg()
{

	if (s_modelworldmatdlgwnd) {
		if (s_model) {
			SetModel2ModelWorldMatDlg(s_model);

			ShowWindow(s_modelworldmatdlgwnd, SW_SHOW);
			UpdateWindow(s_modelworldmatdlgwnd);

		}
	}

	return 0;
}

int ShowShaderTypeParamsDlg()
{

	if (s_shadertypeparamsdlgwnd) {
		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			CMQOMaterial* curmqomat = nullptr;
			if ((s_shadertypeparamsindex >= 0) && (s_shadertypeparamsindex < (materialnum + 1))) {
				int materialindex = s_shadertypeparamsindex - 1;
				if (materialindex >= 0) {
					curmqomat = s_model->GetMQOMaterialByIndex(materialindex);
				}
			}
			SetMaterial2ShaderTypeParamsDlg(curmqomat);

			ShowWindow(s_shadertypeparamsdlgwnd, SW_SHOW);
			UpdateWindow(s_shadertypeparamsdlgwnd);
		}
	}

	return 0;
}



int CreateMaterialRateWnd()
{

	//CCameraDollyDlg dlg(g_camEye);
	//dlg.DoModal();
	//g_camEye = dlg.GetCameraPos();

	HWND hDlgWnd = CreateDialogW((HMODULE)GetModuleHandle(NULL),
		//MAKEINTRESOURCE(IDD_MATERIALRATEDLG), g_mainhwnd, (DLGPROC)MaterialRateDlgProc);
		MAKEINTRESOURCE(IDD_MATERIALRATEDLG), s_3dwnd, (DLGPROC)MaterialRateDlgProc);
	if (hDlgWnd == NULL) {
		return 1;
	}
	s_materialratedlgwnd = hDlgWnd;
	ShowWindow(s_materialratedlgwnd, SW_HIDE);

	return 0;
}

int SetModel2MaterialRateDlg(CModel* srcmodel)
{
	if (srcmodel) {
		WCHAR strname[256] = { 0L };
		ZeroMemory(strname, sizeof(WCHAR) * 256);
		size_t namelen = wcslen(srcmodel->GetFileName());
		if (namelen <= 255) {
			wcscpy_s(strname, 256, srcmodel->GetFileName());
		}
		else {
			wcsncpy_s(strname, 256, srcmodel->GetFileName(), 255);
		}
		SetDlgItemTextW(s_materialratedlgwnd, IDC_STATICMODELNAME, strname);


		WCHAR strval[256] = { 0L };
		ChaVector4 materialdisprate = srcmodel->GetMaterialDispRate();

		swprintf_s(strval, 256, L"%.3f", materialdisprate.x);
		SetDlgItemTextW(s_materialratedlgwnd, IDC_EDIT_DIFFUSERATE, strval);
		swprintf_s(strval, 256, L"%.3f", materialdisprate.y);
		SetDlgItemTextW(s_materialratedlgwnd, IDC_EDIT_SPECULARRATE, strval);
		swprintf_s(strval, 256, L"%.3f", materialdisprate.z);
		SetDlgItemTextW(s_materialratedlgwnd, IDC_EDIT_EMISSIVERATE, strval);
		swprintf_s(strval, 256, L"%.3f", materialdisprate.w);
		SetDlgItemTextW(s_materialratedlgwnd, IDC_EDIT_AMBIENTRATE, strval);
	}

	return 0;

}

int ShowMaterialRateDlg()
{
	if (s_materialratedlgwnd) {
		if (s_model) {
			SetModel2MaterialRateDlg(s_model);

			ShowWindow(s_materialratedlgwnd, SW_SHOW);
			UpdateWindow(s_materialratedlgwnd);
		}

	}

	return 0;
}

int ShowCameraDollyDlg()
{

	GUIMenuSetVisible(-1, -1);

	std::vector<DOLLYELEM> vecdolly;
	vecdolly.clear();
	s_dollyhistorydlg.LoadDollyHistory(vecdolly);
	s_dollyhistorydlg.SetNames(vecdolly);
	s_dollyhistorydlg.ShowWindow(SW_SHOW);

	return 0;
}

int UpdateCameraPosAndTarget()
{
	//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
	//#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
	//#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

	ChaVector3 diffv;
	diffv = g_camEye - g_camtargetpos;
	g_camdist = (float)ChaVector3LengthDbl(&diffv);
	if (g_camdist >= 1e-4) {
		return 0;
	}
	else {
		_ASSERT(0);
		return 1;
	}

	SetCamera3DFromEyePos();
}

bool IsClickedSpriteButton()
{
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);


	//Camera rot, pan, dolly
	if (PickSpCam(ptCursor) != 0){
		return true;
	}


	//UndoRedo
	int pickundo = 0;
	pickundo = PickSpUndo(ptCursor);
	if (pickundo == PICK_UNDO) {
		return true;
	}
	else if (pickundo == PICK_REDO)
	{
		return true;
	}

	//IK Mode
	int pickikmodeflag = 0;
	pickikmodeflag = PickSpIkModeSW(ptCursor);
	if (pickikmodeflag == 1) {
		return true;
	}
	else if (pickikmodeflag == 2) {
		return true;
	}
	else if (pickikmodeflag == 3) {
		return true;
	}
	{
		//lod switch
		int picklodflag = 0;
		picklodflag = PickSpLODSW(ptCursor);
		if (picklodflag == 1) {
			return true;
		}
	}
	{
		//limiteul switch
		int picklimiteulflag = 0;
		picklimiteulflag = PickSpLimitEulSW(ptCursor);
		if (picklimiteulflag == 1) {
			return true;
		}
	}
	{
		//cameramode switch
		int pickcameramodeflag = 0;
		pickcameramodeflag = PickSpCameraModeSW(ptCursor);
		if (pickcameramodeflag == 1) {
			return true;
		}
	}
	{
		//camerainherit switch
		int pickcamerainheritflag = 0;
		pickcamerainheritflag = PickSpCameraInheritSW(ptCursor);
		if (pickcamerainheritflag == 1) {
			return true;
		}
	}
	{
		//wallscraping switch
		int pickscrapingflag = 0;
		pickscrapingflag = PickSpScrapingSW(ptCursor);
		if (pickscrapingflag == 1) {
			return true;
		}
	}

	//2023/02/04
	//Bake LimitedWorld-->World : currentmotion fullframe
	if (PickSpCpLW2W(ptCursor) != 0) {
		return true;
	}

	if (PickSpSmooth(ptCursor) != 0) {
		return true;
	}

	if (PickSpConstExe(ptCursor) != 0) {
		return true;
	}
	if (PickSpConstRefresh(ptCursor) != 0) {
		return true;
	}


	if (PickSpFrog2(ptCursor) != 0) {
		return true;
	}
	if (PickSpCopy(ptCursor) != 0) {
		return true;
	}
	if (PickSpSymCopy(ptCursor) != 0) {
		return true;
	}
	if (PickSpPaste(ptCursor) != 0) {
		return true;
	}
	if (PickSpCopyHistory(ptCursor) != 0) {
		return true;
	}

	if (PickSpInterpolate(ptCursor) != 0) {
		return true;
	}
	if (PickSpInit(ptCursor) != 0) {
		return true;
	}
	if (PickSpScaleInit(ptCursor) != 0) {
		return true;
	}
	if (PickSpProperty(ptCursor) != 0) {
		return true;
	}


	if (PickSpZeroFrame(ptCursor) != 0) {
		return true;
	}
	if (PickSpCameraDolly(ptCursor) != 0) {
		return true;
	}
	if (PickSpModelPosDir(ptCursor) != 0) {
		return true;
	}
	if (PickSpMaterialRate(ptCursor) != 0) {
		return true;
	}

	return false;

}

void InitRootSignature(RootSignature& rs)
{
	rs.Init(D3D12_FILTER_MIN_MAG_MIP_LINEAR,
		D3D12_TEXTURE_ADDRESS_MODE_WRAP,
		D3D12_TEXTURE_ADDRESS_MODE_WRAP,
		D3D12_TEXTURE_ADDRESS_MODE_WRAP);
}

void SetCamera3DFromEyePos()
{
	g_camera3D->SetNear(g_projnear);
	g_camera3D->SetFar(g_projfar);
	//g_camera3D->SetViewAngle(60.0f / 180.0f * (float)PI);
	g_camera3D->SetViewAngle(g_fovy);//2023/12/30
	Vector3 cameye = Vector3(g_camEye.x, g_camEye.y, g_camEye.z);
	g_camera3D->SetPosition(cameye);
	Vector3 target = Vector3(g_camtargetpos.x, g_camtargetpos.y, g_camtargetpos.z);
	g_camera3D->SetTarget(target);
	g_camera3D->SetUp(Vector3(g_cameraupdir.x, g_cameraupdir.y, g_cameraupdir.z));
	g_camera3D->SetWidth((float)g_graphicsEngine->GetFrameBufferWidth());//2023/11/20
	g_camera3D->SetHeight((float)g_graphicsEngine->GetFrameBufferHeight());//2023/11/20
	g_camera3D->Update();

	if (s_model) {
		s_matWorld = s_model->GetWorldMat();
	}
	else {
		s_matWorld.SetIdentity();
	}
	s_matView = ChaMatrix(g_camera3D->GetViewMatrix(false));
	s_matProj = ChaMatrix(g_camera3D->GetProjectionMatrix());
	s_matVP = s_matView * s_matProj;


//// camera for shadowmap
	if (s_model) {
		ChaVector3 dirright = ChaVector3(g_camera3D->GetRight());
		ChaVector3 dirup = ChaVector3(g_camera3D->GetUp());
		ChaVector3 dirforward = ChaVector3(g_camera3D->GetForward());
		ChaVector3 modelpos = ChaMatrixTraVec(s_model->GetWorldMat());
		ChaVector3 camdiff = g_camtargetpos - g_camEye;

		g_cameraShadow->Update();

		if ((g_shadowmap_slotno < 0) || (g_shadowmap_slotno >= SHADOWSLOTNUM)) {
			_ASSERT(0);
			g_shadowmap_slotno = 0;
		}

		ChaVector3 ldir;
		if ((g_shadowmap_lightdir[g_shadowmap_slotno] >= 1) && 
			(g_shadowmap_lightdir[g_shadowmap_slotno] <= 8)) {
			ChaVector3 dirz = ChaVector3(0.0f, 0.0f, 1.0f);
			ChaVector3 lightdir0, nlightdir0;
			lightdir0 = g_camEye - g_camtargetpos;
			ChaVector3Normalize(&nlightdir0, &lightdir0);
			bool rot180flag = false;
			float chkdot180 = ChaVector3Dot(&dirz, &nlightdir0);
			if (chkdot180 <= -0.9999f) {
				rot180flag = true;
			}
			else {
				rot180flag = false;
			}
			CQuaternion camrotq;
			camrotq.RotationArc(dirz, nlightdir0);


			ChaVector3 nlightdir;
			ChaVector3Normalize(&nlightdir, &(g_lightDir[g_lightSlot][g_shadowmap_lightdir[g_shadowmap_slotno] - 1]));//2024/01/04 -1
			ChaVector3 rotdir;
			if (g_lightDirWithView[g_lightSlot]) {//2024/01/04
				if (rot180flag == false) {
					camrotq.Rotate(&rotdir, nlightdir);
				}
				else {
					rotdir = ChaVector3(-nlightdir.x, nlightdir.y, -nlightdir.z);
				}
			}
			else {
				rotdir = ChaVector3(-nlightdir.x, nlightdir.y, -nlightdir.z);
			}
			ChaVector3Normalize(&ldir, &rotdir);
		}
		else {
			ChaVector3Normalize(&ldir, &(g_lightDir[g_lightSlot][0]));
		}
	

		ChaVector3 targetshadow;
		targetshadow = g_camtargetpos;

		ChaVector3 lpos;
		//lpos = g_camEye + ldir * (g_shadowmap_distscale * g_shadowmap_projscale);
		lpos = g_camtargetpos - ldir * (ChaVector3LengthDbl(&camdiff) * 
			g_shadowmap_distscale[g_shadowmap_slotno] * g_shadowmap_projscale[g_shadowmap_slotno]);
		lpos.y = targetshadow.y + g_shadowmap_plusup[g_shadowmap_slotno] * g_shadowmap_projscale[g_shadowmap_slotno];

		g_cameraShadow->SetPosition(Vector3(lpos.x, lpos.y, lpos.z));
		g_cameraShadow->SetTarget(Vector3(targetshadow.x, targetshadow.y, targetshadow.z));

		g_cameraShadow->SetNear(g_shadowmap_near[g_shadowmap_slotno] * g_shadowmap_projscale[g_shadowmap_slotno]);
		g_cameraShadow->SetFar(g_shadowmap_far[g_shadowmap_slotno] * g_shadowmap_projscale[g_shadowmap_slotno]);
		g_cameraShadow->SetViewAngle(g_shadowmap_fov[g_shadowmap_slotno] / 180.0f * (float)PI);
		g_cameraShadow->SetUp(Vector3(0.0f, 1.0f, 0.0f));
		g_cameraShadow->SetWidth((float)SHADOWMAP_SIZE);//2023/12/11 RenderingEngin::InitShadowMapでのバッファのサイズに合わせる
		g_cameraShadow->SetHeight((float)SHADOWMAP_SIZE);//2023/12/11 RenderingEngin::InitShadowMapでのバッファのサイズに合わせる
		g_cameraShadow->Update();
	}
}

int CreateSprites()
{
	char cpath[MAX_PATH];
	char cfxpath[MAX_PATH];

	char cbasedir[MAX_PATH] = { 0 };
	WideCharToMultiByte(CP_ACP, 0, g_basedir, -1, cbasedir, MAX_PATH, NULL, NULL);

	strcpy_s(cpath, MAX_PATH, cbasedir);
	char* clasten = 0;
	char* clast2en = 0;
	clasten = strrchr(cpath, '\\');
	if (!clasten) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	*clasten = 0;
	clast2en = strrchr(cpath, '\\');
	if (!clast2en) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	*clast2en = 0;
	strcat_s(cpath, MAX_PATH, "\\Media\\");


	SetCurrentDirectoryW(g_basedir);


	SpriteInitData spriteinitdata;
	spriteinitdata.m_width = 256;//仮　ファイルから読込時は上書きされる
	spriteinitdata.m_height = 256;//仮　ファイルから読込時は上書きされる
	spriteinitdata.m_colorBufferFormat[0] = DXGI_FORMAT_R32G32B32A32_FLOAT;

	bool screenvertexflag = true;//!!!!!!!!!!!!



	//strcpy_s(cfilepath, MAX_PATH, cpath);
	//strcat_s(cfilepath, MAX_PATH, "MameMedia\\bonecircle.dds");
	//spriteinitdata.m_ddsFilePath[0] = cfilepath;
	//s_bcircle.Init(spriteinitdata, screenvertexflag);
	//spriteinitdata.m_ddsFilePath[0] = 0;



	/////

	
	WCHAR mpath[MAX_PATH];
	WCHAR filepath[MAX_PATH];
	WCHAR* lasten;
	WCHAR* last2en;
	wcscpy_s(mpath, MAX_PATH, g_basedir);
	lasten = 0;
	last2en = 0;
	lasten = wcsrchr(mpath, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	*lasten = 0L;
	last2en = wcsrchr(mpath, TEXT('\\'));
	if (!last2en) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	*last2en = 0L;
	wcscat_s(mpath, MAX_PATH, L"\\Media\\");


	s_undosprite.CreateSprites(mpath);
	s_fpssprite.CreateSprites(mpath);


	strcpy_s(cfxpath, MAX_PATH, cpath);
	strcat_s(cfxpath, MAX_PATH, "Shader\\preset\\InstancedSprite.fx");//!!!!!!!! Set Shader
	spriteinitdata.m_fxFilePath = cfxpath;
	//spriteinitdata.m_alphaBlendMode = AlphaBlendMode_Add;
	spriteinitdata.m_alphaBlendMode = AlphaBlendMode_Trans;


	wcscpy_s(filepath, MAX_PATH, mpath);
	//wcscat_s(filepath, MAX_PATH, L"MameMedia\\JointMark_1.png");
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\boneimage.bmp");//2024/01/12
	s_spritetex0 = new Texture();
	s_spritetex0->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex0;
	s_bcircle.Init(spriteinitdata);//InstancedSprite

	
	strcpy_s(cfxpath, MAX_PATH, cpath);
	strcat_s(cfxpath, MAX_PATH, "Shader\\preset\\sprite.fx");//!!!!!!!! Set Shader
	spriteinitdata.m_fxFilePath = cfxpath;
	spriteinitdata.m_alphaBlendMode = AlphaBlendMode_Trans;

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Undo_1.png");
	s_spritetex1 = new Texture();
	s_spritetex1->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex1;
	s_spundo[0].sprite.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Redo_1.png");
	s_spritetex2 = new Texture();
	s_spritetex2->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex2;
	s_spundo[1].sprite.Init(spriteinitdata, screenvertexflag);

	

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Undo_1.png");
	s_spritetex3 = new Texture();
	s_spritetex3->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex3;
	s_spundo[0].sprite.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Redo_1.png");
	s_spritetex4 = new Texture();
	s_spritetex4->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex4;
	s_spundo[1].sprite.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\X.gif");
	s_spritetex5 = new Texture();
	s_spritetex5->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex5;
	s_spaxis[0].sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Y.gif");
	s_spritetex6 = new Texture();
	s_spritetex6->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex6;
	s_spaxis[1].sprite.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Z.gif");
	s_spritetex7 = new Texture();
	s_spritetex7->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex7;
	s_spaxis[2].sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\RefPosON.gif");
	s_spritetex8 = new Texture();
	s_spritetex8->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex8;
	s_splod.spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\RefPosOFF.gif");
	s_spritetex9 = new Texture();
	s_spritetex9->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex9;
	s_splod.spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\LimitEul_ON.png");
	s_spritetex10 = new Texture();
	s_spritetex10->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex10;
	s_splimiteul.spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\LimitEul_OFF.png");
	s_spritetex11 = new Texture();
	s_spritetex11->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex11;
	s_splimiteul.spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CamAnimON.png");
	s_spritetex12 = new Texture();
	s_spritetex12->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex12;
	s_spcameramode.spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CamAnimOFF.png");
	s_spritetex13 = new Texture();
	s_spritetex13->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex13;
	s_spcameramode.spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CameraInherit_All.png");
	s_spritetex14 = new Texture();
	s_spritetex14->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex14;
	s_spcamerainherit.sprite1.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CameraInherit_CancelNull1.png");
	s_spritetex15 = new Texture();
	s_spritetex15->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex15;
	s_spcamerainherit.sprite2.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CameraInherit_CancelNull2.png");
	s_spritetex16 = new Texture();
	s_spritetex16->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex16;
	s_spcamerainherit.sprite3.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\WallScrapingIK_ON.png");
	s_spritetex17 = new Texture();
	s_spritetex17->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex17;
	s_spscraping.spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\WallScrapingIK_OFF.png");
	s_spritetex18 = new Texture();
	s_spritetex18->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex18;
	s_spscraping.spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKRot2ON.gif");
	s_spritetex19 = new Texture();
	s_spritetex19->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex19;
	s_spikmodesw[0].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKRot2OFF.gif");
	s_spritetex20 = new Texture();
	s_spritetex20->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex20;
	s_spikmodesw[0].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKMove2ON.gif");
	s_spritetex21 = new Texture();
	s_spritetex21->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex21;
	s_spikmodesw[1].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKMove2OFF.gif");
	s_spritetex22 = new Texture();
	s_spritetex22->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex22;
	s_spikmodesw[1].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKScale2ON.gif");
	s_spritetex23 = new Texture();
	s_spritetex23->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex23;
	s_spikmodesw[2].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKScale2OFF.gif");
	s_spritetex24 = new Texture();
	s_spritetex24->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex24;
	s_spikmodesw[2].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_CameraAndIK140ON.png");
	s_spritetex25 = new Texture();
	s_spritetex25->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex25;
	s_spguisw[SPGUISW_CAMERA_AND_IK].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DispAndLimits140ON.png");
	s_spritetex26 = new Texture();
	s_spritetex26->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex26;
	s_spguisw[SPGUISW_DISP_AND_LIMITS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BrushParams140ON.png");
	s_spritetex27 = new Texture();
	s_spritetex27->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex27;
	s_spguisw[SPGUISW_BRUSHPARAMS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BulletPhysics140ON.png");
	s_spritetex28 = new Texture();
	s_spritetex28->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex28;
	s_spguisw[SPGUISW_BULLETPHYSICS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_LOD140ON.png");
	s_spritetex29 = new Texture();
	s_spritetex29->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex29;
	s_spguisw[SPGUISW_PROJ_AND_LOD].spriteON.Init(spriteinitdata, screenvertexflag);
	

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_CameraAndIK140OFF.png");
	s_spritetex30 = new Texture();
	s_spritetex30->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex30;
	s_spguisw[SPGUISW_CAMERA_AND_IK].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DispAndLimits140OFF.png");
	s_spritetex31 = new Texture();
	s_spritetex31->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex31;
	s_spguisw[SPGUISW_DISP_AND_LIMITS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BrushParams140OFF.png");
	s_spritetex32 = new Texture();
	s_spritetex32->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex32;
	s_spguisw[SPGUISW_BRUSHPARAMS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BulletPhysics140OFF.png");
	s_spritetex33 = new Texture();
	s_spritetex33->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex33;
	s_spguisw[SPGUISW_BULLETPHYSICS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_LOD140OFF.png");
	s_spritetex34 = new Texture();
	s_spritetex34->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex34;
	s_spguisw[SPGUISW_PROJ_AND_LOD].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Lights140ON.png");
	s_spritetex35 = new Texture();
	s_spritetex35->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex35;
	s_spdispsw[SPDISPSW_LIGHTS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DispGroup140ON.png");
	s_spritetex36 = new Texture();
	s_spritetex36->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex36;
	s_spdispsw[SPDISPSW_DISPGROUP].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_LaterTransparent140ON.png");
	s_spritetex37 = new Texture();
	s_spritetex37->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex37;
	s_spdispsw[SPDISPSW_LATERTRANSPARENT].spriteON.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Shader140ON.png");
	s_spritetex37_1 = new Texture();
	s_spritetex37_1->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex37_1;
	s_spdispsw[SPDISPSW_SHADERTYPE].spriteON.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Shadow140ON.png");
	s_spritetex80 = new Texture();
	s_spritetex80->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex80;
	s_spdispsw[SPDISPSW_SHADOWPARAMS].spriteON.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Lights140OFF.png");
	s_spritetex38 = new Texture();
	s_spritetex38->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex38;
	s_spdispsw[SPDISPSW_LIGHTS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DispGroup140OFF.png");
	s_spritetex39 = new Texture();
	s_spritetex39->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex39;
	s_spdispsw[SPDISPSW_DISPGROUP].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_LaterTransparent140OFF.png");
	s_spritetex40 = new Texture();
	s_spritetex40->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex40;
	s_spdispsw[SPDISPSW_LATERTRANSPARENT].spriteOFF.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Shader140OFF.png");
	s_spritetex40_1 = new Texture();
	s_spritetex40_1->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex40_1;
	s_spdispsw[SPDISPSW_SHADERTYPE].spriteOFF.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Shadow140OFF.png");
	s_spritetex81 = new Texture();
	s_spritetex81->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex81;
	s_spdispsw[SPDISPSW_SHADOWPARAMS].spriteOFF.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuRigid140ON.png");
	s_spritetex41 = new Texture();
	s_spritetex41->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex41;
	s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuImpulse140ON.png");
	s_spritetex42 = new Texture();
	s_spritetex42->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex42;
	s_sprigidsw[SPRIGIDSW_IMPULSE].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuGP140ON.png");
	s_spritetex43 = new Texture();
	s_spritetex43->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex43;
	s_sprigidsw[SPRIGIDSW_GROUNDPLANE].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuDamp140ON.png");
	s_spritetex44 = new Texture();
	s_spritetex44->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex44;
	s_sprigidsw[SPRIGIDSW_DAMPANIM].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuRigid140OFF.png");
	s_spritetex45 = new Texture();
	s_spritetex45->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex45;
	s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuImpulse140OFF.png");
	s_spritetex46 = new Texture();
	s_spritetex46->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex46;
	s_sprigidsw[SPRIGIDSW_IMPULSE].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuGP140OFF.png");
	s_spritetex47 = new Texture();
	s_spritetex47->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex47;
	s_sprigidsw[SPRIGIDSW_GROUNDPLANE].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuDamp140OFF.png");
	s_spritetex48 = new Texture();
	s_spritetex48->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex48;
	s_sprigidsw[SPRIGIDSW_DAMPANIM].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlateRetarget140ON.png");
	s_spritetex49 = new Texture();
	s_spritetex49->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex49;
	s_spretargetsw[SPRETARGETSW_RETARGET].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlateRetarget140OFF.png");
	s_spritetex50 = new Texture();
	s_spritetex50->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex50;
	s_spretargetsw[SPRETARGETSW_RETARGET].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlateLimitEuler140ON.png");
	s_spritetex51 = new Texture();
	s_spritetex51->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex51;
	s_spretargetsw[SPRETARGETSW_LIMITEULER].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlateLimitEuler140OFF.png");
	s_spritetex52 = new Texture();
	s_spritetex52->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex52;
	s_spretargetsw[SPRETARGETSW_LIMITEULER].spriteOFF.Init(spriteinitdata, screenvertexflag);
	

	//{
	//	int aimno;
	//	for (aimno = 0; aimno < SPAIMBARNUM; aimno++) {
	//		strcpy_s(filepath, MAX_PATH, path);
	//		strcat_s(filepath, MAX_PATH, "MameMedia\\GUIPlateAim140ON.png");
	//		spriteinitdata.m_wicFilePath[0] = filepath; 
	//		s_spaimbar[aimno].spriteON.Init(spriteinitdata, screenvertexflag);
	//
	//		strcpy_s(filepath, MAX_PATH, path);
	//		strcat_s(filepath, MAX_PATH, "MameMedia\\GUIPlateAim140OFF.png");
	//		spriteinitdata.m_wicFilePath[0] = filepath; 
	//		s_spaimbar[aimno].spriteOFF.Init(spriteinitdata, screenvertexflag);
	//	}
	//}
	//{
	//	int aimno;
	//	for (aimno = 0; aimno < SPMENU_MAX; aimno++) {
	//		strcpy_s(filepath, MAX_PATH, path);
	//		strcat_s(filepath, MAX_PATH, "MameMedia\\GUIPlateAim140ON.png");
	//		spriteinitdata.m_wicFilePath[0] = filepath; 
	//		s_spmenuaimbar[aimno].spriteON.Init(spriteinitdata, screenvertexflag);
	//		
	//		strcpy_s(filepath, MAX_PATH, path);
	//		strcat_s(filepath, MAX_PATH, "MameMedia\\GUIPlateAim140OFF.png");
	//		spriteinitdata.m_wicFilePath[0] = filepath; 
	//		s_spmenuaimbar[aimno].spriteOFF.Init(spriteinitdata, screenvertexflag);
	//	}
	//}
	
	{
		wcscpy_s(filepath, MAX_PATH, mpath);
		wcscat_s(filepath, MAX_PATH, L"MameMedia\\button101_Select.tif");
		s_spritetex53 = new Texture();
		s_spritetex53->InitFromWICFile(filepath);
		spriteinitdata.m_textures[0] = s_spritetex53;
		s_spsel3d.spriteON.Init(spriteinitdata, screenvertexflag);
		
		wcscpy_s(filepath, MAX_PATH, mpath);
		wcscat_s(filepath, MAX_PATH, L"MameMedia\\button101_UnSelect.tif");
		s_spritetex54 = new Texture();
		s_spritetex54->InitFromWICFile(filepath);
		spriteinitdata.m_textures[0] = s_spritetex54;
		s_spsel3d.spriteOFF.Init(spriteinitdata, screenvertexflag);
	}
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\cam_i.gif");
	s_spritetex55 = new Texture();
	s_spritetex55->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex55;
	s_spcam[SPR_CAM_I].sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\cam_kai.gif");
	s_spritetex56 = new Texture();
	s_spritetex56->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex56;
	s_spcam[SPR_CAM_KAI].sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\cam_kaku.gif");
	s_spritetex57 = new Texture();
	s_spritetex57->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex57;
	s_spcam[SPR_CAM_KAKU].sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\RigOFF.gif");
	s_spritetex58 = new Texture();
	s_spritetex58->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex58;
	s_sprig[SPRIG_INACTIVE].sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\RigON.gif");
	s_spritetex59 = new Texture();
	s_spritetex59->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex59;
	s_sprig[SPRIG_ACTIVE].sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\img_l105.png");
	s_spritetex60 = new Texture();
	s_spritetex60->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex60;
	s_spmousehere.sprite.Init(spriteinitdata, screenvertexflag);
	

	{
		WCHAR pngpath[MAX_PATH];
		swprintf_s(pngpath, MAX_PATH, L"%simg_l105.png", mpath);
		//swprintf_s(bmppath, MAX_PATH, L"%simg_l105.bmp", mpath);
		//g_mouseherebmp = (HBITMAP)::LoadImage(GetModuleHandle(NULL), bmppath, IMAGE_BITMAP, 52, 50, LR_LOADFROMFILE);
		//_ASSERT(g_mouseherebmp);
		//g_tranbmp = 0xFF000000;
		g_mousehereimage = new Gdiplus::Image(pngpath);
		if (!g_mousehereimage) {
			_ASSERT(0);
			PostQuitMessage(1);
			return S_FALSE;
		}
	}
	
	{
		WCHAR pngpath[MAX_PATH];
		swprintf_s(pngpath, MAX_PATH, L"%sMenuAimBar140.png", mpath);
		//swprintf_s(bmppath, MAX_PATH, L"%simg_l105.bmp", mpath);
		//g_mouseherebmp = (HBITMAP)::LoadImage(GetModuleHandle(NULL), bmppath, IMAGE_BITMAP, 52, 50, LR_LOADFROMFILE);
		//_ASSERT(g_mouseherebmp);
		//g_tranbmp = 0xFF000000;
		g_menuaimbarimage = new Gdiplus::Image(pngpath);
		if (!g_menuaimbarimage) {
			_ASSERT(0);
			PostQuitMessage(1);
			return S_FALSE;
		}
	}
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\img_ret2prev.png");
	s_spritetex61 = new Texture();
	s_spritetex61->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex61;
	s_spret2prev.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\img_ret2prev2.png");
	s_spritetex62 = new Texture();
	s_spritetex62->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex62;
	s_spret2prev2.sprite.Init(spriteinitdata, screenvertexflag);
	
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\BakeLW2W.png");
	s_spritetex63 = new Texture();
	s_spritetex63->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex63;
	s_spcplw2w.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\SmoothFilter.png");
	s_spritetex64 = new Texture();
	s_spritetex64->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex64;
	s_spsmooth.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Constraint_Execute.png");
	s_spritetex65 = new Texture();
	s_spritetex65->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex65;
	s_spconstexe.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Constraint_refresh.png");
	s_spritetex66 = new Texture();
	s_spritetex66->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex66;
	s_spconstrefresh.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CopyButton.gif");
	s_spritetex67 = new Texture();
	s_spritetex67->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex67;
	s_spcopy.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\SymCopyButton3.png");
	s_spritetex68 = new Texture();
	s_spritetex68->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex68;
	s_spsymcopy.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\PasteButton.gif");
	s_spritetex69 = new Texture();
	s_spritetex69->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex69;
	s_sppaste.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CopyHistoryButton.gif");
	s_spritetex70 = new Texture();
	s_spritetex70->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex70;
	s_spcopyhistory.sprite.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\InterpolateButton.png");
	s_spritetex71 = new Texture();
	s_spritetex71->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex71;
	s_spinterpolate.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\InitButton.png");
	s_spritetex72 = new Texture();
	s_spritetex72->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex72;
	s_spinit.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\ScaleInitButton.png");
	s_spritetex73 = new Texture();
	s_spritetex73->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex73;
	s_spscaleinit.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\PropertyButton.png");
	s_spritetex74 = new Texture();
	s_spritetex74->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex74;
	s_spproperty.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Edit0FrameButton.png");
	s_spritetex75 = new Texture();
	s_spritetex75->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex75;
	s_spzeroframe.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CameraDollyButton.png");
	s_spritetex76 = new Texture();
	s_spritetex76->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex76;
	s_spcameradolly.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\ModelPosDirButton.png");
	s_spritetex77 = new Texture();
	s_spritetex77->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex77;
	s_spmodelposdir.sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\MaterialRateButton.png");
	s_spritetex78 = new Texture();
	s_spritetex78->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex78;
	s_spmaterialrate.sprite.Init(spriteinitdata, screenvertexflag);
	

	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\MouseCenterButtonON.png");
	s_spritetex79 = new Texture();
	s_spritetex79->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex79;
	s_mousecenteron.sprite.Init(spriteinitdata, screenvertexflag);
	
	return 0;
}

void DestroySprites()
{
	if (s_spritetex0) {
		delete s_spritetex0;
		s_spritetex0 = 0;
	}
	if (s_spritetex1) {
		delete s_spritetex1;
		s_spritetex1 = 0;
	}
	if (s_spritetex2) {
		delete s_spritetex2;
		s_spritetex2 = 0;
	}
	if (s_spritetex3) {
		delete s_spritetex3;
		s_spritetex3 = 0;
	}
	if (s_spritetex4) {
		delete s_spritetex4;
		s_spritetex4 = 0;
	}
	if (s_spritetex5) {
		delete s_spritetex5;
		s_spritetex5 = 0;
	}
	if (s_spritetex6) {
		delete s_spritetex6;
		s_spritetex6 = 0;
	}
	if (s_spritetex7) {
		delete s_spritetex7;
		s_spritetex7 = 0;
	}
	if (s_spritetex8) {
		delete s_spritetex8;
		s_spritetex8 = 0;
	}
	if (s_spritetex9) {
		delete s_spritetex9;
		s_spritetex9 = 0;
	}
	if (s_spritetex10) {
		delete s_spritetex10;
		s_spritetex10 = 0;
	}

	if (s_spritetex11) {
		delete s_spritetex11;
		s_spritetex11 = 0;
	}
	if (s_spritetex12) {
		delete s_spritetex12;
		s_spritetex12 = 0;
	}
	if (s_spritetex13) {
		delete s_spritetex13;
		s_spritetex13 = 0;
	}
	if (s_spritetex14) {
		delete s_spritetex14;
		s_spritetex14 = 0;
	}
	if (s_spritetex15) {
		delete s_spritetex15;
		s_spritetex15 = 0;
	}
	if (s_spritetex16) {
		delete s_spritetex16;
		s_spritetex16 = 0;
	}
	if (s_spritetex17) {
		delete s_spritetex17;
		s_spritetex17 = 0;
	}
	if (s_spritetex18) {
		delete s_spritetex18;
		s_spritetex18 = 0;
	}
	if (s_spritetex19) {
		delete s_spritetex19;
		s_spritetex19 = 0;
	}
	if (s_spritetex20) {
		delete s_spritetex10;
		s_spritetex10 = 0;
	}

	if (s_spritetex21) {
		delete s_spritetex21;
		s_spritetex21 = 0;
	}
	if (s_spritetex22) {
		delete s_spritetex22;
		s_spritetex22 = 0;
	}
	if (s_spritetex23) {
		delete s_spritetex23;
		s_spritetex23 = 0;
	}
	if (s_spritetex24) {
		delete s_spritetex24;
		s_spritetex24 = 0;
	}
	if (s_spritetex25) {
		delete s_spritetex25;
		s_spritetex25 = 0;
	}
	if (s_spritetex26) {
		delete s_spritetex26;
		s_spritetex26 = 0;
	}
	if (s_spritetex27) {
		delete s_spritetex27;
		s_spritetex27 = 0;
	}
	if (s_spritetex28) {
		delete s_spritetex28;
		s_spritetex28 = 0;
	}
	if (s_spritetex29) {
		delete s_spritetex29;
		s_spritetex29 = 0;
	}
	if (s_spritetex30) {
		delete s_spritetex30;
		s_spritetex30 = 0;
	}

	if (s_spritetex31) {
		delete s_spritetex31;
		s_spritetex31 = 0;
	}
	if (s_spritetex32) {
		delete s_spritetex32;
		s_spritetex32 = 0;
	}
	if (s_spritetex33) {
		delete s_spritetex33;
		s_spritetex33 = 0;
	}
	if (s_spritetex34) {
		delete s_spritetex34;
		s_spritetex34 = 0;
	}
	if (s_spritetex35) {
		delete s_spritetex35;
		s_spritetex35 = 0;
	}
	if (s_spritetex36) {
		delete s_spritetex36;
		s_spritetex36 = 0;
	}
	if (s_spritetex37) {
		delete s_spritetex37;
		s_spritetex37 = 0;
	}
	if (s_spritetex37_1) {
		delete s_spritetex37_1;
		s_spritetex37_1 = 0;
	}
	if (s_spritetex38) {
		delete s_spritetex38;
		s_spritetex38 = 0;
	}
	if (s_spritetex39) {
		delete s_spritetex39;
		s_spritetex39 = 0;
	}
	if (s_spritetex40) {
		delete s_spritetex40;
		s_spritetex40 = 0;
	}
	if (s_spritetex40_1) {
		delete s_spritetex40_1;
		s_spritetex40_1 = 0;
	}

	
	if (s_spritetex41) {
		delete s_spritetex41;
		s_spritetex41 = 0;
	}
	if (s_spritetex42) {
		delete s_spritetex42;
		s_spritetex42 = 0;
	}
	if (s_spritetex43) {
		delete s_spritetex43;
		s_spritetex43 = 0;
	}
	if (s_spritetex44) {
		delete s_spritetex44;
		s_spritetex44 = 0;
	}
	if (s_spritetex45) {
		delete s_spritetex45;
		s_spritetex45 = 0;
	}
	if (s_spritetex46) {
		delete s_spritetex46;
		s_spritetex46 = 0;
	}
	if (s_spritetex47) {
		delete s_spritetex47;
		s_spritetex47 = 0;
	}
	if (s_spritetex48) {
		delete s_spritetex48;
		s_spritetex48 = 0;
	}
	if (s_spritetex49) {
		delete s_spritetex49;
		s_spritetex49 = 0;
	}
	if (s_spritetex50) {
		delete s_spritetex50;
		s_spritetex50 = 0;
	}


	if (s_spritetex51) {
		delete s_spritetex51;
		s_spritetex51 = 0;
	}
	if (s_spritetex52) {
		delete s_spritetex52;
		s_spritetex52 = 0;
	}
	if (s_spritetex53) {
		delete s_spritetex53;
		s_spritetex53 = 0;
	}
	if (s_spritetex54) {
		delete s_spritetex54;
		s_spritetex54 = 0;
	}
	if (s_spritetex55) {
		delete s_spritetex55;
		s_spritetex55 = 0;
	}
	if (s_spritetex56) {
		delete s_spritetex56;
		s_spritetex56 = 0;
	}
	if (s_spritetex57) {
		delete s_spritetex57;
		s_spritetex57 = 0;
	}
	if (s_spritetex58) {
		delete s_spritetex58;
		s_spritetex58 = 0;
	}
	if (s_spritetex59) {
		delete s_spritetex59;
		s_spritetex59 = 0;
	}
	if (s_spritetex60) {
		delete s_spritetex60;
		s_spritetex60 = 0;
	}


	if (s_spritetex61) {
		delete s_spritetex61;
		s_spritetex61 = 0;
	}
	if (s_spritetex62) {
		delete s_spritetex62;
		s_spritetex62 = 0;
	}
	if (s_spritetex63) {
		delete s_spritetex63;
		s_spritetex63 = 0;
	}
	if (s_spritetex64) {
		delete s_spritetex64;
		s_spritetex64 = 0;
	}
	if (s_spritetex65) {
		delete s_spritetex65;
		s_spritetex65 = 0;
	}
	if (s_spritetex66) {
		delete s_spritetex66;
		s_spritetex66 = 0;
	}
	if (s_spritetex67) {
		delete s_spritetex67;
		s_spritetex67 = 0;
	}
	if (s_spritetex68) {
		delete s_spritetex68;
		s_spritetex68 = 0;
	}
	if (s_spritetex69) {
		delete s_spritetex69;
		s_spritetex69 = 0;
	}
	if (s_spritetex70) {
		delete s_spritetex70;
		s_spritetex70 = 0;
	}



	if (s_spritetex71) {
		delete s_spritetex71;
		s_spritetex71 = 0;
	}
	if (s_spritetex72) {
		delete s_spritetex72;
		s_spritetex72 = 0;
	}
	if (s_spritetex73) {
		delete s_spritetex73;
		s_spritetex73 = 0;
	}
	if (s_spritetex74) {
		delete s_spritetex74;
		s_spritetex74 = 0;
	}
	if (s_spritetex75) {
		delete s_spritetex75;
		s_spritetex75 = 0;
	}
	if (s_spritetex76) {
		delete s_spritetex76;
		s_spritetex76 = 0;
	}
	if (s_spritetex77) {
		delete s_spritetex77;
		s_spritetex77 = 0;
	}
	if (s_spritetex78) {
		delete s_spritetex78;
		s_spritetex78 = 0;
	}
	if (s_spritetex79) {
		delete s_spritetex79;
		s_spritetex79 = 0;
	}
	if (s_spritetex80) {
		delete s_spritetex80;
		s_spritetex80 = 0;
	}
	if (s_spritetex81) {
		delete s_spritetex81;
		s_spritetex81 = 0;
	}


}


///////////////////////////////////////////////////////////////////
// ウィンドウの初期化。
///////////////////////////////////////////////////////////////////
RECT InitWindow(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPWSTR lpCmdLine, int nCmdShow, const TCHAR* appName,
	HWND srcparentwnd,
	int srcposx, int srcposy,
	int srcwidth, int srcheight)
{
	//ウィンドウクラスのパラメータを設定(単なる構造体の変数の初期化です。)
	WNDCLASSEX wc =
	{
		sizeof(WNDCLASSEX),		//構造体のサイズ。
		//CS_CLASSDC,				//ウィンドウのスタイル。
		CS_CLASSDC | CS_DBLCLKS,
		//ここの指定でスクロールバーをつけたりできるが、ゲームでは不要なのでCS_CLASSDCでよい。
		//MsgProc,				//メッセージプロシージャ(後述)
		//srcmsgproc,
		AppMsgProc,
		0,						//0でいい。
		0,						//0でいい。
		//GetModuleHandle(NULL),	//このクラスのためのウインドウプロシージャがあるインスタンスハンドル。
		hInstance,
		//何も気にしなくてよい。
		NULL,					//アイコンのハンドル。アイコンを変えたい場合ここを変更する。とりあえずこれでいい。
		//NULL,					//マウスカーソルのハンドル。NULLの場合はデフォルト。
		LoadCursor(nullptr, IDC_ARROW),
		//NULL,					//ウィンドウの背景色。NULLの場合はデフォルト。
		//(HBRUSH)GetStockObject(BLACK_BRUSH),
		//(HBRUSH)GetStockObject(GRAY_BRUSH),
		NULL,
		NULL,					//メニュー名。NULLでいい。
		appName,				//ウィンドウクラスに付ける名前。
		NULL					//NULLでいい。
	};
	//ウィンドウクラスの登録。
	RegisterClassEx(&wc);

	HMENU hMenu = NULL;
	LONG winstyle = WS_OVERLAPPEDWINDOW;
	winstyle &= ~WS_CAPTION;
	winstyle &= ~WS_THICKFRAME;
	winstyle |= WS_CHILD;
	//LONG winstyle = WS_CHILD;

	RECT rc;
	SetRect(&rc, 0, 0, srcwidth, srcheight);
	AdjustWindowRect(&rc, winstyle, (hMenu) ? true : false);
	//s_mainwidth = rc.right - rc.left;
	//s_mainheight = rc.bottom - rc.top;
	//s_bufwidth = rc.right - rc.left;
	//s_bufheight = rc.bottom - rc.top;


	// ウィンドウの作成。
	g_hWnd = CreateWindow(
		appName,				//使用するウィンドウクラスの名前。
		//先ほど作成したウィンドウクラスと同じ名前にする。
		appName,				//ウィンドウの名前。ウィンドウクラスの名前と別名でもよい。
		//WS_OVERLAPPEDWINDOW,	//ウィンドウスタイル。ゲームでは基本的にWS_OVERLAPPEDWINDOWでいい、
		winstyle,
		srcposx,						//ウィンドウの初期X座標。
		srcposy,						//ウィンドウの初期Y座標。
		//s_mainwidth,			//ウィンドウの幅。
		//s_mainheight,			//ウィンドウの高さ。
		(rc.right - rc.left),
		(rc.bottom - rc.top),
		//srcwidth,
		//srcheight,
		srcparentwnd,			//親ウィンドウ。ゲームでは基本的にNULLでいい。
		NULL,					//メニュー。今はNULLでいい。
		hInstance,				//アプリケーションのインスタンス。
		NULL
	);
	if (!g_hWnd) {
		_ASSERT(0);
		::MessageBox(g_mainhwnd, L"ウインドウの作成でエラー.アプリを終了します.", L"CreateWindow Error!!!", MB_OK);
		abort();
	}


	ShowWindow(g_hWnd, nCmdShow);

	return rc;
}


//ゲームの初期化。
RECT InitGame(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow, const TCHAR* appName,
	HWND srcparentwnd,
	int srcposx, int srcposy,
	int srcwidth, int srcheight)
{
	//ウィンドウを初期化。
	RECT rc = InitWindow(hInstance, hPrevInstance, lpCmdLine, nCmdShow, appName,
		srcparentwnd,
		srcposx, srcposy,
		srcwidth, srcheight);
	//TKエンジンの初期化。
	g_engine = new TkEngine;
	g_engine->Init(g_hWnd, srcwidth, srcheight);

	return rc;
}
//ウィンドウメッセージをディスパッチ。falseが返ってきたら、ゲーム終了。
bool DispatchWindowMessage()
{
	MSG msg = { 0 };
	while (WM_QUIT != msg.message) {
		//ウィンドウからのメッセージを受け取る。
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else {
			//ウィンドウメッセージが空になった。
			break;
		}
	}
	return msg.message != WM_QUIT;
}

int OnCreateDevice()
{
	CalcTotalBound();
	
	
	//CallF(GetShaderHandle(), return S_FALSE);
	

	if (!g_texbank) {
		g_texbank = new CTexBank(s_pdev);
		if (!g_texbank) {
			_ASSERT(0);
			PostQuitMessage(1);
			return 0;
		}
	}
	CreateSprites();
	SetSpParams();




	s_select = new CModel();
	if (!s_select) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_select->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\select_2.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_select->MakeDispObj(), return S_FALSE;);
	
	s_matred = s_select->GetMQOMaterialByName("matred");
	if (!s_matred) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_ringred = s_select->GetMQOMaterialByName("ringred");
	if (!s_ringred) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_matblue = s_select->GetMQOMaterialByName("matblue");
	if (!s_matblue) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_ringblue = s_select->GetMQOMaterialByName("ringblue");
	if (!s_ringblue) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_matgreen = s_select->GetMQOMaterialByName("matgreen");
	if (!s_matgreen) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_ringgreen = s_select->GetMQOMaterialByName("ringgreen");
	if (!s_ringgreen) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_matyellow = s_select->GetMQOMaterialByName("matyellow");
	if (!s_matyellow) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	
	s_selectobj_objx = s_select->GetMQOObjectByName("objX");
	if (!s_selectobj_objx) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_ringx = s_select->GetMQOObjectByName("ringX");
	if (!s_selectobj_ringx) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_objy = s_select->GetMQOObjectByName("objY");
	if (!s_selectobj_objy) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_ringy = s_select->GetMQOObjectByName("ringY");
	if (!s_selectobj_ringy) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_objz = s_select->GetMQOObjectByName("objZ");
	if (!s_selectobj_objz) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_ringz = s_select->GetMQOObjectByName("ringZ");
	if (!s_selectobj_ringz) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_center = s_select->GetMQOObjectByName("obj_CENTER");
	if (!s_selectobj_center) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}



	//s_matredmat = s_matred->GetDif4F();
	//s_ringredmat = s_ringred->GetDif4F();
	//s_matbluemat = s_matblue->GetDif4F();
	//s_ringbluemat = s_ringblue->GetDif4F();
	//s_matgreenmat = s_matgreen->GetDif4F();
	//s_ringgreenmat = s_ringgreen->GetDif4F();
	//s_matyellowmat = s_matyellow->GetDif4F();
	s_matredmat = ChaVector4(255.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f, 1.0f);
	s_ringredmat = ChaVector4(255.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f, 1.0f);
	s_matbluemat = ChaVector4(150.0f / 255.0f, 200.0f / 255.0f, 255.0f / 255.0f, 1.0f);
	s_ringbluemat = ChaVector4(150.0f / 255.0f, 200.0f / 255.0f, 255.0f / 255.0f, 1.0f);
	s_matgreenmat = ChaVector4(0.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f, 1.0f);
	s_ringgreenmat = ChaVector4(0.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f, 1.0f);
	s_matyellowmat = s_matyellow->GetDif4F();
	
	
	
	
	s_select_posture = new CModel();
	if (!s_select_posture) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_select_posture->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\select_2_posture.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_select_posture->MakeDispObj(), return S_FALSE);
	
	float rigmult = 1.0f;
	s_rigopemark_sphere = new CModel();
	if (!s_rigopemark_sphere) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_rigopemark_sphere->SetInstancingNum(RIGMULTINDEXMAX);
	CallF(s_rigopemark_sphere->LoadMQO(s_pdev,
		L"..\\Media\\MameMedia\\rigmark.mqo", 0, rigmult, 0), return S_FALSE);

	s_rigopemark_ringX = new CModel();
	if (!s_rigopemark_ringX) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_rigopemark_ringX->SetInstancingNum(RIGMULTINDEXMAX);
	CallF(s_rigopemark_ringX->LoadMQO(s_pdev,
		L"..\\Media\\MameMedia\\ringX.mqo", 0, rigmult, 0), return S_FALSE);

	s_rigopemark_ringY = new CModel();
	if (!s_rigopemark_ringY) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_rigopemark_ringY->SetInstancingNum(RIGMULTINDEXMAX);
	CallF(s_rigopemark_ringY->LoadMQO(s_pdev,
		L"..\\Media\\MameMedia\\ringY.mqo", 0, rigmult, 0), return S_FALSE);

	s_rigopemark_ringZ = new CModel();
	if (!s_rigopemark_ringZ) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_rigopemark_ringZ->SetInstancingNum(RIGMULTINDEXMAX);
	CallF(s_rigopemark_ringZ->LoadMQO(s_pdev,
		L"..\\Media\\MameMedia\\ringZ.mqo", 0, rigmult, 0), return S_FALSE);

	s_matrigmat = ChaVector4(255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f);
	
	
	s_bmark = new CModel();
	if (!s_bmark) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_bmark->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\bonemark.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_bmark->MakeDispObj(), return S_FALSE);
	
	
	
	
	s_ground = new CModel();
	if (!s_ground) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_ground->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\ground2.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_ground->MakeDispObj(), return S_FALSE);
	
	s_gplane = new CModel();
	if (!s_gplane) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_gplane->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\gplane.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_gplane->MakeDispObj(), return S_FALSE);
	ChaVector3 tra(0.0f, 0.0, 0.0f);
	ChaVector3 mult(5.0f, 1.0f, 5.0f);
	CallF(s_gplane->MultDispObj(mult, tra), return S_FALSE);


	//WCHAR initialdir[MAX_PATH] = { 0L };
	//wcscpy_s(initialdir, MAX_PATH, g_basedir);
	//wcscat_s(initialdir, MAX_PATH, L"..\\Test\\");
	//SetCurrentDirectoryW(initialdir);

	return 0;
}

void CloseAllRightPainWindow()
{
	//platemenu用のウインドウ以外を閉じるまたは破棄する
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}
	if (s_copyhistorydlg.GetCreatedFlag() == true) {
		s_copyhistorydlg.ShowWindow(SW_HIDE);
	}
	if (s_dollyhistorydlg.GetCreatedFlag() == true) {
		s_dollyhistorydlg.ShowWindow(SW_HIDE);
	}
	if (s_anglelimitdlg) {
		s_underanglelimithscroll = 0;
		DestroyWindow(s_anglelimitdlg);
		s_anglelimitdlg = 0;
	}
	if (s_rotaxisdlg) {
		DestroyWindow(s_rotaxisdlg);
		s_rotaxisdlg = 0;
	}
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}


	//platemenuのwindowを閉じる
	GUIRigidSetVisible(-2);
	GUIRetargetSetVisible(-2);
	GUIDispSetVisible(-2);
	CloseTheFirstRowGUI();

}

void CloseTheFirstRowGUI()
{
	ShowGUIDlgDispParams(false);
	ShowGUIDlgBrushes(false);
	ShowGUIDlgBullet(false);
	ShowGUIDlgLOD(false);
}

int UpdateTopPosText()
{
	//BrushesウインドウのTopPosスライダーの　フレーム番号表示を更新
	if (s_guidlg[GUIDLG_BRUSHPARAMS]) {
		HWND topposslider = GetDlgItem(s_guidlg[GUIDLG_BRUSHPARAMS], IDC_SLIDER_TOPPOS);
		HWND toppostext = GetDlgItem(s_guidlg[GUIDLG_BRUSHPARAMS], IDC_STATIC_TOPPOS);
		if (topposslider || toppostext) {
			WCHAR strdlg[256] = { 0L };
			swprintf_s(strdlg, 256, L"TopPos %d%% : %d", g_applyrate, IntTime(g_motionbrush_applyframe));
			SetDlgItemText(s_guidlg[GUIDLG_BRUSHPARAMS], IDC_STATIC_TOPPOS, strdlg);
		}
	}
	return 0;
}
