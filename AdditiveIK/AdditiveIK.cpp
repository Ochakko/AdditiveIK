#include "stdafx.h"

#include "useatl.h"

#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#include "resource.h"


#include <Coef.h>
#include "StructHistory.h"

#include <ChaScene.h>
#include <Model.h>
#include <TexBank.h>
#include <Bone.h>
//#include <MySprite.h>
#include <mqoobject.h>
#include <GrassElem.h>

//#include <OrgWindow.h>
//InfoWindowでOrgWindowをincludeしている
#include <InfoWindow.h>

#define DBGH
#include <dbg.h>

#include <shlobj.h> //shell
#include <shlobj_core.h>
#include <objbase.h>
#include <Knownfolders.h>

#include <Commdlg.h>
//#include <ChaVecCalc.h>
#include <GlobalVar.h>

#include <ChaCalcFunc.h>

#include <mqomaterial.h>

#include <ChaFile.h>
#include <RetargetFile.h>
#include <ImpFile.h>
#include <RigidElemFile.h>
#include <RigidElem.h>
#include <MNLFile.h>
#include <ChooseColorFile.h>
#include <LightsForEditFile.h>
#include <ThresholdFile.h>
#include <ShadowParamsFile.h>
#include <SkyParamsFile.h>
#include <FogParamsFile.h>
#include <DofParamsFile.h>
#include "IniFile.h"


#include <BtObject.h>
#include <fbxsdk.h>

#include <BPWorld.h>
#include <GlutStuff.h>
#include <GLDebugDrawer.h>
#include <btBulletDynamicsCommon.h>

#include "ColiIDDlg.h"
#include "GColiIDDlg.h"
#include "RegistDlg.h"
#include <GColiFile.h>
#include "SettingsDlg.h"
#include <CopyHistoryDlg2.h>
#include <DollyHistoryDlg2.h>
#include <RigidParamsDlg.h>
#include <DispLimitsDlg.h>
#include <BulletDlg.h>
#include <ProjLodDlg.h>
#include <BlendShapeDlg.h>
#include <LightsDlg.h>
#include <DispGroupDlg.h>
#include <LaterTransparentDlg.h>
#include <ShaderTypeDlg.h>
#include <ShaderParamsDlg.h>
#include <SkyParamsDlg.h>
#include <RetargetDlg.h>
#include <LimitEulDlg.h>
#include <ShadowDlg.h>
#include <ImpulseDlg.h>
#include <GPlaneDlg.h>
#include <DampAnimDlg.h>
#include <ThresholdDlg.h>
#include <FogDlg.h>
#include <CpInfoDlg2.h>

#include <math.h>
#include <stdio.h>

#include <EditRange.h>
#include "FrameCopyDlg.h"

#include <BVHFile.h>
#include "FBXFile.h"

#include <BntFile.h>

#include <Model.h>
#include "RMenuMain.h"
//#include <BoneProp.h>
#include <lmtFile.h>
#include <RigFile.h>
#include "MotFilter.h"
#include <MotionPoint.h>

#include <StrMisc.h>

#include "DSUpdateUnderTracking.h"
#include "PluginElem.h"

#include "SelectLSDlg.h"

//display undoR undoW sprite
#include "UndoSprite.h"

//display Fps sprite
#include "FpsSprite.h"

//#include <ThreadingUpdateTimeline.h>

#include "SetDlgPos.h"
#include "ColDlg.h"

//#include <uxtheme.h>
//#pragma ( lib, "UxTheme.lib" )


#include <Windows.h>
#include <winuser.h>

//gdiの中でbyteというstd::byteと被る名前を使うのでusing namespace stdよりも前でinclude
#include <gdiplus.h>

#include "../../MiniEngine/MiniEngine.h"


//for MessageLoop
//#include "system/system.h"

#include "../AdditiveIKLib/Grimoire/RenderingEngine.h"
//#include "../AdditiveIKLib/Grimoire/ModelRender.h"
#include "../MiniEngine/Sprite.h"
#include "../MiniEngine/font/Font.h"
#include "../MiniEngine/TResourceBank.h"
#include "../MiniEngine/IMCompute.h"



#include "DXUTmisc/DXUTmisc.h"


using namespace std;




#define WINDOWS_CLASS_NAME TEXT("OchakkoLab.AdditiveIK.Window")

#define WM_USER_FOR_BATCH_PROGRESS	(WM_USER + 1)

#define MAXPLUGIN	255

//#define OPENHISTORYMAXNUM	10
//2022/08/01
#define OPENHISTORYMAXNUM	20

////2022/12/05
//#define ANGLEDLGEDITLEN	256



enum {//OnCameraAnimMouseMove()
	CAMERAANIMEDIT_NONE,
	CAMERAANIMEDIT_ROT,
	CAMERAANIMEDIT_MV,
	CAMERAANIMEDIT_DIST,
	CAMERAANIMEDIT_TWIST,
	CAMERAANIMEDIT_MAX
};

enum {
	SPRIG_INACTIVE,
	SPRIG_ACTIVE,
	SPRIGMAX
};
//#define SPRIGMAX	2

enum {//２段目プレートメニュー行の種類
	//SPPLATEMENUKIND_GUI,//<--１段目は常時表示することにしたので状態遷移の種類からは外す
	SPPLATEMENUKIND_DISP,//2023/08/07
	SPPLATEMENUKIND_RIGID,
	SPPLATEMENUKIND_RETARGET,
	SPPLATEMENUKIND_EFFECT,//2024/03/18
	SPPLATEMENUKINDNUM
};
enum {//１段目のプレート種類
	SPGUISW_CAMERA_AND_IK,
	SPGUISW_DISP_AND_LIMITS,
	//SPGUISW_BRUSHPARAMS,
	SPGUISW_BULLETPHYSICS,
	SPGUISW_PROJ_AND_LOD,
	SPGUISW_BLENDSHAPE,//2024/05/19
	SPGUISWNUM
};
//#define SPGUISWNUM	5

enum {//１段目のメニュープッシュで出る右ペインダイアログの種類
	//DLG_CAMERA_AND_IK,//<--ダイアログではなく画面上スプライト
	GUIDLG_DISP_AND_LIMITS,
	//GUIDLG_BRUSHPARAMS,
	GUIDLG_BULLETPHYSICS,
	GUIDLG_PROJ_AND_LOD,
	GUIDLG_BLENDSHAPE,//2024/05/19 場所は確保するがs_guidlg[GUIDLG_BLENDSHAPE]はnullptr　ダイアログはOrgWindow
	GUIDLGNUM
};



//２段目メニューのSPGUISW_DISP_AND_LIMITS行のプレート
enum {//2023/08/07
	SPDISPSW_LIGHTS,
	SPDISPSW_DISPGROUP,
	SPDISPSW_LATERTRANSPARENT,
	SPDISPSW_SHADERTYPE,//2023/12/08
	SPDISPSW_SHADOWPARAMS,//2023/12/14
	SPDISPSWNUM
};
//#define SPDISPSWNUM	5

//２段目メニューのSPPLATEMENUKIND_RIGID行のプレート
enum {
	SPRIGIDSW_RIGIDPARAMS,
	SPRIGIDSW_IMPULSE,
	SPRIGIDSW_GROUNDPLANE,
	SPRIGIDSW_DAMPANIM,
	SPRIGIDSWNUM
};
//#define SPRIGIDSWNUM	4

//２段目メニューのSPPLATEMENUKIND_RETARGET行のプレート
enum {
	SPRETARGETSW_RETARGET,
	SPRETARGETSW_LIMITEULER,
	SPRETARGETSW_THRESHOLD,//2024/02/20
	SPRETARGETSWNUM
};
//#define SPRETARGETSWNUM	2


//2024/03/18
//２段目メニューのSPPLATEMENUKIND_EFFECT行のプレート
enum {
	SPEFFECTSW_SKY,
	SPEFFECTSW_FOG,
	SPEFFECTSW_DOF,
	SPEFFECTSWNUM
};


enum {
	SPAIMBAR_1,
	SPAIMBAR_2,
	SPAIMBAR_3,
	SPAIMBAR_4,
	SPAIMBAR_5,
	SPAIMBARNUM
};
//#define SPAIMBARNUM	5

enum {
	SPMENU_FILE,
	SPMENU_DISP,
	SPMENU_MOTION,
	SPMENU_MODEL,
	SPMENU_EDIT,
	SPMENU_SELRIGID,
	SPMENU_SELRGD,
	SPMENU_SELRGDMORPH,
	SPMENU_SELIMPULSE,
	SPMENU_HELP,
	SPMENU_MAX
};



//#define FPSSAVENUM 100
#define FPSSAVENUM 120
static double s_fTime = 0.0;
static float s_fElapsedTime = 0.0;
static double s_befftime = 0.0;
static double s_mousemoveBefTime = 0.0;
static double s_fps100[FPSSAVENUM];
static int s_fps100index = 0;
static double s_avrgfps = 0.0;
static double s_rectime = 0.0;
static double s_reccnt = 0;


static HSVTOON s_hsvtoonforall;//mqomaterial指定が無い場合の設定内容を保存
static HSVTOON s_skyhsvtoonforall;//s_skt用の設定内容を保存


//typedef struct tag_spaxis
//{
//	Sprite sprite;
//	POINT dispcenter;
//	tag_spaxis() : sprite() {
//		::ZeroMemory(&dispcenter, sizeof(POINT));
//	};
//}SPAXIS, SPCAM;



//押したボタンの反転色表示回数　60fpsのときの回数
#define BUTTONPUSHEDMAXCOUNT	15


class CSpAxis
{
public:
	CSpAxis() : sprite(), sprite_pushed() {
		::ZeroMemory(&dispcenter, sizeof(POINT));
		pushcount = 0;
	};
	~CSpAxis()
	{
		DestroyObjs();
	};
	void DestroyObjs() {
		sprite.DestroyObjs();
		sprite_pushed.DestroyObjs();
	};
	void ButtonDown() {
		pushcount = 1;
	};
	void ButtonUp() {
		pushcount = 0;
	}
	Sprite* GetSpriteForRender() {
		if (pushcount <= 0) {
			return &sprite;
		}
		else {
			return &sprite_pushed;
		}
	};
public:
	int pushcount;
	Sprite sprite;
	Sprite sprite_pushed;
	POINT dispcenter;
};

class CSpCam
{
public:
	CSpCam() : sprite(), sprite_pushed() {
		::ZeroMemory(&dispcenter, sizeof(POINT));
		pushcount = 0;
	};
	~CSpCam()
	{
		DestroyObjs();
	};
	void DestroyObjs() {
		sprite.DestroyObjs();
		sprite_pushed.DestroyObjs();
	};
	void ButtonDown() {
		pushcount = 1;
	};
	void ButtonUp() {
		pushcount = 0;
	}
	Sprite* GetSpriteForRender() {
		if (pushcount <= 0) {
			return &sprite;
		}
		else {
			return &sprite_pushed;
		}
	};

public:
	int pushcount;
	Sprite sprite;
	Sprite sprite_pushed;
	POINT dispcenter;
};

class CSpElem
{
public:
	CSpElem() : sprite(), sprite_pushed() {
		::ZeroMemory(&dispcenter, sizeof(POINT));
		pushcount = 0;
	};
	~CSpElem()
	{
		DestroyObjs();
	};
	void DestroyObjs() {
		sprite.DestroyObjs();
		sprite_pushed.DestroyObjs();
	};
	void ButtonDown() {
		pushcount = 1;
	};
	void ButtonUp() {
		pushcount = 0;
	}
	void UpdatePushCount() {
		if (pushcount >= GetPushedMaxCount()) {//2024/06/23 現在の表示速度に合わせた回数分
			pushcount = 0;
		}
		if (pushcount > 0) {
			pushcount++;
		}
	};
	Sprite* GetSpriteForRender() {
		if (pushcount <= 0) {
			return &sprite;
		}
		else {
			return &sprite_pushed;
		}
	};
private:
	int GetPushedMaxCount()
	{
		//2024/06/23
		//60fpsのときBUTTONPUSHEDMAXCOUNT回の間反転表示　現在の表示速度(s_avrgfps)においてはretmaxcount回の間反転表示
		int retmaxcount = (int)((double)(BUTTONPUSHEDMAXCOUNT) * (s_avrgfps / 60.0));
		return retmaxcount;
	};
public:
	int pushcount;
	Sprite sprite;
	Sprite sprite_pushed;
	POINT dispcenter;
};

//typedef struct tag_spsw
//{
//	bool state;//ON : 1 or OFF : 0
//	Sprite spriteON;
//	Sprite spriteOFF;
//	POINT dispcenter;
//	tag_spsw() : spriteON(), spriteOFF() {
//		state = 0;
//		::ZeroMemory(&dispcenter, sizeof(POINT));
//	};
//}SPGUISW;
class CSpGUISW
{
public:
	CSpGUISW() : spriteON(),  spriteOFF() {
		state = 0;
		::ZeroMemory(&dispcenter, sizeof(POINT));
	};
	~CSpGUISW() {
		DestroyObjs();
	};
	void DestroyObjs() {
		spriteON.DestroyObjs();
		spriteOFF.DestroyObjs();
	};
	Sprite* GetSpriteForRender() {
		if (state) {
			return &spriteON;
		}
		else {
			return &spriteOFF;
		}
	};
public:
	bool state;//ON : 1 or OFF : 0
	Sprite spriteON;
	Sprite spriteOFF;
	POINT dispcenter;
};

class CSpGUISW3
{
public:
	CSpGUISW3() : sprite1(), sprite2(), sprite3() 
	{
		mode = 0;
		::ZeroMemory(&dispcenter, sizeof(POINT));
	};
	~CSpGUISW3() {
		DestroyObjs();
	};
	void DestroyObjs() {
		sprite1.DestroyObjs();
		sprite2.DestroyObjs();
		sprite3.DestroyObjs();
	};
	Sprite* GetSpriteForRender() {
		if (mode == 0) {
			return &sprite1;
		}
		else if (mode == 1) {
			return &sprite2;
		}
		else if (mode == 2) {
			return &sprite3;
		}
		else {
			_ASSERT(0);
			return &sprite1;
		}
	};

public:
	int mode;
	Sprite sprite1;
	Sprite sprite2;
	Sprite sprite3;
	POINT dispcenter;
};




//global
//2023/12/01 mqofileのmaterialno読込対応時に　マテリアルが被らないようにモデル単位に変更
//TResourceBank<CMQOMaterial> g_materialbank;

IShaderResource* g_shadowmapforshader = nullptr;
CColDlg g_coldlg;



//staic
static Microsoft::WRL::ComPtr<ID3D12DebugDevice> s_debugDevice;

static HWINEVENTHOOK s_hhook = NULL;

static int s_appcnt = 0;
static int s_launchbyc4 = 0;
static int s_launchc4diffx = 0;
static int s_launchc4diffy = 0;
//static int s_onefps = 0;


static vector<wstring> s_bvh2fbxout;
static LONG s_bvh2fbxnum = 0;
static LONG s_bvh2fbxcnt = 0;
static LONG s_befbvh2fbxnum = 0;
static LONG s_befbvh2fbxcnt = 0;
LONG g_bvh2fbxbatchflag = 0;
HWND s_bvh2fbxbatchwnd = 0;
HANDLE s_bvh2fbxhandle1;
HANDLE s_bvh2fbxhandle2;

static LONG s_progressnum = 0;
static LONG s_progresscnt = 0;
static LONG s_progressmodelnum = 0;
static LONG s_progressmodelcnt = 0;
static LONG s_befprogressnum = 0;
static LONG s_befprogresscnt = 0;
static LONG s_befprogressmodelnum = 0;
static LONG s_befprogressmodelcnt = 0;

HWND s_progresswnd;


static bool s_smoothBefRetarget = false;
static vector<wstring> s_retargetout;
static LONG s_retargetnum = 0;
static LONG s_retargetcnt = 0;
static LONG s_befretargetnum = 0;
static LONG s_befretargetcnt = 0;
int s_saveretargetmodel = 0;
LONG g_retargetbatchflag;
HWND s_retargetbatchwnd;
HANDLE s_retargethandle1;
HANDLE s_retargethandle2;
//static void WaitRetargetThreads();
static int s_convbone_model_batch_selindex;
CModel* s_convbone_model_batch = nullptr;


LONG g_calclimitedwmflag;


static Gdiplus::GdiplusStartupInput gdiplusStartupInput;
static ULONG_PTR gdiplusToken;
Gdiplus::Image* g_mousehereimage = 0;
Gdiplus::Image* g_menuaimbarimage = 0;
Gdiplus::Image* g_playerbutton_target26 = 0;
Gdiplus::Image* g_playerbutton_target_inv26 = 0;
Gdiplus::Image* g_playerbutton_target40 = 0;
Gdiplus::Image* g_playerbutton_target_inv40 = 0;

Gdiplus::Image* g_numBG = nullptr;
Gdiplus::Image* g_numbutton[SKNUMBUTTON_MAX];
Gdiplus::Image* g_numbutton_pushed[SKNUMBUTTON_MAX];
Gdiplus::Image* g_alnumbutton[SKALNUM_MAX];
Gdiplus::Image* g_alnumbutton_pushed[SKALNUM_MAX];

int g_currentsubmenuid = 0;
POINT g_currentsubmenupos = { 0, 0 };
int g_submenuwidth = 32;
HWND g_filterdlghwnd = 0;

CRITICAL_SECTION g_CritSection_GetGP;
CRITICAL_SECTION g_CritSection_FbxSdk;


static int s_onselectplugin = 0;
static CPluginElem* s_plugin = 0;



enum {
	MB3D_WND_MAIN,
	MB3D_WND_3D,
	MB3D_WND_TREE,
	MB3D_WND_TOOL,
	MB3D_WND_TIMELINE,
	MB3D_WND_SIDE,
	MB3D_WND_MAX
};


static int s_savebonemarkflag = 1;
static int s_saverigidmarkflag = 1;

static WCHAR s_temppath[MAX_PATH] = { 0L };


//static CDSUpdateUnderTracking* s_dsupdater = 0;
LONG g_undertrackingRMenu = 0;
LONG g_underApealingMouseHere = 0;

extern HANDLE g_hUnderTrackingThread;
//extern DSManager manager;

bool g_enableDS = false;
static void InitDSValues();

//###########################################################
//ゲームパッドはキャラクターに対する操作テストなどに使用していく予定
//ゲームパッドでのウインドウコントロール操作関数は削除
//マウス、キーボード、マウスパッド共存の方向で.
//###########################################################
//static void GetDSValues();
//static void DSColorAndVibration();
//static void DSSelectWindowAndCtrl();//L1, square, triangle
//static void DSSelectCharactor();//(L2 or R2) and L1
//static void DSCrossButton(bool firstctrlselect);
static void DSCrossButtonSelectTree(bool firstctrlselect);
//static void DSCrossButtonSelectUTGUI(bool firstctrlselect);
//static void DSCrossButtonSelectToolCtrls(bool firstctrlselect);
//static void DSCrossButtonSelectPlayerBtns(bool firstctrlselect);
//static void DSCrossButtonSelectRigidCtrls(bool firstctrlselect);
//static void DSCrossButtonSelectImpulseCtrls(bool firstctrlselect);
//static void DSCrossButtonSelectGPCtrls(bool firstctrlselect);
//static void DSCrossButtonSelectDampCtrls(bool firstctrlselect);
//static void DSCrossButtonSelectRetargetCtrls(bool firstctrlselect);
//static void DSCrossButtonSelectEulLimitCtrls(bool firstctrlselect);
//static void DSOptionButtonRightClick();
//static void DSR1ButtonSelectCurrentBone();//R1
//static void DSR1ButtonSelectMotion();//(L2 or R2) and R1
//static void DSAxisLMouseMove();
////static void DSAxisLSelectingPopupMenu();
//static void DSAxisRMainMenuBar();
//static void DSAimBarOK();
//static void DSOButtonSelectedPopupMenu();
//static void DSXButtonCancel();
//static void DSL3R3ButtonMouseHere();
void OnDSUpdate();
//static void OnDSMouseHereApeal();
static void OnArrowKey();//DS関数でキーボードの矢印キーに対応


static void SelectNextWindow(int nextwndid);

static void SetMainWindowTitle();
static void InitPickInfo(UIPICKINFO* ppickinfo);

static RECT s_rcmainwnd;
static RECT s_rc3dwnd;
static RECT s_rctreewnd;
static RECT s_rctoolwnd;
static RECT s_rcltwnd;
static RECT s_rcsidemenuwnd;
static RECT s_rcrigidwnd;
//static RECT s_rcshadertypewnd;
static RECT s_rcshadertypeparamswnd;
static RECT s_rcinfownd;
static RECT s_rctopsliderswnd;
static RECT s_rcmodelpanel;
static RECT s_rcmotionpanel;
static RECT s_rccamerapanel;


#define MB3D_DSBUTTONNUM	14
#define MB3D_DSAXISNUM		6
#define MB3D_DSAXISSRH		(0.70f)
static int s_curaimbarno = -1;
static int s_dsdeviceid = -1;
static int s_currentwndid = 0;
static HWND s_currenthwnd = 0;
static int s_restorewndid = 0;
static HWND s_restorehwnd = 0;
static POINT s_restorecursorpos;
static int s_currentctrlid = -1;
static HWND s_currentctrlhwnd = 0;
//#define SUBMENUNUM	10
//static int g_currentsubmenuid = 0;//globalへ
static int s_currentsubmenuitemid = 0;
static HWND s_ofhwnd = 0;
static HWND s_messageboxhwnd = 0;
static int s_messageboxpushcnt = 0;
static HWND s_getfilenamehwnd = 0;
static HWND s_getfilenametreeview = 0;

static int s_getsym_retmode = 0;


static int s_wmlbuttonup = 0;//ゲームパッド用フラグ
static bool s_utBrushRepeatsFlag = false;//UTDialogのBrushRepeatsスライダー値変更
static bool s_utApplyRateFlag = false;//UTDialogのApplyRateスライダー値変更
static bool s_utBrushMethodFlag = false;
static bool s_BrushMirrorUCheckBoxFlag = false;//UTDialogの
static bool s_BrushMirrorVCheckBoxFlag = false;//UTDialogの
static bool s_IfMirrorVDiv2CheckBoxFlag = false;//UTDialogの
static bool s_LimitDegCheckBoxFlag = false;//UTDialogの
static bool s_WallScrapingCheckBoxFlag = false;//UTDialogの

typedef struct tag_enumdist
{
	HWND hwnd;
	float dist;
	void Init() {
		hwnd = 0;
		dist = 0.0f;
	};
}ENUMDIST;
static std::vector<ENUMDIST> s_enumdist;

static int s_curdsutguikind = 0;
static int s_curdsutguino = 0;
//static std::vector<CDXUTControl*> s_dsutgui0;
//static std::vector<CDXUTControl*> s_dsutgui1;
//static std::vector<CDXUTControl*> s_dsutgui2;
//static std::vector<CDXUTControl*> s_dsutgui3;
//static std::vector<UINT> s_dsutguiid0;
//static std::vector<UINT> s_dsutguiid1;
//static std::vector<UINT> s_dsutguiid2;
//static std::vector<UINT> s_dsutguiid3;

static int s_curdstoolctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dstoolctrls;

static int s_curdsplayerbtnno = 0;

static int s_curdsrigidctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsrigidctrls;

static int s_curdsimpulsectrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsimpulsectrls;

static int s_curdsgpctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsgpctrls;

static int s_curdsdampctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsdampctrls;

static int s_curdsretargetctrlno = 0;
static std::vector<OrgWinGUI::OrgWindowParts*> s_dsretargetctrls;

static int s_curdseullimitctrlno = 0;
static std::vector<UINT> s_dseullimitctrls;


static int s_dsbuttondown[MB3D_DSBUTTONNUM];
static int s_bef_dsbuttondown[MB3D_DSBUTTONNUM];
static int s_dsbuttonup[MB3D_DSBUTTONNUM];
static int s_bef_dsbuttonup[MB3D_DSBUTTONNUM];
static float s_dsaxisvalue[MB3D_DSAXISNUM];
static float s_bef_dsaxisvalue[MB3D_DSAXISNUM];
static int s_dsaxisOverSrh[MB3D_DSAXISNUM];
static int s_bef_dsaxisOverSrh[MB3D_DSAXISNUM];
static int s_dsaxisMOverSrh[MB3D_DSAXISNUM];
static int s_bef_dsaxisMOverSrh[MB3D_DSAXISNUM];
static int s_dspushedOK = 0;
static int s_dspushedL3 = 0;
static int s_dspushedR3 = 0;
//static int s_dsmousewait = 0;

static HWND s_mqodlghwnd = 0;
static bool s_underframecopydlg = false;

static CColiIDDlg* s_pcolidlg = 0;
static bool s_undercolidlg = false;
static CGColiIDDlg* s_pgcolidlg = 0;
static bool s_undergcolidlg = false;

static HWND s_motpropdlghwnd = 0;
//static HWND s_cameradollydlgwnd = 0;
static HWND s_materialratedlgwnd = 0;
static HWND s_modelworldmatdlgwnd = 0;
static HWND s_jumpgravitydlgwnd = 0;
//static HWND s_shadertypeparamsdlgwnd = 0;
//static HWND s_skyparamsdlgwnd = 0;
//static HWND s_fogparamsdlgwnd = 0;
//static HWND s_dofparamsdlgwnd = 0;
static HWND s_savechadlghwnd = 0;
static HWND s_bvhdlghwnd = 0;
static HWND s_saveredlghwnd = 0;
static HWND s_saveimpdlghwnd = 0;
static HWND s_savegcodlghwnd = 0;
static HWND s_rotzisdlghwnd = 0;
static HWND s_customrighwnd = 0;
static HWND s_exportxdlghwnd = 0;


static int s_opedelmodelcnt = -1;
static int s_opedelmotioncnt = -1;
static bool s_underdelmodel = false;
static bool s_underdelmotion = false;
static bool s_underselectmodel = false;
static bool s_underselectcamera = false;
static bool s_underselectmotion = false;
static bool s_underdispmodel = false;
static bool s_underfilteringbymenu = false;
static int s_opeselectmodelcnt = -1;
static int s_opeselectcameracnt = -1;
static int s_opeselectmotioncnt = -1;
static int s_opedispmodelcnt = -1;


static bool s_nowloading = true;
static void OnRenderNowLoading();

extern map<CModel*, int> g_bonecntmap;
extern int gNumIslands;
extern void InitCustomRig(CUSTOMRIG* dstcr, CBone* parentbone, int rigno);
extern int IsValidCustomRig(CModel* srcmodel, CUSTOMRIG srccr, CBone* parentbone);
//void SetCustomRigBone(CUSTOMRIG* dstcr, CBone* childbone);
extern int IsValidRigElem(CModel* srcmodel, RIGELEM srcrigelem);

extern int DXUTSetOverrideSize(int srcw, int srch);

extern void OrgWinGUI::InitEulKeys();
extern void OrgWinGUI::DestroyEulKeys();
extern void OrgWinGUI::InitKeys();
extern void OrgWinGUI::DestroyKeys();

extern HANDLE g_hEvent; //手動リセットイベント



static CRITICAL_SECTION s_CritSection_LTimeline;


//ChaMatrix s_selectmat;//for display manipulator
//ChaMatrix s_ikselectmat;//for ik, fk
static ChaMatrix s_selectmat;//for display manipulator
static ChaMatrix s_selectmat_posture;//for display manipulator
static ChaMatrix s_ikselectmat;//for ik, fk
static int s_selectuserscale = 100;



static int s_onragdollik = 0;
static int s_physicskind = 0;
static int s_platemenukind = 0;
static int s_platemenuno = 1;

static bool s_guiswflag = true;//true : １段目メニュー内容を右ペインに. false : ２段目メニュー内容を右ペインに
static int s_guiswplateno = 1;


static CMQOMaterial* s_matred = 0;// = s_select->GetMQOMaterialByName("matred");
static CMQOMaterial* s_ringred = 0;// = s_select->GetMQOMaterialByName("ringred");
static CMQOMaterial* s_matblue = 0;// = s_select->GetMQOMaterialByName("matblue");
static CMQOMaterial* s_ringblue = 0;// = s_select->GetMQOMaterialByName("ringblue");
static CMQOMaterial* s_matgreen = 0;// = s_select->GetMQOMaterialByName("matgreen");
static CMQOMaterial* s_ringgreen = 0;// = s_select->GetMQOMaterialByName("ringgreen");
static CMQOMaterial* s_matyellow = 0;// = s_select->GetMQOMaterialByName("matyellow");
static CMQOObject* s_selectobj_objx = 0;
static CMQOObject* s_selectobj_objy = 0;
static CMQOObject* s_selectobj_objz = 0;
static CMQOObject* s_selectobj_ringx = 0;
static CMQOObject* s_selectobj_ringy = 0;
static CMQOObject* s_selectobj_ringz = 0;
static CMQOObject* s_selectobj_center = 0;
static ChaVector4 s_matredmat;
static ChaVector4 s_ringredmat;
static ChaVector4 s_matbluemat;
static ChaVector4 s_ringbluemat;
static ChaVector4 s_matgreenmat;
static ChaVector4 s_ringgreenmat;
static ChaVector4 s_matyellowmat;
static ChaVector4 s_ringyellowmat;


static HWND s_rotaxisdlg = 0;
static int s_rotaxiskind = AXIS_X;
static float s_rotaxisdeg = 0.0f;
static float s_befdeltax = 0.0f;

static HWND s_customrigdlg = 0;
static CUSTOMRIG s_customrig;
static CUSTOMRIG s_ikcustomrig;
static CBone* s_customrigbone = 0;
static int s_customrigno = 0;
static int s_tooltipdispcount = 0;
static size_t s_tooltiplen = 0;
static map<int, int> s_customrigmenuindex;

static int s_forcenewaxis = 0;
static int s_doneinit = 0;
//static int s_underselectingframe = 0;//globalに変更
static double s_buttonselectstart = 0.0;
static double s_buttonselectend = 0.0;
static int s_buttonselecttothelast = 0;
static double s_savebuttonselectstart;
static double s_savebuttonselectend;
static int s_savebuttonselecttothelast;
static double s_saveplayingstart;
static double s_saveplayingend;
static double s_savemotionbrush_startframe;
static double s_savemotionbrush_endframe;
static double s_savemotionbrush_applyframe;
static double s_savemotionbrush_numframe;
static int s_savemotionbrush_frameleng;



static float s_selectscale = 1.0f;
//static int s_sethipstra = 0;
//static CFrameCopyDlg s_selbonedlg;
static map<CModel*, CFrameCopyDlg*> s_selbonedlgmap;
static bool s_allmodelbone = false;

static std::vector<HISTORYELEM> s_cptfilename;
static CCopyHistoryDlg2 s_copyhistorydlg2;
static CDollyHistoryDlg2 s_dollyhistorydlg2;


static CRigidParamsDlg s_rigidparamsdlg;
static CDispLimitsDlg s_displimitsdlg;
static CBulletDlg s_bulletdlg;
static CProjLodDlg s_projloddlg;
static CBlendShapeDlg s_blendshapedlg;
static CLightsDlg s_lightsdlg;
static CDispGroupDlg s_dispgroupdlg;
static CLaterTransparentDlg s_latertransparentdlg;
static CShaderTypeDlg s_shadertypedlg;
static CShaderParamsDlg s_shaderparamsdlg;
static CSkyParamsDlg s_skyparamsdlg;
static CRetargetDlg s_retargetdlg;
static CLimitEulDlg s_limiteuldlg;
static CShadowDlg s_shadowdlg;
static CImpulseDlg s_impulsedlg;
static CGPlaneDlg s_gplanedlg;
static CDampAnimDlg s_dampanimdlg;
static CThresholdDlg s_thresholddlg;
static CFogDlg s_fogdlg;

static bool s_undercpinfodlg2;
static CCpInfoDlg2 s_cpinfodlg2;
static CPMOTINFO s_cpinfo;
static MOTINFO s_cpmotinfo;

static bool s_camtargetdisp = false;//カメラターゲット位置にマニピュレータを表示するかどうかのフラグ
static bool s_moveeyepos = false;//s_sidemenu_camdistSlider動作の種類　true:eyeposが動く、false:targetposが動く
//float g_initcamdist = 10.0f;
//static float g_projnear = 0.01f;
//float g_initcamdist = 50.0f;
//static float g_projnear = 0.001f;
//static float g_projnear = 1.0f;
//static ChaVector3 g_cameraupdir.SetParams(0.0f, 1.0f, 0.0f);
static double s_cameraframe = 0.0;
//static float g_camdist = g_initcamdist;
//static float g_projnear = 0.01f;
//static float g_projfar = g_initcamdist * 100.0f;
static float s_fAspectRatio = 1.0f;
//static float g_fovy = (float)(PI / 4.0);
//static float s_cammvstep = 100.0f;
static float s_cammvstep = 500.0f;
static int s_editmotionflag = -1;
static int s_editcameraflag = -1;//2024/06/16
static int s_tkeyflag = 0;
//static float s_maxcamdist = 5000.0f;
static float s_maxcamdist = 20000.0f;


static WCHAR s_strcurrent[256] = L"MoveToCurrentFrame";
static WCHAR s_streditrange[256] = L"Drag Edit Range";
static WCHAR s_strmark[256] = L"LongTimeLine";



//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), powf( 10.0f, 3.2f ) };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), 1e8 };
//float g_a_kval[3] = { powf( 10.0f, 0.0f ), powf( 10.0f, 0.3f ), 1e8 };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), 1000.0f };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), powf( 10.0f, 3.27f ) };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), powf( 10.0f, 3.3f ) };
//float g_l_kval[3] = { powf( 10.0f, 2.0f ), powf( 10.0f, 2.61f ), 1000.0f };


bool g_controlkey = false;
bool g_shiftkey = false;
bool g_ctrlshiftkeyformb = false;//ForMiddleButton
static bool s_skey = false;
static int s_akeycnt = 0;
static int s_dkeycnt = 0;
static int s_1keycnt = 0;

static bool s_dispsampleui = true;
static HWND s_sampleuihwnd = 0;

//double g_erp = 1.0;
double g_erp = 0.8;
//static float g_erp = 0.99f;
//static float g_erp = 0.75f;
//static double g_erp = 0.5;
//static float g_erp = 0.2f;
//static float s_impup = 0.0f;


static int s_savepreviewFlag = 0;
static int s_savecameraanimmode = 0;
static int s_saveCameraInheritMode = 0;

double s_btstartframe = 0.0;
bool g_btsimurecflag = false;

static FbxManager* s_psdk = 0;
static BPWorld* s_bpWorld = 0;
static btDynamicsWorld* s_btWorld = 0;

using namespace OrgWinGUI;

static ChaMatrix s_inimat;
static double s_time = 0.0;
//static double s_difftime = 0.0;
static int s_ikkind = 0;
static int s_cameraeditkind = 0;//2024/08/05

//PICKRANGEを大きくするとジョイントではなく疑似ボーンドラッグまで可能になるが、マニピュレータのリングのpickが難しくなる
#define PICKRANGE	16
static UIPICKINFO s_pickinfo;
static vector<TLELEM> s_tlarray;


//static int s_curmotmenuindex = -1;
//static int s_curreindex = -1;
//static int s_rgdindex = -1;
	//each character each param //2021/03/18 
static map<CModel*, int> s_motmenuindexmap;
static map<CModel*, int> s_cameramenuindexmap;
static map<CModel*, int> s_reindexmap;
static map<CModel*, int> s_rgdindexmap;


static HWND		s_3dwnd = 0;
static HMENU	s_mainmenu = 0;
static HMENU	s_animmenu = 0;
static HMENU	s_morphmenu = 0;
static HMENU	s_modelmenu = 0;
static HMENU	s_remenu = 0;
static HMENU	s_rgdmenu = 0;
static HMENU	s_impmenu = 0;
static int s_filterindex = 1;
static bool s_grassflag = false;
static HMENU	s_cursubmenu = 0;


//#define TOPSLIDERSWNDH		32
#define TOPSLIDERSWNDH		40

static int s_totalwndwidth = (1216 + 450);
static int s_totalwndheight = 950;
static int s_2ndposy = 600;

static int s_mainwidth = 800;
static int s_mainheight = (520 - TOPSLIDERSWNDH);
static int s_bufwidth = 800;
static int s_bufheight = (520 - TOPSLIDERSWNDH);

static int s_timelinewidth = 400;
static int s_timelineheight = s_2ndposy - TOPSLIDERSWNDH;

static int s_longtimelinewidth = 970;
static int s_longtimelineheight = s_totalwndheight - s_2ndposy - TOPSLIDERSWNDH - 18;

static int s_toolwidth = 230;
static int s_toolheight = 290;

static int s_modelwindowwidth = 400;
static int s_modelwindowheight = 460;
static int s_motionwindowwidth = 400;
//static int s_motionwindowheight = 700;
static int s_motionwindowheight = 400;
static int s_camerawindowwidth = 400;
static int s_camerawindowheight = 300;

static int s_infowinwidth = s_mainwidth;
static int s_infowinheight = s_2ndposy - s_mainheight - TOPSLIDERSWNDH;

static int s_sidemenuwidth = 450;
//static int s_sidemenuheight = TOPSLIDERSWNDH;
static int s_sidemenuheight = TOPSLIDERSWNDH + 16;

static int s_sidewidth = s_sidemenuwidth;
static int s_sideheight = s_totalwndheight - TOPSLIDERSWNDH - s_sidemenuheight - 28;

static int s_guibarX0 = 120;

static ID3D12Device* s_pdev = 0;

static CModel* s_model = NULL;
static CModel* s_cameramodel = NULL;
static CModel* s_select = NULL;
static CModel* s_select_posture = NULL;
static CModel* s_bmark = NULL;
//static CModel* s_coldisp[ COL_MAX ];
static CModel* s_ground = NULL;
static CModel* s_gplane = NULL;
static CModel* s_sky = NULL;

static std::vector<CGrassElem*> s_grassElemVec;


static int s_rigsphere_num;
static int s_rigringX_num;
static int s_rigringY_num;
static int s_rigringZ_num;
static CModel* s_rigopemark_sphere;//2024/01/11 use Instancing
static CModel* s_rigopemark_ringX;//2024/01/11 use Instancing
static CModel* s_rigopemark_ringY;//2024/01/11 use Instancing
static CModel* s_rigopemark_ringZ;//2024/01/11 use Instancing
//static CMQOMaterial* s_rigmaterial_sphere[RIGMULTINDEXMAX + 1];
//static CMQOMaterial* s_rigmaterial_ringX[RIGMULTINDEXMAX + 1];
//static CMQOMaterial* s_rigmaterial_ringY[RIGMULTINDEXMAX + 1];
//static CMQOMaterial* s_rigmaterial_ringZ[RIGMULTINDEXMAX + 1];
static ChaVector4 s_matrigmat;


//static CModel* s_dummytri = NULL;


static int s_fbxbunki = 1;

static ChaMatrix s_matWorld;//シーン(カメラ)のworldmat. modelのworldmatでは無い.
static ChaMatrix s_matProj;
static ChaMatrix s_matVP;
static ChaMatrix s_matView;
static ChaMatrix s_befLockMatView;//Lock2Sel処理前のs_matView
static ChaMatrix s_matSkyProj;
//static ChaVector3 s_camUpVec.SetParams(0.00001f, 1.0f, 0.0f);

static int s_curmotid = -1;
static int s_curboneno = -1;
static int s_saveboneno = -1;
static int s_curbaseno = -1;


//select joint using shortcutkey
static int s_selecthand = 0;
static int s_selectfoot = 0;



static int s_tiprigboneno = -1;
static int s_tiprigno = -1;

static int s_ikcnt = 0;
static ChaMatrix s_selm = ChaMatrix(0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f
);
static ChaMatrix s_selm_posture = ChaMatrix(0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 0.0f
);

static void OrgWindowListenMouse(bool srcflag);

static OrgWindow* s_timelineWnd = 0;
static OWP_Timeline* s_owpTimeline = 0;
static OWP_PlayerButton* s_owpPlayerButton = 0;
static OWP_CheckBoxA* s_parentcheck = 0;

static OrgWindow* s_LtimelineWnd = 0;
static OWP_Timeline* s_owpLTimeline = 0;
static OWP_EulerGraph* s_owpEulerGraph = 0;
static OWP_Separator* s_LTSeparator = 0;

static OrgWindow* s_dofWnd = 0;
static OWP_Label* s_dofLabel = 0;
static OWP_ComboBoxA* s_dofslotCombo = 0;
static OWP_Label* s_dofspacerLabel1 = 0;
static OWP_Separator* s_dofdistsp1 = 0;
static OWP_Separator* s_dofdistsp2 = 0;
static OWP_Separator* s_dofdistsp3 = 0;
static OWP_Label* s_dofdistnearLabel = 0;
static OWP_EditBox* s_dofdistnearEdit = 0;
static OWP_Label* s_dofdistfarLabel = 0;
static OWP_EditBox* s_dofdistfarEdit = 0;
static OWP_Label* s_dofspacerLabel2 = 0;
static OWP_CheckBoxA* s_dofskyChk = 0;
static OWP_Label* s_dofspacerLabel3 = 0;
static OWP_Separator* s_dofapplysp = 0;
static OWP_Button* s_dofapplyB = 0;

static OrgWindow* s_sidemenuWnd = 0;
//static OWP_Separator* s_sidemenusp = 0;
//static OWP_Separator* s_sidemenusp1 = 0;
//static OWP_Separator* s_sidemenusp2 = 0;
//static OWP_Button* s_sidemenu_rigid = 0;
//static OWP_Button* s_sidemenu_limiteul = 0;
//static OWP_Button* s_sidemenu_copyhistory = 0;
//static OWP_Button* s_sidemenu_retarget = 0;
static OWP_Separator* s_sidemenusp1 = 0;
static OWP_Separator* s_sidemenusp2 = 0;
static OWP_Separator* s_sidemenusp3 = 0;
static OWP_CheckBoxA* s_sidemenu_sellock = 0;
static OWP_Button* s_sidemenu_sellockOnce = 0;
static OWP_CheckBoxA* s_sidemenu_targetdisp = 0;
static OWP_CheckBoxA* s_sidemenu_moveeyepos = 0;
static OWP_Slider* s_sidemenu_camdistSlider = 0;
static bool s_camdistsliderflag = false;
static float s_camdistsliderval = g_camdist;


static OrgWindow* s_topSlidersWnd = 0;
static OWP_Separator* s_topSlidersSeparator1 = 0;
static OWP_Separator* s_topSlidersSeparator2 = 0;
static OWP_Slider* s_owpEditRateSlider = 0;
static OWP_Slider* s_owpSpeedSlider = 0;
//static OWP_Slider* s_owpTopPosSlider = 0;
//static OWP_Label* s_mainmenulabel = 0;
static OWP_Separator* s_topSlidersSeparator3 = 0;
static OWP_Separator* s_topSlidersSeparator4 = 0;
static OWP_Slider* s_owpBrushRepeatsSlider = 0;
static OWP_CheckBoxA* s_owpBrushMirrorU = 0;
static OWP_CheckBoxA* s_owpBrushMirrorV = 0;


static OrgWindow* s_placefolderWnd = 0;
//static OWP_Label* s_placefolderlabel_1 = 0;
//static OWP_Label* s_placefolderlabel_2 = 0;
//static OWP_Label* s_placefolderlabel_3 = 0;
//#define SHORTCUTTEXTNUM	35
//#define SHORTCUTTEXTNUM	40
//#define SHORTCUTTEXTNUM	44
//#define SHORTCUTTEXTNUM	48
//#define SHORTCUTTEXTNUM	50
//#define SHORTCUTTEXTNUM	52
//#define SHORTCUTTEXTNUM	46
//#define SHORTCUTTEXTNUM	49
#define SHORTCUTTEXTNUM	50
static OWP_Label* s_shortcuttext[SHORTCUTTEXTNUM];

static bool s_skyparamsFlag = false;
static bool s_fogparamsFlag = false;
static bool s_dofparamsFlag = false;

static OrgWindow* s_toolWnd = 0;
static OWP_Separator* s_toolSeparator = 0;
static OWP_Button* s_toolCopyB = 0;
static OWP_Button* s_toolZeroFrameB = 0;
static OWP_Button* s_toolSymCopyB = 0;
static OWP_Button* s_toolCutB = 0;
static OWP_Button* s_toolPasteB = 0;
static OWP_Button* s_toolDeleteB = 0;
static OWP_Button* s_toolMotPropB = 0;
static OWP_Button* s_toolMarkB = 0;
static OWP_Button* s_toolSelBoneB = 0;
static OWP_Button* s_toolInitMPB = 0;
static OWP_Button* s_toolInterpolateB = 0;
static OWP_Button* s_toolFilterB = 0;
static OWP_Button* s_toolSelectCopyFileName = 0;
static OWP_Button* s_toolSkipRenderBoneMarkB = 0;
static OWP_Button* s_toolSkipRenderBoneMarkB2 = 0;
static OWP_Button* s_tool180deg = 0;
static OWP_Button* s_toolScaleInitAllB = 0;
static OWP_Button* s_toolCameraDollyB = 0;
static OWP_Button* s_toolMaterialRateB = 0;
static OWP_Button* s_toolModelWorldMatB = 0;


//#define CONVBONEMAX		256

//2023/07/08 TheHunt のアセット読み込み時にボーン数制限オーバーしたので　値を大きく
//#define CONVBONEMAX		1024//MAXBONENUM 2048;を使う

static OrgWindow* s_layerWnd = 0;
static OWP_LayerTable* s_owpLayerTable = 0;

static bool InBlendShapeMode(CModel** ppmodel, CMQOObject** ppmqoobj, int* pchannelindex);

static bool s_SpriteButtonDown = false;
static bool s_SpriteButtonDownUndoRedo = false;

static bool s_closeFlag = false;			// 終了フラグ
static bool s_closetoolFlag = false;
static bool s_closeobjFlag = false;
static bool s_closemodelFlag = false;
static bool s_closecameraFlag = false;
static bool s_closemotionFlag = false;
static bool s_DcloseFlag = false;
static bool s_ScloseFlag = false;
static bool s_GcloseFlag = false;
static bool s_displimitscloseFlag = false;
static bool s_undoFlag = false;
static bool s_redoFlag = false;
static bool s_undoredoFromPlayerButton = false;
static bool s_frogFlag = false;

static bool s_copycameraFlag = false;
static bool s_pastecameraFlag = false;
static bool s_initmpcameraFlag = false;
static bool s_interpolatecameraFlag = false;
static bool s_smoothcameraFlag = false;

static bool s_plateFlag = false;
static bool s_copyFlag = false;			// コピーフラグ
static bool s_copyLW2WFlag = false;			//Limited2World ベイクフラグ
static bool s_zeroFrameFlag = false;
//static bool s_oneFrameFlag = false;
static bool s_selCopyHisotryFlag = false;
static bool s_symcopyFlag = false;
static bool s_symcopyFlag2 = false;
static bool s_undersymcopyFlag = false;
static bool s_cutFlag = false;			// カットフラグ
static bool s_pasteFlag = false;			// ペーストフラグ
static bool s_cursorFlag = false;			// カーソル移動フラグ
static bool s_cursorUnderUndo = false;
static bool s_LTimelineApplyFrameFlag = false;
static bool s_selectFlag = false;			// キー選択フラグ
static bool s_keyShiftFlag = false;		// キー移動フラグ
static bool s_deleteFlag = false;		// キー削除フラグ
static bool s_motpropFlag = false;
static bool s_markFlag = false;
static bool s_selboneFlag = false;
static bool s_selboneAndPasteFlag = false;
static bool s_RboneAndPasteFlag = false;
static bool s_initmpFlag = false;
static bool s_filterFlag = false;
static int  s_filterState = 0;
static bool s_smoothFlag = false;//s_spsmoothボタン用
static bool s_constexeFlag = false;//s_spconstexeボタン用
static bool s_constrefreshFlag = false;//s_spconstrefreshボタン用
//static bool s_filternodlg = false;
static bool s_delmodelFlag = false;
static bool s_delallmodelFlag = false;
static bool s_newmotFlag = false;
static bool s_delcurmotFlag = false;
static bool s_jumpinterpolateFlag = false;
static bool s_interpolateFlag = false;
static int s_interpolateState = 0;
static int s_skipJointMark = 0;
static bool s_180DegFlag = false;
static bool s_scaleAllInitFlag = false;
static bool s_cameradollyFlag = false;
static bool s_materialrateFlag = false;
static bool s_modelworldmatFlag = false;
static bool s_jumpgravityFlag = false;

static bool s_firstkeyFlag = false;
static bool s_lastkeyFlag = false;
static bool s_btresetFlag = false;

static bool s_LcloseFlag = false;
static bool s_LnextkeyFlag = false;
static bool s_LbefkeyFlag = false;
static bool s_LcursorFlag = false;			// カーソル移動フラグ
static bool s_LupFlag = false;
static bool s_LstartFlag = false;
static bool s_LstopFlag = false;
static bool s_LchangeTargetFlag = false;
static int s_LrefreshEditTarget = 0;
static bool s_LchangeTarget2Camera = false;
//static int s_LstopDoneCount = 0;

static int s_calclimitedwmState = 0;

static bool s_EcursorFlag = false;			// カーソル移動フラグ

static bool s_topslidersEditRateFlag = false;
static bool s_topslidersSpeedFlag = false;
static bool s_topslidersTopPosFlag = false;
static bool s_topslidersBrushRepeatsFlag = false;
static bool s_topslidersBrushMirrorUFlag = false;
static bool s_topslidersBrushMirrorVFlag = false;






static CMQOMaterial* s_toonmqomaterial = nullptr;//toonスライダーを離した後の処理用
static bool s_toonparamchange = false;//toonスライダーを離した後の処理用
static CShaderTypeParams s_shadertypeparams;
static bool s_skytoonparamchange = false;//toonスライダーを離した後の処理用
static CShaderTypeParams s_skyparams[SKYSLOTNUM];

static bool s_timelineRUpFlag = false;
static bool s_timelinembuttonFlag = false;
static int s_mbuttoncnt = 1;
static double s_mbuttonstart = 0.0;
static bool s_timelinewheelFlag = false;
static bool s_timelineshowposFlag = false;

static bool s_prevrangeFlag = false;
static bool s_nextrangeFlag = false;

static bool s_dispmw = true;
static bool s_disptool = true;
//static bool s_dispobj = true;
static bool s_dispobj = false;
static bool s_dispmodel = false;//!!!!!!!!!!!!!!!!!
static bool s_dispmotion = false;//!!!!!!!!!!!!!!!!!
static bool s_dispcamera = false;//!!!!!!!!!!!!!!!!!
static bool s_dispground = true;
static bool s_dispselect = true;
//static bool s_displightarrow = true;
static bool s_dispconvbone = false;

static bool s_Ldispmw = true;

static bool s_dispmodelworldmat = false;
static bool s_pickmodelworldmat = false;
static bool s_removegrassflag = false;
static float s_removegrassdistance = 50.0f;
//static bool s_putgrassflag = false;

static double s_keyShiftTime = 0.0;			// キー移動量
static list<KeyInfo> s_copyKeyInfoList;	// コピーされたキー情報リスト

//static multimap<CBone*, CMotionPoint> s_copymotmap;
typedef struct tag_cpelem
{
	CBone* bone;
	CMotionPoint mp;
	//ChaVector3 localscale;//mpのmatに掛け算しておく
	tag_cpelem() {
		bone = 0;
		mp.InitParams();
	};
}CPELEM2;
static vector<CPELEM2> s_copymotvec;
static vector<CPELEM2> s_pastemotvec;
static int WriteCPTFile(WCHAR* dstfilename);
static int WriteCPIFile(CModel* srcmodel, MOTINFO* curmi, WCHAR* cptfilename);
static bool LoadCPTFile(CModel* srcmodel);
static int LoadCPIFile(HISTORYELEM* srcdstelem);

static vector<CBone*> s_pasteRJoint;
static int SetRJoint(int srcboneno);
static void AddRJointReq(CBone* srcbone);


//static int WriteTBOFile();
//static bool LoadTBOFile();


static list<KeyInfo> s_deletedKeyInfoList;	// 削除されたキー情報リスト
static list<KeyInfo> s_selectKeyInfoList;	// コピーされたキー情報リスト

static CEditRange s_editrange;
static CEditRange* s_editrangehistory = 0;
static int s_editrangehistoryno = 0;
static int s_editrangesetindex = 0;
static CEditRange s_previewrange;





#define SPAXISNUM	3
//#define SPCAMNUM	3	//Coef.h : SPR_CAM_MAX





#define SPPLAYERBUTTONNUM	16

static Texture* s_spritetex0 = 0;
static Texture* s_spritetex1 = 0;
static Texture* s_spritetex2 = 0;
static Texture* s_spritetex3 = 0;
static Texture* s_spritetex4 = 0;
static Texture* s_spritetex5 = 0;
static Texture* s_spritetex6 = 0;
static Texture* s_spritetex7 = 0;
static Texture* s_spritetex8 = 0;
static Texture* s_spritetex9 = 0;
static Texture* s_spritetex10 = 0;
static Texture* s_spritetex11 = 0;
static Texture* s_spritetex12 = 0;
static Texture* s_spritetex13 = 0;
static Texture* s_spritetex14 = 0;
static Texture* s_spritetex15 = 0;
static Texture* s_spritetex16 = 0;
static Texture* s_spritetex17 = 0;
static Texture* s_spritetex18 = 0;
static Texture* s_spritetex19 = 0;
static Texture* s_spritetex20 = 0;
static Texture* s_spritetex21 = 0;
static Texture* s_spritetex22 = 0;
static Texture* s_spritetex23 = 0;
static Texture* s_spritetex24 = 0;
static Texture* s_spritetex25 = 0;
static Texture* s_spritetex26 = 0;
static Texture* s_spritetex27 = 0;
static Texture* s_spritetex28 = 0;
static Texture* s_spritetex29 = 0;
static Texture* s_spritetex30 = 0;
static Texture* s_spritetex31 = 0;
static Texture* s_spritetex32 = 0;
static Texture* s_spritetex33 = 0;
static Texture* s_spritetex34 = 0;
static Texture* s_spritetex35 = 0;
static Texture* s_spritetex36 = 0;
static Texture* s_spritetex37 = 0;
static Texture* s_spritetex37_1 = 0;
static Texture* s_spritetex38 = 0;
static Texture* s_spritetex39 = 0;
static Texture* s_spritetex40 = 0;
static Texture* s_spritetex40_1 = 0;
static Texture* s_spritetex41 = 0;
static Texture* s_spritetex42 = 0;
static Texture* s_spritetex43 = 0;
static Texture* s_spritetex44 = 0;
static Texture* s_spritetex45 = 0;
static Texture* s_spritetex46 = 0;
static Texture* s_spritetex47 = 0;
static Texture* s_spritetex48 = 0;
static Texture* s_spritetex49 = 0;
static Texture* s_spritetex50 = 0;
static Texture* s_spritetex51 = 0;
static Texture* s_spritetex52 = 0;
static Texture* s_spritetex53 = 0;
static Texture* s_spritetex54 = 0;
static Texture* s_spritetex55 = 0;
static Texture* s_spritetex56 = 0;
static Texture* s_spritetex57 = 0;
static Texture* s_spritetex58 = 0;
static Texture* s_spritetex59 = 0;
static Texture* s_spritetex60 = 0;
static Texture* s_spritetex61 = 0;
static Texture* s_spritetex62 = 0;
static Texture* s_spritetex63 = 0;
static Texture* s_spritetex64 = 0;
static Texture* s_spritetex65 = 0;
static Texture* s_spritetex66 = 0;
static Texture* s_spritetex67 = 0;
static Texture* s_spritetex68 = 0;
static Texture* s_spritetex69 = 0;
static Texture* s_spritetex70 = 0;
static Texture* s_spritetex71 = 0;
static Texture* s_spritetex72 = 0;
static Texture* s_spritetex73 = 0;
static Texture* s_spritetex74 = 0;
static Texture* s_spritetex75 = 0;
static Texture* s_spritetex76 = 0;
static Texture* s_spritetex77 = 0;
static Texture* s_spritetex78 = 0;
static Texture* s_spritetex79 = 0;
static Texture* s_spritetex80 = 0;
static Texture* s_spritetex81 = 0;
static Texture* s_spritetex82 = 0;
static Texture* s_spritetex83 = 0;
static Texture* s_spritetex84 = 0;
static Texture* s_spritetex85 = 0;
static Texture* s_spritetex86 = 0;
static Texture* s_spritetex87 = 0;
static Texture* s_spritetex88 = 0;
static Texture* s_spritetex89 = 0;
static Texture* s_spritetex90 = 0;
static Texture* s_spritetex91 = 0;
static Texture* s_spritetex92 = 0;
static Texture* s_spritetex93 = 0;

static Texture* s_spritetex_pushed1 = 0;
static Texture* s_spritetex_pushed2 = 0;
static Texture* s_spritetex_pushed5 = 0;
static Texture* s_spritetex_pushed6 = 0;
static Texture* s_spritetex_pushed7 = 0;
static Texture* s_spritetex_pushed55 = 0;
static Texture* s_spritetex_pushed56 = 0;
static Texture* s_spritetex_pushed57 = 0;
static Texture* s_spritetex_pushed63 = 0;
static Texture* s_spritetex_pushed64 = 0;
static Texture* s_spritetex_pushed65 = 0;
static Texture* s_spritetex_pushed66 = 0;
static Texture* s_spritetex_pushed67 = 0;
static Texture* s_spritetex_pushed68 = 0;
static Texture* s_spritetex_pushed69 = 0;
static Texture* s_spritetex_pushed70 = 0;
static Texture* s_spritetex_pushed85 = 0;
static Texture* s_spritetex_pushed71 = 0;
static Texture* s_spritetex_pushed72 = 0;
static Texture* s_spritetex_pushed73 = 0;
static Texture* s_spritetex_pushed74 = 0;
static Texture* s_spritetex_pushed75 = 0;
static Texture* s_spritetex_pushed76 = 0;
static Texture* s_spritetex_pushed77 = 0;
static Texture* s_spritetex_pushed78 = 0;
static Texture* s_spritetex_pushed61 = 0;
static Texture* s_spritetex_pushed62 = 0;


static Texture* s_spritetexCamera67 = 0;
static Texture* s_spritetexCamera_pushed67 = 0;
static Texture* s_spritetexCamera69 = 0;
static Texture* s_spritetexCamera_pushed69 = 0;
static Texture* s_spritetexCamera71 = 0;
static Texture* s_spritetexCamera_pushed71 = 0;
static Texture* s_spritetexCamera72 = 0;
static Texture* s_spritetexCamera_pushed72 = 0;
static Texture* s_spritetexCamera64 = 0;
static Texture* s_spritetexCamera_pushed64 = 0;



static int s_toolspritemode = 0;
static float s_spsize = 45.0f;//CheckResolution()でセットする
static float s_spsizeSmall = 26.0f;//CheckResolution()でセットする
static float s_sptopmargin = 35.0f;
static float s_spsidemargin = 35.0f;
static CSpElem s_spundo[2];
static CSpAxis s_spaxis[SPAXISNUM];
static CSpCam s_spcam[SPR_CAM_MAX];
static CSpElem s_sprig[SPRIGMAX];//inactive, active
//static CSpElem s_spbt;
static CSpElem s_spret2prev;
static CSpElem s_spret2prev2;
static CSpElem s_spcplw2w;
static CSpElem s_spsmooth;
static CSpElem s_spconstexe;
static CSpElem s_spconstrefresh;
static CSpElem s_spcopy;
static CSpElem s_spsymcopy;
static CSpElem s_sppaste;
static CSpElem s_spcopyhistory;
static CSpElem s_spinterpolate;
static CSpElem s_spjumpinterpolate;
static CSpElem s_spinit;
static CSpElem s_spscaleinit;
static CSpElem s_spproperty;
static CSpElem s_spzeroframe;
static CSpElem s_spcameradolly;
static CSpElem s_spmodelposdir;
static CSpElem s_spmaterialrate;
static CSpGUISW s_spguisw[SPGUISWNUM];
static CSpGUISW s_spdispsw[SPDISPSWNUM];
static CSpGUISW s_sprigidsw[SPRIGIDSWNUM];
static CSpGUISW s_spretargetsw[SPRETARGETSWNUM];
static CSpGUISW s_speffectsw[SPEFFECTSWNUM];
static bool s_firstmoveaimbar = true;
//static CSpGUISW s_spaimbar[SPAIMBARNUM];
//static CSpGUISW s_spmenuaimbar[SPMENU_MAX];
static int s_oprigflag = 0;
static CSpGUISW s_spsel3d;
static CSpElem s_spmousehere;
static CSpGUISW s_spikmodesw[3];
static CSpGUISW s_sprefpos;
static CSpGUISW s_splimiteul;
static CSpGUISW s_spscraping;
static CSpElem s_mousecenteron;
static CSpGUISW s_spcameramode;
static CSpGUISW3 s_spcamerainherit;
static InstancedSprite s_bcircle;
static Sprite s_kinsprite;
static CUndoSprite s_undosprite;
static CFpsSprite s_fpssprite;
static CSpElem s_spupperbar;

static CSpElem s_spcopy_camera;
static CSpElem s_sppaste_camera;
static CSpElem s_spinterpolate_camera;
static CSpElem s_spinit_camera;
static CSpElem s_spsmooth_camera;

typedef struct tag_modelpanel
{
	OrgWindow* panel;
	OWP_ScrollWnd* scroll;
	OWP_RadioButton* radiobutton;
	OWP_Separator* separator;
	OWP_Separator* separator2;
	vector<OWP_CheckBoxA*> checkvec;
	vector<OWP_Button*> delbutton;
	int modelindex;
	tag_modelpanel() {
		panel = 0;
		scroll = 0;
		radiobutton = 0;
		separator = 0;
		separator2 = 0;
		checkvec.clear();
		delbutton.clear();
		modelindex = 0;
	};
}MODELPANEL;
static MODELPANEL s_modelpanel;
static bool s_firstmodelpanelpos = true;
static WindowPos s_modelpanelpos;

typedef struct tag_motionpanel
{
	OrgWindow* panel;
	OWP_ScrollWnd* scroll;
	OWP_RadioButton* radiobutton;
	OWP_Separator* separator;
	vector<OWP_Button*> delbutton;
	int modelindex;

	tag_motionpanel() {
		panel = 0;
		scroll = 0;
		radiobutton = 0;
		separator = 0;
		delbutton.clear();
		modelindex = 0;
	};
}MOTIONPANEL;
static MOTIONPANEL s_motionpanel;
static bool s_firstmotionpanelpos = true;
static WindowPos s_motionpanelpos;

typedef struct tag_camerapanel
{
	OrgWindow* panel;
	OWP_ScrollWnd* scroll;
	OWP_RadioButton* radiobutton;
	OWP_Separator* separator;
	vector<OWP_Button*> delbutton;
	int modelindex;

	tag_camerapanel() {
		panel = 0;
		scroll = 0;
		radiobutton = 0;
		separator = 0;
		delbutton.clear();
		modelindex = 0;
	};
}CAMERAPANEL;
static CAMERAPANEL s_camerapanel;
static bool s_firstcamerapanelpos = true;
static WindowPos s_camerapanelpos;



static map<int, int> s_lineno2boneno;
static map<int, int> s_boneno2lineno;

static ChaScene* s_chascene = 0;
//static vector<MODELELEM> s_modelindex;
//static MODELBOUND	s_totalmb;
static int s_curmodelmenuindex = -1;
static int s_savemodelpanelshowposline = -1;
static int s_savemotionpanelshowposline = -1;
static int s_savecamerapanelshowposline = -1;

static WCHAR s_tmpmotname[256] = { 0L };
static double s_tmpmotframeleng = 100.0f;
//static double s_tmpmotframeleng = 5640.0f;
static int s_tmpmotloop = 1;

static WCHAR s_projectname[64] = { 0L };
static WCHAR s_projectdir[MAX_PATH] = { 0L };
static WCHAR s_chapath[MAX_PATH] = { 0 };
static WCHAR s_chasavename[64] = { 0 };
static WCHAR s_chasavedir[MAX_PATH] = { 0 };

static WCHAR s_REname[MAX_PATH] = { 0L };
static WCHAR s_Impname[MAX_PATH] = { 0L };
static WCHAR s_Gconame[MAX_PATH] = { 0L };

static bool s_cancelLButtonDown = false;
static bool s_cancelRButtonDown = false;


static int s_camtargetflag = 0;
static int s_camtargetOnceflag = 0;
static bool s_twistcameraFlag = false;
static bool s_rbuttonSelectFlag = false;
//CDXUTCheckBox* s_CamTargetCheckBox = 0;
////CDXUTCheckBox* s_LightCheckBox = 0;
//CDXUTCheckBox* s_ApplyEndCheckBox = 0;
////CDXUTCheckBox* s_SlerpOffCheckBox = 0;
////CDXUTCheckBox* s_AbsIKCheckBox = 0;
//CDXUTCheckBox* s_HighRpmCheckBox = 0;
//CDXUTCheckBox* s_BoneMarkCheckBox = 0;
//CDXUTCheckBox* s_LightingCheckBox = 0;
//CDXUTCheckBox* s_RigidMarkCheckBox = 0;
////CDXUTCheckBox* s_PseudoLocalCheckBox = 0;
////CDXUTCheckBox* s_WallScrapingIKCheckBox = 0;
////CDXUTCheckBox* s_LimitDegCheckBox = 0;
//CDXUTCheckBox* s_BrushMirrorUCheckBox = 0;
//CDXUTCheckBox* s_BrushMirrorVCheckBox = 0;
//CDXUTCheckBox* s_IfMirrorVDiv2CheckBox = 0;
////CDXUTCheckBox* s_VSyncCheckBox = 0;
//CDXUTCheckBox* s_TraRotCheckBox = 0;
//CDXUTCheckBox* s_PreciseCheckBox = 0;
//CDXUTCheckBox* s_X180CheckBox = 0;
//CDXUTCheckBox* s_TPoseCheckBox = 0;
////CDXUTCheckBox* s_EdgeSmpCheckBox = 0;
//
//
//CDXUTStatic* s_TipText1 = 0;
//CDXUTStatic* s_TipText2 = 0;
//CDXUTStatic* s_TipText3 = 0;
//CDXUTStatic* s_TipText4 = 0;
//CDXUTStatic* s_TipText5 = 0;

Font s_fontfortip;
bool s_dispfontfortip = false;
bool s_dispPickfortip = false;
WCHAR s_strfortip[512] = { 0 };
Vector2 s_fontposfortip;

static bool s_utcontrolvisible = true;
////Left
//static CDXUTControl* s_ui_fpskind = 0;
//static CDXUTControl* s_ui_lightscale = 0;
//static CDXUTControl* s_ui_lighting = 0;
//static CDXUTControl* s_ui_dispbone = 0;
//static CDXUTControl* s_ui_disprigid = 0;
//static CDXUTControl* s_ui_boneaxis = 0;
//static CDXUTControl* s_ui_bone = 0;
//static CDXUTControl* s_ui_locktosel = 0;
//static CDXUTControl* s_ui_iklevel = 0;
//static CDXUTControl* s_ui_editmode = 0;
//static CDXUTControl* s_ui_texapplyrate = 0;
//static CDXUTControl* s_ui_slapplyrate = 0;
//static CDXUTControl* s_ui_motionbrush = 0;
//static CDXUTControl* s_ui_texikorder = 0;
//static CDXUTControl* s_ui_slikorder = 0;
////static CDXUTControl* s_ui_texikrate = 0;
////static CDXUTControl* s_ui_slikrate = 0;
//static CDXUTControl* s_ui_texref = 0;
//static CDXUTControl* s_ui_slirefpos = 0;
//static CDXUTControl* s_ui_slirefalpha = 0;
//static CDXUTControl* s_ui_applytotheend = 0;
//static CDXUTControl* s_ui_slerpoff = 0;
////static CDXUTControl* s_ui_absikon = 0;
//static CDXUTControl* s_ui_highrpmon = 0;
//
//static CDXUTControl* s_ui_texbrushrepeats = 0;
//static CDXUTControl* s_ui_brushrepeats = 0;
//static CDXUTControl* s_ui_brushmirroru = 0;
//static CDXUTControl* s_ui_brushmirrorv = 0;
//static CDXUTControl* s_ui_ifmirrorvdiv2 = 0;
//static CDXUTControl* s_ui_precise = 0;
//static CDXUTControl* s_ui_x180 = 0;
//static CDXUTControl* s_ui_tpose = 0;
//
////Left 2nd
//static CDXUTControl* s_ui_texthreadnum = 0;
//static CDXUTControl* s_ui_slthreadnum = 0;
//static CDXUTControl* s_ui_umthreads = 0;
//static CDXUTControl* s_ui_slumthreads = 0;
////static CDXUTControl* s_ui_pseudolocal = 0;
//static CDXUTControl* s_ui_wallscrapingik = 0;
//static CDXUTControl* s_ui_limiteul = 0;
//static CDXUTControl* s_ui_texspeed = 0;
//static CDXUTControl* s_ui_speed = 0;
////static CDXUTControl* s_ui_vsync = 0;
//static CDXUTControl* s_ui_trarot = 0;
////static CDXUTControl* s_ui_edgesmp = 0;
//
//
////Bullet
//static CDXUTControl* s_ui_btstart = 0;
//static CDXUTControl* s_ui_btrecstart = 0;
//static CDXUTControl* s_ui_stopbt = 0;
//static CDXUTControl* s_ui_texbtcalccnt = 0;
//static CDXUTControl* s_ui_btcalccnt = 0;
//static CDXUTControl* s_ui_texerp = 0;
//static CDXUTControl* s_ui_erp = 0;
//
//
////PhysicsIK
//static CDXUTControl* s_ui_texphysmv = 0;
//static CDXUTControl* s_ui_slphysmv = 0;
//static CDXUTControl* s_ui_physrotstart = 0;
//static CDXUTControl* s_ui_physmvstart = 0;
//static CDXUTControl* s_ui_physikstop = 0;
//
////static bool s_guivisible_left = true;
////static bool s_guivisible_left2nd = true;
////static bool s_guivisible_bullet = true;
////static bool s_guivisible_physicsik = true;



//#define DEBUG_VS   // Uncomment this line to debug vertex shaders 
//#define DEBUG_PS   // Uncomment this line to debug pixel shaders 

bool g_4kresolution = false;

ChaVector3 g_vCenter(0.0f, 0.0f, 0.0f);


std::vector<void*> g_eulpool;//allocate EULPOOLBLKLEN EulKey at onse and pool 
std::vector<void*> g_keypool;//allocate KEYPOOLBLKLEN Key at onse and pool 


//static bool IsEditingCameraAnim();
static MOTINFO GetCameraMotInfo();
static MOTINFO GetEditTargetMotInfo();
static CBone* GetEditTargetOpeBone(int* pmotid, int* pframeleng);
static void CalcTotalBound();
static int SetCameraModel();
static void SetCamera3DFromEyePos();
static int ChangeCameraDist(float newcamdist, bool moveeyeposflag, bool calledbyslider);

//--------------------------------------------------------------------------------------
// Global variables
//--------------------------------------------------------------------------------------
////ID3DX11Font*                  g_pFont = NULL;         // Font for drawing text
////ID3DX11Sprite                g_pSprite = NULL;       // Sprite for batching draw text calls
//CDXUTTextHelper* g_pTxtHelper = NULL;

bool                        g_bShowHelp = true;     // If true, it renders the UI control text
//CModelViewerCamera* g_Camera = 0;// A model viewing camera
////ID3DX11Effect*                g_pEffect = NULL;       // D3DX effect interface
////ID3DXMesh*                  g_pMesh = NULL;         // Mesh object
//
////IDirect3DTexture10*          g_pMeshTexture = NULL;  // Mesh texture
////LPD3DXFONT                  g_pFont9 = NULL;         // Font for drawing text
//
//
//CDXUTDialogResourceManager  g_DialogResourceManager; // manager for shared resources of dialogs
////CD3DSettingsDlg             g_SettingsDlg;          // Device settings dialog
//CDXUTDialog                 g_HUD;                  // manages the 3D UI
//CDXUTDialog                 g_SampleUI;             // dialog for sample specific controls
bool                        g_bEnablePreshader;     // if TRUE, then D3DXSHADER_NO_PRESHADER is used when compiling the shader
//ChaMatrix               g_mCenterWorld;
ChaMatrix               g_mCenterWorld;


////#define MAX_LIGHTS 3
////CDXUTDirectionWidget g_LightControl[MAX_LIGHTS];
//CDXUTDirectionWidget g_LightControl[LIGHTNUMMAX];

ChaVector4 g_lightdirforshader[LIGHTNUMMAX];//有効なライトだけ格納
ChaVector4 g_lightdiffuseforshader[LIGHTNUMMAX];//有効なライトだけ格納
ChaVector4 g_lightdirforall[LIGHTNUMMAX];//2024/02/15 有効無効に関わらずオリジナルのインデックスで格納


//--------------------------------------------------------------------------------------
// UI control IDs
//--------------------------------------------------------------------------------------

//#####################
//ID_RMENU_0を足して使う
//#####################

//Dlgからのメニューオフセットはcoef.hに
//// (90)はCRetargetDlgをトリガーとする呼び出し用に確保
//#define MENUOFFSET_RETARGETDLG		(90)
//// (91)はCLightsDlgをトリガーとする呼び出し用に確保
//#define MENUOFFSET_LIGHTSDLG			(91)
//// (92)はCBlendShapeDlgをトリガーとする呼び出し用に確保
//#define MENUOFFSET_BLENDSHAPEDLG		(92)
//// (93)はCProjLodDlgをトリガーとする呼び出し用に確保
//#define MENUOFFSET_PROJLODDLG			(93)
//// (94)はCBulletDlgをトリガーとする呼び出し用に確保
//#define MENUOFFSET_BULLETDLG			(94)
//// (95)はCDispLimitsDlgをトリガーとする呼び出し用に確保
//#define MENUOFFSET_DISPLIMITSDLG		(95)
//// (96)はCRigidParamsDlgをトリガーとする呼び出し用に確保
//#define MENUOFFSET_RIGIDPARAMSDLG		(96)
//// (97)はCpInfoDlg2をトリガーとするCopyMotionFunc()呼び出し用に確保
//#define MENUOFFSET_CPINFODLG			(97)
//// (98)はDollyHistoryDlg2のOnSaveDolly()呼び出し用に確保
//#define MENUOFFSET_DOLLYHISTORYDLG		(98)
//// (99)はCopyHistoryDlg2のOnSearch()呼び出し用に確保
//#define MENUOFFSET_COPYHISTORYDLG		(99)


#define MENUOFFSET_SETCONVBONEMODEL		(100)
#define MENUOFFSET_SETCONVBONEBVH		(MENUOFFSET_SETCONVBONEMODEL + 100)
#define MENUOFFSET_SETCONVBONE			(MENUOFFSET_SETCONVBONEBVH + 100)
//#define MENUOFFSET_SETCONVBONE			(MENUOFFSET_SETCONVBONEBVH + 500)
#define MENUOFFSET_INITMPFROMTOOL		(MENUOFFSET_SETCONVBONE + MAXBONENUM)

#define MENUOFFSET_GETSYMROOTMODE		(MENUOFFSET_INITMPFROMTOOL + 100)
#define MENUOFFSET_INTERPOLATEFROMTOOL		(MENUOFFSET_GETSYMROOTMODE + 30)
#define MENUOFFSET_FILTERFROMTOOL		(MENUOFFSET_INTERPOLATEFROMTOOL + 30)
#define MENUOFFSET_CHECKSIMILARGROUP		(MENUOFFSET_FILTERFROMTOOL + 30)


//
#define MENUOFFSET_BRUSHESCONTEXTMENU		19500
//2024/03/23 MENUOFFSET_BRUSHESCONTEXTMENU から　(MENUOFFSET_BRUSHESCONTEXTMENU + MAXPLUGIN)まで使用


#define MENUOFFSET_BONERCLICK		20000
//################################################
//ID_RMENU_*は　MENUOFFSET_BONERCLICKを足して使う
//################################################
#define ID_RMENU_PHYSICSCONSTRAINT	(10)
#define ID_RMENU_KINEMATIC_ON_LOWER	(ID_RMENU_PHYSICSCONSTRAINT + 13)
#define ID_RMENU_KINEMATIC_OFF_LOWER	(ID_RMENU_PHYSICSCONSTRAINT + 14)

#define ID_RMENU_IKTARGET (ID_RMENU_PHYSICSCONSTRAINT + 15)
#define ID_RMENU_IKSTOP (ID_RMENU_PHYSICSCONSTRAINT + 16)
#define ID_RMENU_COPY (ID_RMENU_PHYSICSCONSTRAINT + 17)
#define ID_RMENU_PASTE (ID_RMENU_PHYSICSCONSTRAINT + 18)



#define IDC_TOGGLEFULLSCREEN    1
#define IDC_TOGGLEREF           3
#define IDC_CHANGEDEVICE        4
#define IDC_ENABLE_PRESHADER    5
#define IDC_NUM_LIGHTS          6
#define IDC_NUM_LIGHTS_STATIC   7
#define IDC_ACTIVE_LIGHT        8
#define IDC_LIGHT_SCALE         9
#define IDC_LIGHTING  10

#define IDC_COMBO_BONE			11
#define IDC_FK_XP				12
#define IDC_FK_XM				13
#define IDC_FK_YP				14
#define IDC_FK_YM				15
#define IDC_FK_ZP				16
#define IDC_FK_ZM				17

#define IDC_T_XP				18
#define IDC_T_XM				19
#define IDC_T_YP				20
#define IDC_T_YM				21
#define IDC_T_ZP				22
#define IDC_T_ZM				23

#define IDC_SPEED_STATIC		24
#define IDC_SPEED				25

#define IDC_CAMTARGET			26

#define IDC_COMBO_EDITMODE		27
#define IDC_IK_ROT				28
#define IDC_IK_MV				29
#define IDC_IK_LIGHT			30
#define IDC_BT_RIGID			31
#define IDC_BT_IMP				32
#define IDC_BT_GP				33
#define IDC_BT_DAMP				34

#define IDC_COMBO_IKLEVEL		35

#define IDC_LIGHT_DISP			36

#define IDC_SL_IKFIRST			37
#define IDC_SL_IKRATE			38
#define IDC_STATIC_IKFIRST		39
#define IDC_STATIC_IKRATE		40

#define IDC_SLERP_OFF			41
#define IDC_ABS_IK				42

#define IDC_SL_APPLYRATE			43
#define IDC_STATIC_APPLYRATE		44

#define IDC_APPLY_TO_THEEND			45
#define IDC_BMARK					46
#define IDC_PSEUDOLOCAL				47

#define IDC_COMBO_BONEAXIS			48
#define IDC_LIMITDEG				49

#define IDC_STATIC_BTCALCCNT		50
#define IDC_BTCALCCNT				51
#define IDC_STATIC_ERP0				52
#define IDC_ERP						53

#define IDC_PHYSICS_IK				54
#define IDC_BTSTART					55
#define IDC_PHYSICS_MV_IK				56
#define IDC_PHYSICS_MV_SLIDER			57
#define IDC_STATIC_PHYSICS_MV_SLIDER	58
//#define IDC_APPLY_BT				59
#define IDC_STOP_BT					60

#define IDC_SL_NUMTHREAD			61
#define IDC_STATIC_NUMTHREAD		62

#define IDC_COMBO_MOTIONBRUSH_METHOD	63
#define IDC_RMARK					64

#define IDC_PHYSICS_IK_STOP			65
#define IDC_BTRECSTART				66

#define IDC_STATIC_BRUSHREPEATS		67
#define IDC_SL_BRUSHREPEATS			68
#define IDC_BRUSH_MIRROR_U			69
#define IDC_BRUSH_MIRROR_V			70
#define IDC_BRUSH_MIRROR_V_DIV2		71

#define IDC_IK_SC					72

#define IDC_SL_REFPOSSTEP			73
#define IDC_SL_REFARROW				74
#define IDC_STATIC_REF				75
#define IDC_SL_REFALPHA				76

#define IDC_WALLSCRAPINGIK			77
#define IDC_HIGHRPM					78
#define IDC_SL_UMTHREADS			79
#define IDC_STATIC_UMTHREADS		80

//#define IDC_VSYNC					81
#define IDC_PRECISEONPREVIEWTOO		82
#define IDC_TPOSE_MANIPULATOR		83

#define IDC_TRAROT					84
#define IDC_COMBO_FPS				85
#define IDC_X180					86

#define IDC_TIPRIG1					87
#define IDC_TIPRIG2					88
#define IDC_TIPRIG3					89
#define IDC_TIPRIG4					90
#define IDC_TIPRIG5					91
//#define IDC_EDGESMP					88


HWND g_mainhwnd = NULL;//アプリケーションウインドウハンドル
HWND g_hWnd = NULL;//3Dウィンドウハンドル。


//ゲームの初期化。
RECT InitGame(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPWSTR lpCmdLine, int nCmdShow, const TCHAR* appName, HWND srcparentwnd,
	int srcposx, int srcposy,
	int srcwidth, int srcheight);
//ウィンドウメッセージをディスパッチ。falseが返ってきたら、ゲーム終了。
bool DispatchWindowMessage();
int OnCreateDevice();


//##########################
//MessageProc of Main Window
//##########################
LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static void InitApp();
static int CheckResolution();
static HWND CreateMainWindow();
static void InitRootSignature(RootSignature& rs);
static void OnDestroyDevice();
static int InitPluginMenu();
static int OnPluginClose();

//##########################
//MessageProc of 3d window
//##########################
LRESULT CALLBACK AppMsgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static HWND Create3DWnd(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd);
static void OnUserFrameMove(double fTime, float fElapsedTime, int* ploopstartflag);
static void OnFrameRender(myRenderer::RenderingEngine* re, RenderContext* rc, 
	double fTime, float fElapsedTime, int loopstartflag);

//################
//GUI Plate Menu
//################
static bool GUIGetNextMenu(POINT ptCursor, int srcmenukind, int* dstmenukind, int* dstplateno);
static void GUIMenuSetVisible(int srcmenukind, int srcplateno);
static void ChangeToNextPlateMenuKind(int srcmenukind, int srcmenuno);
static void ChangeToNextPlateMenuPlate(int srcmenukind, int srcmenuno);
static void GUISetVisible(int srcplateno);
static void GUISetVisible_CameraAndIK();
static void GUISetVisible_DispAndLimits();
//static void GUISetVisible_BrushParams();
static void GUISetVisible_Bullet();
static void GUISetVisible_LOD();
void GUISetVisible_BlendShape();
static void GUISetVisible_AimBar();
static void GUIDispSetVisible(int srcplateno);

static void ShowLightsWnd(bool srcflag);
static void ShowGUIDlgDispParams(bool srcflag);
//static void ShowGUIDlgBrushes(bool srcflag);
static void ShowGUIDlgBullet(bool srcflag);
static void ShowGUIDlgLOD(bool srcflag);
static void ShowGUIDlgBlendShape(bool srcflag);
static void CloseAllRightPainWindow(bool closefirstrow);
static void CloseAllAndDispPlaceFolder();
static void CloseTheFirstRowGUI();


static void ShowLaterTransparentWnd(bool srcflag);
static void ShowShadowParamsWnd(bool srcflag);
static void ShowDispGroupWnd(bool srcflag);
static void GUIRigidSetVisible(int srcplateno);
static void ShowRigidWnd(bool srcflag);
static void ShowImpulseWnd(bool srcflag);
static void ShowGroundWnd(bool srcflag);
static void ShowDampAnimWnd(bool srcflag);
static void GUIRetargetSetVisible(int srcplateno);
static void ShowRetargetWnd(bool srcflag);
static void ShowLimitEulerWnd(bool srcflag);
static void ShowThresholdWnd(bool srcflag);
static void GUIEffectSetVisible(int srcplateno);
static void ShowSkyWnd(bool srcflag);
static void ShowFogWnd(bool srcflag);
static void ShowDofWnd(bool srcflag);


static CInfoWindow* CreateInfoWnd();
static int CreateSprites();
static void InitSprites();
static void DestroySprites();


//#################################
//For DualSence GamePad Controller
//#################################
static HWND GetOFWnd(POINT srcpoint);
static BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam);
static HWND GetNearestEnumDist();
static BOOL CALLBACK EnumIDOKProc(HWND hwnd, LPARAM lParam);
static BOOL CALLBACK EnumTreeViewProc(HWND hwnd, LPARAM lParam);
void CALLBACK WinEventProc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread, DWORD dwmsEventTime);
static void DSMessageBox(HWND srcparenthwnd, const WCHAR* srcmessage, const WCHAR* srctitle, LONG srcok);


static CModel* s_pickmodel = nullptr;
static CMQOObject* s_pickmqoobj = nullptr;
static CMQOMaterial* s_pickmaterial = nullptr;
static CModel* s_befpickmodel = nullptr;
static CMQOObject* s_befpickmqoobj = nullptr;
static CMQOMaterial* s_befpickmaterial = nullptr;
static ChaVector3 s_pickhitpos = ChaVector3(0.0f, 0.0f, 0.0f);

static CModel* s_befselectmodel = nullptr;
static CMQOObject* s_befselectmqoobj = nullptr;
static CMQOMaterial* s_befselectmaterial = nullptr;
static bool GetResultOfPickRay();


static int DispToolTip();
static int CreateToolTip(POINT ptCursor, WCHAR* srctext);
static int CreateTipRig(CBone* currigbone, int currigno, POINT ptCursor);
static bool DispTipUI();
static bool DispTipUIFrog();
static bool DispTipRig();
static bool DispTipMesh();
static bool DispTipMaterial();
static bool DispTipBone();
static bool DispTipSelect();

static int ClearLimitedWM(CModel* srcmodel);

static float CalcSelectScale();
static double CalcRefFrame();
static void ChangeCurDirFromMameMediaToTest();

static int SetModel2Dlgs(CModel* srcmodel);


//static int CreateCameraDollyWnd();//2023/08/23 CreateDollyHistoryDlg()に移行
static int CreateDollyHistoryDlg();
static int ShowCameraDollyDlg();
static int CreateMaterialRateWnd();
static int ShowMaterialRateDlg();
static int SetModel2MaterialRateDlg(CModel* srcmodel);
static int CreateModelWorldMatWnd();
static int SetModel2ModelWorldMatDlg(CModel* srcmodel);
static int ShowModelWorldMatDlg();
static int GetModelWorldMat(ChaVector3* dstpos, ChaVector3* dstrot);
static int SetModelWorldMat();
static int CreateJumpGravityWnd();
static int ShowJumpGravityDlg();

//static void CheckShaderTypeButton(HWND hDlgWnd, int srcshadertype);//DispAndLimitプレートメニュー用

//#################################################
//ShaderPlateMenuプッシュで表示するOWPのShaderTypeWnd
//#################################################
static void ShowShaderTypeWnd(bool srcflag);//マテリアルリストの方

//#######################################################
//OWPのShaderTypeWndウインドウから呼び出すparamsDlg
//#######################################################
static int ShowShaderTypeParamsDlg(bool srcflag);//params設定用
static int OnFrameShaderTypeParamsDlg();//params設定用　//OnFrameToolWnd()から呼び出す

static int SetSkyParamsToSky(CShaderTypeParams srcparams);//ファイルからの設定用
static void ShowSkyWnd(bool srcflag);
static int OnFrameSkyParamsDlg();//OnFrameToolWnd()から呼び出す

static int CreateDofParamsDlg();//params設定用　OWPでは無い方
static int DofParams2Dlg();//params設定用　OWPでは無い方



void CALLBACK OnKeyboard(UINT nChar, bool bKeyDown, bool bAltDown, void* pUserContext);
//void CALLBACK OnGUIEvent(UINT nEvent, int nControlID, CDXUTControl* pControl, void* pUserContext);


LRESULT CALLBACK OpenMqoDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK MotPropDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK CameraDollyDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK MaterialRateDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ModelWorldMatDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK JumpGravityDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ShaderTypeParamsDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK OpenBvhDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK SaveChaDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK ExportXDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK SaveREDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK SaveImpDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK SaveGcoDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK CheckAxisTypeProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK RotAxisDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK CustomRigDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK AboutDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK bvh2FbxBatchDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK RetargetBatchDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CALLBACK ProgressDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp);


//static int OwnerDrawLightColorBar(HWND hDlgWnd, int lightindex, int idcolorbar);
//static int ChooseLightColorBar(HWND hDlgWnd, int lightindex, int idcolorbar);

//static int OwnerDrawFogColorBar(HWND hDlgWnd, int lightindex, int idcolorbar);
//static int ChooseFogColorBar(HWND hDlgWnd, int lightindex, int idcolorbar);




bool ChkEnableIK();

//HRESULT LoadMesh( ID3D12Device* pd3dDevice, WCHAR* strFileName, ID3DXMesh** ppMesh );
void CalcFps(double fTime);
static int RetargetFile(char* fbxpath);

static int OnMouseMoveFunc();
static int OnCameraAnimMouseMove(int opekind, int pickxyz, float deltax);
static int OnCameraAnimPaste();

static int RollbackCurBoneNo();
static void PrepairUndo();
static void PrepairUndo_SelectModel(CModel* befmodel, CModel* nextmodel);
static void PrepairUndo_BlendShape(CBlendShapeElem srcblendshapeelem);
static void RollbackBrushState(BRUSHSTATE srcbrushstate);
static void RollbackUndoCamera(UNDOCAMERA srcundocamera);
static int OnFrameUndo(bool fromds, int fromdskind);
static int OnSpriteUndo();
static int SetShowPosTime();
//static int CallFilterFunc(int callnum);
static int FilterFuncDlg();
static int FilterNoDlg(bool copylw2w, CModel* srcmodel, int curmotid);

static void SavePlayingStartEnd();
static void SetButtonStartEndFromPlaying();

static void AutoCameraTarget();

static bool UnderDragOperation_L();
static bool UnderDragOperation_R();
static bool IsClickedSpriteButton();
static int CreateTimelineWnd();
static int CreateLongTimelineWnd();
static int CreateSideMenuWnd();
static int Params2SideMenuWnd();
static int CreateTopSlidersWnd();
static int Params2TopSlidersWnd();
static int CreateToolWnd();
static int CreateLayerWnd();
static int CreatePlaceFolderWnd();


static void InitTimelineSelection();
static void ClampTimelineSelection();

static int CheckSimilarMenu();//context menu

static int SetLightDirection();

static int OnFrameBlendShape();
static int UpdateCameraPosAndTarget();
static int OnFrameAngleLimit(bool updateonlycheckeul);
static int OnFrameLightsForEdit();
static int OnFrameKeyboard();
static bool FocusEditWnd();
static int ChangeToolSpriteMode();
static int OnFrameUtCheckBox();
static int OnFrameProcessTime(double difftime, double* pnextframe, int* pendflag, int* ploopstartflag);
static int OnFrameProcessCameraTime(double difftime, double* pnextframe, int* pendflag, int* ploopstartflag);
static int OnFramePreviewCamera(double nextframe);
static int OnFramePreviewStop();
static int OnFramePreviewNormal(double nextframe, double difftime, int endflag, int loopstartflag);
static int OnFramePreviewBt(double nextframe, double difftime, int endflag, int loopstartflag);
//int OnFramePreviewBtAftFunc(double nextframe, CModel* curmodel);
//static int OnFramePreviewRagdoll(double* pnextframe, double* pdifftime);
static int OnFrameCloseFlag();
static int OnFrameTimeLineWnd();
static int OnFrameMouseButton();
static int OnFrameToolWnd();
static int OnFrameStartPreview(double curtime, double* psavetime);
static int OnFrameBatchThread();
//static int OnFrame();
static int OnFrameUpdateGround();
static int OnFrameInitBtWorld();

int StopBtRec();
static int ToggleRig();
//static void UpdateBtSimu(double nextframe, CModel* curmodel);
//static void SetKinematicToHand(CModel* srcmodel, bool srcflag);
//static void SetKinematicToHandReq(CModel* srcmodel, CBone* srcbone, bool srcflag);
static void DispProgressCalcLimitedWM();

static int OnRenderModel(RenderContext* pRenderContext);
static int OnRenderOnlyOneObj(myRenderer::RenderingEngine* re, RenderContext* rc);
static int OnRenderRefPos(myRenderer::RenderingEngine* re, CModel* curmodel);
static int OnRenderGround(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderBoneMark(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderSelect(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderSprite(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderFontForTip(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int OnRenderUtDialog(RenderContext* pRenderContext, float fElapsedTime);
static int OnRenderSky(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);

static int DispCpInfoDlg2(CModel* srcmodel, MOTINFO* curmi, int srctype);//srctype:0->copy, 1->cameracopy, 2->symcopy
static int CopyMotionFunc(CModel* srcmodel, MOTINFO* curmi);
static int PasteMotionFunc(CModel* srcmodel, MOTINFO* curmi);
static int InterpolateMotionFunc(CModel* srcmodel, MOTINFO* curmi);
static int PasteMotionPoint(int curmotid, CBone* srcbone, CMotionPoint srcmp, double newframe);
static int PasteNotMvParMotionPoint(CModel* srcmodel, CBone* srcbone, int curmotid,
	double copystarttime, double srcframe, double srcframe2, double interpolaterate, 
	double dststartframe, double newframe);
static int PasteMotionPointJustInTerm(CModel* srcmodel, int curmotid, double copyStartTime, double copyEndTime, double startframe, double endframe);
//static int PasteMotionPointAfterCopyEnd(double copyStartTime, double copyEndTime, double startframe, double endframe);
static CMotionPoint CalcPasteMotionPoint(CBone* srcbone, double srcframe, double srcframe2, double interpolaterate);
static void ResetPasteDoneFlagReq(CBone* srcbone);


static int ChangeCurrentBone(int prepairundoflag);
static int ChangeLimitDegFlag(bool srcflag, bool setcheckflag, bool updateeulflag);
static int ChangeWallScrapingIKFlag(bool srcflag);
static int ChangeCameraMode(int forcemode);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2
static int ChangeCameraInherit();

static int InitCurMotion(int selectflag, double expandmotion);

static int OpenChaFile();
static int PostOpenChaFile();//2024/04/17 常駐スライダーなどに読込値を反映する
CModel* OpenMQOFile();
CModel* OpenFBXFile(bool callfromcha, bool dorefreshtl, int skipdefref, int inittimelineflag, std::vector<std::string> ikstopname, bool srcgrassflag);
static int OpenREFile();
static int OpenImpFile();
static int OpenGcoFile();
static int OpenMNLFile();

int OnDelMotion(int delindex, bool ondelbutton = false);
int OnAddMotion(int srcmotid, bool dorefreshtl);

static int StartBt(CModel* curmodel, BOOL isfirstmodel, int flag, int btcntzero);
static int StopBt();
static int GetShaderHandle();
static int SetBaseDir();
static int LoadIniFile();
static int SaveIniFile();
static int LoadChooseColor();
static int SaveChooseColor();
static int LoadLightsForEdit();
static int SaveLightsForEdit();
static int LoadThreshold();
static int SaveThreshold();
static int LoadShadowParamsFile();
static int SaveShadowParamsFile();
static int LoadSkyParamsFile();
static int SaveSkyParamsFile();
static int LoadFogParamsFile();
static int SaveFogParamsFile();
static int LoadDofParamsFile();
static int SaveDofParamsFile();

static int OpenFile();
static int BVH2FBX();
static void FindF(std::vector<wstring>& out, const wstring& directory, const wstring& findext);
static int BVH2FBXBatch();
static int RetargetBatch();
static int SaveBatchHistory(WCHAR* selectname);
static int GetBatchHistoryDir(WCHAR* dstname, int dstlen);
static int Savebvh2FBXHistory(WCHAR* selectname);
static int SaveRtgHistory(WCHAR* selectname);
static int GetbvhHistoryDir(std::vector<wstring>& dstvecopenfilename);
static int GetchaHistoryDir(std::vector<wstring>& dstvecopenfilename, int filter_cha);
static int GetCPTFileName(std::vector<HISTORYELEM>& dstcptfilename);
static int GetRtgHistoryDir(std::vector<wstring>& dstvecopenfilename);
static int SaveProject();
static int SaveREFile();
static int SaveImpFile();
static int SaveGcoFile();
static int ExportFBXFile();

static void refreshTimeline(OWP_Timeline& timeline);
static int refreshEulerGraph();
static int AddBoneTra(int kind, float srctra);
static int AddBoneTra2(ChaVector3 diffvec);
//static int AddBoneTraPhysics(ChaVector3 diffvec);

static int AddBoneScale(int kind, float srctra);
static int AddBoneScale2(ChaVector3 diffvec);

static int DispMotionWindow();
static int DispToolWindow();
static int DispObjPanel();
static int DispModelPanel();
static int DispMotionPanel();
static int DispCameraPanel();
static int DispRotAxisDlg();
static int DispCustomRigDlg(int rigno);
static int InvalidateCustomRig(int rigno);
static int BoneRClick(int srcboneno);
static int BrushesContextMenu();

//CustomRigDlg
static int Bone2CustomRig(int rigno);
static int CustomRig2Bone();
static int GetCustomRigRateVal(HWND hDlgWnd, int resid, float* dstptr);
static int CustomRig2Dlg(HWND hDlgWnd);
static int SetCustomRigDlgLevel(HWND hDlgWnd, int levelnum);
static int SetRigRigCombo(HWND hDlgWnd, int elemno);
static int CheckRigRigCombo(HWND hDlgWnd, int elemno);
static int EnableRigAxisUV(HWND hDlgWnd);

//angle limit dlg
static int UpdateAfterEditAngleLimit(int limit2boneflag, bool setcursorflag = true);//2022/12/06


static int CopyWorldToLimitedWorld(CModel* srcmodel);
static int CopyLimitedWorldToWorld(CModel* srcmodel, bool allframeflag, bool setcursorflag,
	int operatingjointno, bool onpasteflag);
static int ApplyNewLimitsToWM(CModel* srcmodel);
static int ApplyNewLimitsToWMSelected();

static int InitRotAxis();
static int RotAxis(HWND hDlgWnd);

static int EraseKeyList();
static int DestroyTimeLine(int dellist);
static int AddTimeLine(int newmotid, bool dorefreshtl);
static int AddMotion(const WCHAR* wfilename, double srcleng = 0.0);
static int OnCameraMenu(bool dorefreshflag, int selindex, int saveundoflag = 1);
static int OnAnimMenu(bool dorefreshflag, int selindex, int saveundoflag = 1);
static int OnRgdMorphMenu(int selindex);
static int AddModelBound(MODELBOUND* mb, MODELBOUND* addmb);
static int OnSetMotSpeed();

static int OnModelMenu(bool dorefreshtl, int selindex, int callbymenu);
static int OnChangeModel(CModel* selmodel, bool forceflag, bool callundo);
static int OnChangeModel(int selindex, bool forceflag, bool callundo);
static int SetTimelineHasRigFlag();
static int OnREMenu(int selindex, int callbymenu);
static int OnRgdMenu(int selindex, int callbymenu);
static int OnImpMenu(int selindex);
static int OnDelModel(int delindex, bool ondelbutton = false);
static int OnDispModel(int dispindex);
static int OnDelAllModel();
static int refreshModelPanel();
//static int refreshMotionPanel();
static int RenderSelectMark(myRenderer::RenderingEngine* re, RenderContext* pRenderContext, int renderflag);
static int RenderSelectFunc(myRenderer::RenderingEngine* re);
static int RenderSelectPostureFunc(myRenderer::RenderingEngine* re);
static int RenderRigMarkFunc(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static int SetSelectState();
static int RenderGrass(myRenderer::RenderingEngine* re, RenderContext* pRenderContext);
static void DestroyGrassElem();

static void ResetRigModelNum();
static CModel* GetCurRigModel(CUSTOMRIG currig, int* pinstanceno, ChaVector4* prigmat);
static CFrameCopyDlg* GetCurrentFrameCopyDlg(bool cameraflag);

static int CreateModelPanel();
static int DestroyModelPanel();
static int CreateMotionPanel();
static int DestroyMotionPanel();
static int CreateCameraPanel();
static int DestroyCameraPanel();
//static int CreateConvBoneWnd();
//static int DestroyConvBoneWnd();
static int SetConvBoneModel();
static int SetConvBoneBvh();
static int SetConvBone(int cbno);
static int SaveRetargetFile();
static int LoadRetargetFile(WCHAR* srcfilename);
static int SaveMotionNameListFile();
//static int LoadMotionNameListFile(WCHAR* srcfilename);
static int SetJointPair2ConvBoneWnd();
static int InitJointPair2ConvBoneWnd();


//static int ConvBoneConvert();//--> RetargetMotion()に改名
static int RetargetMotion();

//AdditiveIKLibのRetarget.h, Retarget.cppへ移動
//static void ConvBoneConvertReq(CBone* modelbone, double srcframe, CBone* befbvhbone, float hrate);
//static int ConvBoneRotation(int selfflag, CBone* srcbone, CBone* bvhbone, double srcframe, CBone* befbvhbone, float hrate);


static int CalcTargetPos(ChaVector3* dstpos);
static int CalcPickRay(ChaVector3* start3d, ChaVector3* end3d);
static void ActivatePanel(int state);
static int SetCamera6Angle();

static bool PickAndSelectMeshOfDispGroupDlg();
static bool PickAndSelectMaterialOfShaderTypeDlg();
static bool PickAndPut();

static int SetSpParams();
static int SetSpSel3DParams();
static int SetSpAimBarParams();
static int SetSpMenuAimBarParams();
static int SetSpAxisParams();
static int SetSpUndoParams();
static int SetSpMouseCenterParams();
static int PickSpAxis(POINT srcpos);
static int PickSpUndo(POINT srcpos);
static int PickBone(UIPICKINFO* ppickinfo);

static int SetSpGUISWParams();
static int PickSpGUISW(POINT srcpos);
static int SetSpDispSWParams();
static int PickSpDispSW(POINT srcpos);
static int SetSpRigidSWParams();
static int PickSpRigidSW(POINT srcpos);
static int SetSpRetargetSWParams();
static int PickSpRetargetSW(POINT srcpos);
static int SetSpEffectSWParams();
static int PickSpEffectSW(POINT srcpos);
static int SetSpCamParams();
static int PickSpCam(POINT srcpos);
static int SetSpRigParams();
static int PickSpRig(POINT srcpos);
static int SetSpCpLW2WParams();
static int PickSpCpLW2W(POINT srcpos);
static int SetSpSmoothParams();
static int PickSpSmooth(POINT srcpos);
static int SetSpLimitEulSWParams();
static int PickSpLimitEulSW(POINT srcpos);
static int SetSpScrapingSWParams();
static int PickSpScrapingSW(POINT srcpos);
static int SetSpConstExeParams();
static int PickSpConstExe(POINT srcpos);
static int SetSpConstRefreshParams();
static int PickSpConstRefresh(POINT srcpos);
static int SetSpCameraModeSWParams();
static int PickSpCameraModeSW(POINT srcpos);
static int SetSpCameraInheritSWParams();
static int PickSpCameraInheritSW(POINT srcpos);
static int SetSpUpperBarParams();


static int SetSpRet2PrevParams();
static bool PickSpFrog(POINT srcpos);
static bool PickSpFrog2(POINT srcpos);

static int SetSpCameraCommandParams();
static int PickSpCopyCamera(POINT srcpos);
static int PickSpPasteCamera(POINT srcpos);
static int PickSpInitCamera(POINT srcpos);
static int PickSpInterpolateCamera(POINT srcpos);
static int PickSpSmoothCamera(POINT srcpos);

static int SetSpCopyParams();
static int PickSpCopy(POINT srcpos);
static int SetSpSymCopyParams();
static int PickSpSymCopy(POINT srcpos);
static int SetSpPasteParams();
static int PickSpPaste(POINT srcpos);
static int SetSpCopyHistoryParams();
static int PickSpCopyHistory(POINT srcpos);

static int SetSpInterpolateParams();
static int PickSpInterpolate(POINT srcpos);
static int SetSpInitParams();
static int PickSpInit(POINT srcpos);
static int SetSpScaleInitParams();
static int PickSpScaleInit(POINT srcpos);
static int SetSpPropertyParams();
static int PickSpProperty(POINT srcpos);

static int SetSpZeroFrameParams();
static int PickSpZeroFrame(POINT srcpos);
static int SetSpCameraDollyParams();
static int PickSpCameraDolly(POINT srcpos);
static int SetSpModelPosDirParams();
static int PickSpModelPosDir(POINT srcpos);
static int SetSpMaterialRateParams();
static int PickSpMaterialRate(POINT srcpos);


static int PickRigBone(UIPICKINFO* ppickinfo, bool forrigtip = false, int* dstrigno = 0);
static ChaMatrix CalcRigMat(CUSTOMRIG* currig, CBone* curbone, int curmotid, double curframe, int dispaxis, int disporder, bool posinverse);

static int PickManipulator(UIPICKINFO* ppickinfo, bool pickring);



//static int SetSpBtParams();
//static int PickSpBt(POINT srcpos);
static int SetSpMouseHereParams();
static int SetSpIkModeSWParams();
static int PickSpIkModeSW(POINT srcpos);
static int SetSpRefPosSWParams();
static int PickSpRefPosSW(POINT srcpos);



static int InsertCopyMP(bool limitdegflag, CBone* curbone, double curframe, MOTINFO* curmi);
static void InsertCopyMPReq(bool limitdegflag, CBone* curbone, double curframe, MOTINFO* curmi);
static int InsertSymMP(bool limitdegflag, CBone* curbone, double curframe, int symrootmode);
static void InsertSymMPReq(bool limitdegflag, CBone* curbone, double curframe, int symrootmode);

static int JumpInterpolateFromTool();
static int InterpolateFromTool();
static int FilterFromTool();
static int InitMpFromTool();
//static int InitMP( CBone* curbone, double curframe );
//static void InitMPReq(CBone* curbone, double curframe);
static int InitMpByEul(int initmode, CBone* curbone, int srcmotid, double srcframe);
static void InitMpByEulReq(int initmode, CBone* curbone, int srcmotid, double srcframe, bool broflag);
static void InitMpByEulEndJointReq(int initmode, CBone* curbone, int srcmotid, double srcframe, bool broflag);

static void SkipJointMarkReq(int srcstate, CBone* srcbone, bool setbrotherflag);

static int AdjustBoneTra(CBone* curbone, double frame);
static int CreateTimeLineMark(int topboneno = -1);
static void CreateMarkReq(int curboneno, int broflag);
static int SetLTimelineMark(int curboneno);
static int SetTimelineMark();
static int CreateMotionBrush(double srcstart, double srcend, bool onrefreshflag);
static int SetBrushName();

static int ExportBntFile();

static const int s_appindex = 1;

static void AboutMotionBrush();
static int s_registflag = 1;//!!!!!!!!!!!
static HKEY s_hkey;
static int RegistKey();
static int IsRegist();

static int TimelineCursorToMotion();
int OnTimeLineCursor();
static int OnTimeLineButtonSelectFromSelectStartEnd(int tothelastflag);
static int OnTimeLineSelectFromSelectedKey();
static int OnTimeLineMButtonDown(bool ctrlshiftflag);
static int OnTimeLineWheel();
static int AddEditRangeHistory();
static int RollBackEditRange(int prevrangeFlag, int nextrangeFlag);
static int RecalcBoneAxisX(CBone* srcbone);
static void RecalcAxisX_All();

static int GetSymRootMode();

static int UpdateEditedEuler();


static void SetDlgHistory(HWND hDlgWnd, std::vector<wstring> vecopenfilename, int pagenum, int currentpage);
static bool FindAtTheLast(std::wstring const& strsource, std::wstring const& strpat);


static int ChangeUpdateMatrixThreads();

static CGrassElem* FindGrassElem(CModel* srcmodel);


static std::wstring ReplaceString
(
	std::wstring String1  // 置き換え対象
	, std::wstring String2  // 検索対象
	, std::wstring String3  // 置き換える内容
);


std::wstring ReplaceString
(
	std::wstring String1  // 置き換え対象
	, std::wstring String2  // 検索対象
	, std::wstring String3  // 置き換える内容
)
{
	std::wstring::size_type  Pos(String1.find(String2));

	while (Pos != std::string::npos)
	{
		String1.replace(Pos, String2.length(), String3);
		Pos = String1.find(String2, Pos + String3.length());
	}

	return String1;
}

//#############################################
//保存時のダイアログの初期フォルダ設定用　メモ
//#############################################
//// パス取得バッファ
//TCHAR waFolderPath[MAX_PATH];
//// デスクトップのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_DESKTOP, 0);
//// デスクトップのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_DESKTOPDIRECTORY, 0);
//// スタートメニューのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_STARTMENU, 0);
//// Program Filesのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PROGRAMS, 0);
//// Startupのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_STARTUP, 0);
//// Startup(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_ALTSTARTUP, 0);
//// My Documentsのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PERSONAL, 0);
//// お気に入りのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_FAVORITES, 0);
//// ゴミ箱のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_RECENT, 0);
//// Sendtoのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_SENDTO, 0);
//// NetHoodのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_NETHOOD, 0);
//// Fontsのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_FONTS, 0);
//// ShellNewのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_TEMPLATES, 0);
//// AppDataのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_APPDATA, 0);
//// PrintHoodのバスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PRINTHOOD, 0);
//// INetキャッシュのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_INTERNET_CACHE, 0);
//// INet Cookiesのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COOKIES, 0);
//// 履歴のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_HISTORY, 0);
//// デスクトップ(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_DESKTOPDIRECTORY, 0);
//// スタートメニュー(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_STARTMENU, 0);
//// Program Files(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_PROGRAMS, 0);
//// スタートアップ(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_STARTUP, 0);
//// スタートアップ(AllUser)のパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_ALTSTARTUP, 0);
//// お気に入りのパスを取得
//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_COMMON_FAVORITES, 0);
//実行結果
//CSIDL_DESKTOP : C:\Users\testuser\Desktop
//CSIDL_DESKTOPDIRECTORY : C:\Users\testuser\Desktop
//CSIDL_STARTMENU : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Start Menu
//CSIDL_PROGRAMS : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Start Menu\Programs
//CSIDL_STARTUP : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
//CSIDL_ALTSTARTUP : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
//CSIDL_PERSONAL : C:\Users\testuser\Documents
//CSIDL_FAVORITES : C:\Users\testuser\Favorites
//CSIDL_RECENT : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Recent
//CSIDL_SENDTO : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\SendTo
//CSIDL_NETHOOD : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Network Shortcuts
//CSIDL_FONTS : C:\WINDOWS\Fonts
//CSIDL_TEMPLATES : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Templates
//CSIDL_APPDATA : C:\Users\testuser\AppData\Roaming
//CSIDL_PRINTHOOD : C:\Users\testuser\AppData\Roaming\Microsoft\Windows\Printer Shortcuts
//CSIDL_INTERNET_CACHE : C:\Users\testuser\AppData\Local\Microsoft\Windows\INetCache
//CSIDL_COOKIES : C:\Users\testuser\AppData\Local\Microsoft\Windows\INetCookies
//CSIDL_HISTORY : C:\Users\testuser\AppData\Local\Microsoft\Windows\History
//CSIDL_COMMON_DESKTOPDIRECTORY : C:\Users\Public\Desktop
//CSIDL_COMMON_STARTMENU : C:\ProgramData\Microsoft\Windows\Start Menu
//CSIDL_COMMON_PROGRAMS : C:\ProgramData\Microsoft\Windows\Start Menu\Programs
//CSIDL_COMMON_STARTUP : C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup
//CSIDL_COMMON_ALTSTARTUP : C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup
//CSIDL_COMMON_FAVORITES : C:\Users\testuser\Favorites



LRESULT CALLBACK AboutDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);
		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
		}
	case WM_CLOSE:
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}


void AboutMotionBrush()
{
	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_DIALOG1),
		s_3dwnd, (DLGPROC)AboutDlgProc);

}



int RegistKey()
{
	/*
		CRegistDlg dlg;
		dlg.DoModal();

		if( strcmp( s_appkey[ s_appindex ], dlg.m_regkey ) == 0 ){
			if( s_registflag == 0 ){
				LONG lret;
				DWORD dwret;
				lret = RegCreateKeyExA( HKEY_CURRENT_USER, "Software\\OchakkoLab\\AdditiveIK_0003", 0, "",
					REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &s_hkey, &dwret );
				if( dwret == REG_CREATED_NEW_KEY ){
					lret = RegSetValueExA( s_hkey, "registkey", 0, REG_SZ, (LPBYTE)(dlg.m_regkey), sizeof(char) * 36 );
					if( lret != ERROR_SUCCESS ){
						::MessageBoxA( NULL, "エラー　：　レジストに失敗しました。", "レジストエラー", MB_OK );
					}
					RegCloseKey( s_hkey );
					::MessageBoxA( NULL, "成功　：　レジストに成功しました。", "レジスト成功", MB_OK );
				}else{
					::MessageBoxA( NULL, "エラー　：　レジストに失敗しました。", "レジストエラー", MB_OK );
				}
			}
		}else{
			::MessageBoxA( NULL, "エラー　：　不正なレジストキーです。", "レジストエラー", MB_OK );
		}
	*/
	return 0;
}

int IsRegist()
{
	s_registflag = 1;
	//	s_registflag = 0;

	/*
		LONG lret;
		lret = RegOpenKeyExA( HKEY_CURRENT_USER, "Software\\OchakkoLab\\AdditiveIK_0003", 0, KEY_ALL_ACCESS, &s_hkey );
		if( lret == ERROR_SUCCESS ){
			DWORD dwtype;
			char strkey[37] = {0};
			DWORD dwsize = 37;
			lret = RegQueryValueExA( s_hkey, "registkey", NULL, &dwtype, (LPBYTE)strkey, &dwsize );
			if( lret == ERROR_SUCCESS ){
				if( dwtype == REG_SZ ){
					if( strncmp( strkey, s_appkey[ s_appindex ], 36 ) == 0 ){
						s_registflag = 1;
					}
				}
			}
			RegCloseKey( s_hkey );
		}
	*/

	return 0;
}



//--------------------------------------------------------------------------------------
// Entry point to the program. Initializes everything and goes into a message processing 
// loop. Idle time is used to render the scene.
//--------------------------------------------------------------------------------------
//INT WINAPI wWinMain( HINSTANCE, HINSTANCE, LPWSTR, int )
//INT WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
INT WINAPI wWinMain(
	_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR lpCmdLine,
	_In_ int nShowCmd)//SAL付き
{
	// Enable run-time memory check for debug builds.
#if defined(DEBUG) | defined(_DEBUG)
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

	//SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

	//_CrtSetBreakAlloc(1080459);
	//_CrtSetBreakAlloc(1081145);

	//_CrtSetBreakAlloc(22296);
	//_CrtSetBreakAlloc(22292);

	//_CrtSetBreakAlloc(3879301);
	//_CrtSetBreakAlloc(3879304);
	//_CrtSetBreakAlloc(3879308);

	//_CrtSetBreakAlloc(297);
	//_CrtSetBreakAlloc(303);
	//_CrtSetBreakAlloc(307);

//_CrtSetBreakAlloc(10309);
//_CrtSetBreakAlloc(10833);

//_CrtSetBreakAlloc(787);
//_CrtSetBreakAlloc(2806);
//_CrtSetBreakAlloc(758);
//_CrtSetBreakAlloc(469193);
//_CrtSetBreakAlloc(5557505);
//_CrtSetBreakAlloc(5557507);
//_CrtSetBreakAlloc(1750750);
//_CrtSetBreakAlloc(602);

//_CrtSetBreakAlloc(65234);
//_CrtSetBreakAlloc(1526483);

	//_CrtSetBreakAlloc(32639);

	//_CrtSetBreakAlloc(46773535);
	//_CrtSetBreakAlloc(46773550);


	SetBaseDir();

	LoadIniFile();


	//s_appcntのセット。CheckResolution()よりも前
	s_appcnt = 0;
	s_launchbyc4 = 0;
	int    i;
	int    nArgs;
	//WCHAR  szBuf[256];
	LPWSTR* lplpszArgs;
	lplpszArgs = CommandLineToArgvW(GetCommandLine(), &nArgs);
	for (i = 0; i < nArgs; i++) {
		//wsprintf(szBuf, TEXT("%d番目の引数"), i + 1);
		//MessageBox(NULL, lplpszArgs[i], szBuf, MB_OK);
		if (wcscmp(lplpszArgs[i], L"-progno") == 0) {
			s_launchbyc4 = 1;
			if ((i + 1) < nArgs) {
				i++;
				WCHAR strprogno[MAX_PATH] = { 0L };
				wcscpy_s(strprogno, MAX_PATH, lplpszArgs[i]);
				s_appcnt = _wtoi(strprogno);
			}
		}
		else if (wcscmp(lplpszArgs[i], L"-diffx") == 0) {
			if ((i + 1) < nArgs) {
				i++;
				WCHAR strdiffx[MAX_PATH] = { 0L };
				wcscpy_s(strdiffx, MAX_PATH, lplpszArgs[i]);
				s_launchc4diffx = _wtoi(strdiffx);
			}
		}
		else if (wcscmp(lplpszArgs[i], L"-diffy") == 0) {
			if ((i + 1) < nArgs) {
				i++;
				WCHAR strdiffy[MAX_PATH] = { 0L };
				wcscpy_s(strdiffy, MAX_PATH, lplpszArgs[i]);
				s_launchc4diffy = _wtoi(strdiffy);
			}
		}
	}

	LocalFree(lplpszArgs);


	OpenDbgFile(s_appcnt);


	s_doneinit = 0;
	InitApp();
	if (s_doneinit != 1) {
		_ASSERT(0);
		return 1;
	}


	//2K TV or 4K TV. Create*Window()よりも前
	int chkresult = CheckResolution();
	if (chkresult != 0) {//大小選択ダイアログでキャンセルボタンを押した場合はアプリ終了
		OnDestroyDevice();//2024/03/08
		return 0;
	}

	if (g_4kresolution) {
		s_dispmodel = true;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
		s_dispmotion = true;//!!!!!!!!!!!!!!!! motionpanelのdispflag
		s_dispcamera = true;//!!!!!!!!!!!!!!!! camerapanelのdispflag
	}
	else {
		s_dispmodel = false;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
		s_dispmotion = false;//!!!!!!!!!!!!!!!! motionpanelのdispflag
		s_dispcamera = false;//!!!!!!!!!!!!!!!! camerapanelのdispflag
	}

	s_copyKeyInfoList.clear();	// コピーされたキー情報リスト
	s_copymotvec.clear();
	s_pastemotvec.clear();
	s_deletedKeyInfoList.clear();	// 削除されたキー情報リスト
	s_selectKeyInfoList.clear();	// コピーされたキー情報リスト

	s_pasteRJoint.clear();



	HRESULT hr1 = CoInitialize(NULL);
	if (FAILED(hr1)) {
		//すでに初期化済なだけでエラーリターンするのでそのまま続行する
		//_ASSERT(0);
		//return 1;
	}

	g_mainhwnd = CreateMainWindow();
	if (g_mainhwnd == NULL) {
		_ASSERT(0);
		return 1;
	}

	::SetPriorityClass(GetModuleHandle(NULL), REALTIME_PRIORITY_CLASS);
	::SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

	//#############################
	//SetTreadAffinityはヒントでしかない
	//#############################
	//SYSTEM_INFO sys;
	//::GetSystemInfo(&sys);
	//DWORD cpunum = sys.dwNumberOfProcessors;
	//DWORD_PTR affinitymask = 0;
	//DWORD cpucnt;
	////for (cpucnt = 0; cpucnt < cpunum; cpucnt++) {
	////affinitymask |= (DWORD_PTR)(1 << (cpunum - 1));
	////}
	//DWORD_PTR befaffinity = ::SetThreadAffinityMask(GetCurrentThread(), affinitymask);
	//--------------------------------------------------------------------------------------
	// Limit the current thread to one processor (the current one). This ensures that timing code 
	// runs on only one processor, and will not suffer any ill effects from power management.
	// See "Game Timing and Multicore Processors" for more details
	//--------------------------------------------------------------------------------------
	//	void CDXUTTimer::LimitThreadAffinityToCurrentProc()


/*
#define SPAXISNUM	3
//#define SPCAMNUM	3	//Coef.h : SPR_CAM_MAX
#define SPRIGMAX	2
#define SPGUISWNUM	5
#define SPRIGIDSWNUM	4
#define SPRETARGETSWNUM	2
#define SPAIMBARNUM	5
*/

	s_chascene = new ChaScene();
	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}


	//CreateUtDialog();
	//int spgno;
	//for (spgno = 0; spgno < SPGUISWNUM; spgno++) {
	//	GUISetVisible(spgno + 2);
	//}


	if (!Create3DWnd(hInstance, hPrevInstance, lpCmdLine, nShowCmd)) {
		_ASSERT(0);
		return 1;
	}

	InitPluginMenu();


	//// 背景モデルのレンダラーを初期化
	//myRenderer::ModelRender bgModelRender;
	//bgModelRender.InitDeferredRendering(renderingEngine, "Assets/modelData/bg/bg.tkm", true);
	//// step-1 ティーポットの描画処理を初期化する
	//myRenderer::ModelInitDataFR modelInitData;
	//modelInitData.m_tkmFilePath = "Assets/modelData/teapot.tkm";
	//modelInitData.m_fxFilePath = "Assets/shader/sample.fx";
	//// 拡張SRVにZPrepassで作成された深度テクスチャを指定する
	//modelInitData.m_expandShaderResoruceView[0] = &renderingEngine.GetZPrepassDepthTexture();
	//// 初期化情報を使って描画処理を初期化する
	//myRenderer::ModelRender teapotModelRender;
	//// InitForwardRendering()を利用すると、
	//// フォワードレンダリングの描画パスで描画される
	//teapotModelRender.InitForwardRendering(renderingEngine, modelInitData);
	////シャドウキャスターフラグをオンにする
	//teapotModelRender.SetShadowCasterFlag(true);
	//teapotModelRender.UpdateWorldMatrix({ 0.0f, 50.0f, 0.0f }, g_quatIdentity, g_vec3One);
	////////////////////////////////////////
	//// 初期化を行うコードを書くのはここまで！！！
	////////////////////////////////////////
	s_pdev = g_graphicsEngine->GetD3DDevice();


	//##########################################################################################################
	//2024/02/07
	//RenderingEngine.Init()でg_shadowmapforshaderを初期化してからモデルを読み込まないとConstBufferのRegistでエラーになる
	//OnCreateDevice()よりも先にRenderingEngineを初期化する
	//##########################################################################################################
	// ルートシグネチャを作成
	RootSignature rootSignature;
	InitRootSignature(rootSignature);
	//レンダリングエンジンを初期化
	myRenderer::RenderingEngine renderingEngine;
	renderingEngine.Init();


	
	s_psdk = FbxManager::Create();
	if (!s_psdk)
	{
		_ASSERT(0);
		return 1;
	}
	FbxIOSettings* ios = FbxIOSettings::Create(s_psdk, IOSROOT);
	s_psdk->SetIOSettings(ios);
	// Load plugins from the executable directory
	FbxString lPath = FbxGetApplicationDirectory();
#if defined(KARCH_ENV_WIN)
	FbxString lExtension = "dll";
#elif defined(KARCH_ENV_MACOSX)
	FbxString lExtension = "dylib";
#elif defined(KARCH_ENV_LINUX)
	FbxString lExtension = "so";
#endif
	s_psdk->LoadPluginsDirectory(lPath.Buffer(), "dll");





	OnCreateDevice();

	OWP_EditBox::makeSoftNumKey();

	LoadSkyParamsFile();//s_skyを作成した後で呼ぶ
	LoadFogParamsFile();
	LoadDofParamsFile();

	CreatePlaceFolderWnd();
	CreateTimelineWnd();
	CreateToolWnd();
	CreateLongTimelineWnd();
	CreateLayerWnd();
	CreateInfoWnd();
	CreateSideMenuWnd();
	CreateTopSlidersWnd();

	//CreateLaterTransparentWnd();//s_modelが設定されてから作成する

	CreateMaterialRateWnd();
	CreateModelWorldMatWnd();
	CreateJumpGravityWnd();
	CreateDofParamsDlg();



	//CreateCopyHistoryDlg();//s_modelが出来てから呼ぶ　OnModelMenu()に移動
	CreateDollyHistoryDlg();//CheckResolution()より後、g_mainhwndがセットされた後で呼ぶ


	GUIMenuSetVisible(s_platemenukind, s_platemenuno);


	//if (!s_eventhook) {
	//s_eventhook = SetWinEventHook(
	//	//EVENT_SYSTEM_DIALOGSTART,
	//	//EVENT_SYSTEM_DIALOGSTART,
	//	//EVENT_SYSTEM_DIALOGEND,
	//	EVENT_MIN,
	//	EVENT_MAX,
	//	NULL,
	//	WinEventProc,
	//	//GetDlgItemInt(IDC_PROCESSID),
	//	//GetProcessId(GetModuleHandle(NULL)),
	//	//GetThreadId(g_hUnderTrackingThread),
	//	//GetThreadId(s_messageboxthread),
	//	0,
	//	0,
	//	WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS
	//);
	//IntPtr hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, IntPtr.Zero,
	//	procDelegate, 0, 0, WINEVENT_OUTOFCONTEXT);
	//// MessageBox provides the necessary mesage loop that SetWinEventHook requires.
	//MessageBox.Show("Tracking focus, close message box to exit.");
	////UnhookWinEvent(hhook);
	//}


	//s_iktimerid = (int)::SetTimer(g_mainhwnd, s_iktimerid, 16, NULL);

	//if (g_mainhwnd) {
	//	SetCapture(g_mainhwnd);
	//}

	s_hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);

	if (g_4kresolution) {
		s_dispmodel = true;
		DispModelPanel();
		s_dispmotion = true;
		DispMotionPanel();
		s_dispcamera = true;
		DispCameraPanel();
	}
	
	{//2024/03/02
		//s_sky用のprojection行列を１回計算するためにg_camera3Dを使う
		s_matSkyProj.SetIdentity();
		g_camera3D->SetNear(100.0f);
		g_camera3D->SetFar(500000.0f);
		g_camera3D->SetViewAngle(g_fovy);//2023/12/30
		Vector3 cameye;
		cameye.Set(g_camEye.x, g_camEye.y, g_camEye.z);
		g_camera3D->SetPosition(cameye);
		Vector3 target;
		target.Set(g_camtargetpos.x, g_camtargetpos.y, g_camtargetpos.z);
		g_camera3D->SetTarget(target);
		g_camera3D->SetUp(Vector3(g_cameraupdir.x, g_cameraupdir.y, g_cameraupdir.z));
		g_camera3D->SetWidth((float)g_graphicsEngine->GetFrameBufferWidth());//2023/11/20
		g_camera3D->SetHeight((float)g_graphicsEngine->GetFrameBufferHeight());//2023/11/20
		g_camera3D->Update();
		
		s_matSkyProj.SetParams(g_camera3D->GetProjectionMatrix());
	}


	


	int dbgcount = 0;
	while (DispatchWindowMessage())
	{
		if (s_chascene && (g_underloading == false)) {
			// レンダリング開始
			auto& renderContext = g_graphicsEngine->GetRenderContext();

			//g_camera3D->MoveForward(g_pad[0]->GetLStickYF());
			//g_camera3D->MoveRight(g_pad[0]->GetLStickXF());
			//g_camera3D->MoveUp(g_pad[0]->GetRStickYF());

			//double fTime = 0.0;
			//float fElapsedTime = 0.0;
			if (DXUTGetGlobalTimer()) {
				s_fTime = DXUTGetGlobalTimer()->GetTime();
				s_fElapsedTime = DXUTGetGlobalTimer()->GetElapsedTime();
			}
			CalcFps(s_fTime);

			
			////for tmp check
			//WCHAR strmaintitle[MAX_PATH * 3] = { 0L };
			//int dispfps = (int)(s_avrgfps + 0.5);
			//swprintf_s(strmaintitle, MAX_PATH * 3, L"AdditiveIK Ver1.0.0.1 : No.%d : fps %d", s_appcnt, dispfps);
			//SetWindowText(g_mainhwnd, strmaintitle);
			if (g_underWriteFbx == false) {//2024/02/10

				//2024/08/09
				//リターゲットバッチ中にタイミングでエラー　OnUserFrameMove()の中に入れて バッチ中はスキップ
				//s_chascene->SetUpdateSlot();//2023/03/13 
				////s_chascene->ResetCSFirstDispatchFlag();

				//ドキュメント更新
				int loopstartflag = 0;
				OnUserFrameMove(s_fTime, s_fElapsedTime, &loopstartflag);

				//ビュー更新
				OnFrameRender(&renderingEngine, &renderContext, s_fTime, s_fElapsedTime, loopstartflag);

				if (g_infownd && (dbgcount < 60)) {
					g_infownd->UpdateWindow();//起動時に白くなる不具合に対して　応急処置
				}
			}
			dbgcount++;
		}
	}

	OnDestroyDevice();
	renderingEngine.DestroyObjs();
	rootSignature.DestroyObjs();

	//詳細版
	if (s_debugDevice) {
		s_debugDevice->ReportLiveDeviceObjects(D3D12_RLDO_DETAIL);
		//s_debugDevice->ReportLiveDeviceObjects(D3D12_RLDO_SUMMARY);
	}


	//return DXUTGetExitCode();
	return 0;
}


//--------------------------------------------------------------------------------------
// Initialize the app 
//--------------------------------------------------------------------------------------
int CheckResolution()
{
	g_4kresolution = false;

	/*
	//基準とする大きさ　mainwindowの大きさ
	(1216 + 450) * 2, (950 - TOPSLIDERSWNDH) * 2
	*/


	int cXborder = GetSystemMetrics(SM_CXBORDER);
	int cYborder = GetSystemMetrics(SM_CYBORDER);
	int cXFrame = GetSystemMetrics(SM_CXDLGFRAME);
	int cYFrame = GetSystemMetrics(SM_CYDLGFRAME);


	if ((s_appcnt == 0) && (s_launchbyc4 == 0)) {

		HWND desktopwnd;
		desktopwnd = ::GetDesktopWindow();
		if (desktopwnd) {
			RECT desktoprect;
			::GetClientRect(desktopwnd, &desktoprect);
			if ((desktoprect.right >= (s_totalwndwidth * 2)) && (desktoprect.bottom >= ((s_totalwndheight - TOPSLIDERSWNDH) * 2))) {

				CSelectLSDlg dlg;
				int dlgret = (int)dlg.DoModal();
				if (dlgret != IDOK) {
					return 1;//キャンセルボタンはアプリ終了
				}
				BOOL selectL = dlg.GetIsLarge();//4K可能の場合には大小を選択可能
								
				if (selectL == TRUE) {
					g_4kresolution = true;//!!!!!!!!!!!!!!!!
					g_zpreflag = true;//2023/12/30 4Kのときだけtrue
					//g_zpreflag = false;//2024/02/14

					s_modelwindowwidth = 400;
					s_motionwindowwidth = s_modelwindowwidth;
					s_camerawindowwidth = s_modelwindowwidth;

					s_spsize = 80.0f;
					s_spsizeSmall = 50.0f;
					s_sptopmargin = 60.0f;
					s_spsidemargin = 60.0f;

					s_totalwndwidth = (1216 + 450) * 2;
					s_totalwndheight = (950 - TOPSLIDERSWNDH) * 2 + 8;
					s_2ndposy = 600 * 2;


					//s_timelinewidth = 400 * 2;
					//s_timelinewidth = s_toolwidth;
					s_timelinewidth = 600;
					s_timelineheight = s_2ndposy - TOPSLIDERSWNDH;

					s_toolwidth = 400;
					s_toolheight = s_totalwndheight - s_2ndposy - (TOPSLIDERSWNDH + 18) * 2 + TOPSLIDERSWNDH + 8 + 8;

					s_sidemenuwidth = 600;
					s_sidemenuheight = TOPSLIDERSWNDH + 16;
					s_sidewidth = s_sidemenuwidth;
					s_sideheight = s_totalwndheight - s_sidemenuheight - 28 * 2 - 4;

					//s_mainwidth = 800 * 2 + 340 + 450 - 64 + 60 - s_modelwindowwidth;
					//s_mainwidth = s_totalwndwidth - s_timelinewidth - s_modelwindowwidth - s_sidewidth - cXFrame * 2 - cXborder * 8;
					s_mainwidth = s_totalwndwidth - s_timelinewidth - s_modelwindowwidth - s_sidewidth - 16;
					s_mainheight = (520 * 2 - TOPSLIDERSWNDH);
					
					//s_bufwidth = (800 * 2);
					//s_bufwidth = 800 * 2 + 340 + 450 - 64 + 60 - s_modelwindowwidth;
					s_bufwidth = s_mainwidth;
					s_bufheight = s_mainheight;


					//s_longtimelinewidth = 970 * 2;
					//s_longtimelinewidth = s_mainwidth + s_modelwindowwidth;
					s_longtimelinewidth = s_totalwndwidth - s_toolwidth - s_sidewidth - 16;
					//s_longtimelineheight = (s_totalwndheight - s_2ndposy - TOPSLIDERSWNDH - 18) * 2;
					s_longtimelineheight = s_toolheight;

					s_infowinwidth = s_mainwidth;
					s_infowinheight = (s_2ndposy - s_mainheight - TOPSLIDERSWNDH);


					s_modelwindowheight = 460;
					s_camerawindowheight = 300;
					s_motionwindowheight = s_mainheight - s_modelwindowheight - s_camerawindowheight + s_infowinheight;


					//s_guibarX0 = s_mainwidth / 2 - 180 - 2 * 180 - 30;
					s_guibarX0 = s_mainwidth / 2 - 130 * 2;

					g_4kresolution = true;

				}
				else {
					g_4kresolution = false;
				}
			}
		}
	}


	if (!g_4kresolution) {
		//g_zpreflag = false;
		g_zpreflag = true;


		//s_spsize = 38.0f;
		s_spsize = 32.0f;
		s_spsizeSmall = 22.0f;
		s_sptopmargin = 35.0f;
		s_spsidemargin = 35.0f;

		s_totalwndwidth = (1216 + 450);
		s_totalwndheight = 950 + 8;
		s_2ndposy = 600;

		s_modelwindowwidth = 400;
		s_motionwindowwidth = s_modelwindowwidth;
		s_camerawindowwidth = s_modelwindowwidth;

		s_modelwindowheight = 460;
		//s_motionwindowheight = 700;
		s_motionwindowheight = 400;
		s_camerawindowheight = 300;


		s_toolwidth = 230;
		//s_toolheight = 290;
		s_toolheight = s_totalwndheight - s_2ndposy - TOPSLIDERSWNDH - 28 + 8;

		s_mainwidth = 800 - 64;
		s_mainheight = (520 - TOPSLIDERSWNDH);

		s_bufwidth = 800 - 64;
		s_bufheight = (520 - TOPSLIDERSWNDH);


		s_timelinewidth = 400;
		s_timelineheight = s_2ndposy - TOPSLIDERSWNDH;

		s_longtimelinewidth = 970 - 64;
		s_longtimelineheight = s_toolheight;


		s_infowinwidth = s_mainwidth;
		s_infowinheight = (s_2ndposy - s_mainheight - TOPSLIDERSWNDH);

		s_sidemenuwidth = 450 + 64 - 4 + 4;
		s_sidemenuheight = TOPSLIDERSWNDH + 16;

		s_sidewidth = s_sidemenuwidth;
		s_sideheight = s_totalwndheight - TOPSLIDERSWNDH - s_sidemenuheight - 28 + 8;

		s_guibarX0 = 120;

	}


	{
		int windowposx;
		if (g_4kresolution) {
			windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
		}
		else {
			windowposx = s_timelinewidth + s_mainwidth;
		}
		s_copyhistorydlg2.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_dollyhistorydlg2.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_rigidparamsdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_displimitsdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_bulletdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_projloddlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_blendshapedlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_lightsdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_dispgroupdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_latertransparentdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_shadertypedlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_shaderparamsdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_skyparamsdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_retargetdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_limiteuldlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_shadowdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_impulsedlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_gplanedlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_dampanimdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_thresholddlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
		s_fogdlg.SetPosAndSize(windowposx, s_sidemenuheight, s_sidewidth, s_sideheight);
	}

	return 0;
}


void InitApp()
{
	s_hhook = NULL;
	g_hWnd = NULL;
	//g_shadertype = -1;//マテリアル毎に設定することに

	InitializeCriticalSection(&s_CritSection_LTimeline);
	InitializeCriticalSection(&g_CritSection_GetGP);
	InitializeCriticalSection(&g_CritSection_FbxSdk);

	InitCommonControls();

	s_copyhistorydlg2.InitParams();

	{
		s_dollyhistorydlg2.InitParams();
		//ここではまだhistorydlg2.SetPosAndSize()が呼ばれていないのでダイアログの作成はしない
		//SetPosAndSize()が呼ばれてg_mainhwndがセットされた後で作成する
	}
	s_rigidparamsdlg.InitParams();
	s_displimitsdlg.InitParams();
	s_bulletdlg.InitParams();
	s_projloddlg.InitParams();
	s_blendshapedlg.InitParams();
	s_lightsdlg.InitParams();
	s_dispgroupdlg.InitParams();
	s_latertransparentdlg.InitParams();
	s_shadertypedlg.InitParams();
	s_shaderparamsdlg.InitParams();
	s_skyparamsdlg.InitParams();
	s_retargetdlg.InitParams();
	s_impulsedlg.InitParams();
	s_gplanedlg.InitParams();
	s_dampanimdlg.InitParams();
	s_thresholddlg.InitParams();
	s_fogdlg.InitParams();

	s_limiteuldlg.InitParams();
	s_limiteuldlg.SetFunctions(PrepairUndo, UpdateAfterEditAngleLimit);
	s_shadowdlg.InitParams();
	s_shadowdlg.SetFunctions(SetCamera3DFromEyePos);

	s_undercpinfodlg2 = false;
	s_cpinfodlg2.InitParams();
	s_cpinfo.Init();
	s_cpmotinfo.Init();


	g_edittarget = EDITTARGET_BONE;
	s_LchangeTargetFlag = false;
	s_LrefreshEditTarget = 0;
	s_LchangeTarget2Camera = false;

	s_SpriteButtonDown = false;
	s_SpriteButtonDownUndoRedo = false;

	{
		g_camEye.SetParams(0.0f, 0.0f, 0.0f);
		g_camtargetpos.SetParams(0.0f, 0.0f, 0.0f);
		g_befcamEye.SetParams(0.0f, 0.0f, 0.0f);
		g_befcamtargetpos.SetParams(0.0f, 0.0f, 0.0f);
		g_cameraupdir.SetParams(0.0f, 1.0f, 0.0f);
		g_camdist = 50.0f;
		g_initcamdist = 50.0f;
		g_fovy = (float)(PI / 4.0);
		g_projnear = 0.01f;
		g_projfar = g_initcamdist * 100.0f;
	
		g_vCenter.SetParams(0.0f, 0.0f, 0.0f);
	}

	g_mouseherealpha = 1.0f;

	s_filterindex = 1;
	s_grassflag = false;

	s_pickmodel = nullptr;
	s_pickmqoobj = nullptr;
	s_pickmaterial = nullptr;
	s_befpickmodel = nullptr;
	s_befpickmqoobj = nullptr;
	s_befpickmaterial = nullptr;
	s_pickhitpos.SetParams(0.0f, 0.0f, 0.0f);

	s_befselectmodel = nullptr;
	s_befselectmqoobj = nullptr;
	s_befselectmaterial = nullptr;

	g_pickorder = 1;//2024/02/16
	g_pickmeshflag = false;
	g_pickdistrate = 0.5;

	ZeroMemory(g_brushname, sizeof(WCHAR) * MAX_PATH);
	wcscpy_s(g_brushname, MAX_PATH, L"Brush None Yet.");


	int fogindex;
	for (fogindex = 0; fogindex < FOGSLOTNUM; fogindex++) {
		g_fogparams[fogindex].InitParams();
	}
	g_fogindex = 0;
	
	int dofindex;
	for (dofindex = 0; dofindex < DOFSLOTNUM; dofindex++) {
		g_dofparams[dofindex].SetParams(3000.0f, 5000.0f, 0.0f, 0.0f);
		g_skydofflag[dofindex] = false;
	}
	g_dofindex = 0;


	s_matWorld.SetIdentity();
	s_matProj.SetIdentity();
	s_matVP.SetIdentity();
	s_matView.SetIdentity();
	s_befLockMatView.SetIdentity();
	s_matSkyProj.SetIdentity();

	//s_maxcamdist = 5000.0f;
	s_maxcamdist = 20000.0f;//2024/06/04

	g_pasteScale = true;
	g_pasteRotation = true;
	g_pasteTranslation = true;

	g_jumpgravity = 65;


	InitSprites();

	//g_materialbank.InitParams();

	s_platemenukind = SPPLATEMENUKIND_DISP;
	s_platemenuno = 1;
	s_guiswflag = true;//true : １段目メニュー内容を右ペインに. false : ２段目メニュー内容を右ペインに
	s_guiswplateno = 1;

	g_skydispflag = true;

	g_hdrpbloom = true;
	g_alphablending = true;
	g_freefps = true;
	g_zalways = false;
	s_befftime = 0.0;
	s_mousemoveBefTime = 0.0;
	g_dspeed = 1.0;//2024/01/13  3.0-->1.0に変更
	g_physicsmvrate = 0.3f;


	g_uvset = 0;
	g_bonemark_bright = 1.0f;//inifile読み込み処理で上書きされる
	g_rigidmark_alpha = 0.75f;//inifile読み込み処理で上書きされる
	g_rigmark_alpha = 0.75f;//inifile読み込み処理で上書きされる

	g_boneaxis = BONEAXIS_CURRENT;


	g_lodrate2L[CHKINVIEW_LOD0] = 0.01f;//rate * projfar.  distance of clipping
	g_lodrate2L[CHKINVIEW_LOD1] = 1.0f;
	g_lodrate2L[CHKINVIEW_LOD2] = 1.0f;
	g_lodrate2L[CHKINVIEW_LOD3] = 1.0f;

	g_lodrate3L[CHKINVIEW_LOD0] = 0.01f;//rate * projfar.  distance of clipping
	g_lodrate3L[CHKINVIEW_LOD1] = 0.15f;
	g_lodrate3L[CHKINVIEW_LOD2] = 1.0f;
	g_lodrate3L[CHKINVIEW_LOD3] = 1.0f;

	g_lodrate4L[CHKINVIEW_LOD0] = 0.01f;//rate * projfar.  distance of clipping
	g_lodrate4L[CHKINVIEW_LOD1] = 0.15f;
	g_lodrate4L[CHKINVIEW_LOD2] = 0.5f;
	g_lodrate4L[CHKINVIEW_LOD3] = 1.0f;


	{
		g_l_kval[0] = 1.0f;
		g_l_kval[1] = powf(10.0f, 2.61f);
		g_l_kval[2] = 2000.0f;
		g_a_kval[0] = 0.1f;
		g_a_kval[1] = powf(10.0f, 0.3f);
		g_a_kval[2] = 70.0f;
		g_initcuslk = 1e2;
		g_initcusak = 0.10f;
		g_l_dmp = 0.50f;
		g_a_dmp = 0.50f;

		g_akscale = 1.0f;//2024/04/23 全ての剛体の回転バネ定数に対するスケール
	}


	{
		s_spritetex0 = 0;
		s_spritetex1 = 0;
		s_spritetex2 = 0;
		s_spritetex3 = 0;
		s_spritetex4 = 0;
		s_spritetex5 = 0;
		s_spritetex6 = 0;
		s_spritetex7 = 0;
		s_spritetex8 = 0;
		s_spritetex9 = 0;
		s_spritetex10 = 0;
		s_spritetex11 = 0;
		s_spritetex12 = 0;
		s_spritetex13 = 0;
		s_spritetex14 = 0;
		s_spritetex15 = 0;
		s_spritetex16 = 0;
		s_spritetex17 = 0;
		s_spritetex18 = 0;
		s_spritetex19 = 0;
		s_spritetex20 = 0;
		s_spritetex21 = 0;
		s_spritetex22 = 0;
		s_spritetex23 = 0;
		s_spritetex24 = 0;
		s_spritetex25 = 0;
		s_spritetex26 = 0;
		s_spritetex27 = 0;
		s_spritetex28 = 0;
		s_spritetex29 = 0;
		s_spritetex30 = 0;
		s_spritetex31 = 0;
		s_spritetex32 = 0;
		s_spritetex33 = 0;
		s_spritetex34 = 0;
		s_spritetex35 = 0;
		s_spritetex36 = 0;
		s_spritetex37 = 0;
		s_spritetex37_1 = 0;
		s_spritetex38 = 0;
		s_spritetex39 = 0;
		s_spritetex40 = 0;
		s_spritetex40_1 = 0;
		s_spritetex41 = 0;
		s_spritetex42 = 0;
		s_spritetex43 = 0;
		s_spritetex44 = 0;
		s_spritetex45 = 0;
		s_spritetex46 = 0;
		s_spritetex47 = 0;
		s_spritetex48 = 0;
		s_spritetex49 = 0;
		s_spritetex50 = 0;
		s_spritetex51 = 0;
		s_spritetex52 = 0;
		s_spritetex53 = 0;
		s_spritetex54 = 0;
		s_spritetex55 = 0;
		s_spritetex56 = 0;
		s_spritetex57 = 0;
		s_spritetex58 = 0;
		s_spritetex59 = 0;
		s_spritetex60 = 0;
		s_spritetex61 = 0;
		s_spritetex62 = 0;
		s_spritetex63 = 0;
		s_spritetex64 = 0;
		s_spritetex65 = 0;
		s_spritetex66 = 0;
		s_spritetex67 = 0;
		s_spritetex68 = 0;
		s_spritetex69 = 0;
		s_spritetex70 = 0;
		s_spritetex71 = 0;
		s_spritetex72 = 0;
		s_spritetex73 = 0;
		s_spritetex74 = 0;
		s_spritetex75 = 0;
		s_spritetex76 = 0;
		s_spritetex77 = 0;
		s_spritetex78 = 0;
		s_spritetex79 = 0;
		s_spritetex80 = 0;
		s_spritetex81 = 0;


		s_spritetex_pushed1 = 0;
		s_spritetex_pushed2 = 0;
		s_spritetex_pushed5 = 0;
		s_spritetex_pushed6 = 0;
		s_spritetex_pushed7 = 0;
		s_spritetex_pushed55 = 0;
		s_spritetex_pushed56 = 0;
		s_spritetex_pushed57 = 0;
		s_spritetex_pushed63 = 0;
		s_spritetex_pushed64 = 0;
		s_spritetex_pushed65 = 0;
		s_spritetex_pushed66 = 0;
		s_spritetex_pushed67 = 0;
		s_spritetex_pushed68 = 0;
		s_spritetex_pushed69 = 0;
		s_spritetex_pushed70 = 0;
		s_spritetex_pushed85 = 0;
		s_spritetex_pushed71 = 0;
		s_spritetex_pushed72 = 0;
		s_spritetex_pushed73 = 0;
		s_spritetex_pushed74 = 0;
		s_spritetex_pushed75 = 0;
		s_spritetex_pushed76 = 0;
		s_spritetex_pushed77 = 0;
		s_spritetex_pushed78 = 0;
		s_spritetex_pushed61 = 0;
		s_spritetex_pushed62 = 0;


		s_spritetexCamera67 = 0;
		s_spritetexCamera_pushed67 = 0;
		s_spritetexCamera69 = 0;
		s_spritetexCamera_pushed69 = 0;
		s_spritetexCamera71 = 0;
		s_spritetexCamera_pushed71 = 0;
		s_spritetexCamera72 = 0;
		s_spritetexCamera_pushed72 = 0;
		s_spritetexCamera64 = 0;
		s_spritetexCamera_pushed64 = 0;
	}

	{
		g_enableshadow = true;
		g_VSMflag = true;
		g_blurShadow = true;
		g_shadowmapforshader = nullptr;
		g_shadowmap_slotno = 0;
		int slotno;
		for (slotno = 0; slotno < SHADOWSLOTNUM; slotno++) {
			g_shadowmap_fov[slotno] = 60.0f;
			g_shadowmap_projscale[slotno] = 1.0f;
			g_shadowmap_near[slotno] = 50.0f;
			g_shadowmap_far[slotno] = 2000.0f;
			g_shadowmap_color[slotno] = 0.5f;
			g_shadowmap_bias[slotno] = 0.0010f;
			g_shadowmap_plusup[slotno] = 300.0f;
			g_shadowmap_distscale[slotno] = 1.0f;
			g_shadowmap_lightdir[slotno] = 1;
		}
	}

	s_chascene = 0;

	s_dispfontfortip = false;
	s_dispPickfortip = false;
	ZeroMemory(s_strfortip, sizeof(WCHAR) * 512);
	s_fontposfortip.Set(0.0f, 0.0f);
	s_fontfortip.SetShadowParam(true, 1.0, 
		Vector4(15.0f / 255.0f, 77.0f / 255.0f, 33.0f / 255.0f, 1.0f));//font縁取り設定


	g_coldlg.InitParams();
	s_selbonedlgmap.clear();

	s_utcontrolvisible = true;

	s_cancelLButtonDown = false;
	s_cancelRButtonDown = false;

	//########################################################################
	// s_mainwidth, s_mainheightはInitApp()よりも前にCheckResolution()でセットする
	// ここでs_mainwidth, s_mainheightを初期化してはいけない
	//########################################################################
	//s_mainwidth = 800;
	//s_mainheight = (520 - TOPSLIDERSWNDH);
	//s_bufwidth = 800;
	//s_bufheight = (520 - TOPSLIDERSWNDH);

	//{
	//	g_hRenderBoneL0 = 0;
	//	g_hRenderBoneL1 = 0;
	//	g_hRenderBoneL2 = 0;
	//	g_hRenderBoneL3 = 0;
	//	g_hRenderBoneL4 = 0;
	//	g_hRenderBoneL5 = 0;
	//	g_hRenderBoneL6 = 0;
	//	g_hRenderBoneL7 = 0;
	//	g_hRenderBoneL8 = 0;
	//	g_hRenderNoBoneL0 = 0;
	//	g_hRenderNoBoneL1 = 0;
	//	g_hRenderNoBoneL2 = 0;
	//	g_hRenderNoBoneL3 = 0;
	//	g_hRenderNoBoneL4 = 0;
	//	g_hRenderNoBoneL5 = 0;
	//	g_hRenderNoBoneL6 = 0;
	//	g_hRenderNoBoneL7 = 0;
	//	g_hRenderNoBoneL8 = 0;
	//	g_hRenderLine = 0;
	//	g_hRenderSprite = 0;

	//	g_hm4x4Mat = 0;
	//	g_hmWorld = 0;
	//	g_hmVP = 0;

	//	g_hEyePos = 0;
	//	g_hnNumLight = 0;
	//	g_hLightDir = 0;
	//	g_hLightDiffuse = 0;
	//	g_hLightAmbient = 0;
	//	g_hSpriteOffset = 0;
	//	g_hSpriteScale = 0;
	//	g_hPm3Scale = 0;
	//	g_hPm3Offset = 0;


	//	g_hdiffuse = 0;
	//	g_hambient = 0;
	//	g_hspecular = 0;
	//	g_hpower = 0;
	//	g_hemissive = 0;
	//	g_hMeshTexture = 0;
	//}


	g_controlkey = false;
	g_shiftkey = false;
	g_ctrlshiftkeyformb = false;//ForMiddleButton
	s_skey = false;
	
	//////check
	//WCHAR strchk[256] = { 0L };
	//swprintf_s(strchk, 256, L"NULL == %p\nINVALID_HANDLE_VALUE == %p", NULL, INVALID_HANDLE_VALUE);
	//::MessageBox(NULL, strchk, L"check", MB_OK);

	{
		s_matred = 0;// = s_select->GetMQOMaterialByName("matred");
		s_ringred = 0;// = s_select->GetMQOMaterialByName("ringred");
		s_matblue = 0;// = s_select->GetMQOMaterialByName("matblue");
		s_ringblue = 0;// = s_select->GetMQOMaterialByName("ringblue");
		s_matgreen = 0;// = s_select->GetMQOMaterialByName("matgreen");
		s_ringgreen = 0;// = s_select->GetMQOMaterialByName("ringgreen");
		s_matyellow = 0;// = s_select->GetMQOMaterialByName("matyellow");
		s_selectobj_objx = 0;
		s_selectobj_objy = 0;
		s_selectobj_objz = 0;
		s_selectobj_ringx = 0;
		s_selectobj_ringy = 0;
		s_selectobj_ringz = 0;
		s_selectobj_center = 0;
		s_matredmat.SetParams(1.0f, 0.0f, 0.0f, 1.0f);
		s_ringredmat.SetParams(1.0f, 0.0f, 0.0f, 1.0f);
		s_matbluemat.SetParams(0.0f, 0.0f, 1.0f, 1.0f);
		s_ringbluemat.SetParams(0.0f, 0.0f, 1.0f, 1.0f);
		s_matgreenmat.SetParams(0.0f, 1.0f, 0.0f, 1.0f);
		s_ringgreenmat.SetParams(0.0f, 1.0f, 0.0f, 1.0f);
		s_matyellowmat.SetParams(1.0f, 1.0f, 0.0f, 1.0f);
		s_ringyellowmat.SetParams(1.0f, 1.0f, 0.0f, 1.0f);
	}

	s_grassElemVec.clear();

	s_rigopemark_sphere = nullptr;
	s_rigopemark_ringX = nullptr;
	s_rigopemark_ringY = nullptr;
	s_rigopemark_ringZ = nullptr;
	//::ZeroMemory(s_rigmaterial_sphere, sizeof(CMQOMaterial*) * (RIGMULTINDEXMAX + 1));
	//::ZeroMemory(s_rigmaterial_ringX, sizeof(CMQOMaterial*) * (RIGMULTINDEXMAX + 1));
	//::ZeroMemory(s_rigmaterial_ringY, sizeof(CMQOMaterial*) * (RIGMULTINDEXMAX + 1));
	//::ZeroMemory(s_rigmaterial_ringZ, sizeof(CMQOMaterial*) * (RIGMULTINDEXMAX + 1));
	s_matrigmat.SetParams(255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f);


	s_curmotid = -1;
	s_curboneno = -1;
	s_saveboneno = -1;
	s_curbaseno = -1;


	//select joint using shortcutkey
	s_selecthand = 0;
	s_selectfoot = 0;



	s_tiprigboneno = -1;
	s_tiprigno = -1;
	s_tooltipdispcount = 0;
	s_tooltiplen = 0;

	//g_edgesmp = false;


	g_previewFlag = 0;
	s_savepreviewFlag = 0;
	g_cameraanimmode = 0;//0: OFF, 1:ON
	s_savecameraanimmode = 0;
	g_cameraInheritMode = CAMERA_INHERIT_ALL;
	s_saveCameraInheritMode = g_cameraInheritMode;

	s_camtargetflag = 0;
	s_camtargetOnceflag = 0;

	{
		s_camtargetdisp = false;
		s_moveeyepos = false;
		s_twistcameraFlag = false;
		s_rbuttonSelectFlag = false;
		s_cameraframe = 0.0;
		g_cameraupdir.SetParams(0.0f, 1.0f, 0.0f);

		g_initcamdist = 50.0f;
		g_camdist = g_initcamdist;
		g_projnear = 0.01f;
		g_projfar = g_initcamdist * 100.0f;
		s_fAspectRatio = 1.0f;
		g_fovy = (float)(PI / 4.0);
		//s_cammvstep = 100.0f;
		s_cammvstep = 500.0f;
	}

	{
		s_model = NULL;
		s_curmodelmenuindex = -1;
		s_cameramodel = NULL;//2023/05/23
		s_select = NULL;
		s_select_posture = NULL;
		s_bmark = NULL;
		s_ground = NULL;
		s_gplane = NULL;
		s_sky = NULL;
	}

	s_layerWnd = 0;
	s_owpLayerTable = 0;
	
	{
		s_skyparamsFlag = false;
		s_fogparamsFlag = false;
		s_dofparamsFlag = false;
	}

	{
		s_dofWnd = 0;
		s_dofLabel = 0;
		s_dofslotCombo = 0;
		s_dofspacerLabel1 = 0;
		s_dofdistsp1 = 0;
		s_dofdistsp2 = 0;
		s_dofdistsp3 = 0;
		s_dofdistnearLabel = 0;
		s_dofdistnearEdit = 0;
		s_dofdistfarLabel = 0;
		s_dofdistfarEdit = 0;
		s_dofspacerLabel2 = 0;
		s_dofskyChk = 0;
		s_dofspacerLabel3 = 0;
		s_dofapplysp = 0;
		s_dofapplyB = 0;
	}

	{
		s_placefolderWnd = 0;
		//s_placefolderlabel_1 = 0;
		//s_placefolderlabel_2 = 0;
		//s_placefolderlabel_3 = 0;
		ZeroMemory(s_shortcuttext, sizeof(OWP_Label*) * SHORTCUTTEXTNUM);
	}


	s_cameradollyFlag = false;
	s_materialrateFlag = false;
	s_modelworldmatFlag = false;
	s_jumpgravityFlag = false;

	//g_zpreflag = false;
	g_zpreflag = true;
	g_zcmpalways = false;
	g_lightflag = 1;

	//g_btcalccnt = 2.0;
	g_btcalccnt = 1.0;//2023/11/04 物理ダブルバッファ化で表示速度が速くなったので　2だった値を1に変更

	s_befdeltax = 0.0f;

	g_rotatetanim = true;
	g_tpose = true;
	g_preciseOnPreviewToo = false;
	g_x180flag = false;

	g_refposstep = 10;
	g_refalpha = 50;

	g_underloading = false;
	//g_underIKRot = false;
	//g_underIKRotApplyFrame = false;
	g_fpsforce30 = false;
	//g_underRetargetFlag = false;
	s_smoothBefRetarget = false;

	g_underWriteFbx = false;
	//g_underCalcEul = false;
	//g_underPostFKTra = false;
	//g_underInitMp = false;
	//g_underCopyW2LW = false;
	g_changeUpdateThreadsNum = false;

	g_VSync = false;
	g_fpskind = 0;

	g_rotatetanim = false;
	g_HighRpmMode = true;//2023/12/30 起動時にオン
	g_UpdateMatrixThreads = 2;


	s_fTime = 0.0;
	s_fElapsedTime = 0.0;

	int saveno;
	for (saveno = 0; saveno < FPSSAVENUM; saveno++) {
		s_fps100[saveno] = 60.0;
	}
	s_fps100index = 0;
	s_avrgfps = 0.0;

	s_utBrushRepeatsFlag = false;//UTDialogのBrushRepeatsスライダー値変更
	s_utApplyRateFlag = false;//UTDialogのApplyRateスライダー値変更
	s_utBrushMethodFlag = false;
	s_BrushMirrorUCheckBoxFlag = false;//UTDialogの
	s_BrushMirrorVCheckBoxFlag = false;//UTDialogの
	s_IfMirrorVDiv2CheckBoxFlag = false;//UTDialogの
	s_LimitDegCheckBoxFlag = false;
	s_WallScrapingCheckBoxFlag = false;

	//s_totalmb.center.SetParams(0.0f, 0.0f, 0.0f);
	//s_totalmb.max.SetParams(5.0f, 5.0f, 5.0f);
	//s_totalmb.min.SetParams(-5.0f, -5.0f, -5.0f);
	//s_totalmb.r = (float)ChaVector3LengthDbl(&s_totalmb.max);

	//s_undosprite = 0;
	//s_fpssprite = 0;


	g_wallscrapingikflag = 0;

	s_ikkind = 0;
	s_cameraeditkind = CAMERAANIMEDIT_NONE;

	//g_wmatDirectSetFlag = false;
	g_limitdegflag = false;
	

	//2024/04/17 limitrateは構造体ANGLELIMITのメンバにしてCBone::m_anglelimitでボーンごとに管理することにした
	//g_limitrate = 15;
	//g_limitrate = 85;//2024/04/15 limitrateが実質FreeRateになっていたので修正　新しいlimitrate = (100 - 古いlimitrate)
	g_physicalLimitScale = 0.0;//全てのCBoneのlimitrateに掛けるスケール limitを0に設定しても制限角度を越えるとフラグが立って速度設定が変わる
	g_physicalMovableRate = 100;//2024/05/02 LimitEulオンで物理シミュをする場合の　制限角度内における動作変化率％
	g_physicalVeloScale = 0.20;//2024/05/04 LimitEulオンで物理シミュする場合の　剛体速度スケール


	s_progressnum = 0;
	s_progresscnt = 0;
	s_progressmodelnum = 0;
	s_progressmodelcnt = 0;
	s_befprogressnum = 0;
	s_befprogresscnt = 0;
	s_befprogressmodelnum = 0;
	s_befprogressmodelcnt = 0;


	//g_ClearColorIndex = 0;//inifileで読み込み
	//g_ClearColor[BGCOL_MAX][4] = {
	//	{0.0f, 0.0f, 0.0f, 1.0f},
	//	{1.0f, 1.0f, 1.0f, 1.0f},
	//	{0.0f, 0.0f, 1.0f, 1.0f},
	//	{0.0f, 0.5f, 0.25f, 1.0f},
	//	{1.0f, 0.5f, 0.5f, 1.0f}
	//};
	g_ClearColor[BGCOL_BLACK][0] = 0.0f;
	g_ClearColor[BGCOL_BLACK][1] = 0.0f;
	g_ClearColor[BGCOL_BLACK][2] = 0.0f;
	g_ClearColor[BGCOL_BLACK][3] = 1.0f;
	g_ClearColor[BGCOL_WHITE][0] = 1.0f;
	g_ClearColor[BGCOL_WHITE][1] = 1.0f;
	g_ClearColor[BGCOL_WHITE][2] = 1.0f;
	g_ClearColor[BGCOL_WHITE][3] = 1.0f;
	g_ClearColor[BGCOL_BLUE][0] = 0.0f;
	g_ClearColor[BGCOL_BLUE][1] = 0.0f;
	g_ClearColor[BGCOL_BLUE][2] = 1.0f;
	g_ClearColor[BGCOL_BLUE][3] = 1.0f;
	g_ClearColor[BGCOL_GREEN][0] = 0.0f;
	g_ClearColor[BGCOL_GREEN][1] = 0.5f;
	g_ClearColor[BGCOL_GREEN][2] = 0.25f;
	g_ClearColor[BGCOL_GREEN][3] = 1.0f;
	g_ClearColor[BGCOL_RED][0] = 1.0f;
	g_ClearColor[BGCOL_RED][1] = 0.5f;
	g_ClearColor[BGCOL_RED][2] = 0.5f;
	g_ClearColor[BGCOL_RED][3] = 1.0f;
	g_ClearColor[BGCOL_GRAY][0] = 0.5f;
	g_ClearColor[BGCOL_GRAY][1] = 0.5f;
	g_ClearColor[BGCOL_GRAY][2] = 0.5f;
	g_ClearColor[BGCOL_GRAY][3] = 1.0f;



	s_firstmodelpanelpos = true;
	s_modelpanelpos = WindowPos(0, 0);;
	s_firstmotionpanelpos = true;
	s_motionpanelpos = WindowPos(0, 0);;
	s_firstcamerapanelpos = true;
	s_camerapanelpos = WindowPos(0, 0);;



	s_opedelmodelcnt = -1;
	s_opedelmotioncnt = -1;
	s_underdelmodel = false;
	s_underdelmotion = false;
	s_opeselectmodelcnt = -1;
	s_opeselectcameracnt = -1;
	s_opeselectmotioncnt = -1;
	s_underselectmodel = false;
	s_underselectcamera = false;
	s_underselectmotion = false;
	s_underfilteringbymenu = false;
	s_underdispmodel = false;
	s_opedispmodelcnt = -1;


	s_dispsampleui = true;
	s_dispmw = true;
	s_disptool = true;
	s_dispobj = false;
	s_dispmodel = false;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
	s_dispmotion = false;//!!!!!!!!!!!!!!!! motionpanelのdispflag
	s_dispcamera = false;//!!!!!!!!!!!!!!!! camerapanelのdispflag
	s_dispground = true;
	s_dispselect = true;
	//s_displightarrow = true;
	s_dispconvbone = false;
	s_dispmodelworldmat = false;
	s_pickmodelworldmat = false;
	s_removegrassflag = false;
	s_removegrassdistance = 50.0f;
	//s_putgrassflag = false;

	s_oprigflag = 0;

	s_tkeyflag = 0;//bone twist
	s_closeFlag = false;			// 終了フラグ
	s_closetoolFlag = false;
	s_closeobjFlag = false;
	s_closemodelFlag = false;
	s_closemotionFlag = false;
	s_closecameraFlag = false;
	s_DcloseFlag = false;
	s_ScloseFlag = false;
	s_GcloseFlag = false;
	s_displimitscloseFlag = false;
	s_undoFlag = false;
	s_redoFlag = false;
	s_undoredoFromPlayerButton = false;
	s_frogFlag = false;

	s_copycameraFlag = false;
	s_pastecameraFlag = false;
	s_initmpcameraFlag = false;
	s_interpolatecameraFlag = false;
	s_smoothcameraFlag = false;

	s_plateFlag = false;
	s_copyFlag = false;			// コピーフラグ
	s_copyLW2WFlag = false;
	s_zeroFrameFlag = false;
	//s_oneFrameFlag = false;
	s_selCopyHisotryFlag = false;
	s_symcopyFlag = false;
	s_symcopyFlag2 = false;
	s_undersymcopyFlag = false;
	s_cutFlag = false;			// カットフラグ
	s_pasteFlag = false;			// ペーストフラグ
	s_cursorFlag = false;			// カーソル移動フラグ
	s_cursorUnderUndo = false;
	s_LTimelineApplyFrameFlag = false;
	s_selectFlag = false;			// キー選択フラグ
	s_keyShiftFlag = false;		// キー移動フラグ
	s_deleteFlag = false;		// キー削除フラグ
	s_motpropFlag = false;
	s_markFlag = false;
	s_selboneFlag = false;
	s_selboneAndPasteFlag = false;
	s_RboneAndPasteFlag = false;
	s_initmpFlag = false;
	s_filterFlag = false;
	s_filterState = 0;
	s_smoothFlag = false;
	s_constexeFlag = false;
	s_constrefreshFlag = false;
	//s_filternodlg = false;
	s_jumpinterpolateFlag = false;
	s_interpolateFlag = false;
	s_interpolateState = 0;
	s_skipJointMark = 0;
	s_firstkeyFlag = false;
	s_lastkeyFlag = false;
	s_btresetFlag = false;
	s_LcloseFlag = false;
	s_LnextkeyFlag = false;
	s_LbefkeyFlag = false;
	s_LcursorFlag = false;			// カーソル移動フラグ
	s_LupFlag = false;
	s_LstartFlag = false;
	s_LstopFlag = false;
	//s_LstopDoneCount = 0;
	s_EcursorFlag = false;			// カーソル移動フラグ
	s_timelineRUpFlag = false;
	s_timelinembuttonFlag = false;
	s_delmodelFlag = false;
	s_delallmodelFlag = false;
	s_mbuttoncnt = 1;
	s_mbuttonstart = 0.0;
	s_timelinewheelFlag = false;
	s_timelineshowposFlag = false;
	s_prevrangeFlag = false;
	s_nextrangeFlag = false;
	s_newmotFlag = false;
	s_delcurmotFlag = false;
	s_calclimitedwmState = 0;
	s_180DegFlag = false;
	s_scaleAllInitFlag = false;
	s_topslidersEditRateFlag = false;
	s_topslidersSpeedFlag = false;
	s_topslidersTopPosFlag = false;
	s_topslidersBrushRepeatsFlag = false;
	s_topslidersBrushMirrorUFlag = false;
	s_topslidersBrushMirrorVFlag = false;



	s_toonmqomaterial = nullptr;
	s_toonparamchange = false;
	s_skytoonparamchange = false;
	s_hsvtoonforall.Init();
	s_skyhsvtoonforall.Init();
	s_shadertypeparams.InitParams(s_hsvtoonforall);
	g_skyindex = 0;
	int skyindex;
	for (skyindex = 0; skyindex < SKYSLOTNUM; skyindex++) {
		s_skyparams[skyindex].InitParams(s_skyhsvtoonforall);
	}

	g_refposflag = false;

	s_temppath[0] = 0L;
	::GetTempPathW(MAX_PATH, s_temppath);
	_ASSERT(s_temppath[0]);
	s_cptfilename.clear();
	GetCPTFileName(s_cptfilename);//s_temppathセットより後。初回。


	LoadChooseColor();//s_temppathのセットよりも後


	InitDSValues();

	s_onselectplugin = 0;
	s_plugin = 0;

	//s_onefps = 0;

	s_rectime = 0.0;
	s_reccnt = 0;
	g_btsimurecflag = false;

	s_bvh2fbxhandle1 = INVALID_HANDLE_VALUE;
	s_bvh2fbxhandle2 = INVALID_HANDLE_VALUE;
	s_bvh2fbxnum = 0;
	s_bvh2fbxcnt = 0;
	s_befbvh2fbxnum = 0;
	s_befbvh2fbxcnt = 0;
	g_bvh2fbxbatchflag = 0;
	s_bvh2fbxbatchwnd = 0;
	s_bvh2fbxout.clear();

	s_saveretargetmodel = 0;
	s_convbone_model_batch_selindex = 0;
	s_retargethandle1 = INVALID_HANDLE_VALUE;
	s_retargethandle2 = INVALID_HANDLE_VALUE;
	s_retargetnum = 0;
	s_retargetcnt = 0;
	s_befretargetnum = 0;
	s_befretargetcnt = 0;
	g_retargetbatchflag = 0;
	s_retargetbatchwnd = 0;
	s_retargetout.clear();

	g_calclimitedwmflag = 0;

	g_mousehereimage = 0;
	g_menuaimbarimage = 0;
	g_playerbutton_target26 = 0;
	g_playerbutton_target_inv26 = 0;
	g_playerbutton_target40 = 0;
	g_playerbutton_target_inv40 = 0;


	g_numBG = nullptr;
	int numindex;
	for (numindex = 0; numindex < SKNUMBUTTON_MAX; numindex++) {
		g_numbutton[numindex] = nullptr;
		g_numbutton_pushed[numindex] = nullptr;
	}
	int alnumindex;
	for (alnumindex = 0; alnumindex < SKALNUM_MAX; alnumindex++) {
		g_alnumbutton[alnumindex] = nullptr;
		g_alnumbutton_pushed[alnumindex] = nullptr;
	}

	g_currentsubmenuid = 0;
	g_currentsubmenupos.x = 0;
	g_currentsubmenupos.y = 0;

	g_submenuwidth = 32;

	g_filterdlghwnd = 0;

	Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

	s_cursubmenu = 0;

	g_dsmousewait = 0;
	g_mouseherebmp = 0;
	g_tranbmp = 0;

	s_sampleuihwnd = 0;
	s_nowloading = true;

	s_getsym_retmode = 0;

	s_rcmainwnd.top = 0;
	s_rcmainwnd.left = 0;
	s_rcmainwnd.bottom = 0;
	s_rcmainwnd.right = 0;
	s_rc3dwnd.top = 0;
	s_rc3dwnd.left = 0;
	s_rc3dwnd.bottom = 0;
	s_rc3dwnd.right = 0;
	s_rctreewnd.top = 0;
	s_rctreewnd.left = 0;
	s_rctreewnd.bottom = 0;
	s_rctreewnd.right = 0;
	s_rctoolwnd.top = 0;
	s_rctoolwnd.left = 0;
	s_rctoolwnd.bottom = 0;
	s_rctoolwnd.right = 0;
	s_rcltwnd.top = 0;
	s_rcltwnd.left = 0;
	s_rcltwnd.bottom = 0;
	s_rcltwnd.right = 0;
	s_rcsidemenuwnd.top = 0;
	s_rcsidemenuwnd.left = 0;
	s_rcsidemenuwnd.bottom = 0;
	s_rcsidemenuwnd.right = 0;
	s_rcrigidwnd.top = 0;
	s_rcrigidwnd.left = 0;
	s_rcrigidwnd.bottom = 0;
	s_rcrigidwnd.right = 0;
	//s_rcshadertypewnd.top = 0;
	//s_rcshadertypewnd.left = 0;
	//s_rcshadertypewnd.bottom = 0;
	//s_rcshadertypewnd.right = 0;
	s_rcshadertypeparamswnd.top = 0;
	s_rcshadertypeparamswnd.left = 0;
	s_rcshadertypeparamswnd.bottom = 0;
	s_rcshadertypeparamswnd.right = 0;
	s_rcinfownd.top = 0;
	s_rcinfownd.left = 0;
	s_rcinfownd.bottom = 0;
	s_rcinfownd.right = 0;
	s_rctopsliderswnd.top = 0;
	s_rctopsliderswnd.left = 0;
	s_rctopsliderswnd.bottom = 0;
	s_rctopsliderswnd.right = 0;
	s_rcmodelpanel.top = 0;
	s_rcmodelpanel.left = 0;
	s_rcmodelpanel.bottom = 0;
	s_rcmodelpanel.right = 0;
	s_rcmotionpanel.top = 0;
	s_rcmotionpanel.left = 0;
	s_rcmotionpanel.bottom = 0;
	s_rcmotionpanel.right = 0;
	s_rccamerapanel.top = 0;
	s_rccamerapanel.left = 0;
	s_rccamerapanel.bottom = 0;
	s_rccamerapanel.right = 0;


	//s_CamTargetCheckBox = 0;
	////s_LightCheckBox = 0;
	//s_ApplyEndCheckBox = 0;
	////s_SlerpOffCheckBox = 0;
	////s_AbsIKCheckBox = 0;
	//s_HighRpmCheckBox = 0;
	//s_BoneMarkCheckBox = 0;
	//s_LightingCheckBox = 0;
	//s_RigidMarkCheckBox = 0;
	////s_PseudoLocalCheckBox = 0;
	////s_WallScrapingIKCheckBox = 0;
	////s_LimitDegCheckBox = 0;
	//s_BrushMirrorUCheckBox = 0;
	//s_BrushMirrorVCheckBox = 0;
	//s_IfMirrorVDiv2CheckBox = 0;
	////s_VSyncCheckBox = 0;
	//s_TraRotCheckBox = 0;
	////s_EdgeSmpCheckBox = 0;
	//s_PreciseCheckBox = 0;
	//s_X180CheckBox = 0;
	//s_TPoseCheckBox = 0;
	//s_TipText1 = 0;
	//s_TipText2 = 0;
	//s_TipText3 = 0;
	//s_TipText4 = 0;
	//s_TipText5 = 0;

	////Left
	//s_ui_fpskind = 0;
	//s_ui_lightscale = 0;
	//s_ui_lighting = 0;
	//s_ui_dispbone = 0;
	//s_ui_disprigid = 0;
	//s_ui_boneaxis = 0;
	//s_ui_bone = 0;
	//s_ui_locktosel = 0;
	//s_ui_iklevel = 0;
	//s_ui_editmode = 0;
	//s_ui_texapplyrate = 0;
	//s_ui_slapplyrate = 0;
	//s_ui_motionbrush = 0;
	//s_ui_texikorder = 0;
	//s_ui_slikorder = 0;
	////s_ui_texikrate = 0;
	////s_ui_slikrate = 0;
	//s_ui_texref = 0;
	//s_ui_slirefpos = 0;
	//s_ui_slirefalpha = 0;
	//s_ui_applytotheend = 0;
	//s_ui_slerpoff = 0;
	////s_ui_absikon = 0;
	//s_ui_highrpmon = 0;
	//s_ui_texbrushrepeats = 0;
	//s_ui_brushrepeats = 0;
	//s_ui_brushmirroru = 0;
	//s_ui_brushmirrorv = 0;
	//s_ui_ifmirrorvdiv2 = 0;

	////Left 2nd
	//s_ui_texthreadnum = 0;
	//s_ui_slthreadnum = 0;
	//s_ui_umthreads = 0;
	//s_ui_slumthreads = 0;
	////s_ui_pseudolocal = 0;
	//s_ui_wallscrapingik = 0;
	//s_ui_limiteul = 0;
	//s_ui_texspeed = 0;
	//s_ui_speed = 0;
	////s_ui_vsync = 0;
	//s_ui_trarot = 0;
	////s_ui_edgesmp = 0;
	//s_ui_precise = 0;
	//s_ui_x180 = 0;
	//s_ui_tpose = 0;

	////Bullet
	//s_ui_btstart = 0;
	//s_ui_btrecstart = 0;
	//s_ui_stopbt = 0;
	//s_ui_texbtcalccnt = 0;
	//s_ui_btcalccnt = 0;
	//s_ui_texerp = 0;
	//s_ui_erp = 0;
	////PhysicsIK
	//s_ui_texphysmv = 0;
	//s_ui_slphysmv = 0;
	//s_ui_physrotstart = 0;
	//s_ui_physmvstart = 0;
	//s_ui_physikstop = 0;



	//bool bsuccess1 = false;
	//bool bsuccess2 = false;
	//if ((s_appcnt == 0) && (s_launchbyc4 == 0)) {//C4から起動時にはゲームパッド未対応。//2021/08/30
	//	bsuccess1 = StartDS4();
	//}
	//else {
	//	bsuccess1 = false;
	//}
	//if (bsuccess1) {
	//	bsuccess2 = GetController();
	//}
	//if (bsuccess1 && bsuccess2) {
	//	g_enableDS = true;
	//	s_dsdeviceid = 0;
	//	s_curaimbarno = 0;
	//}
	//else {
		g_enableDS = false;
		s_dsdeviceid = -1;
		s_curaimbarno = -1;
	//}


	CRigidElem::InitRigidElems();
	CBone::InitBones();
	CMotionPoint::InitMotionPoints();
	OrgWinGUI::InitEulKeys();
	OrgWinGUI::InitKeys();


	s_motmenuindexmap.clear();
	s_cameramenuindexmap.clear();
	s_reindexmap.clear();
	s_rgdindexmap.clear();

	//s_lightsforeditdlg = 0;
	//s_latertransparentdlg = 0;
	//s_shadowparamsdlg = 0;
	//int dlgno;
	//for (dlgno = 0; dlgno < GUIDLGNUM; dlgno++) {
	//	s_guidlg[GUIDLGNUM] = nullptr;
	//}
	

	s_rotaxisdlg = 0;

	g_motionbrush_method = 0;
	g_motionbrush_startframe = 0.0;
	g_motionbrush_endframe = 0.0;
	g_motionbrush_applyframe = 0.0;
	g_motionbrush_numframe = 0.0;
	g_motionbrush_frameleng = 0;
	g_motionbrush_value = 0;

	s_timelineWnd = 0;
	s_owpTimeline = 0;
	s_owpPlayerButton = 0;
	s_parentcheck = 0;
	s_LtimelineWnd = 0;
	s_owpLTimeline = 0;
	s_owpEulerGraph = 0;
	s_LTSeparator = 0;
	s_sidemenusp1 = 0;
	s_sidemenusp2 = 0;
	s_sidemenusp3 = 0;
	s_sidemenu_sellock = 0;
	s_sidemenu_sellockOnce = 0;
	s_sidemenu_targetdisp = 0;
	s_sidemenu_moveeyepos = 0;
	s_sidemenu_camdistSlider = 0;
	s_camdistsliderflag = false;
	s_camdistsliderval = g_camdist;

	s_topSlidersWnd = 0;
	s_topSlidersSeparator1 = 0;
	s_topSlidersSeparator2 = 0;
	s_owpEditRateSlider = 0;
	s_owpSpeedSlider = 0;
	//s_owpTopPosSlider = 0;
	//s_mainmenulabel = 0;
	s_topSlidersSeparator3 = 0;
	s_topSlidersSeparator4 = 0;
	s_owpBrushRepeatsSlider = 0;
	s_owpBrushMirrorU = 0;
	s_owpBrushMirrorV = 0;


	s_toolWnd = 0;
	s_toolSeparator = 0;
	s_toolCopyB = 0;
	s_toolZeroFrameB = 0;
	s_toolSymCopyB = 0;
	s_toolCutB = 0;
	s_toolPasteB = 0;
	s_toolDeleteB = 0;
	s_toolMotPropB = 0;
	s_toolMarkB = 0;
	s_toolSelBoneB = 0;
	s_toolInitMPB = 0;
	s_toolFilterB = 0;
	s_toolInterpolateB = 0;
	s_toolSelectCopyFileName = 0;
	s_toolSkipRenderBoneMarkB = 0;
	s_toolSkipRenderBoneMarkB2 = 0;
	s_tool180deg = 0;
	s_toolScaleInitAllB = 0;
	s_toolCameraDollyB = 0;
	s_toolMaterialRateB = 0;
	s_toolModelWorldMatB = 0;

	s_customrigbone = 0;
	s_customrigdlg = 0;

	g_underselectingframe = 0;
	s_buttonselectstart = 0.0;
	s_buttonselectend = 0.0;
	s_buttonselecttothelast = 0;
	g_playingstart = 1.0;
	g_playingend = 1.0;
	s_savebuttonselectstart = 0.0;
	s_savebuttonselectend = 0.0;
	s_savebuttonselecttothelast = 0;
	s_saveplayingstart = 1.0;
	s_saveplayingend = 1.0;
	s_savemotionbrush_startframe = 1.0;
	s_savemotionbrush_endframe = 1.0;
	s_savemotionbrush_applyframe = 1.0;
	s_savemotionbrush_numframe = 1.0;
	s_savemotionbrush_frameleng = 1;


	s_editmotionflag = -1;
	s_editcameraflag = -1;

	s_editrangehistoryno = 0;
	s_editrangesetindex = 0;
	s_editrangehistory = new CEditRange[EDITRANGEHISTORYNUM];
	if (!s_editrangehistory) {
		_ASSERT(0);
		return;
	}
	int erhno;
	for (erhno = 0; erhno < EDITRANGEHISTORYNUM; erhno++) {
		(s_editrangehistory + erhno)->Clear();
	}

	ChaMatrixIdentity(&s_selectmat);
	ChaMatrixIdentity(&s_selectmat_posture);
	ChaMatrixIdentity(&s_ikselectmat);
	s_selectuserscale = 100;

	s_convbone_model_batch = 0;

	{
		s_toolspritemode = 0;
		//::ZeroMemory(s_spundo, sizeof(CSpElem) * 2);
		//::ZeroMemory(s_spaxis, sizeof(SPAXIS) * SPAXISNUM);
		//::ZeroMemory(s_spcam, sizeof(SPCAM) * SPR_CAM_MAX);
		//::ZeroMemory(s_sprig, sizeof(CSpElem) * SPRIGMAX);
		//::ZeroMemory(&s_spbt, sizeof(CSpElem));
		//::ZeroMemory(&s_spmousehere, sizeof(CSpElem));
		//::ZeroMemory(&s_spret2prev, sizeof(CSpElem));
		//::ZeroMemory(&s_spret2prev2, sizeof(CSpElem));
		//::ZeroMemory(&s_spcplw2w, sizeof(CSpElem));
		//::ZeroMemory(&s_spsmooth, sizeof(CSpElem));
		//::ZeroMemory(&s_spconstexe, sizeof(CSpElem));
		//::ZeroMemory(&s_spconstrefresh, sizeof(CSpElem));
		//::ZeroMemory(&s_spcopy, sizeof(CSpElem));
		//::ZeroMemory(&s_spsymcopy, sizeof(CSpElem));
		//::ZeroMemory(&s_sppaste, sizeof(CSpElem));
		//::ZeroMemory(&s_spcopyhistory, sizeof(CSpElem));
		//::ZeroMemory(&s_spinterpolate, sizeof(CSpElem));
		//::ZeroMemory(&s_spinit, sizeof(CSpElem));
		//::ZeroMemory(&s_spscaleinit, sizeof(CSpElem));
		//::ZeroMemory(&s_spproperty, sizeof(CSpElem));
		//::ZeroMemory(&s_spzeroframe, sizeof(CSpElem));
		//::ZeroMemory(&s_spcameradolly, sizeof(CSpElem));
		//::ZeroMemory(&s_spmodelposdir, sizeof(CSpElem));
		//::ZeroMemory(&s_spmaterialrate, sizeof(CSpElem));
		//::ZeroMemory(&s_mousecenteron, sizeof(CSpElem));
	}
	//{
	//	::ZeroMemory(&s_spaimbar, sizeof(SPGUISW) * SPAIMBARNUM);
	//	int spgno;
	//	for (spgno = 0; spgno < SPAIMBARNUM; spgno++) {
	//		s_spaimbar[spgno].state = false;
	//	}
	//}
	//{
	//	::ZeroMemory(&s_spmenuaimbar, sizeof(SPGUISW) * SPMENU_MAX);
	//	int spgno;
	//	for (spgno = 0; spgno < SPMENU_MAX; spgno++) {
	//		s_spmenuaimbar[spgno].state = false;
	//	}
	//}
	//{
	//	::ZeroMemory(&s_spsel3d, sizeof(SPGUISW));
	//	s_spsel3d.state = false;
	//}
	{
		//::ZeroMemory(&s_spikmodesw, sizeof(SPGUISW) * 3);
		s_spikmodesw[0].state = true;
		s_spikmodesw[1].state = false;
		s_spikmodesw[2].state = false;
	}
	//{
	//	::ZeroMemory(&s_sprefpos, sizeof(SPGUISW));
	//	//s_sprefpos.state = true;
		s_sprefpos.state = false;//2021/11/22 ReferencePose Off by default
	//}
	//{
	//	::ZeroMemory(&s_splimiteul, sizeof(SPGUISW));
	//	//s_splimiteul.state = true;
	//	s_splimiteul.state = false;
	//}
	//{
	//	::ZeroMemory(&s_spcameramode, sizeof(SPGUISW));
	//	//s_splimiteul.state = true;
	//	s_spcameramode.state = false;
	//}
	//{
	//	::ZeroMemory(&s_spcamerainherit, sizeof(SPGUISW3));
	//	//s_splimiteul.state = true;
	//	s_spcamerainherit.mode = CAMERA_INHERIT_ALL;
	//}
	//{
	//	::ZeroMemory(&s_spscraping, sizeof(SPGUISW));
	//	//s_spscraping.state = true;
	//	s_spscraping.state = false;
	//}
	//{
	//	::ZeroMemory(&s_spguisw, sizeof(SPGUISW) * SPGUISWNUM);
	//	int spgno;
	//	for (spgno = 0; spgno < SPGUISWNUM; spgno++) {
	//		s_spguisw[spgno].state = false;
	//	}
	//}
	//{
	//	::ZeroMemory(&s_spdispsw, sizeof(SPGUISW) * SPDISPSWNUM);
	//	int spgno;
	//	for (spgno = 0; spgno < SPDISPSWNUM; spgno++) {
	//		s_spdispsw[spgno].state = false;
	//	}
	//	s_spdispsw[SPDISPSW_LIGHTS].state = true;
	//}
	//{
	//	::ZeroMemory(&s_sprigidsw, sizeof(SPGUISW) * SPRIGIDSWNUM);
	//	int spgno;
	//	for (spgno = 0; spgno < SPRIGIDSWNUM; spgno++) {
	//		s_sprigidsw[spgno].state = false;
	//	}
	//	s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].state = true;
	//}
	//::ZeroMemory(&s_spretargetsw, sizeof(SPGUISW) * SPRETARGETSWNUM);
	//s_spretargetsw[SPRETARGETSW_RETARGET].state = false;
	//s_spretargetsw[SPRETARGETSW_LIMITEULER].state = false;


	g_bonecntmap.clear();

	ChaMatrixIdentity(&s_inimat);

	g_bEnablePreshader = true;


	//for (int i = 0; i < MAX_LIGHTS; i++) {
	//	g_LightControl[i].SetLightDirection(
	//		ChaVector3((float)sin(PI * 2 * (MAX_LIGHTS - i - 1) / MAX_LIGHTS - PI / 6),
	//			0.0f,
	//			(float)-cos(PI * 2 * (MAX_LIGHTS - i - 1) / MAX_LIGHTS - PI / 6)).D3DX());
	//}
	//g_nActiveLight = 0;
	ZeroMemory(g_lightNo, sizeof(int)* LIGHTNUMMAX);
	g_nNumActiveLights = 1;
	g_fLightScale = 1.0f;
	int slotindex;
	int lightindex;
	for (slotindex = 0; slotindex < LIGHTSLOTNUM; slotindex++) {
		for (lightindex = 0; lightindex < LIGHTNUMMAX; lightindex++) {
			double initrad = PI * 2.0 * (double)lightindex / (double)LIGHTNUMMAX;// -PI / 6;
			ChaVector3 dir0, ndir;
			dir0.SetParams((float)sin(initrad),
				-0.5f,
				(float)-cos(initrad));
			ChaVector3Normalize(&ndir, &dir0);
			g_lightDir[slotindex][lightindex] = ndir;
			//g_lightdirforshader[lightindex] = -g_lightdir[lightindex];//-lightdir

			g_lightDiffuse[slotindex][lightindex].SetParams(1.0f, 1.0f, 1.0f);
			//g_lightdiffuseforshader[lightindex].SetParams(g_lightdiffuse[lightindex].x, g_lightdiffuse[lightindex].y, g_lightdiffuse[lightindex].z, 1.0f);

			if (lightindex == 0) {//初期状態では lightindex == 0のときキャラの正面を照らす向き
				g_lightEnable[slotindex][lightindex] = true;
			}
			else {
				g_lightEnable[slotindex][lightindex] = false;
			}
			g_lightDirWithView[slotindex][lightindex] = true;

			g_lightScale[slotindex][lightindex] = 1.0f;

			//g_LightControl[lightindex].SetLightDirection(g_lightdir[lightindex].D3DX());

		}
	}
	LoadLightsForEdit();//ファイルに保存してあるLight情報を g_lightdirとg_ligthdiffuseとg_lightenableとg_lightdirwithviewに読込
	LoadThreshold();

	g_lightSlot = 0;
	SetLightDirection();


	LoadShadowParamsFile();//ファイルに保存してあるShadowParams情報をg_shadowmap_*に読み込む



	//CreateUtDialog();



	//s_updatetimeline = new CThreadingUpdateTimeline();
	//if(!s_updatetimeline){
	//	return;
	//}
	//s_updatetimeline->CreateThread();



//////////
	InitPickInfo(&s_pickinfo);

	s_modelpanel.panel = 0;
	s_modelpanel.scroll = 0;
	s_modelpanel.radiobutton = 0;
	s_modelpanel.separator = 0;
	s_modelpanel.separator2 = 0;
	s_modelpanel.checkvec.clear();
	s_modelpanel.delbutton.clear();
	s_modelpanel.modelindex = -1;

	s_motionpanel.panel = 0;
	s_motionpanel.scroll = 0;
	s_motionpanel.radiobutton = 0;
	s_motionpanel.separator = 0;
	s_motionpanel.delbutton.clear();
	s_motionpanel.modelindex = -1;

	s_camerapanel.panel = 0;
	s_camerapanel.scroll = 0;
	s_camerapanel.radiobutton = 0;
	s_camerapanel.separator = 0;
	s_camerapanel.delbutton.clear();
	s_camerapanel.modelindex = -1;


	//s_cameradollydlgwnd = 0;
	s_materialratedlgwnd = 0;
	s_modelworldmatdlgwnd = 0;
	s_jumpgravitydlgwnd = 0;
	//s_shadertypeparamsdlgwnd = 0;
	//s_skyparamsdlgwnd = 0;
	//s_fogparamsdlgwnd = 0;
	//s_dofparamsdlgwnd = 0;


	{
		char strtitle[256];
		strcpy_s(strtitle, 256, "BpPiyo");
		s_bpWorld = new BPWorld(NULL, s_matWorld, strtitle, // ウィンドウのタイトル
			460, 460,         // ウィンドウの幅と高さ [pixels]
			NULL);    // モニタリング用関数へのポインタ  
		_ASSERT(s_bpWorld);


		s_bpWorld->enableFixedTimeStep(false);
		//s_bpWorld->enableFixedTimeStep(false);
		//s_bpWorld->setTimeStep(0.015);// seconds
		s_bpWorld->setGlobalERP(btScalar(g_erp));// ERP
		//s_bpWorld->start();// ウィンドウを表示して，シミュレーションを開始する
		s_btWorld = s_bpWorld->getDynamicsWorld();
		s_bpWorld->setNumThread(g_numthread);
	}


	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	InterlockedExchange(&g_underApealingMouseHere, (LONG)0);
	//if (g_enableDS == true) {
	//	s_dsupdater = new CDSUpdateUnderTracking();
	//	if (s_dsupdater) {
	//		int isuccess = s_dsupdater->CreateDSUpdateUnderTracking(GetModuleHandle(NULL));
	//		if (isuccess != 0) {
	//			delete s_dsupdater;
	//			s_dsupdater = 0;
	//		}
	//	}
	//}
	//else {
	//	s_dsupdater = 0;
	//}

	s_doneinit = 1;
}


int OnPluginClose()
{
	if (!s_plugin) {
		return 0;
	}

	int pluginno;
	for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
		if ((s_plugin + pluginno)->validflag == 1) {
			(s_plugin + pluginno)->CallOnClose();
		}
	}
	return 0;
}


void OnDestroyDevice()
{
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//DirectX11 : because of DX11 defferd destroy, some ref count will be alive.//!!!!!!!!!!!!!!!
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


	g_endappflag = 1;
	//UNREFERENCED_PARAMETER(pUserContext);

	OrgWindowListenMouse(false);

	SaveIniFile();
	SaveChooseColor();
	SaveLightsForEdit();
	SaveThreshold();
	SaveShadowParamsFile();
	SaveSkyParamsFile();
	SaveFogParamsFile();
	SaveDofParamsFile();

	//if (s_updatetimeline) {
	//	delete s_updatetimeline;
	//	s_updatetimeline = 0;
	//}


	OnPluginClose();
	if (s_plugin) {
		delete[] s_plugin;
		s_plugin = 0;
	}

	if (s_hhook) {
		UnhookWinEvent(s_hhook);
		s_hhook = NULL;
	}




	//if (s_eventhook) {
		////UnhookWinEvent(s_eventhook);
		//s_eventhook = 0;
	//}


	DestroySprites();

	//if (s_dsupdater) {
	//	delete s_dsupdater;
	//	s_dsupdater = 0;
	//}

	//EndDS4();

	if (g_mouseherebmp) {
		::DeleteObject(g_mouseherebmp);
		g_mouseherebmp = 0;
	}


	if (g_mousehereimage) {
		delete g_mousehereimage;
		g_mousehereimage = 0;
	}
	if (g_menuaimbarimage) {
		delete g_menuaimbarimage;
		g_menuaimbarimage = 0;
	}
	if (g_playerbutton_target26) {
		delete g_playerbutton_target26;
		g_playerbutton_target26 = 0;
	}
	if (g_playerbutton_target_inv26) {
		delete g_playerbutton_target_inv26;
		g_playerbutton_target_inv26 = 0;
	}
	if (g_playerbutton_target40) {
		delete g_playerbutton_target40;
		g_playerbutton_target40 = 0;
	}
	if (g_playerbutton_target_inv40) {
		delete g_playerbutton_target_inv40;
		g_playerbutton_target_inv40 = 0;
	}


	if (g_numBG) {
		delete g_numBG;
		g_numBG = 0;
	}
	int numindex;
	for (numindex = 0; numindex < SKNUMBUTTON_MAX; numindex++) {
		if (g_numbutton[numindex]) {
			delete g_numbutton[numindex];
			g_numbutton[numindex] = nullptr;
		}
		if (g_numbutton_pushed[numindex]) {
			delete g_numbutton_pushed[numindex];
			g_numbutton_pushed[numindex] = nullptr;
		}
	}

	int alnumindex;
	for (alnumindex = 0; alnumindex < SKALNUM_MAX; alnumindex++) {
		if (g_alnumbutton[alnumindex]) {
			delete g_alnumbutton[alnumindex];
			g_alnumbutton[alnumindex] = nullptr;
		}
		if (g_alnumbutton_pushed[alnumindex]) {
			delete g_alnumbutton_pushed[alnumindex];
			g_alnumbutton_pushed[alnumindex] = nullptr;
		}
	}


	Gdiplus::GdiplusShutdown(gdiplusToken);


	s_motmenuindexmap.clear();
	s_cameramenuindexmap.clear();
	s_reindexmap.clear();
	s_rgdindexmap.clear();


	//::KillTimer(g_mainhwnd, s_iktimerid);


	if (s_editrangehistory) {
		delete[] s_editrangehistory;
		s_editrangehistory = 0;
	}
	s_editrangehistoryno = 0;

	//if (s_anglelimitdlg) {
	//	s_underanglelimithscroll = 0;
	//	if (IsWindow(s_anglelimitdlg)) {
	//		DestroyWindow(s_anglelimitdlg);
	//	}
	//	s_anglelimitdlg = 0;
	//}
	//if (s_lightsforeditdlg) {
	//	if (IsWindow(s_lightsforeditdlg)) {
	//		DestroyWindow(s_lightsforeditdlg);
	//	}
	//	s_lightsforeditdlg = 0;
	//}
	//if (s_latertransparentdlg) {
	//	if (IsWindow(s_latertransparentdlg)) {
	//		DestroyWindow(s_latertransparentdlg);
	//	}
	//	s_latertransparentdlg = nullptr;
	//}
	//if (s_shadowparamsdlg) {
	//	if (IsWindow(s_shadowparamsdlg)) {
	//		DestroyWindow(s_shadowparamsdlg);
	//	}
	//	s_shadowparamsdlg = nullptr;
	//}
	//int guidlgno;
	//for (guidlgno = 0; guidlgno < GUIDLGNUM; guidlgno++) {
	//	HWND delhwnd = s_guidlg[guidlgno];
	//	if ((delhwnd != nullptr) && IsWindow(delhwnd)) {
	//		DestroyWindow(delhwnd);
	//	}
	//	s_guidlg[guidlgno] = nullptr;
	//}


	if (s_rotaxisdlg) {
		DestroyWindow(s_rotaxisdlg);
		s_rotaxisdlg = 0;
	}
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}


	s_copyhistorydlg2.DestroyObjs();
	s_dollyhistorydlg2.DestroyObjs();
	s_rigidparamsdlg.DestroyObjs();
	s_displimitsdlg.DestroyObjs();
	s_bulletdlg.DestroyObjs();
	s_projloddlg.DestroyObjs();
	s_blendshapedlg.DestroyObjs();
	s_lightsdlg.DestroyObjs();
	s_dispgroupdlg.DestroyObjs();
	s_latertransparentdlg.DestroyObjs();
	s_shadertypedlg.DestroyObjs();
	s_shaderparamsdlg.DestroyObjs();
	s_skyparamsdlg.DestroyObjs();
	s_retargetdlg.DestroyObjs();
	s_limiteuldlg.DestroyObjs();
	s_shadowdlg.DestroyObjs();
	s_impulsedlg.DestroyObjs();
	s_gplanedlg.DestroyObjs();
	s_dampanimdlg.DestroyObjs();
	s_thresholddlg.DestroyObjs();
	s_fogdlg.DestroyObjs();
	s_cpinfodlg2.DestroyObjs();


	//if (s_cameradollydlgwnd) {
	//	DestroyWindow(s_cameradollydlgwnd);
	//	s_cameradollydlgwnd = 0;
	//}
	if (s_materialratedlgwnd) {
		DestroyWindow(s_materialratedlgwnd);
		s_materialratedlgwnd = 0;
	}
	if (s_modelworldmatdlgwnd) {
		DestroyWindow(s_modelworldmatdlgwnd);
		s_modelworldmatdlgwnd = 0;
	}
	if (s_jumpgravitydlgwnd) {
		DestroyWindow(s_jumpgravitydlgwnd);
		s_jumpgravitydlgwnd = 0;
	}
	//if (s_shadertypeparamsdlgwnd) {
	//	DestroyWindow(s_shadertypeparamsdlgwnd);
	//	s_shadertypeparamsdlgwnd = 0;
	//}
	//if (s_skyparamsdlgwnd) {
	//	DestroyWindow(s_skyparamsdlgwnd);
	//	s_skyparamsdlgwnd = 0;
	//}
	//if (s_fogparamsdlgwnd) {
	//	DestroyWindow(s_fogparamsdlgwnd);
	//	s_fogparamsdlgwnd = 0;
	//}
	//if (s_dofparamsdlgwnd) {
	//	DestroyWindow(s_dofparamsdlgwnd);
	//	s_dofparamsdlgwnd = 0;
	//}

	CloseDbgFile();
	if (g_infownd) {
		delete g_infownd;
		g_infownd = 0;
	}



	s_oprigflag = 0;
	s_customrigbone = 0;

	map<CModel*, CFrameCopyDlg*>::iterator itrcpdlg;
	for (itrcpdlg = s_selbonedlgmap.begin(); itrcpdlg != s_selbonedlgmap.end(); itrcpdlg++) {
		CFrameCopyDlg* curcpdlg = itrcpdlg->second;
		if (curcpdlg) {
			delete curcpdlg;
		}
	}
	s_selbonedlgmap.clear();


	if (s_chascene) {
		delete s_chascene;
		s_chascene = nullptr;
	}
	s_model = nullptr;


	DestroyGrassElem();


	//if (s_undosprite) {
	//	delete s_undosprite;
	//	s_undosprite = 0;
	//}
	//if (s_fpssprite) {
	//	delete s_fpssprite;
	//	s_fpssprite = 0;
	//}


	if (s_select) {
		delete s_select;
		s_select = 0;
	}
	if (s_select_posture) {
		delete s_select_posture;
		s_select_posture = 0;
	}
	if (s_sky) {
		delete s_sky;
		s_sky = nullptr;
	}

	//s_grassはChaSceneのデストラクタで破棄される
	//if (s_grass) {
	//	delete s_grass;
	//	s_grass = nullptr;
	//}

	if (s_rigopemark_sphere) {
		delete s_rigopemark_sphere;
		s_rigopemark_sphere = nullptr;
	}
	if (s_rigopemark_ringX) {
		delete s_rigopemark_ringX;
		s_rigopemark_ringX = nullptr;
	}
	if (s_rigopemark_ringY) {
		delete s_rigopemark_ringY;
		s_rigopemark_ringY = nullptr;
	}
	if (s_rigopemark_ringZ) {
		delete s_rigopemark_ringZ;
		s_rigopemark_ringZ = nullptr;
	}


	if (s_ground) {
		delete s_ground;
		s_ground = 0;
	}
	if (s_gplane) {
		delete s_gplane;
		s_gplane = 0;
	}
	if (s_bmark) {
		delete s_bmark;
		s_bmark = 0;
	}


	s_bcircle.DestroyObjs();

	//if (s_bcircle) {
	//	delete s_bcircle;
	//	s_bcircle = 0;
	//}
	//if (s_kinsprite) {
	//	delete s_kinsprite;
	//	s_kinsprite = 0;
	//}

	if (g_texbank) {
		delete g_texbank;
		g_texbank = 0;
	}


	if (s_mainmenu) {
		DestroyMenu(s_mainmenu);
		s_mainmenu = 0;
	}

	DestroyTimeLine(1);

	if (s_timelineWnd) {
		delete s_timelineWnd;
		s_timelineWnd = 0;
	}
	if (s_LtimelineWnd) {
		delete s_LtimelineWnd;
		s_LtimelineWnd = 0;
	}

	if (s_toolWnd) {
		delete s_toolWnd;
		s_toolWnd = 0;
	}
	if (s_toolSeparator) {
		delete s_toolSeparator;
		s_toolSeparator = 0;
	}

	if (s_toolCopyB) {
		delete s_toolCopyB;
		s_toolCopyB = 0;
	}
	if (s_toolZeroFrameB) {
		delete s_toolZeroFrameB;
		s_toolZeroFrameB = 0;
	}

	if (s_toolSymCopyB) {
		delete s_toolSymCopyB;
		s_toolSymCopyB = 0;
	}
	if (s_toolCutB) {
		delete s_toolCutB;
		s_toolCutB = 0;
	}
	if (s_toolPasteB) {
		delete s_toolPasteB;
		s_toolPasteB = 0;
	}
	if (s_toolDeleteB) {
		delete s_toolDeleteB;
		s_toolDeleteB = 0;
	}
	if (s_toolMotPropB) {
		delete s_toolMotPropB;
		s_toolMotPropB = 0;
	}
	if (s_toolMarkB) {
		delete s_toolMarkB;
		s_toolMarkB = 0;
	}
	if (s_toolSelBoneB) {
		delete s_toolSelBoneB;
		s_toolSelBoneB = 0;
	}
	if (s_toolInitMPB) {
		delete s_toolInitMPB;
		s_toolInitMPB = 0;
	}
	if (s_toolFilterB) {
		delete s_toolFilterB;
		s_toolFilterB = 0;
	}
	if (s_toolInterpolateB) {
		delete s_toolInterpolateB;
		s_toolInterpolateB = 0;
	}
	if (s_toolSelectCopyFileName) {
		delete s_toolSelectCopyFileName;
		s_toolSelectCopyFileName = 0;
	}
	if (s_toolSkipRenderBoneMarkB) {
		delete s_toolSkipRenderBoneMarkB;
		s_toolSkipRenderBoneMarkB = 0;
	}
	if (s_toolSkipRenderBoneMarkB2) {
		delete s_toolSkipRenderBoneMarkB2;
		s_toolSkipRenderBoneMarkB2 = 0;
	}
	if (s_tool180deg) {
		delete s_tool180deg;
		s_tool180deg = 0;
	}
	if (s_toolScaleInitAllB) {
		delete s_toolScaleInitAllB;
		s_toolScaleInitAllB = 0;
	}
	if (s_toolCameraDollyB) {
		delete s_toolCameraDollyB;
		s_toolCameraDollyB = 0;
	}
	if (s_toolMaterialRateB) {
		delete s_toolMaterialRateB;
		s_toolMaterialRateB = 0;
	}
	if (s_toolModelWorldMatB) {
		delete s_toolModelWorldMatB;
		s_toolModelWorldMatB = 0;
	}


	if (s_owpTimeline) {
		delete s_owpTimeline;
		s_owpTimeline = 0;
	}
	if (s_owpPlayerButton) {
		delete s_owpPlayerButton;
		s_owpPlayerButton = 0;
	}
	if (s_owpLTimeline) {
		delete s_owpLTimeline;
		s_owpLTimeline = 0;
	}
	if (s_owpEulerGraph) {
		delete s_owpEulerGraph;
		s_owpEulerGraph = 0;
	}
	if (s_LTSeparator) {
		delete s_LTSeparator;
		s_LTSeparator = 0;
	}


	if (s_layerWnd) {
		delete s_layerWnd;
		s_layerWnd = 0;
	}
	if (s_owpLayerTable) {
		delete s_owpLayerTable;
		s_owpLayerTable = 0;
	}

	//if (s_placefolderlabel_1) {
	//	delete s_placefolderlabel_1;
	//	s_placefolderlabel_1 = 0;
	//}
	//if (s_placefolderlabel_2) {
	//	delete s_placefolderlabel_2;
	//	s_placefolderlabel_2 = 0;
	//}
	//if (s_placefolderlabel_3) {
	//	delete s_placefolderlabel_3;
	//	s_placefolderlabel_3 = 0;
	//}
	if (s_placefolderWnd) {
		delete s_placefolderWnd;
		s_placefolderWnd = 0;
	}
	int textno;
	for (textno = 0; textno < SHORTCUTTEXTNUM; textno++) {
		if (s_shortcuttext[textno]) {
			delete s_shortcuttext[textno];
			s_shortcuttext[textno] = 0;
		}
	}



	if (s_sidemenusp1) {
		delete s_sidemenusp1;
		s_sidemenusp1 = 0;
	}
	if (s_sidemenusp2) {
		delete s_sidemenusp2;
		s_sidemenusp2 = 0;
	}
	if (s_sidemenusp3) {
		delete s_sidemenusp3;
		s_sidemenusp3 = 0;
	}
	if (s_sidemenu_sellock) {
		delete s_sidemenu_sellock;
		s_sidemenu_sellock = 0;
	}
	if (s_sidemenu_sellockOnce) {
		delete s_sidemenu_sellockOnce;
		s_sidemenu_sellockOnce = 0;
	}
	if (s_sidemenu_targetdisp) {
		delete s_sidemenu_targetdisp;
		s_sidemenu_targetdisp = 0;
	}
	if (s_sidemenu_moveeyepos) {
		delete s_sidemenu_moveeyepos;
		s_sidemenu_moveeyepos = 0;
	}
	if (s_sidemenu_camdistSlider) {
		delete s_sidemenu_camdistSlider;
		s_sidemenu_camdistSlider = 0;
	}


	if (s_sidemenuWnd) {
		delete s_sidemenuWnd;
		s_sidemenuWnd = 0;
	}

	if (s_topSlidersWnd) {
		delete s_topSlidersWnd;
		s_topSlidersWnd = 0;
	}
	if (s_owpEditRateSlider) {
		delete s_owpEditRateSlider;
		s_owpEditRateSlider = 0;
	}
	if (s_owpSpeedSlider) {
		delete s_owpSpeedSlider;
		s_owpSpeedSlider = 0;
	}
	//if (s_owpTopPosSlider) {
	//	delete s_owpTopPosSlider;
	//	s_owpTopPosSlider = 0;
	//}
	if (s_topSlidersSeparator1) {
		delete s_topSlidersSeparator1;
		s_topSlidersSeparator1 = 0;
	}
	if (s_topSlidersSeparator2) {
		delete s_topSlidersSeparator2;
		s_topSlidersSeparator2 = 0;
	}
	if (s_topSlidersSeparator3) {
		delete s_topSlidersSeparator3;
		s_topSlidersSeparator3 = 0;
	}
	if (s_topSlidersSeparator4) {
		delete s_topSlidersSeparator4;
		s_topSlidersSeparator4 = 0;
	}
	if (s_owpBrushRepeatsSlider) {
		delete s_owpBrushRepeatsSlider;
		s_owpBrushRepeatsSlider = 0;
	}
	if (s_owpBrushMirrorU) {
		delete s_owpBrushMirrorU;
		s_owpBrushMirrorU = 0;
	}
	if (s_owpBrushMirrorV) {
		delete s_owpBrushMirrorV;
		s_owpBrushMirrorV = 0;
	}

	//if (s_mainmenulabel) {
	//	delete s_mainmenulabel;
	//	s_mainmenulabel = 0;
	//}

	{
		if (s_dofLabel) {
			delete s_dofLabel;
			s_dofLabel = 0;
		}
		if (s_dofslotCombo) {
			delete s_dofslotCombo;
			s_dofslotCombo = 0;
		}
		if (s_dofspacerLabel1) {
			delete s_dofspacerLabel1;
			s_dofspacerLabel1 = 0;
		}
		if (s_dofdistsp1) {
			delete s_dofdistsp1;
			s_dofdistsp1 = 0;
		}
		if (s_dofdistsp2) {
			delete s_dofdistsp2;
			s_dofdistsp2 = 0;
		}
		if (s_dofdistsp3) {
			delete s_dofdistsp3;
			s_dofdistsp3 = 0;
		}
		if (s_dofdistnearLabel) {
			delete s_dofdistnearLabel;
			s_dofdistnearLabel = 0;
		}
		if (s_dofdistnearEdit) {
			delete s_dofdistnearEdit;
			s_dofdistnearEdit = 0;
		}
		if (s_dofdistfarLabel) {
			delete s_dofdistfarLabel;
			s_dofdistfarLabel = 0;
		}
		if (s_dofdistfarEdit) {
			delete s_dofdistfarEdit;
			s_dofdistfarEdit = 0;
		}
		if (s_dofspacerLabel2) {
			delete s_dofspacerLabel2;
			s_dofspacerLabel2 = 0;
		}
		if (s_dofskyChk) {
			delete s_dofskyChk;
			s_dofskyChk = 0;
		}
		if (s_dofspacerLabel3) {
			delete s_dofspacerLabel3;
			s_dofspacerLabel3 = 0;
		}
		if (s_dofapplysp) {
			delete s_dofapplysp;
			s_dofapplysp = 0;
		}
		if (s_dofapplyB) {
			delete s_dofapplyB;
			s_dofapplyB = 0;
		}

		if (s_dofWnd) {
			delete s_dofWnd;
			s_dofWnd = 0;
		}
	}

	if (g_motionbrush_value) {
		free(g_motionbrush_value);
		g_motionbrush_value = 0;
	}

	//if (g_Camera) {
	//	delete g_Camera;
	//	g_Camera = 0;
	//}

	DestroyModelPanel();
	DestroyMotionPanel();
	DestroyCameraPanel();

	//DestroySdkObjects();


	//DestroySavedScene();//2024/02/10


	if (s_psdk) {
		s_psdk->Destroy();
		s_psdk = 0;
	}

	if (s_bpWorld) {
		delete s_bpWorld;
		s_bpWorld = 0;
	}


	OWP_EditBox::destroySoftNumWnd();
	CMotionPoint::DestroyMotionPoints();
	CBone::DestroyColDisp();
	CBone::DestroyBones();
	CRigidElem::DestroyRigidElems();
	IMCompute::DestroyStaticMem();//全てのCModel削除の後で呼ぶ


	DestroyEulKeys();
	DestroyKeys();



	if (s_3dwnd && IsWindow(s_3dwnd)) {
		DestroyWindow(s_3dwnd);
		s_3dwnd = 0;
	}
	s_3dwnd = 0;


	//エンジンの破棄。
	if (g_engine) {
		delete g_engine;
		g_engine = nullptr;
	}

	CoUninitialize();


	DeleteCriticalSection(&s_CritSection_LTimeline);
	DeleteCriticalSection(&g_CritSection_GetGP);
	DeleteCriticalSection(&g_CritSection_FbxSdk);


	if (g_mainhwnd && IsWindow(g_mainhwnd)) {
		DestroyWindow(g_mainhwnd);
		g_mainhwnd = 0;
	}
	g_mainhwnd = 0;


}


void OnUserFrameMove(double fTime, float fElapsedTime, int* ploopstartflag)
{

	static double savetime = 0.0;
	static double savetooltiptime = 0.0;
	static int capcnt = 0;

	if (ploopstartflag) {
		*ploopstartflag = 0;
	}

	//if (g_bvh2fbxbatchflag || g_motioncachebatchflag || g_retargetbatchflag) {
	//if((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)){
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		OnFrameBatchThread();
		return;//!!!!!!!!!!!!!!!!!!!
	}


	//2024/08/09
	//リターゲットバッチ中にタイミングでエラー(ChaSceneのm_modelindexのCModel*の値が不正)　OnUserFrameMove()の中に入れて バッチ中はスキップ
	s_chascene->SetUpdateSlot();


	SetCameraModel();


	//マウスがUtDialogのコントロールの上を通るとSetCaptureが生じるのでIK中は非表示にする
	//VisibleUtDialog();


	if (s_underdelmotion || s_underdelmodel || 
		s_underselectmotion || s_underselectcamera || s_underselectmodel || s_underdispmodel || 
		g_changeUpdateThreadsNum || s_toonparamchange || s_skytoonparamchange
		) {

		OnFrameCloseFlag();
		OnFrameToolWnd();

		if (s_model) {
			if (s_model->GetBefInView(0) != s_model->GetInView(0)) {
				if (s_owpEulerGraph) {
					//2023/08/27 オイラーグラフの表示非表示の条件が変わった場合には　再描画
					//オイラーグラフのdraw()は OrgWindow.cppにある
					s_owpEulerGraph->callRewrite();
				}
			}
		}
	}
	else {




		////if ((UnderDragOperation_R() == false) && (UnderDragOperation_L() == false) && ((s_tooltipdispcount % 6) == 0)) {
		//if ((UnderDragOperation_R() == false) && (UnderDragOperation_L() == false) &&
		//	((fTime - savetooltiptime) >= 0.1)) {
		//	//マウスがUtDialogのコントロールの上を通るとSetCaptureが生じるのでIK中は非表示にする
		//	DispToolTip();
		//
		//	savetooltiptime = fTime;
		//}
		//s_tooltipdispcount++;


		//WCHAR sz[100];
		////swprintf_s(sz, 100, L"ThreadNum:%d(%d)", g_numthread, gNumIslands);
		////g_SampleUI.GetStatic(IDC_STATIC_NUMTHREAD)->SetText(sz);
		//swprintf_s(sz, 100, L"UpdateThreads:%d", g_UpdateMatrixThreads);
		//g_SampleUI.GetStatic(IDC_STATIC_UMTHREADS)->SetText(sz);


		if (g_undertrackingRMenu == 0) {
			OnDSUpdate();
		}


		OnFrameStartPreview(fTime, &savetime);


		OnFrameUtCheckBox();
		SetCamera6Angle();
		AutoCameraTarget();

		OnFrameKeyboard();

		if ((g_previewFlag == 0) && (s_savepreviewFlag != 0)) {
			s_cursorFlag = true;
			if (s_undoFlag || s_redoFlag) {
				s_cursorUnderUndo = true;
			}
		}
		OnFrameTimeLineWnd();


		OnFrameMouseButton();

		s_time = fTime;
		////#replacing comment out#g_Camera->FrameMove(fElapsedTime);
		double difftime = fTime - savetime;
		//double difftime = fElapsedTime;

		//Preview前に　CameraAnimのために　時間を確定する必要がある
		//時間が確定 --> CameraAnim --> s_matWorld, s_matProj, s_matVP確定 --> Preview時のUpdataMatrix(  s_matVP )

		//##############
		//Process Time
		//##############
		double nextframe = 0.0;
		int endflag = 0;
		int loopstartflag = 0;
		OnFrameProcessTime(difftime, &nextframe, &endflag, &loopstartflag);
		if (ploopstartflag) {
			*ploopstartflag = loopstartflag;
		}



		//#############
		//Camera Anim
		//#############
		double cameranextframe = 0.0;
		if (loopstartflag) {
			//#####################################################
			//タイムラインを範囲指定してプレビュー中に　範囲の最初に戻る場合
			//#####################################################
			double curmotframe = s_model->GetCurrentFrame();
			if ((s_editrange.GetStartFrame() != s_editrange.GetEndFrame()) && (curmotframe == s_editrange.GetStartFrame())) 
			{
				cameranextframe = curmotframe;
				if (s_cameramodel) {
					s_cameramodel->SetCameraMotionFrame(s_cameramodel->GetCameraMotionId(), cameranextframe);
				}
			}
			else {
				//#####################################################
				//範囲を指定しないでループした場合には　通常の処理をする
				//#####################################################
				int cameraendflag = 0;
				int cameraloopstartflag = 0;
				OnFrameProcessCameraTime(difftime, &cameranextframe, &cameraendflag, &cameraloopstartflag);
			}
		}
		else {
			//####################
			//通常処理　時間を進める
			//####################
			int cameraendflag = 0;
			int cameraloopstartflag = 0;
			OnFrameProcessCameraTime(difftime, &cameranextframe, &cameraendflag, &cameraloopstartflag);
		}
		OnFramePreviewCamera(cameranextframe);
	

		SetCamera3DFromEyePos();

		//if (g_previewFlag != 0) {
		//	WCHAR dbgline[1024] = { 0 };
		//	swprintf_s(dbgline, 1024, L"difftime %f, nextframe %.3f, caemranextframe %.3f\n",
		//		difftime, nextframe, cameranextframe);
		//	OutputDebugString(dbgline);
		//}


		////###################
		////Set Updated Params
		////###################
		////FLOAT fObjectRadius;
		////if (s_chascene) {
		////	g_vCenter = s_chascene->GetTotalModelBound().center;
		////	fObjectRadius = s_chascene->GetTotalModelBound().r;
		////}
		////else {
		////	_ASSERT(0);
		////	g_vCenter.SetParams(0.0f, 0.0f, 0.0f);
		////	fObjectRadius = 10.0f;
		////}
		////if (fObjectRadius < 0.1f) {
		////	fObjectRadius = 10.0f;
		////}
		//////#replacing comment out#g_Camera->SetProjParams(g_fovy, s_fAspectRatio, g_projnear, g_projfar);
		//////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		//////#replacing comment out#g_Camera->SetRadius(fObjectRadius * 3.0f, fObjectRadius * 0.5f, fObjectRadius * 6.0f);
		//s_matWorld = ChaMatrix(//#replacing comment out#g_Camera->GetWorldMatrix());
		//s_matView = ChaMatrix(//#replacing comment out#g_Camera->GetViewMatrix());
		//s_matProj = ChaMatrix(//#replacing comment out#g_Camera->GetProjMatrix());
		s_matWorld.SetTranslationZero();
		////s_matW = s_matWorld;
		s_matVP = s_matView * s_matProj;



		//int modelno;
		//int modelnum = (int)s_modelindex.size();
		//for (modelno = 0; modelno < modelnum; modelno++) {
		//	s_modelindex[modelno].modelptr->SetWorldMatFromCamera(s_matWorld);
		//}


		//##########
		//Preview
		//##########
		if (g_previewFlag) {
			MOTINFO targetmi = GetEditTargetMotInfo();
			double previewframe;
			if (targetmi.motid > 0) {
				previewframe = targetmi.curframe;
			}
			else {
				//2024/06/06
				//カメラグラフ表示中にカメラアニメが存在しない場合　targetmi.motid == 0　その場合にはカレントモーションのカレントフレームを表示
				previewframe = s_model->GetCurrentFrame();
			}

			if (s_model && s_model->ExistCurrentMotion()) {
				if (g_previewFlag <= 3) {
					OnFramePreviewNormal(previewframe, difftime, endflag, loopstartflag);
				}
				else if (g_previewFlag == 4) {//BTの物理
					OnFramePreviewBt(previewframe, difftime, endflag, loopstartflag);
				}
				else if (g_previewFlag == 5) {//ラグドール
					//OnFramePreviewRagdoll(&nextframe, &difftime);

					//ラグドール休止中
					_ASSERT(0);
					OnFramePreviewNormal(previewframe, difftime, endflag, loopstartflag);
				}
				else {
					OnTimeLineCursor();
				}
			}
			else {
				g_previewFlag = 0;
			}
		}
		else {
			OnFramePreviewStop();
		}
		

		if (s_model) {
			if (s_model->GetBefInView(0) != s_model->GetInView(0)) {
				if (s_owpEulerGraph) {
					//2023/08/27 オイラーグラフの表示非表示の条件が変わった場合には　再描画
					//オイラーグラフのdraw()は OrgWindow.cppにある
					s_owpEulerGraph->callRewrite();
				}
			}
		}


		//s_difftime = difftime;
		savetime = fTime;


		OnFrameCloseFlag();
		OnFrameToolWnd();
		OnFrameUndo(false, 0);

		OnFrameUpdateGround();
		OnFrameInitBtWorld();


		if (s_spretargetsw[1].state == true) {
			bool updateonlycheckeul = true;
			OnFrameAngleLimit(updateonlycheckeul);//2022/12/30 AngleLimitDlgのcheck値のリアルタイム更新のため
		}
		if (s_spdispsw[SPDISPSW_LIGHTS].state == true) {
			OnFrameLightsForEdit();
		}

		//OnDSMouseHereApeal();


		//s_tum.WaitUpdateMatrix();


		if (s_spdispsw[SPDISPSW_DISPGROUP].state || s_spdispsw[SPDISPSW_SHADERTYPE].state || 
			(s_dispmodelworldmat && s_pickmodelworldmat)) {//2024/05/11 ModelWorldMatダイアログのPick&Setチェック時も
			g_pickmeshflag = true;
		}
		else {
			g_pickmeshflag = false;
		}
	}

	s_savepreviewFlag = g_previewFlag;
}

void InsertCopyMPReq(bool limitdegflag, CBone* curbone, double curframe, MOTINFO* curmi)
{
	if (curbone && curmi) {

		if (curbone->IsSkeleton() || curbone->IsCamera() || curbone->IsNullAndChildIsCamera()) {
			InsertCopyMP(limitdegflag, curbone, curframe, curmi);
		}
		
		if (curbone->GetChild(false)) {
			InsertCopyMPReq(limitdegflag, curbone->GetChild(false), curframe, curmi);
		}
		if (curbone->GetBrother(false)) {
			InsertCopyMPReq(limitdegflag, curbone->GetBrother(false), curframe, curmi);
		}
	}
}

int InsertCopyMP(bool limitdegflag, CBone* curbone, double curframe, MOTINFO* curmi)
{
	double roundingframe = RoundingTime(curframe);

	if (curmi && curbone && (curbone->IsSkeleton() || curbone->IsCamera() || curbone->IsNullAndChildIsCamera())) {
		if (curmi->motid > 0) {
			if (curbone->IsSkeleton()) {
				int rotcenterflag1 = 1;
				ChaMatrix localmat = curbone->CalcLocalScaleRotMat(limitdegflag,
					rotcenterflag1, curmi->motid, curframe);
				ChaVector3 curanimtra = curbone->CalcLocalTraAnim(limitdegflag,
					curmi->motid, curframe);
				ChaVector3 localscale = curbone->CalcLocalScaleAnim(limitdegflag,
					curmi->motid, curframe);

				localmat.AddTranslation(curanimtra);//SetではなくAdd

				CPELEM2 cpelem;
				ZeroMemory(&cpelem, sizeof(CPELEM2));
				cpelem.bone = curbone;
				cpelem.mp.SetFrame(curframe);
				cpelem.mp.SetWorldMat(localmat);
				cpelem.mp.SetLocalMatFlag(1);//!!!!!!!!!! 1
				s_copymotvec.push_back(cpelem);
			}
			else {
				ChaMatrix localmat = curbone->GetLocalMat(false, curmi->motid, roundingframe, 0);
				ChaMatrix worldmat = curbone->GetWorldMat(false, curmi->motid, roundingframe, 0);
				ChaVector3 localeul = curbone->GetLocalEul(false, curmi->motid, roundingframe, 0);

				CPELEM2 cpelem;
				ZeroMemory(&cpelem, sizeof(CPELEM2));
				cpelem.bone = curbone;
				cpelem.mp.SetFrame(curframe);
				cpelem.mp.SetWorldMat(worldmat);
				cpelem.mp.SetLimitedWM(worldmat);
				cpelem.mp.SetLocalMat(localmat);//!!!!!!!!
				cpelem.mp.SetLocalEul(localeul);//!!!!!!!!
				cpelem.mp.SetLocalMatFlag(0);//!!!!!!!!!! 0
				s_copymotvec.push_back(cpelem);
			}

		}
	}

	return 0;
}

void InsertSymMPReq(bool limitdegflag, CBone* curbone, double curframe, int symrootmode)
{
	if (curbone) {
		if (curbone->IsSkeleton()) {
			InsertSymMP(limitdegflag, curbone, curframe, symrootmode);
		}

		if (curbone->GetChild(false)) {
			InsertSymMPReq(limitdegflag, curbone->GetChild(false), curframe, symrootmode);
		}
		if (curbone->GetBrother(false)) {
			InsertSymMPReq(limitdegflag, curbone->GetBrother(false), curframe, symrootmode);
		}
	}
}
int InsertSymMP(bool limitdegflag, CBone* curbone, double curframe, int symrootmode)
{
	if (curbone && (curbone->IsSkeleton())) {

		ChaMatrix symmat = curbone->CalcSymXMat2(limitdegflag,
			s_model->GetCurMotInfo().motid, curframe, symrootmode);

		CPELEM2 cpelem;
		ZeroMemory(&cpelem, sizeof(CPELEM2));
		cpelem.bone = curbone;
		cpelem.mp.SetFrame(curframe);
		cpelem.mp.SetWorldMat(symmat);
		cpelem.mp.SetLocalMatFlag(1);//!!!!!!!!!!
		s_copymotvec.push_back(cpelem);
	}

	return 0;
}



//int AdjustBoneTra( CBone* curbone, double curframe )
//{
//	CMotionPoint* pcurmp = 0;
//	pcurmp = curbone->GetMotionPoint(s_model->GetCurMotInfo()->motid, curframe);
//	if(pcurmp){
//		ChaVector3 orgpos;
//		ChaVector3 tmpfpos = curbone->GetJointFPos();
//		ChaMatrix tmpbefwm = pcurmp->GetBefWorldMat();
//		ChaVector3TransformCoord( &orgpos, &tmpfpos, &tmpbefwm);
//
//		ChaVector3 newpos;
//		ChaMatrix tmpwm = pcurmp->GetWorldMat();
//		ChaVector3TransformCoord( &newpos, &tmpfpos, &tmpwm);
//
//		ChaVector3 diffpos;
//		diffpos = orgpos - newpos;
//
//		CEditRange tmper;
//		KeyInfo tmpki;
//		tmpki.time = curframe;
//		list<KeyInfo> tmplist;
//		tmplist.push_back( tmpki );
//		tmper.SetRange( tmplist, curframe );
//		s_model->FKBoneTra( 0, &tmper, curbone->GetBoneNo(), diffpos );
//	}
//
//	return 0;
//}


//--------------------------------------------------------------------------------------
// This callback function will be called at the end of every frame to perform all the 
// rendering calls for the scene, and it will also be called if the window needs to be 
// repainted. After this function has returned, DXUT will call 
// IDirect3DDevice9::Present to display the contents of the next buffer in the swap chain
//--------------------------------------------------------------------------------------

void OnRenderNowLoading()
{
	/*
	HBRUSH GetSysColorBrush(
		int nIndex
	);

	　システムカラーのインデックスまたは定義されている定数名を指定します。
	　定義されているシステムカラーは以下の通りです。重複している定数もありますので、インデックスも表記しています。

	定数	 	内容
	COLOR_SCROLLBAR	0	スクロールバーの灰色の領域。
	COLOR_DESKTOP
	COLOR_BACKGROUND	1	デスクトップの色。
	COLOR_ACTIVECAPTION	2	アクティブなウィンドウのタイトルバーの色。
	グラデーションが有効な場合はグラデーションの左側の色。
	COLOR_INACTIVECAPTION	3	非アクティブなウィンドウのタイトルバーの色。
	グラデーションが有効な場合はグラデーションの左側の色。
	COLOR_MENU	4	メニューの背景色。
	COLOR_WINDOW	5	ウィンドウの背景色。
	COLOR_WINDOWFRAME	6	ウィンドウフレームの色。
	COLOR_MENUTEXT	7	メニュー内のテキストの色。
	COLOR_WINDOWTEXT	8	ウィンドウ内のテキストの色。
	COLOR_CAPTIONTEXT	9	キャプション、サイズボックス、スクロールバーの矢印ボックス内のテキストの色。
	COLOR_ACTIVEBORDER	10	アクティブなウィンドウの境界線の色。
	COLOR_INACTIVEBORDER	11	非アクティブなウィンドウの境界線の色。
	COLOR_APPWORKSPACE	12	MDIウィンドウの背景色。
	COLOR_HIGHLIGHT	13	コントロールで選択された時の反転色。
	COLOR_HIGHLIGHTTEXT	14	コントロールで選択された時のテキストの色。
	COLOR_3DFACE
	COLOR_BTNFACE	15	3D表示及びダイアログボックスの背景色。
	COLOR_3DSHADOW
	COLOR_BTNSHADOW	16	3D表示の影の色。
	COLOR_GRAYTEXT	17	無効のテキストの色。
	COLOR_BTNTEXT	18	プッシュボタンのテキストの色。
	COLOR_INACTIVECAPTIONTEXT	19	非アクティブウィンドウのキャプションのテキスト色。
	COLOR_3DHILIGHT
	COLOR_3DHIGHLIGHT
	COLOR_BTNHILIGHT
	COLOR_BTNHIGHLIGHT	20	3D表示のハイライト色。
	COLOR_3DDKSHADOW	21	3D表示の暗い影の色。
	COLOR_3DLIGHT	22	3D表示の光の色。
	COLOR_INFOTEXT	23	ツールチップのテキスト色。
	COLOR_INFOBK	24	ツールチップの背景色。
	-	25	不明
	COLOR_HOTLIGHT	26	ハイパーリンクされたアイテムの色。
	COLOR_GRADIENTACTIVECAPTION	27	アクティブウィンドウのタイトルバーのグラデーション右側の色。
	COLOR_GRADIENTINACTIVECAPTION	28	非アクティブウィンドウのタイトルバーのグラデーション右側の色。
	COLOR_MENUHILIGHT	29	ハイライトされたメニューアイテムの色。
	COLOR_MENUBAR	29	メニューバーの背景色。
	 */


	HDC hdc;
	RECT rect;
	HBRUSH brush;
	hdc = ::GetDC(s_3dwnd);
	::GetClientRect(s_3dwnd, &rect);
	brush = CreateSolidBrush(BLACK_BRUSH);
	//brush = CreateSolidBrush(RGB(64, 128, 256));
	//brush = ::GetSysColorBrush(COLOR_HIGHLIGHT);//黒と青でちらくつ
	//brush = ::GetSysColorBrush(COLOR_HIGHLIGHT);
	::FillRect(hdc, &rect, brush);
	::DeleteObject(brush);
	::ReleaseDC(s_3dwnd, hdc);

	return;

}

void OnFrameRender(myRenderer::RenderingEngine* re, RenderContext* rc, 
	double fTime, float fElapsedTime, int loopstartflag)
{
	static double savetooltiptime = 0.0;

	if (!re || !rc) {
		_ASSERT(0);
		return;
	}

	////OnRenderNowLoadingも何も無しだとdevice->Presentで固まる。 OnRenderNowLoadingを入れると３Dモデル表示がちらつく。よって通常描画する。
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	//	//OnRenderNowLoading();
	//	return;
	//}

	if (!s_chascene) {
		_ASSERT(0);
		return;
	}
	if ((s_chascene->GetModelNum() > 0) && 
		s_model && s_model->GetLoadedFlag() && (s_nowloading == false)) {
		SetCamera3DFromEyePos();
	}
	else {
		OnRenderNowLoading();
		Sleep(1);
		return;//!!!!!!!!!!!! ModelNum == 0のときは　すぐにリターン
	}

	if (s_toonparamchange || s_skytoonparamchange) {
		OnRenderNowLoading();
		Sleep(1);
		return;//!!!!!!!!!!!!
	}


	// レンダリング開始
	g_engine->BeginFrame();


	//g_camera3D->MoveForward(g_pad[0]->GetLStickYF());
	//g_camera3D->MoveRight(g_pad[0]->GetLStickXF());
	//g_camera3D->MoveUp(g_pad[0]->GetRStickYF());

	//// Render the light arrow so the user can visually see the light dir
	//for (int i = 0; i < g_nNumActiveLights; i++)
	//{
	//	DirectX::XMFLOAT4 arrowColor = (i == g_nActiveLight) ? DirectX::XMFLOAT4(1, 1, 0, 1) : DirectX::XMFLOAT4(1, 1, 1, 1);
	//	//V(g_LightControl[i].OnRender10(arrowColor, &mView, &mProj, //#replacing comment out#g_Camera->GetEyePt()));
	//	vLightDir[i].SetParams(g_LightControl[i].GetLightDirection());
	//	vLightDiffuse[i].SetParams(1, 1, 1, 1) * g_fLightScale;
	//}

	////V(g_pLightDir->SetRawValue(vLightDir, 0, sizeof(ChaVector3) * MAX_LIGHTS));
	////V(g_pLightDiffuse->SetFloatVectorArray((float*)vLightDiffuse, 0, MAX_LIGHTS));
	////V(g_pmWorldViewProjection->SetMatrix((float*)&mWorldViewProjection));
	////V(g_pmWorld->SetMatrix((float*)&mWorld));
	////V(g_pfTime->SetFloat((float)fTime));
	////V(g_pnNumLights->SetInt(g_nNumActiveLights));


	//if ((InterlockedAdd(&g_retargetbatchflag, 0) == 0) && (InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 0) && (InterlockedAdd(&g_motioncachebatchflag, 0) == 0) &&
	if ((InterlockedAdd(&g_retargetbatchflag, 0) == 0) && (InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 0) && (InterlockedAdd(&g_calclimitedwmflag, 0) == 0) &&
		!s_underdelmodel && !s_underdelmotion && 
		!s_underselectmodel && !s_underselectmotion && !s_underselectcamera && !s_underdispmodel && !g_changeUpdateThreadsNum) {

		if (s_dispgroupdlg.GetDispGroupOnlyOneObjFlag() == false) {

			if (g_skydispflag) {
				OnRenderSky(re, rc);//透過テクスチャの奥に空がみえるように　空は一番最初に描画する
			}

			int lightflag = -1;
			ChaVector4 diffusemult;
			diffusemult.SetParams(1.0f, 1.0f, 1.0f, 1.0f);
			int btflag;
			if ((g_previewFlag != 4) && (g_previewFlag != 5)) {
				btflag = 0;
			}
			else {
				btflag = 1;
			}

			if (s_model) {
				if (s_sprefpos.state) {
					//s_model->SetRefPosFlag(true);
					s_chascene->SetRefPosFlag(s_model);//s_modelにtrue, 他のモデルにfalse
					g_refposflag = true;
				}
				else {
					//s_model->SetRefPosFlag(false);
					s_chascene->SetRefPosFlag(nullptr);
					g_refposflag = false;
				}
			}
			bool calcslotflag = false;
			//bool calcslotflag = true;
			s_chascene->SetBoneMatrixForShader(btflag, calcslotflag);
			if (s_model && s_sprefpos.state) {
				OnRenderRefPos(re, s_model);
			}
			s_chascene->RenderModels(re, lightflag, diffusemult, btflag);


			if (s_ground) {
				OnRenderGround(re, rc);//メッシュではなくラインオブジェクト
			}

			if (!s_grassElemVec.empty()) {
				//2024/05/11
				RenderGrass(re, rc);
			}

			OnRenderBoneMark(re, rc);

			if ((s_dispselect || s_camtargetdisp) && s_select) {
				OnRenderSelect(re, rc);
			}


		}
		else {
			OnRenderOnlyOneObj(re, rc);
		}
		


		//OnRenderUtDialog(fElapsedTime);

		if (s_dispsampleui) {//ctrl + 1 (one) key --> toggle
			OnRenderSprite(re, rc);
		}

		if ((UnderDragOperation_R() == false) && (UnderDragOperation_L() == false) &&
			((fTime - savetooltiptime) >= 0.032)) {
			//マウスがUtDialogのコントロールの上を通るとSetCaptureが生じるのでIK中は非表示にする
			DispToolTip();
			savetooltiptime = fTime;
		}
		s_tooltipdispcount++;


		OnRenderFontForTip(re, rc);

	}
	else {
		OnRenderNowLoading();
	}


	////font test
	//s_fontfortip.Begin(rc);
	//Vector2 fontpos = Vector2(0.0f, 100.0f);
	//Vector4 fontcol = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
	//Vector2 fontpivot = Vector2(0.0f, 0.0f);
	//s_fontfortip.SetShadowParam(true, 1.0, Vector4(0.0f, 1.0f, 0.0f, 1.0f));
	//s_fontfortip.Draw(L"Font Test", fontpos, fontcol, 0.0, 1.0, fontpivot);
	//s_fontfortip.End(rc);



	//レンダリングエンジンを実行
	re->Execute(rc, s_chascene);
	// レンダリング終了
	g_engine->EndFrame(s_chascene);

	//s_chascene->CopyCSDeform();
	s_chascene->ClearRenderObjs();//CopyCSDeform()よりも後で呼ぶ

	//s_dispPickfortip = GetResultOfPickRay();//EndFrame()よりも後で呼ぶ


}

//--------------------------------------------------------------------------------------
// Render the help and statistics text. This function uses the ID3DX10Font interface for 
// efficient text rendering.
//--------------------------------------------------------------------------------------

void CalcFps(double fTime)
{
	static double s_savetime = 0.0;
	//double g_calcfps;
	if (fTime != s_savetime) {
		g_calcfps = 1.0 / (fTime - s_savetime);
	}
	else {
		g_calcfps = 100.0;
	}

	if ((s_fps100index >= 0) && (s_fps100index < FPSSAVENUM)) {
		s_fps100[s_fps100index] = g_calcfps;
		s_fps100index++;
		if (s_fps100index >= FPSSAVENUM) {
			s_fps100index = 0;
		}
	}


	//2023/12/15
	//表示用の数字の更新は10fps程にしておく
	if ((s_befftime == 0.0) || ((fTime - s_befftime) >= 0.10)) {
		s_avrgfps = 0.0;
		int saveno;
		for (saveno = 0; saveno < FPSSAVENUM; saveno++) {
			s_avrgfps += s_fps100[saveno];
		}
		s_avrgfps /= (double)FPSSAVENUM;

		s_befftime = fTime;//値を更新した時だけセット
	}


	s_savetime = fTime;
}

void PrepairUndo_BlendShape(CBlendShapeElem srcblendshapeelem)
{
	if (!srcblendshapeelem.validflag || !srcblendshapeelem.model || !srcblendshapeelem.mqoobj ||
		(srcblendshapeelem.channelindex < 0)) {
		return;
	}


	BRUSHSTATE brushstate;
	brushstate.Init();
	brushstate.brushmirrorUflag = g_brushmirrorUflag;
	brushstate.brushmirrorVflag = g_brushmirrorVflag;
	brushstate.ifmirrorVDiv2flag = g_ifmirrorVDiv2flag;
	brushstate.limitdegflag = g_limitdegflag;
	brushstate.motionbrush_method = g_motionbrush_method;
	brushstate.wallscrapingikflag = g_wallscrapingikflag;
	brushstate.brushrepeats = g_brushrepeats;

	UNDOCAMERA undocamera;
	undocamera.Init();
	undocamera.spcameramode = s_spcameramode.state;
	undocamera.camtargetflag = s_camtargetflag;
	undocamera.camtargetdisp = s_camtargetdisp;
	undocamera.moveeyepos = s_moveeyepos;
	undocamera.camEyePos = g_camEye;
	undocamera.camtargetpos = g_camtargetpos;
	undocamera.camUpVec = g_cameraupdir;
	undocamera.camdist = g_camdist;
	undocamera.cameramodel = s_cameramodel;

	if (s_model) {
		int result = s_model->SaveUndoBlendShapeMotion(
			g_limitdegflag, s_curboneno, s_curbaseno,
			g_edittarget, &s_editrange, g_applyrate,
			brushstate, undocamera, srcblendshapeelem);
		_ASSERT(result == 0);
	}
}

void PrepairUndo_SelectModel(CModel* befmodel, CModel* nextmodel)
{
	if (befmodel == nextmodel) {
		//選択モデルに変化が無い場合はすぐにリターン
		return;
	}

	UNDOSELECT undoselectFromThis;
	undoselectFromThis.Init();
	undoselectFromThis.from_model = befmodel;
	undoselectFromThis.to_model = nextmodel;
	if (befmodel) {
		undoselectFromThis.undokind = UNDOKIND_SELECTMODEL_FROMTHIS;
		undoselectFromThis.from_motion = befmodel->GetCurrentMotID();
		//undoselectFromThis.from_undoR = befmodel->GetCurrentUndoR();
		//undoselectFromThis.from_undoW = befmodel->GetCurrentUndoW();
		if (nextmodel) {
			undoselectFromThis.to_motion = nextmodel->GetCurrentMotID();
			//undoselectFromThis.to_undoR = nextmodel->GetCurrentUndoR();
			//undoselectFromThis.to_undoW = nextmodel->GetCurrentUndoW();
		}
	}


	UNDOSELECT undoselectToThis;
	undoselectToThis.Init();
	undoselectToThis.from_model = befmodel;
	undoselectToThis.to_model = nextmodel;
	if (nextmodel) {
		undoselectToThis.undokind = UNDOKIND_SELECTMODEL_TOTHIS;
		undoselectToThis.to_motion = nextmodel->GetCurrentMotID();
		//undoselectToThis.to_undoR = nextmodel->GetCurrentUndoR();
		//undoselectToThis.to_undoW = nextmodel->GetCurrentUndoW();
		if (befmodel) {
			undoselectToThis.from_motion = befmodel->GetCurrentMotID();
			//undoselectToThis.from_undoR = befmodel->GetCurrentUndoR();
			//undoselectToThis.from_undoW = befmodel->GetCurrentUndoW();
		}
	}


	BRUSHSTATE brushstate;
	brushstate.Init();
	brushstate.brushmirrorUflag = g_brushmirrorUflag;
	brushstate.brushmirrorVflag = g_brushmirrorVflag;
	brushstate.ifmirrorVDiv2flag = g_ifmirrorVDiv2flag;
	brushstate.limitdegflag = g_limitdegflag;
	brushstate.motionbrush_method = g_motionbrush_method;
	brushstate.wallscrapingikflag = g_wallscrapingikflag;
	brushstate.brushrepeats = g_brushrepeats;

	UNDOCAMERA undocamera;
	undocamera.Init();
	undocamera.spcameramode = s_spcameramode.state;
	undocamera.camtargetflag = s_camtargetflag;
	undocamera.camtargetdisp = s_camtargetdisp;
	undocamera.moveeyepos = s_moveeyepos;
	undocamera.camEyePos = g_camEye;
	undocamera.camtargetpos = g_camtargetpos;
	undocamera.camUpVec = g_cameraupdir;
	undocamera.camdist = g_camdist;
	undocamera.cameramodel = s_cameramodel;//2024/06/24

	//2024/07/02
	CBlendShapeElem blendshapeelem;
	blendshapeelem.Init();
	int blendshapenum = s_blendshapedlg.GetBlendShapeLineNum();
	int blendshapeindex = s_blendshapedlg.GetBlendShapeOpeIndex();
	if ((blendshapeindex >= 0) && (blendshapeindex < blendshapenum)) {
		blendshapeelem = s_blendshapedlg.GetBlendShapeElem(blendshapeindex);
		//if (blendshapeelem.validflag && blendshapeelem.model && blendshapeelem.mqoobj) {
		//}
	}

	bool allframeflag = false;

	if (befmodel) {
		befmodel->SaveUndoMotion(undoselectFromThis,
			s_LimitDegCheckBoxFlag, g_limitdegflag, s_curboneno, s_curbaseno,
			g_edittarget, &s_editrange, g_applyrate,
			brushstate, undocamera, blendshapeelem,
			allframeflag);
	}
	if (nextmodel) {
		nextmodel->SaveUndoMotion(undoselectToThis,
			s_LimitDegCheckBoxFlag, g_limitdegflag, nextmodel->GetSelectedBoneNo(), 0,
			g_edittarget, &s_editrange, g_applyrate,
			brushstate, undocamera, blendshapeelem,
			allframeflag);
	}
}

void PrepairUndo()
{
	if (!s_model) {
		return;
	}

	//リターゲットバッチ中はSaveUndoしない
	//モデル削除時、モーション削除時はSaveUndoしない
	//UndoRedoボタンを押した場合にはSaveUndoしない

	if ((InterlockedAdd(&g_retargetbatchflag, 0) == 0) && (s_underdelmodel == 0) &&
		(s_underdelmotion == 0) && (s_undoFlag == false) && (s_redoFlag == false)) {
		//2022/09/13 選択範囲だけをアンドゥリドゥするようにした
		//その影響で選択範囲の未編集状態も保存する必要が生じた
		//よって次のif文はコメントアウト
		//if ((s_editmotionflag >= 0) || (g_btsimurecflag == true)) {

		if (s_model) {
			//CreateTimeLineMark();
			SetLTimelineMark(s_curboneno);

			BRUSHSTATE brushstate;
			brushstate.Init();
			brushstate.brushmirrorUflag = g_brushmirrorUflag;
			brushstate.brushmirrorVflag = g_brushmirrorVflag;
			brushstate.ifmirrorVDiv2flag = g_ifmirrorVDiv2flag;
			brushstate.limitdegflag = g_limitdegflag;
			brushstate.motionbrush_method = g_motionbrush_method;
			brushstate.wallscrapingikflag = g_wallscrapingikflag;
			brushstate.brushrepeats = g_brushrepeats;

			UNDOCAMERA undocamera;
			undocamera.Init();
			undocamera.spcameramode = s_spcameramode.state;
			undocamera.camtargetflag = s_camtargetflag;
			undocamera.camtargetdisp = s_camtargetdisp;
			undocamera.moveeyepos = s_moveeyepos;
			undocamera.camEyePos = g_camEye;
			undocamera.camtargetpos = g_camtargetpos;
			undocamera.camUpVec = g_cameraupdir;
			undocamera.camdist = g_camdist;
			undocamera.cameramodel = s_cameramodel;//2024/06/24


			//2024/07/02
			CBlendShapeElem blendshapeelem;
			blendshapeelem.Init();
			int blendshapenum = s_blendshapedlg.GetBlendShapeLineNum();
			int blendshapeindex = s_blendshapedlg.GetBlendShapeOpeIndex();
			if ((blendshapeindex >= 0) && (blendshapeindex < blendshapenum)) {
				blendshapeelem = s_blendshapedlg.GetBlendShapeElem(blendshapeindex);
				//if (blendshapeelem.validflag && blendshapeelem.model && blendshapeelem.mqoobj) {
				//}
			}


			UNDOSELECT undoselect;
			undoselect.Init();
			undoselect.undokind = UNDOKIND_EDITMOTION;//!!!!!!!!!!


			HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));//長いフレームの保存は数秒時間がかかることがあるので砂時計カーソルにする

			bool allframeflag;
			if ((s_copyLW2WFlag == true) || (s_limiteuldlg.GetAngleLimitChangeFlag() == true) ||
				(s_scaleAllInitFlag == true)) {
				allframeflag = true;
			}
			else {
				allframeflag = false;
			}

			//##################################################################################
			//2024/06/24 s_model->SaveUndoMotion()は　BoneMotionとCameraAnimの両方をSaveするように.
			//##################################################################################
			//2023/10/27 1.2.0.27 RC5 : s_LimitDegCheckBoxFlag == true時　つまり　LimitEulボタンのオンオフ時はモーションの保存をスキップ
			s_model->SaveUndoMotion(undoselect,
				s_LimitDegCheckBoxFlag, g_limitdegflag, s_curboneno, s_curbaseno,
				g_edittarget, &s_editrange, g_applyrate, 
				brushstate, undocamera, blendshapeelem,
				allframeflag);

			SetCursor(oldcursor);//カーソルを元に戻す

		}
		s_editmotionflag = -1;
		s_editcameraflag = -1;

		//}
	}
}


//--------------------------------------------------------------------------------------
// Before handling window messages, DXUT passes incoming windows 
// messages to the application through this callback function. If the application sets 
// *pbNoFurtherProcessing to TRUE, then DXUT will not process this message.
//--------------------------------------------------------------------------------------
LRESULT CALLBACK AppMsgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam
//	, bool* pbNoFurtherProcessing,
//	void* pUserContext
)
{
	if (!s_sampleuihwnd && hWnd && IsWindow(hWnd)) {
		s_sampleuihwnd = hWnd;
	}

	////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	////DXUTのスライダーのマウスアップを捕まえたかった
	////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//if (uMsg == WM_NOTIFY) {
	//	int c;
	//	c = 1;
	//}
	//if(wParam == NM_RELEASEDCAPTURE) {
	//	int d;
	//	d = 1;
	//}



////	DbgOut( L"msgproc!!! %d, %d\r\n", uMsg, WM_LBUTTONDOWN );
//	//if(s_anglelimitdlg && IsDialogMessage(s_anglelimitdlg, &msg))
//
//	// Always allow dialog resource manager calls to handle global messages
//	// so GUI state is updated correctly
//	//g_DialogResourceManager.MsgProc(hWnd, uMsg, wParam, lParam);
//	*pbNoFurtherProcessing = g_DialogResourceManager.MsgProc(hWnd, uMsg, wParam, lParam);
//	if (*pbNoFurtherProcessing) {
//		//_ASSERT(0);
//		return 0;
//	}

	////if( g_SettingsDlg.IsActive() )
	////{
	////    g_SettingsDlg.MsgProc( hWnd, uMsg, wParam, lParam );
	////    //return 0;
	////}

	//// Give the dialogs a chance to handle the message first
	////g_SampleUI.MsgProc(hWnd, uMsg, wParam, lParam);
	//*pbNoFurtherProcessing = g_SampleUI.MsgProc(hWnd, uMsg, wParam, lParam);
	//if (*pbNoFurtherProcessing) {
	//	//_ASSERT(0);
	//	return 0;
	//}

	// Pass all remaining windows messages to camera so it can respond to user input
	////#replacing comment out#g_Camera->HandleMessages(hWnd, uMsg, wParam, lParam);
	CBone* curbone = 0;
	CBone* opebone = 0;
	CRigidElem* curre = 0;
	//if (g_retargetbatchflag == 0) {
	if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
		//int maxboneno = 0;
		if (s_model && (s_curboneno >= 0)) {
			curbone = s_model->GetBoneByID(s_curboneno);
			curre = s_model->GetRigidElem(s_curboneno);
		}
		else {
			curbone = 0;
			curre = 0;
		}

		//if (curbone && curbone->GetParent()) {
		//2023/02/08 opeboneにparentをセットするのは　IKRotのときだけ
		if (curbone && curbone->GetParent(false) && curbone->GetParent(false)->IsSkeleton() && (s_ikkind == 0)) {
			opebone = curbone->GetParent(false);
		}
		else {
			opebone = curbone;
		}



		////if (g_retargetbatchflag == 0) {
		//if (s_model && s_convbone_bvh) {
		//	map<int, CBone*>::iterator itrbone;
		//	for (itrbone = s_convbone_bvh->GetBoneListBegin(); itrbone != s_convbone_bvh->GetBoneListEnd(); itrbone++) {
		//		CBone* curbone = itrbone->second;
		//		if (curbone) {
		//			int boneno = curbone->GetBoneNo();
		//			if (boneno > maxboneno) {
		//				maxboneno = boneno;
		//			}
		//		}
		//	}
		//}
		////}
	}

	if (uMsg == WM_COMMAND) {

		WORD menuid;
		menuid = LOWORD(wParam);
		int modelnum;
		if (s_chascene) {
			modelnum = s_chascene->GetModelNum();
		}
		else {
			modelnum = 0;
		}


		//if ((menuid >= (ID_RMENU_0 + MENUOFFSET_SETCONVBONEMODEL)) && (menuid < (ID_RMENU_0 + modelnum + MENUOFFSET_SETCONVBONEMODEL))) {
		//	int modelindex = menuid - ID_RMENU_0 - MENUOFFSET_SETCONVBONEMODEL;
		//	s_convbone_model = s_modelindex[modelindex].modelptr;

		//	WCHAR strmes[1024];
		//	if (!s_convbone_model) {
		//		swprintf_s(strmes, 1024, L"convbone : sel model : modelptr NULL !!!");
		//		::DSMessageBox(NULL, strmes, L"check!!!", MB_OK);
		//	}
		//	else {
		//		swprintf_s(strmes, 1024, L"%s", s_convbone_model->GetFileName());
		//		s_cbselmodel->setName(strmes);
		//	}
		//}


		//else 



		//if (menuid == (ID_RMENU_IKTARGET + MENUOFFSET_BONERCLICK)) {
		//	int dbgflag1 = 1;
		//}


		if ((menuid >= (ID_RMENU_0 + MENUOFFSET_SETCONVBONEBVH)) && (menuid < (ID_RMENU_0 + modelnum + MENUOFFSET_SETCONVBONEBVH))) {
			int modelindex = menuid - ID_RMENU_0 - MENUOFFSET_SETCONVBONEBVH;
			if (s_chascene) {
				s_retargetdlg.SetRetargetBvh(s_chascene->GetModel(modelindex));
			}
			else {
				s_retargetdlg.SetRetargetBvh(nullptr);
			}

			WCHAR strmes[1024] = { 0L };
			if (!s_retargetdlg.GetRetargetBvh()) {
				swprintf_s(strmes, 1024, L"convbone : sel model : modelptr NULL !!!");
				::DSMessageBox(NULL, strmes, L"check!!!", MB_OK);
				//s_maxboneno = 0;
			}
			else {
				//swprintf_s(strmes, 1024, L"%s", s_convbone_bvh->GetFileName());
				ShortenNameW(s_retargetdlg.GetRetargetBvh()->GetFileName(), strmes, 1024, 21);
				//s_cbselbvh->setName(strmes);
				COLORREF importantcol = RGB(168, 129, 129);
				//s_cbselbvh->setTextColor(importantcol);
				////s_maxboneno = s_convbone_bvh->GetBoneListSize();
				////s_maxboneno = s_convbone_bvh->GetBoneForMotionSize();
				//s_maxboneno = s_convbone_bvh->GetMaxBoneNo();
				s_retargetdlg.SetBvhName(strmes, importantcol);
			}
		}

		////else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_SETCONVBONE)) && (menuid <= (ID_RMENU_0 + s_maxboneno + 1 + MENUOFFSET_SETCONVBONE))) {
		//else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_SETCONVBONE)) && (menuid < (ID_RMENU_0 + MAXBONENUM + MENUOFFSET_SETCONVBONE))) {
		//	if ((s_bvhbone_cbno >= 0) && (s_bvhbone_cbno < MAXBONENUM)) {
		//		if (menuid == (ID_RMENU_0 + 0 + MENUOFFSET_SETCONVBONE)) {
		//			//未設定
		//			s_bvhbone_bone[s_bvhbone_cbno] = 0;
		//			CBone* modelbone = s_modelbone_bone[s_bvhbone_cbno];
		//			_ASSERT(modelbone);
		//			if (modelbone) {
		//				s_convbonemap[modelbone] = 0;
		//			}
		//			s_bvhbone[s_bvhbone_cbno]->setName(L"NotSet");
		//			s_bvhbone[s_bvhbone_cbno]->callRewrite();
		//		}
		//		else {
		//			int cbno = menuid - ID_RMENU_0 - 1 - MENUOFFSET_SETCONVBONE;
		//			int boneno = s_bvhbone_bonenomap[cbno];//2024/07/07 変換表
		//			curbone = s_convbone_bvh->GetBoneByID(boneno);
		//			WCHAR strmes[1024];
		//			if (!curbone) {
		//				s_bvhbone_bone[s_bvhbone_cbno] = 0;
		//				CBone* modelbone = s_modelbone_bone[s_bvhbone_cbno];
		//				_ASSERT(modelbone);
		//				if (modelbone) {
		//					s_convbonemap[modelbone] = 0;
		//				}
		//				s_bvhbone[s_bvhbone_cbno]->setName(L"NotSet");
		//				s_bvhbone[s_bvhbone_cbno]->callRewrite();
		//
		//				swprintf_s(strmes, 1024, L"convbone : sel bvh bone : curbone NULL !!!");
		//				::DSMessageBox(NULL, strmes, L"check!!!", MB_OK);
		//			}
		//			else {
		//				swprintf_s(strmes, 1024, L"%s", curbone->GetWBoneName());
		//				s_bvhbone[s_bvhbone_cbno]->setName(strmes);
		//				s_bvhbone[s_bvhbone_cbno]->callRewrite();
		//				s_bvhbone_bone[s_bvhbone_cbno] = curbone;
		//
		//				CBone* modelbone = s_modelbone_bone[s_bvhbone_cbno];
		//				if (modelbone) {
		//					s_convbonemap[modelbone] = curbone;
		//				}
		//			}
		//		}
		//	}
		//
		//}

		else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_INTERPOLATEFROMTOOL)) && 
			(menuid < (ID_RMENU_0 + MENUOFFSET_INTERPOLATEFROMTOOL + 3))) {
			if (s_model && s_model->GetTopBone() && curbone) {
				s_interpolateState = (menuid - ID_RMENU_0 - MENUOFFSET_INTERPOLATEFROMTOOL + 1);

				MOTINFO curmi = s_model->GetCurMotInfo();
				InterpolateMotionFunc(s_model, &curmi);
			
			}
			s_interpolateFlag = false;//!!!!!
		}
		else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_FILTERFROMTOOL)) &&
			(menuid < (ID_RMENU_0 + MENUOFFSET_FILTERFROMTOOL + 3))) {
			if (s_model && s_model->GetTopBone() && curbone && (s_underfilteringbymenu == false)) {
				s_underfilteringbymenu = true;
				s_filterState = (menuid - ID_RMENU_0 - MENUOFFSET_FILTERFROMTOOL + 1);
				FilterFuncDlg();
				//s_filterState = 0;//2023/08/09コメントアウト:前回の値を保持
				s_underfilteringbymenu = false;
			}
		}
		else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_CHECKSIMILARGROUP)) &&
			(menuid <= (ID_RMENU_0 + MENUOFFSET_CHECKSIMILARGROUP + 7))) {
			if (s_model && s_dispgroupdlg.GetVisible()) {
				int opetype = menuid - (ID_RMENU_0 + MENUOFFSET_CHECKSIMILARGROUP);
				s_dispgroupdlg.CheckSimilarGroup(opetype);
			}
		}
		//else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_INITMPFROMTOOL)) && (menuid <= (ID_RMENU_0 + 3 * 3 + MENUOFFSET_INITMPFROMTOOL))) {
		else if ((menuid >= (ID_RMENU_0 + MENUOFFSET_INITMPFROMTOOL)) && (menuid <= (ID_RMENU_0 + 4 * 4 + MENUOFFSET_INITMPFROMTOOL))) {//### 2022/07/04
			if (s_model) {
				int subid = (menuid - ID_RMENU_0 - MENUOFFSET_INITMPFROMTOOL) / 4;//4 * 3 / 4 --> 0, 1, 2, 3 : submenu
							//int initmode = (menuid - ID_RMENU_0 - MENUOFFSET_INITMPFROMTOOL) - subid * 4;//0, 1, 2, 3
				int initmode = (menuid - ID_RMENU_0 - MENUOFFSET_INITMPFROMTOOL) % 4;//0, 1, 2, 3 //### 2022/07/04 : subsubmenu

				CModel* srcmodel;
				MOTINFO curmi;
				if (s_initmpFlag) {
					srcmodel = s_model;
					curmi = s_model->GetCurMotInfo();
				}
				else if (s_initmpcameraFlag) {
					srcmodel = s_cameramodel;
					curmi = GetCameraMotInfo();
				}
				else {
					srcmodel = nullptr;
					curmi.Init();
				}

				if (srcmodel && (curmi.motid > 0)) {
				//if (s_model->ExistCurrentMotion()) {
					s_copymotvec.clear();
					s_copyKeyInfoList.clear();
					//s_copyKeyInfoList = s_owpLTimeline->getSelectedKey();
					//s_editrange.SetRange(s_copyKeyInfoList, s_owpTimeline->getCurrentTime());
					//CEditRange::SetApplyRate((double)g_applyrate);

					OnTimeLineButtonSelectFromSelectStartEnd(0);
					OnTimeLineSelectFromSelectedKey();
					if (s_owpTimeline) {
						s_copyKeyInfoList = s_owpLTimeline->getSelectedKey();
					}

					int updatejointno = -1;

					if (subid == 0) {//all
						list<KeyInfo>::iterator itrcp;
						for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
							double curframe = itrcp->time;
							CBone* topbone = srcmodel->GetTopBone(false);
							if (topbone) {
								bool broflag = false;
								//InitMpByEulReq(initmode, topbone, srcmodel->GetCurrentMotID(), curframe, broflag);//topbone req
								InitMpByEulReq(initmode, topbone, curmi.motid, curframe, broflag);//topbone req
								updatejointno = topbone->GetBoneNo();
							}
						}
					}
					else if (subid == 1) {//one
						if (opebone) {
							list<KeyInfo>::iterator itrcp;
							for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
								double curframe = itrcp->time;
								//InitMpByEul(initmode, opebone, srcmodel->GetCurrentMotID(), curframe);//opebone
								InitMpByEul(initmode, opebone, curmi.motid, curframe);//opebone
								updatejointno = opebone->GetBoneNo();
							}
						}
					}
					else if (subid == 2) {//deeper
						if (opebone) {
							list<KeyInfo>::iterator itrcp;
							for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
								double curframe = itrcp->time;
								bool broflag = false;
								//InitMpByEulReq(initmode, opebone, srcmodel->GetCurrentMotID(), curframe, broflag);//opebone req
								InitMpByEulReq(initmode, opebone, curmi.motid, curframe, broflag);//opebone req
								updatejointno = opebone->GetBoneNo();
							}
						}
					}
					else if (subid == 3) {//deeperEndJoint
						if (opebone) {
							list<KeyInfo>::iterator itrcp;
							for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
								double curframe = itrcp->time;
								bool broflag = false;
								//InitMpByEulEndJointReq(initmode, opebone, srcmodel->GetCurrentMotID(), curframe, broflag);//opebone req
								InitMpByEulEndJointReq(initmode, opebone, curmi.motid, curframe, broflag);//opebone req
								updatejointno = opebone->GetBoneNo();
							}
						}
					}

					if (s_initmpFlag && (g_limitdegflag == true)){
						bool allframeflag = false;
						bool setcursorflag = false;
						bool onpasteflag = false;
						CopyLimitedWorldToWorld(srcmodel, allframeflag, setcursorflag, updatejointno, onpasteflag);
					}

					//s_model->CalcBoneEul(g_limitdegflag, s_model->GetCurrentMotID());//2023/11/07
					srcmodel->CalcBoneEul(g_limitdegflag, curmi.motid);

					refreshEulerGraph();
					PrepairUndo();
				}
			}
			s_initmpFlag = false;//!!!!
			s_initmpcameraFlag = false;//!!!!
		}


		else if ((menuid >= (MENUOFFSET_BRUSHESCONTEXTMENU)) && (menuid < (MENUOFFSET_BRUSHESCONTEXTMENU + MAXPLUGIN))) {
			if (s_model) {
				int subid = menuid - MENUOFFSET_BRUSHESCONTEXTMENU;
				if (s_model->ExistCurrentMotion()) {
					if (s_plugin && ((s_plugin + subid)->validflag == 1)) {

						RollbackCurBoneNo();//2024/04/22 右クリックで初期化されてしまったジョイント選択を復元

						g_motionbrush_method = (s_plugin + subid)->menuid;

						if (s_editmotionflag < 0) {//IK中でないとき
							int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
							if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
								_ASSERT(0);
								::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
								PostQuitMessage(result);
							}
							s_utBrushMethodFlag = true;//PrepairUndo();//保存はOnFrameUtCheckBoxにて
						}
					}
					else {
						_ASSERT(0);
					}

					//if (s_guidlg[GUIDLG_BRUSHPARAMS]) {
					//	HWND combownd = GetDlgItem(s_guidlg[GUIDLG_BRUSHPARAMS], IDC_COMBO_BRUSHES);
					//	if (combownd != NULL) {
					//		::SendMessage(combownd, CB_SETCURSEL, (WPARAM)subid, 0);
					//	}
					//}
				}
			}
		}

		else if (menuid == (ID_RMENU_COPY + MENUOFFSET_BONERCLICK)) {
			if (s_copyFlag == false) {
				s_copyFlag = true;
			}
		}
		else if (menuid == (ID_RMENU_PASTE + MENUOFFSET_BONERCLICK)) {
			if ((s_pasteFlag == false) && (s_RboneAndPasteFlag == false)) {
				s_RboneAndPasteFlag = true;
			}
		}

		else if (menuid == (ID_RMENU_IKTARGET + MENUOFFSET_BONERCLICK)) {
			//toggle
			if (curbone->GetIKTargetFlag() == false){
				curbone->SetIKTargetFlag(true);
			}
			else{
				curbone->SetIKTargetFlag(false);
			}
			if (s_owpTimeline) {
				refreshTimeline(*s_owpTimeline);
			}
		}
		else if (menuid == (ID_RMENU_IKSTOP + MENUOFFSET_BONERCLICK)) {
			//toggle
			if (curbone->GetIKStopFlag() == false) {
				curbone->SetIKStopFlag(true);
			}
			else {
				curbone->SetIKStopFlag(false);
			}
			if (s_owpTimeline) {
				refreshTimeline(*s_owpTimeline);
			}
		}
		//else if (menuid == (ID_RMENU_KINEMATIC_ON_LOWER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->SetKinematicTmpLower(curbone, true);
		//	}
		//}
		//else if (menuid == (ID_RMENU_KINEMATIC_OFF_LOWER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->SetKinematicTmpLower(curbone, false);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_ON_ALL + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_All(true);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_OFF_ALL + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_All(false);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_ON_UPPER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_Upper(true, curbone);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_OFF_UPPER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_Upper(false, curbone);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_ON_LOWER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_Lower(true, curbone);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0_OFF_LOWER + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		s_model->Mass0_Lower(false, curbone);
		//	}
		//}
		//else if (menuid == (ID_RMENU_MASS0 + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		//toggle
		//		if (curbone->GetMass0() == 0) {
		//			s_model->SetMass0(curbone);
		//		}
		//		else {
		//			s_model->RestoreMass(curbone);
		//		}
		//	}
		//}
		//else if (menuid == (ID_RMENU_EXCLUDE_MV + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curbone) {
		//		//toggle
		//		if (curbone->GetExcludeMv() == 0) {
		//			curbone->SetExcludeMv(1);
		//		}
		//		else {
		//			curbone->SetExcludeMv(0);
		//		}
		//	}
		//}
		//else if (menuid == (ID_RMENU_FORBIDROT_ONE + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curre) {
		//		curre->SetForbidRotFlag(1);
		//	}
		//}
		//else if (menuid == (ID_RMENU_ENABLEROT_ONE + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curre) {
		//		curre->SetForbidRotFlag(0);
		//	}
		//}
		//else if (menuid == (ID_RMENU_FORBIDROT_CHILDREN + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curre) {
		//		s_model->EnableRotChildren(curbone, false);
		//	}
		//}
		//else if (menuid == (ID_RMENU_ENABLEROT_CHILDREN + MENUOFFSET_BONERCLICK)) {
		//	if (s_model && curre) {
		//		s_model->EnableRotChildren(curbone, true);
		//	}
		//}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_BONERCLICK)) {
			//新規
			//GUIMenuSetVisible(-1, -1);
			bool closefirstrow = true;
			CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる
			int currigno = -1;
			DispCustomRigDlg(currigno);
		}
		else if ((menuid >= (ID_RMENU_0 + MAXRIGNUM + MENUOFFSET_BONERCLICK)) && (menuid < (ID_RMENU_0 + MAXRIGNUM * 2 + MENUOFFSET_BONERCLICK))) {
			//設定
			//GUIMenuSetVisible(-1, -1);
			bool closefirstrow = true;
			CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる
			int currigno = s_customrigmenuindex[menuid - (ID_RMENU_0 + MAXRIGNUM) - MENUOFFSET_BONERCLICK];
			DispCustomRigDlg(currigno);
		}
		else if ((menuid >= (ID_RMENU_0 + MAXRIGNUM * 2 + MENUOFFSET_BONERCLICK)) && (menuid < (ID_RMENU_0 + MAXRIGNUM * 3 + MENUOFFSET_BONERCLICK))) {
			//実行
			int currigno = s_customrigmenuindex[menuid - (ID_RMENU_0 + MAXRIGNUM * 2) - MENUOFFSET_BONERCLICK];
			////Bone2CustomRig(currigno);
			//GUIMenuSetVisible(-1, -1);
			bool closefirstrow = true;
			CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる
			DispCustomRigDlg(currigno);//2024/01/21 設定ダイアログ表示をピックしたリグの内容に更新
			if (s_customrigbone) {
				s_oprigflag = 1;
			}
		}
		else if ((menuid >= (ID_RMENU_0 + MAXRIGNUM * 3 + MENUOFFSET_BONERCLICK)) && (menuid < (ID_RMENU_0 + MAXRIGNUM * 4 + MENUOFFSET_BONERCLICK))) {
			//削除(無効化)
			int currigno = s_customrigmenuindex[menuid - (ID_RMENU_0 + MAXRIGNUM * 3) - MENUOFFSET_BONERCLICK];
			InvalidateCustomRig(currigno);
		}


		if ((menuid >= (ID_RMENU_0 + MENUOFFSET_GETSYMROOTMODE)) && (menuid <= (ID_RMENU_0 + 3 + MENUOFFSET_GETSYMROOTMODE))) {
			switch (menuid) {
			case (ID_RMENU_0 + MENUOFFSET_GETSYMROOTMODE):
				s_getsym_retmode = SYMROOTBONE_SAMEORG;
				break;
			case (ID_RMENU_0 + 1 + MENUOFFSET_GETSYMROOTMODE):
				s_getsym_retmode = SYMROOTBONE_SYMDIR | SYMROOTBONE_SYMPOS;
				break;
			case (ID_RMENU_0 + 2 + MENUOFFSET_GETSYMROOTMODE):
				s_getsym_retmode = SYMROOTBONE_SYMDIR;
				break;
			case (ID_RMENU_0 + 3 + MENUOFFSET_GETSYMROOTMODE):
				s_getsym_retmode = SYMROOTBONE_SYMPOS;
				break;
			default:
				s_getsym_retmode = SYMROOTBONE_SYMDIR | SYMROOTBONE_SYMPOS;
				break;
			}
		}






		else if ((menuid >= 59900) && (menuid <= (59900 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 59900;
			OnAnimMenu(true, selindex);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 61000) && (menuid <= (61000 + MAXMODELNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 61000;
			//OnModelMenu(true, selindex, 1);
			bool forceflag = true;
			bool callundo = true;
			OnChangeModel(selindex, forceflag, callundo);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 62000) && (menuid <= (62000 + MAXRENUM))) {
			ActivatePanel(0);
			int selindex = menuid - 62000;
			OnREMenu(selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 63000) && (menuid <= (63000 + MAXRENUM))) {
			ActivatePanel(0);
			int selindex = menuid - 63000;
			OnRgdMenu(selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 64000) && (menuid <= (64000 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 64000;
			OnRgdMorphMenu(selindex);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 64500) && (menuid <= (64500 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 64500;
			OnImpMenu(selindex);
			ActivatePanel(1);
			//return 0;
		}
		else {
			switch (menuid) {
			case ID_40047:
				// "編集・変換"
				// "ボーン軸をXに再計算"
				ActivatePanel(0);
				//RecalcBoneAxisX(0);
				RecalcAxisX_All();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_CAMERADOLLY:
				ActivatePanel(0);
				ShowCameraDollyDlg();
				ActivatePanel(1);
				break;
			case 29800:
				ActivatePanel(0);
				//RegistKey();
				AboutMotionBrush();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_EXPORTBNT:
				ActivatePanel(0);
				ExportBntFile();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_OPEN40001:
				ActivatePanel(0);
				OpenFile();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_BVH2FBX:
				if (s_registflag == 1) {
					ActivatePanel(0);
					BVH2FBX();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_FILE_BVH2FBXBATCH:
				if (s_registflag == 1) {
					CloseAllAndDispPlaceFolder();//バッチ処理中にOnModelMenu()で頻繁にCreate*DlgするとDlgが閉じられなくなることがあるので対応
					ActivatePanel(0);
					BVH2FBXBatch();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_FILE_RETARGETBATCH:
				if (s_registflag == 1) {
					CloseAllAndDispPlaceFolder();//バッチ処理中にOnModelMenu()で頻繁にCreate*DlgするとDlgが閉じられなくなることがあるので対応
					ActivatePanel(0);
					RetargetBatch();
					ActivatePanel(1);
				}
				//return 0;
				break;

				/***
							case ID_SAVE_FBX40039:
								if( s_registflag == 1 ){
									ActivatePanel( 0 );
									ExportFBXFile();
									ActivatePanel( 1 );
								}
								break;
				***/
			case ID_SAVEPROJ_40035:
				if (s_registflag == 1) {
					CloseAllAndDispPlaceFolder();
					ActivatePanel(0);
					SaveProject();
					ActivatePanel(1);
				}
				break;
			case ID_RESAVE_40028:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveREFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_IMPSAVE_40030:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveImpFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_SAVEGCOLI_40033:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveGcoFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_SAVE_MOTIONNAMELIST:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveMotionNameListFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_DISPMW40002:
				DispMotionWindow();
				//return 0;
				break;
			case 4007:
				DispToolWindow();
				//return 0;
				break;
			case 40012:
			{
				bool savedispflag = s_dispobj;
				s_dispobj = !savedispflag;
				DispObjPanel();
				//return 0;
			}
			break;
			case ID_40048:
				//DispConvBoneWindow();
				s_platemenukind = SPPLATEMENUKIND_RETARGET;
				GUIMenuSetVisible(s_platemenukind, 1);
				//return 0;
				break;
			case ID_40049:
				//DispAngleLimitDlg();
				s_platemenukind = SPPLATEMENUKIND_RETARGET;
				GUIMenuSetVisible(s_platemenukind, 2);
				//return 0;
				break;
			case ID_40050:
				DispRotAxisDlg();
				//return 0;
				break;
			case ID_DISPMODELPANEL:
			{
				bool savedispflag = s_dispmodel;
				s_dispmodel = !savedispflag;
				DispModelPanel();
				//return 0;
			}
			break;
			case ID_MOTIONPANEL:
			{
				bool savedispflag = s_dispmotion;
				s_dispmotion = !savedispflag;
				DispMotionPanel();
				//return 0;
			}
			break;
			case ID_CAMERAPANEL:
			{
				bool savedispflag = s_dispcamera;
				s_dispcamera = !savedispflag;
				DispCameraPanel();
				//return 0;
			}
			break;
			case ID_SETTINGS:
			{
				s_skyparamsFlag = true;
			}
			break;
			case ID_FOG:
			{
				s_fogparamsFlag = true;
			}
			break;
			case ID_DOF:
			{
				s_dofparamsFlag = true;
			}
			break;

			case ID_DISPGROUND:
				s_dispground = !s_dispground;
				//return 0;
				break;
			case ID_NEWMOT:
				s_newmotFlag = true;
				//AddMotion( 0 );
				//InitCurMotion(0, 0);
				////return 0;
				break;
			case ID_DELCURMOT:
				if (s_model) {
					s_delcurmotFlag = true;
					//OnDelMotion(s_motmenuindexmap[s_model]);
				}
				//return 0;
				break;
			case ID_DELMODEL:
				s_delmodelFlag = true;
				//OnDelModel( s_curmodelmenuindex );
				//return 0;
				break;
			case ID_DELALLMODEL:
				s_delallmodelFlag = true;
				//OnDelAllModel();
				//return 0;
				break;
			default:
				break;
			}
		}
	}
	else if (uMsg == WM_MOUSEWHEEL) {
		if ((g_keybuf['T'] & 0x80) != 0) {
			if (s_model && (s_curboneno > 0) && ChkEnableIK()) {
				s_tkeyflag = 1;

				int delta;
				delta = GET_WHEEL_DELTA_WPARAM(wParam);
				s_ikselectmat = s_selm;
				//s_editmotionflag = s_model->TwistBoneAxisDelta(&s_editrange, s_curboneno, (float)delta, g_iklevel, s_ikcnt, s_ikselectmat);
				s_editmotionflag = s_model->IKRotateAxisDelta(g_limitdegflag,
					&s_editrange, PICK_X, s_curboneno, (float)delta, g_iklevel, s_ikcnt, s_ikselectmat);

				//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
				//UpdateEditedEuler();
			}
		}

		/*
		int delta;
		delta = GET_WHEEL_DELTA_WPARAM(wParam);
		if (g_underselectingframe == 1){
			OnTimeLineButtonSelectFromSelectStartEnd((double)delta, 0);
		}
		else{
			OnTimeLineCursor();
		}
		*/
		/*
		if( g_keybuf[VK_CONTROL] & 0x80 ){
			float radstep = 0.5f * (float)DEG2PAI;
			float delta;

			int curdelta;
			curdelta = GET_WHEEL_DELTA_WPARAM(wParam);
			if( curdelta >= 0 ){
				delta = radstep;
			}else{
				delta = -1.0f * radstep;
			}

			if( s_model && s_model->GetTopBt() ){
//s_model->CalcBtAxismat( delta );//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			}
		}
		*/


	}
	else if(uMsg == WM_CAPTURECHANGED){
		//if ((HWND)lParam != hWnd) {
		//	::SendMessage(hWnd, WM_LBUTTONUP, 0, 0);
		//}
	}
	else if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_LBUTTONDBLCLK)) {

		if (UnderDragOperation_R()) {
			s_cancelLButtonDown = true;
			return 0;//!!!!!!!!!!!!!!!!
		}

		if (!s_model) {
			//!!!!!!!!!!!!!! 
			return DefWindowProc(hWnd, uMsg, wParam, lParam);
		}


		//s_cameraeditkind = CAMERAANIMEDIT_NONE;//コメントアウト：グラフ表示を保持するために初期化しない

		if (s_curboneno >= 0) {
			s_saveboneno = s_curboneno;
		}
		//s_curboneno = -1;

		s_ikcnt = 0;
		s_rectime = 0.0;
		s_reccnt = 0;

		
		if (s_model) {
			s_model->ClearIKRotRec();
			s_model->ClearIKRotRecUV();
		}

		//!!!!!!!!!!!!!!!!!!!!!!!!!!
		//DS deviceがあっても、マウスを併用する場合があるのでマウスのSetCaptureとReleaseCaptureは必要
		//!!!!!!!!!!!!!!!!!!!!!!!!!!

		//if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
			//DS deviceが無い場合
		//SetCapture(s_3dwnd);
		//}
		//SetCapture( s_3dwnd );


		//SetCapture(DXUTGetHWND());
		SetCapture(s_3dwnd);
		
		


		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);

		bool pickflag = false;//2024/02/04

		if (g_previewFlag == 0) {//2024/02/05
			//UndoRedo
			int pickundo = 0;
			pickundo = PickSpUndo(ptCursor);
			if (pickundo == PICK_UNDO) {
				//RollbackCurBoneNo();
				if ((s_undoFlag == false) && (s_redoFlag == false)) {
					s_undoFlag = true;
					s_spundo[0].ButtonDown();
					s_SpriteButtonDownUndoRedo = true;
				}
				//PostMessage(g_mainhwnd, WM_KEYDOWN, VK_CONTROL | 'Z', 0);
				//PostMessage(s_3dwnd, WM_KEYDOWN, VK_CONTROL | 'Z', 0);
				pickflag = true;
			}
			else if (pickundo == PICK_REDO)
			{
				//RollbackCurBoneNo();
				if ((s_undoFlag == false) && (s_redoFlag == false)) {
					s_redoFlag = true;
					s_spundo[1].ButtonDown();
					s_SpriteButtonDownUndoRedo = true;
				}
				//PostMessage(g_mainhwnd, WM_KEYDOWN, VK_CONTROL | VK_SHIFT | 'Z', 0);
				//PostMessage(s_3dwnd, WM_KEYDOWN, VK_CONTROL | VK_SHIFT | 'Z', 0);
				pickflag = true;
			}
		}


		s_pickinfo.clickpos = ptCursor;
		s_pickinfo.mousepos = ptCursor;
		s_pickinfo.mousebefpos = ptCursor;
		s_pickinfo.diffmouse.SetParams(0.0f, 0.0f);
		s_pickinfo.firstdiff.SetParams(0.0f, 0.0f);

		//s_pickinfo.winx = (int)DXUTGetWindowWidth();
		//s_pickinfo.winy = (int)DXUTGetWindowHeight();
		s_pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
		s_pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
		s_pickinfo.pickrange = PICKRANGE;

		s_pickinfo.pickobjno = -1;

		int platemenukind = s_platemenukind;
		int nextplatemenukind = 0;
		int nextplateno = 0;


		//if (s_dispmodel && s_modelpanel.panel && s_modelpanel.separator) {
		//	
		//	//SetCapture(s_modelpanel.panel->getHWnd());//!!!!!!!!!!!!
		//	POINT tmppos;
		//	GetCursorPos(&tmppos);
		//	LPARAM panallparam;
		//	panallparam = (tmppos.y << 16) | tmppos.x;
		//	SendMessage(s_modelpanel.panel->getHWnd(), WM_LBUTTONDOWN, MK_LBUTTON, panallparam);
		//}



		{//2024/02/05 カメラはpreview中もドラッグ可能にする
			if (pickflag == false) {
				//cameramode switch
				int pickcameramodeflag = 0;
				pickcameramodeflag = PickSpCameraModeSW(ptCursor);
				if (pickcameramodeflag == 1) {
					ChangeCameraMode(0);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2
					pickflag = true;
				}
			}
			if (pickflag == false) {
				//camerainherit switch
				int pickcamerainheritflag = 0;
				pickcamerainheritflag = PickSpCameraInheritSW(ptCursor);
				if (pickcamerainheritflag == 1) {
					ChangeCameraInherit();
					pickflag = true;
				}
			}
			if ((pickflag == false) && (PickSpCameraDolly(ptCursor) != 0)) {
				if (s_model) {
					if (s_cameradollyFlag == false) {
						s_cameradollyFlag = true;
						s_spcameradolly.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			int spckind = 0;
			if ((pickflag == false) && s_spguisw[SPGUISW_CAMERA_AND_IK].state && ((spckind = PickSpCam(ptCursor)) != 0)) {
				s_pickinfo.buttonflag = spckind;
				s_pickinfo.pickobjno = -1;
				RollbackCurBoneNo();
				if ((spckind >= PICK_CAMROT) && (spckind <= PICK_CAMDIST)) {
					s_spcam[spckind - PICK_CAMROT].ButtonDown();
				}
				pickflag = true;
			}
		}




		//check and op rigflag : s_oprigflag turn to 1 when RClickRigMenu selected too.
		if (g_previewFlag == 0) {//2024/02/05
			if (pickflag == false) {
				//IK Mode
				int pickikmodeflag = 0;
				pickikmodeflag = PickSpIkModeSW(ptCursor);
				if (pickikmodeflag == 1) {
					s_ikkind = 0;
					s_spikmodesw[0].state = true;
					s_spikmodesw[1].state = false;
					s_spikmodesw[2].state = false;
					SetLTimelineMark(s_curboneno);//グラフの操作ジョイント名表示も
					refreshEulerGraph();
					pickflag = true;
				}
				else if (pickikmodeflag == 2) {
					s_ikkind = 1;
					s_spikmodesw[0].state = false;
					s_spikmodesw[1].state = true;
					s_spikmodesw[2].state = false;
					SetLTimelineMark(s_curboneno);//グラフの操作ジョイント名表示も
					refreshEulerGraph();
					pickflag = true;
				}
				else if (pickikmodeflag == 3) {
					s_ikkind = 2;
					s_spikmodesw[0].state = false;
					s_spikmodesw[1].state = false;
					s_spikmodesw[2].state = true;
					SetLTimelineMark(s_curboneno);//グラフの操作ジョイント名表示も
					refreshEulerGraph();
					pickflag = true;
				}
			}
			if (pickflag == false) {
				//RefPos switch
				int picklodflag = 0;
				picklodflag = PickSpRefPosSW(ptCursor);
				if (picklodflag == 1) {
					s_sprefpos.state = !s_sprefpos.state;
					pickflag = true;
				}
			}
			if (pickflag == false) {
				//limiteul switch
				int picklimiteulflag = 0;
				picklimiteulflag = PickSpLimitEulSW(ptCursor);
				if (picklimiteulflag == 1) {
					//2023/02/15
					bool newstate = !s_splimiteul.state;
					ChangeLimitDegFlag(newstate, true, true);
					pickflag = true;
				}
			}
			if (pickflag == false) {
				//wallscraping switch
				int pickscrapingflag = 0;
				pickscrapingflag = PickSpScrapingSW(ptCursor);
				if (pickscrapingflag == 1) {
					bool newstate = !s_spscraping.state;
					ChangeWallScrapingIKFlag(newstate);
					pickflag = true;
				}
			}

			//2023/02/04
			//Bake LimitedWorld-->World : currentmotion fullframe
			if ((pickflag == false) && (PickSpCpLW2W(ptCursor) != 0)) {
				if (s_copyLW2WFlag == false) {
					s_copyLW2WFlag = true;
					s_spcplw2w.ButtonDown();
					s_SpriteButtonDown = true;
				}
				pickflag = true;
			}

			if ((pickflag == false) && (PickSpSmooth(ptCursor) != 0)) {
				if (s_smoothFlag == false) {
					s_smoothFlag = true;
					s_spsmooth.ButtonDown();
					s_SpriteButtonDown = true;
				}
				pickflag = true;
			}

			if ((pickflag == false) && (PickSpConstExe(ptCursor) != 0)) {
				if (s_constexeFlag == false) {
					s_constexeFlag = true;
					s_spconstexe.ButtonDown();
					s_SpriteButtonDown = true;
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpConstRefresh(ptCursor) != 0)) {
				if (s_constrefreshFlag == false) {
					s_constrefreshFlag = true;
					s_spconstrefresh.ButtonDown();
					s_SpriteButtonDown = true;
				}
				pickflag = true;
			}


			if ((pickflag == false) && (PickSpFrog2(ptCursor) != 0)) {
				if (s_model) {
					s_spret2prev2.ButtonDown();
					s_SpriteButtonDown = true;
					ChangeToolSpriteMode();
				}
				pickflag = true;
			}

			if ((pickflag == false) && (PickSpCopyCamera(ptCursor) != 0)) {
				if (s_model) {
					if (s_copycameraFlag == false) {
						s_copycameraFlag = true;
						s_spcopy_camera.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpPasteCamera(ptCursor) != 0)) {
				if (s_model) {
					if (s_pastecameraFlag == false) {
						s_pastecameraFlag = true;
						s_sppaste_camera.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpInitCamera(ptCursor) != 0)) {
				if (s_model) {
					if (s_initmpcameraFlag == false) {
						s_initmpcameraFlag = true;
						s_spinit_camera.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpInterpolateCamera(ptCursor) != 0)) {
				if (s_model) {
					if (s_interpolatecameraFlag == false) {
						s_interpolatecameraFlag = true;
						s_spinterpolate_camera.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpSmoothCamera(ptCursor) != 0)) {
				if (s_model) {
					if (s_smoothcameraFlag == false) {
						s_smoothcameraFlag = true;
						s_spsmooth_camera.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}


			if ((pickflag == false) && (PickSpCopy(ptCursor) != 0)) {
				if (s_model) {
					if (s_copyFlag == false) {
						s_copyFlag = true;
						s_spcopy.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpSymCopy(ptCursor) != 0)) {
				if (s_model) {
					if (s_symcopyFlag == false) {
						s_symcopyFlag = true;
						s_spsymcopy.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpPaste(ptCursor) != 0)) {
				if (s_model) {
					if (s_pasteFlag == false) {
						s_pasteFlag = true;
						s_sppaste.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpCopyHistory(ptCursor) != 0)) {
				if (s_model) {
					if (s_selCopyHisotryFlag == false) {
						s_selCopyHisotryFlag = true;
						s_spcopyhistory.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}

			int pickinterpolate = 0;
			if ((pickflag == false) && ((pickinterpolate = PickSpInterpolate(ptCursor)) != 0)) {
				if (s_model) {
					if (pickinterpolate == 1) {
						if (s_interpolateFlag == false) {
							s_interpolateFlag = true;
							s_spinterpolate.ButtonDown();
							s_SpriteButtonDown = true;
						}
					}
					else if (pickinterpolate == 2) {
						if (s_jumpinterpolateFlag == false) {
							s_jumpinterpolateFlag = true;
							s_spjumpinterpolate.ButtonDown();
							s_SpriteButtonDown = true;
						}
					}
					else {
						_ASSERT(0);
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpInit(ptCursor) != 0)) {
				if (s_model) {
					if (s_initmpFlag == false) {
						s_initmpFlag = true;
						s_spinit.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpScaleInit(ptCursor) != 0)) {
				if (s_model) {
					if (s_scaleAllInitFlag == false) {
						s_scaleAllInitFlag = true;
						s_spscaleinit.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpProperty(ptCursor) != 0)) {
				if (s_model) {
					if (s_motpropFlag == false) {
						s_motpropFlag = true;
						s_spproperty.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}

			if ((pickflag == false) && (PickSpZeroFrame(ptCursor) != 0)) {
				if (s_model) {
					if (s_zeroFrameFlag == false) {
						s_LstopFlag = true;
						g_previewFlag = 0;
						s_LcursorFlag = true;
						s_zeroFrameFlag = true;
						s_spzeroframe.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpModelPosDir(ptCursor) != 0)) {
				if (s_model) {
					if (s_modelworldmatFlag == false) {
						s_modelworldmatFlag = true;
						s_spmodelposdir.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}
			if ((pickflag == false) && (PickSpMaterialRate(ptCursor) != 0)) {
				if (s_model) {
					if (s_materialrateFlag == false) {
						s_materialrateFlag = true;
						s_spmaterialrate.ButtonDown();
						s_SpriteButtonDown = true;
					}
				}
				pickflag = true;
			}

			int oprigdoneflag = 0;
			int pickrigflag = 0;
			if (pickflag == false) {
				pickrigflag = PickSpRig(ptCursor);
				if (pickrigflag == 1) {


					//開いている設定ダイアログを閉じないと、設定ダイアログのrigboneと新たなrigboneが異なってしまい、Applyボタンで異なるリグを保存することがある
					if (s_customrigdlg) {
						DestroyWindow(s_customrigdlg);
						s_customrigdlg = 0;
					}


					if (s_oprigflag == 1) {

						//オンだったRigをオフにする
						RollbackCurBoneNo();
						ToggleRig();
						oprigdoneflag = 1;

						s_curboneno = -1;//Sprite Menuより後で。Rigid作成に選択済s_curbonenoが必要。
					}
					else {

						//オフだったリグをオンにする
						RollbackCurBoneNo();

						ToggleRig();
						oprigdoneflag = 1;
						//s_oprigflag == 1 のときのpickrigflag == 0　だから　rigはオン
						//s_curboneno はそのまま
					}
					pickflag = true;
				}
			}

			if (pickflag == false) {
				//menukind : from 0 to 4
				//plateno : from 1 to platenum
				pickflag = GUIGetNextMenu(ptCursor, platemenukind, &nextplatemenukind, &nextplateno);
				if ((nextplatemenukind >= 0) && (nextplateno != 0)) {
					s_platemenukind = nextplatemenukind;
					s_platemenuno = nextplateno;
					GUIMenuSetVisible(s_platemenukind, nextplateno);
				}
			}

			//s_curboneno = -1;//Sprite Menuより後で。Rigid作成に選択済s_curbonenoが必要。

			if (s_model) {
				int spakind = 0;
				//int pickrigflag = 0;
				if ((pickflag == false) && s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
					spakind = PickSpAxis(ptCursor);
				}
				if (spakind != 0) {

					pickflag = true;

					if ((spakind >= PICK_SPA_X) && (spakind <= PICK_SPA_Z)) {
						s_spaxis[spakind - PICK_SPA_X].ButtonDown();
					}

					if (g_edittarget == EDITTARGET_MORPH) {
						RollbackCurBoneNo();
						s_pickinfo.buttonflag = spakind;
						s_pickinfo.pickobjno = s_curboneno;
					}
					else if (g_edittarget == EDITTARGET_BONE) {
						if (s_saveboneno >= 0) {
							RollbackCurBoneNo();
							s_pickinfo.buttonflag = spakind;
							s_pickinfo.pickobjno = s_curboneno;

							//g_underIKRot = true;//2023/10/14 !!!!! 設定し忘れていた
							//g_underIKRotApplyFrame = true;//2023/10/14 !!!!! 設定し忘れていた
							s_model->SetUnderIKRot(true);
							s_model->SetUnderIKRotApplyFrame(true);


							//} else if ((oprigdoneflag == 0) && (pickrigflag == 1)){
							//	RollbackCurBoneNo();
							//	ToggleRig();
						}
					}
					else if (g_edittarget == EDITTARGET_CAMERA) {
						int cameramotid = 0;
						int cameraframeleng = 100;
						CBone* opebone = GetEditTargetOpeBone(&cameramotid, &cameraframeleng);
						if (opebone) {
							s_pickinfo.buttonflag = spakind;
							s_pickinfo.pickobjno = opebone->GetBoneNo();

							s_model->SetUnderIKRot(true);
							s_model->SetUnderIKRotApplyFrame(true);
						}
						else {
							s_pickinfo.pickobjno = -1;
						}
					}
					
				}

				if ((pickflag == false) && (s_oprigflag == 0)) {
					if (g_shiftkey == false) {
						CallF(PickBone(&s_pickinfo), return 1);
					}
					if (s_pickinfo.pickobjno >= 0) {
						s_curboneno = s_pickinfo.pickobjno;//!!!!!!!

						if (s_owpTimeline) {
							s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
						}

						ChangeCurrentBone(true);


						//if (s_model->GetInitAxisMatX() == 0){//OnAnimMenuに移動
						//	s_owpLTimeline->setCurrentTime(0.0, true);
						//	s_owpEulerGraph->setCurrentTime(0.0, false);
						//	s_model->SetMotionFrame(0.0);
						//	s_model->UpdateMatrix(&s_model->GetWorldMat(), &s_matVP);
						//	//ここでAxisMatXの初期化
						//	s_model->CreateBtObject(1);
						//	s_model->CalcBtAxismat(2);//2
						//	s_model->SetInitAxisMatX(1);
						//}

						s_pickinfo.buttonflag = PICK_CENTER;//!!!!!!!!!!!!!
						if (g_edittarget == EDITTARGET_BONE) {
							//g_underIKRot = true;
							//g_underIKRotApplyFrame = true;
							s_model->SetUnderIKRot(true);
							s_model->SetUnderIKRotApplyFrame(true);
						}

						//IK中は30fpsにする
						//IK中の描画回数が多いと　IKROTRECの保存数が多すぎて
						//ドラッグ終了後のウェイトカーソルが長くなりすぎる
						//IKROTREC保存数を減らすため30fps
						g_fpsforce30 = true;


						//CModel::PickBone内でセット
						//s_pickinfo.firstdiff.x = (float)s_pickinfo.clickpos.x - s_pickinfo.objscreen.x;
						//s_pickinfo.firstdiff.y = (float)s_pickinfo.clickpos.y - s_pickinfo.objscreen.y;

						pickflag = true;
					}

					if (pickflag == false) {
						bool pickring = false;
						int pickmanipulator = PickManipulator(&s_pickinfo, pickring);
						if (pickmanipulator >= 0) {
							if (g_edittarget == EDITTARGET_BONE) {
								//g_underIKRot = true;
								//g_underIKRotApplyFrame = true;
								s_model->SetUnderIKRot(true);
								s_model->SetUnderIKRotApplyFrame(true);
							}

							//IK中は30fpsにする
							//IK中の描画回数が多いと　IKROTRECの保存数が多すぎて
							//ドラッグ終了後のウェイトカーソルが長くなりすぎる
							//IKROTREC保存数を減らすため30fps
							g_fpsforce30 = true;

							pickflag = true;
						}
					}
				}
				if (pickflag == false) {
					int savecurboneno = s_curboneno;
					CBone* saverigbone = s_customrigbone;
					int pickrigboneno = PickRigBone(&s_pickinfo);
					if (pickrigboneno < 0) {
						s_curboneno = savecurboneno;
						s_customrigbone = saverigbone;

						////ZeroMemory(&s_pickinfo, sizeof(UIPICKINFO));
						s_pickinfo.pickobjno = savecurboneno;
					}
					else {
						if (g_edittarget == EDITTARGET_BONE) {
							//g_underIKRot = true;
							//g_underIKRotApplyFrame = true;
							s_model->SetUnderIKRot(true);
							s_model->SetUnderIKRotApplyFrame(true);
						}

						//IK中は30fpsにする
						//IK中の描画回数が多いと　IKROTRECの保存数が多すぎて
						//ドラッグ終了後のウェイトカーソルが長くなりすぎる
						//IKROTREC保存数を減らすため30fps
						g_fpsforce30 = true;

						pickflag = true;
					}
				}

				//2024/02/04 カメラ操作などのためのpickよりも後で
				if ((pickflag == false) && s_dispmodelworldmat && s_pickmodelworldmat) {
					pickflag = PickAndPut();
				}
				else {
					if ((pickflag == false) && s_spdispsw[SPDISPSW_DISPGROUP].state) {
						pickflag = PickAndSelectMeshOfDispGroupDlg();
					}
					if ((pickflag == false) && s_spdispsw[SPDISPSW_SHADERTYPE].state) {
						pickflag = PickAndSelectMaterialOfShaderTypeDlg();
					}
				}
			}
			else {
				InitPickInfo(&s_pickinfo);
			}
		}


		//ChaMatrixIdentity(&s_ikselectmat);
		if (s_model && (s_curboneno >= 0)) {
			curbone = s_model->GetBoneByID(s_curboneno);
			//_ASSERT(curbone);//<-- ジョイント以外クリックで普通に通る場所　コメントアウト
			if (curbone) {
				s_saveboneno = s_curboneno;

				if (s_camtargetflag && (s_camtargetOnceflag == 0)) {//2024/07/29 s_camtargetOnceflagが１のときはOnFrameToolWndで処理
					AutoCameraTarget();
				}

				if (s_model->ExistCurrentMotion()) {
					//int multworld = 1;
					//s_ikselectmat = curbone->CalcManipulatorMatrix(0, 0, multworld, curmi->motid, curmi->curframe);//curmotinfo!!!
					s_ikselectmat = s_selm;
					//if (curbone && curbone->GetParent()) {
					//	curbone->GetParent()->CalcAxisMatX(0, curbone, &s_ikselectmat, 0);
					//}
					//else {
					//	s_ikselectmat = s_selm;
					//}
					s_ikselectmat.SetTranslationZero();
				}
			}
			else {
				s_curboneno = -1;
			}
		}


		//pickでボーン選択が変わらなかったとき。モーションフレーム選択をした場合など。
		if ((s_curboneno <= 0) && (s_saveboneno > 0)) {
			s_curboneno = s_saveboneno;
		}


		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));//!!!!!!!!!!
		//////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));//!!!!!!!!!!
		ChaVector3 diffv = g_camEye - g_camtargetpos;
		float newcamdist = (float)ChaVector3LengthDbl(&diffv);
		ChangeCameraDist(newcamdist, true, false);

		//if (s_model && (s_pickinfo.pickobjno >= 0) && (g_previewFlag == 5)){
		if (s_model && (g_previewFlag == 5)) {
			if ((s_pickinfo.pickobjno >= 0)) {// && 
				//((s_spguisw[SPGUISW_CAMERA_AND_IK].state == false)) || (PickSpBt(ptCursor) == 0))){//物理IK中でジョイントをクリックしていて、Applyボタンを押していないとき
				StartBt(s_model, TRUE, 1, 1);
				//s_model->BulletSimulationStart();
			}
		}


		if (s_model && (s_curboneno >= 0)) {
			s_rigidparamsdlg.SetModel(s_model, s_curboneno, s_reindexmap, s_rgdindexmap);
			s_limiteuldlg.SetModel(s_model, s_curboneno);
			s_impulsedlg.SetModel(s_model, s_curboneno, s_rgdindexmap);
			s_gplanedlg.SetModel(s_gplane, s_bpWorld);
			s_dampanimdlg.SetModel(s_model, s_curboneno, s_rgdindexmap);
		}

	}
	else if (uMsg == WM_MBUTTONDOWN) {

	}
	else if (uMsg == WM_MOUSEMOVE) {

		OnMouseMoveFunc();

	}
	else if (uMsg == WM_LBUTTONUP) {
		if (s_cancelLButtonDown) {
			s_cancelLButtonDown = false;
			return 0;
		}

		if (!s_model) {
			//!!!!!!!!!!!!!! 
			return DefWindowProc(hWnd, uMsg, wParam, lParam);
		}


		//if (s_dispmodel && s_modelpanel.panel && s_modelpanel.separator) {
		//	POINT tmppos;
		//	GetCursorPos(&tmppos);
		//	LPARAM panallparam;
		//	panallparam = (tmppos.y << 16) | tmppos.x;
		//	SendMessage(s_modelpanel.panel->getHWnd(), WM_LBUTTONUP, MK_LBUTTON, panallparam);
		//}


		//!!!!!!!!!!!!!!!!!!!!!!!!!!
		//DS deviceがあっても、マウスを併用することがあるのでマウスのSetCaptureとReleaseCaptureは必要
		//!!!!!!!!!!!!!!!!!!!!!!!!!!

		//if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
			//DS deviceが無い場合
		ReleaseCapture();
		//}
		//ReleaseCapture();

		{
			int spacnt;
			for (spacnt = 0; spacnt < SPR_CAM_MAX; spacnt++) {
				s_spcam[spacnt].ButtonUp();
			}
		}
		{
			int spacnt;
			for (spacnt = 0; spacnt < SPAXISNUM; spacnt++) {
				s_spaxis[spacnt].ButtonUp();
			}
		}


		bool ikdoneflag = false;
		int ikframenum = 0;
		double startframe = 1.0;
		double endframe = 1.0;
		if (s_editmotionflag >= 0) {
			//s_editrangeがクリアされないうちにフレーム数を保存
			//ikframenum = s_editrange.GetKeyNum();
			s_editrange.GetRange(&ikframenum, &startframe, &endframe);
		}


		//マウスによるIKとFKの後処理　applyframe以外のフレームの処理
		//g_underIKRotApplyFrame = false;
		s_model->SetUnderIKRotApplyFrame(false);

		g_fpsforce30 = false;
		int editmotionflag = s_editmotionflag;

		if (g_edittarget != EDITTARGET_CAMERA) {
			if (ChkEnableIK() && (s_undoFlag == false) && (s_redoFlag == false)) {
				if (s_oprigflag == 0) {
					if ((s_ikkind == 0) && (editmotionflag >= 0)) {
						if (s_pickinfo.buttonflag == PICK_CENTER) {
							HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
							s_editmotionflag = s_model->IKRotatePostIK(g_limitdegflag,
								&s_editrange, s_pickinfo.pickobjno, g_iklevel);

							if (oldcursor != NULL) {
								SetCursor(oldcursor);
							}
							ikdoneflag = true;
						}
						else if ((s_pickinfo.buttonflag == PICK_X) ||
							(s_pickinfo.buttonflag == PICK_Y) ||
							(s_pickinfo.buttonflag == PICK_Z) ||
							(s_pickinfo.buttonflag == PICK_SPA_X) ||
							(s_pickinfo.buttonflag == PICK_SPA_Y) ||
							(s_pickinfo.buttonflag == PICK_SPA_Z)) {
							HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

							s_editmotionflag = s_model->IKRotateAxisDeltaPostIK(
								g_limitdegflag,
								&s_editrange, s_pickinfo.buttonflag, s_pickinfo.pickobjno,
								g_iklevel, s_ikcnt);


							if (oldcursor != NULL) {
								SetCursor(oldcursor);
							}
							ikdoneflag = true;
						}
					}
					else if ((s_ikkind == 1) && (editmotionflag >= 0)) {
						if (s_pickinfo.buttonflag == PICK_CENTER) {
							HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

							//g_underPostFKTra = true;
							s_model->SetUnderPostFKTra(true);

							s_model->FKBoneTraPostFK(g_limitdegflag,
								&s_editrange, s_curboneno);
							s_editmotionflag = s_curboneno;

							//g_underPostFKTra = false;
							s_model->SetUnderPostFKTra(false);

							if (oldcursor != NULL) {
								SetCursor(oldcursor);
							}
							ikdoneflag = true;
						}
						else if ((s_pickinfo.buttonflag == PICK_X) ||
							(s_pickinfo.buttonflag == PICK_Y) ||
							(s_pickinfo.buttonflag == PICK_Z) ||
							(s_pickinfo.buttonflag == PICK_SPA_X) ||
							(s_pickinfo.buttonflag == PICK_SPA_Y) ||
							(s_pickinfo.buttonflag == PICK_SPA_Z)) {
							HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

							//g_underPostFKTra = true;
							s_model->SetUnderPostFKTra(true);

							s_model->FKBoneTraAxisPostFK(
								g_limitdegflag,
								&s_editrange, s_curboneno);
							s_editmotionflag = s_curboneno;

							//g_underPostFKTra = false;
							s_model->SetUnderPostFKTra(false);

							if (oldcursor != NULL) {
								SetCursor(oldcursor);
							}
							ikdoneflag = true;
						}
					}

				}
				else {
					if (s_customrigbone && (s_customrigno >= 0) && (editmotionflag >= 0)) {

						HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

						s_ikcustomrig = s_customrigbone->GetCustomRig(s_customrigno);
						s_model->RigControlPostRig(g_limitdegflag,
							0, &s_editrange, s_pickinfo.pickobjno,
							0,
							s_ikcustomrig, s_pickinfo.buttonflag);
						ChaMatrix tmpwm = s_model->GetWorldMat();
						s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
						s_model->RigControlPostRig(g_limitdegflag,
							0, &s_editrange, s_pickinfo.pickobjno,
							1,
							s_ikcustomrig, s_pickinfo.buttonflag);
						tmpwm = s_model->GetWorldMat();
						s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
						s_editmotionflag = s_curboneno;

						if (oldcursor != NULL) {
							SetCursor(oldcursor);
						}
						ikdoneflag = true;
					}
				}
			}
		}
		else {
			if ((s_undoFlag == false) && (s_redoFlag == false)) {
				//if (((s_ikkind == 0) || (s_ikkind == 1) || (s_ikkind == 2)) && (s_editcameraflag >= 0)) {//2024/06/16 ドリー編集も対象に
				if (s_cameramodel && (s_cameraeditkind > CAMERAANIMEDIT_NONE) && (editmotionflag >= 0)) {//2024/08/05 s_cameraeditkind : OnCameraAnimMouseMove()呼び出し時のopekind
					ikdoneflag = true;
				}
			}
		}


		//g_underIKRot = false;
		s_model->SetUnderIKRot(false);


		s_wmlbuttonup = 1;//ゲームパッド用フラグ

		s_befdeltax = 0.0f;

		if (s_model && (s_onragdollik != 0)) {
			//s_model->BulletSimulationStop();
			//s_model->SetBtKinFlagReq(s_model->GetTopBt(), 1);
			s_model->BulletSimulationStop();
			g_previewFlag = 0;
			s_model->ApplyPhysIkRec(g_limitdegflag);
		}



		HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));


		//2023/08/09
		//自動フィルターは選択フレーム数が少ないときに動かなくなる　また　他の制限を満たしているジョイントの角度まで小さくなる
		//よって　自動フィルターは止めてみる　手動でSmoothボタンを押すことに
		//
		//2023/02/13
		//IKRot終了時　LimitEulオンで　編集ボーンがあった場合
		//グラフが波打つことは分かっているので(XYZどれか１つでも制限に掛かると　XYZ全て動かなくなるため)
		//自動で　フィルターを掛けて　滑らかにする
		//if ((((s_ikkind == 0) || (s_ikkind == 1)) || ((s_oprigflag != 0) && s_customrigbone)) &&
		//	(g_limitdegflag == true) && 
		//	(s_editmotionflag >= 0) &&
		//	(ikframenum >= 14)) {
		//	//ギザギザを平滑化
		//	bool copylw2w = false;
		//	FilterNoDlg(copylw2w);
		//}


		if ((s_undoFlag == false) && (s_redoFlag == false)) {

			//2023//11/06 CopyLimitedWorldToWorldよりも後ろに移動
			//if (s_model && ikdoneflag) {
			//	//############################################################################################################
			//	//2023/10/16 - 2023/10/19
			//	//マルチスレッドのコンテクストを　揃っている情報と要求される計算順序によって決めた
			//	//親のボーンの姿勢を使う階層順の計算では　フレーム番号単位のマルチスレッド
			//	//全ボーンの姿勢が揃った後で　前のフレームの姿勢を元にオイラー角を計算する際には　ボーンごとのマルチスレッド
			//	// 
			//	//befeul.currentframeeulでオイラーは　フレーム番号ごとのマルチスレッドで計算されている状態
			//	// ！！！！！　g_underIKRot = falseとした後で　！！！！！
			//	//後処理として　befeul.befframeeulで　ボーンごとのマルチスレッドで計算して正しいオイラーにする
			//	//############################################################################################################
			//	MOTINFO* curmi = s_model->GetCurMotInfo();
			//	if (curmi) {
			//		s_model->CalcBoneEul(g_limitdegflag, curmi->motid);
			//	}
			//}

			//2023/02/04
			//LimitEulにチェックを入れて編集したモーション部分を　角度制限無しの姿勢にベイクする
			//if ((g_limitdegflag == true) && (s_editmotionflag >= 0)) {
			if ((g_limitdegflag == true) && ikdoneflag && (g_edittarget != EDITTARGET_CAMERA)) {
				bool allframeflag = false;
				bool setcursorflag = true;
				bool onpasteflag = false;


				//CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, s_editmotionflag, onpasteflag);

				//2023/03/04
				//rigの場合や　IKTargetの場合があるので　operatingjointnoはTopBoneの番号
				CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag,
					s_model->GetTopBone(false)->GetBoneNo(), onpasteflag);
			}

			//if (s_cameramodel && (g_edittarget == EDITTARGET_CAMERA) && ikdoneflag) {
			//	s_cameramodel->CalcBoneEul(g_limitdegflag, s_cameramodel->GetCameraMotionId());
			//}
			//2023//11/06 CopyLimitedWorldToWorldよりも後ろに移動
			//else 
			if (s_model && ikdoneflag) {
				//############################################################################################################
				//2023/10/16 - 2023/10/19
				//マルチスレッドのコンテクストを　揃っている情報と要求される計算順序によって決めた
				//親のボーンの姿勢を使う階層順の計算では　フレーム番号単位のマルチスレッド
				//全ボーンの姿勢が揃った後で　前のフレームの姿勢を元にオイラー角を計算する際には　ボーンごとのマルチスレッド
				// 
				//befeul.currentframeeulでオイラーは　フレーム番号ごとのマルチスレッドで計算されている状態
				// ！！！！！　g_underIKRot = falseとした後で　！！！！！
				//後処理として　befeul.befframeeulで　ボーンごとのマルチスレッドで計算して正しいオイラーにする
				//############################################################################################################
				if (s_model->ExistCurrentMotion()) {
					if (g_edittarget != EDITTARGET_CAMERA) {
						s_model->CalcBoneEul(g_limitdegflag, s_model->GetCurrentMotID());
					}
					else if (s_cameramodel) {
						s_cameramodel->CalcBoneEul(false, s_cameramodel->GetCameraMotionId());
					}
				}
			}



			UpdateEditedEuler();
			//refreshEulerGraph();

			//2024/07/09 場所移動　undoFlag, redoFlagによらずに実行するべき
			//if (oldcursor != NULL) {
			//	SetCursor(oldcursor);
			//}
			//s_pickinfo.buttonflag = 0;
			//s_ikcnt = 0;
			//s_onragdollik = 0;

			//if ((s_editmotionflag >= 0) || (g_btsimurecflag == true)) {
			if (ikdoneflag || (g_btsimurecflag == true)) {
				PrepairUndo();//３Dウインドウでの編集後状態保存を想定		
			}

		}


		if (oldcursor != NULL) {
			SetCursor(oldcursor);
		}
		s_pickinfo.buttonflag = 0;
		s_ikcnt = 0;
		s_onragdollik = 0;


		//s_cameraeditkind = CAMERAANIMEDIT_NONE;//コメントアウト：グラフ表示を保持するために初期化しない

		//else {//2024/06/18 OnFrameToolWnd()に移動
		//	s_pickinfo.buttonflag = 0;
		//	s_ikcnt = 0;
		//	s_onragdollik = 0;
		//
		//	OnSpriteUndo();
		//}

	}
	else if (uMsg == WM_RBUTTONDOWN) {

		if (UnderDragOperation_L()) {
			s_cancelRButtonDown = true;
			return 0;
		}

		//s_cameraeditkind = CAMERAANIMEDIT_NONE;//コメントアウト：グラフ表示を保持するために初期化しない


		//SetCapture(DXUTGetHWND());
		SetCapture(s_3dwnd);

		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);

		s_pickinfo.clickpos = ptCursor;
		s_pickinfo.mousepos = ptCursor;
		s_pickinfo.mousebefpos = ptCursor;
		s_pickinfo.diffmouse.SetParams(0.0f, 0.0f);
		s_pickinfo.firstdiff.SetParams(0.0f, 0.0f);

		//s_pickinfo.winx = (int)DXUTGetWindowWidth();
		//s_pickinfo.winy = (int)DXUTGetWindowHeight();
		s_pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
		s_pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
		s_pickinfo.pickrange = PICKRANGE;

		s_pickinfo.pickobjno = -1;

		bool doneflag = false;



		//プレビュー中もカメラ操作は可能にする
		if (doneflag == false) {
			//カメラの回転を右ドラッグした場合は　OnMouseMoveFunc()にて　カメラのupvecをツイストする
			if (PickSpCam(ptCursor) == PICK_CAMROT) {
				if (s_twistcameraFlag == false) {
					s_twistcameraFlag = true;
				}
				doneflag = true;
			}
		}

		if (g_previewFlag == 0) {//2024/02/06
			if (s_skey) {
				//マニピュレータユーザー倍率
				//Sキーが押されているRDragは　ジョイント選択時も倍率設定
				if (doneflag == false) {
					if (s_rbuttonSelectFlag == false) {
						s_rbuttonSelectFlag = true;
					}
					doneflag = true;
				}
			}
			else if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {

				if (PickSpSmooth(ptCursor) != 0) {
					//SmoothSpriteButton上で右クリックした場合は　Smooth用のメニューを出す
					//SmoothSpriteButton上で左クリックした場合には　前回のSmooth設定にてSmoothをすぐに実行
					FilterFromTool();
					doneflag = true;
				}

				if (doneflag == false) {
					//ペーストスプライトボタン右クリック：操作対象ボーン設定ダイアログを出した後にペースト処理
					if (PickSpPaste(ptCursor) != 0) {
						if (s_model) {
							if ((s_selboneFlag == false) && (s_selboneAndPasteFlag == false)) {
								s_selboneFlag = true;
								s_selboneAndPasteFlag = true;
								doneflag = true;
							}
						}
					}
				}


				if (doneflag == false) {
					//スプライトボタンクリック時には　ボーン右クリック用のメニューを出さないように
					doneflag = IsClickedSpriteButton();
				}
			}

			int pickboneorrig = 0;
			if (doneflag == false) {
				//ボーン右クリック用のメニュー
				pickboneorrig = BoneRClick(-1);
				if (pickboneorrig != 0) {
					doneflag = true;
				}
			}

			if (doneflag == false) {
				BrushesContextMenu();
				doneflag = true;
			}


		}
	}
	else if (uMsg == WM_RBUTTONDBLCLK) {
		//右ボタン　ダブルクリック

		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);

		//カメラの回転を　右ダブルクリックした場合は　カメラのupvecを初期化する
		if (PickSpCam(ptCursor) == PICK_CAMROT) {
			g_cameraupdir.SetParams(0.0f, 1.0f, 0.0f);

			//////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
			////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
			////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();
			g_befcamEye = g_camEye;
			ChaVector3 diffv;
			diffv = g_camEye - g_camtargetpos;
			g_camdist = (float)ChaVector3LengthDbl(&diffv);
		}
	}
	else if (uMsg == WM_RBUTTONUP) {
		if (s_cancelRButtonDown) {
			s_cancelRButtonDown = false;
			return 0;
		}

		ReleaseCapture();
		
		s_pickinfo.buttonflag = 0;
		s_twistcameraFlag = false;
		s_rbuttonSelectFlag = false;
	}
	else if (uMsg == WM_MBUTTONUP) {
		//ReleaseCapture();
		s_pickinfo.buttonflag = 0;
	}
	else if (uMsg == WM_DESTROY) {
		//ここでOnDestroyDevice()を呼ぶと　何回もOnDestroyDevice()が呼ばれる
		//WM_QUITでメッセージループを抜けて　ループを出たところでOnDestroyDevice()を呼ぶ
		PostQuitMessage(0);
		return 0;
	}
	else if (uMsg == WM_ACTIVATE) {
		if (wParam == 1) {
			DbgOut(L"%f, activate wparam 1\r\n", s_time);
			ActivatePanel(1);
		}
	}
	else if (uMsg == WM_SYSCOMMAND) {
		switch (wParam) {
		case SC_CLOSE:
			DbgOut(L"%f, syscommand close\r\n", s_time);
			break;
		case SC_MINIMIZE:
			DbgOut(L"%f, syscommand minimize\r\n", s_time);
			ActivatePanel(0);
			break;
		case SC_MAXIMIZE:
			DbgOut(L"%f, syscommand maximize\r\n", s_time);
			DefWindowProc(s_3dwnd, uMsg, wParam, lParam);
			ActivatePanel(1);
			//return 1;//!!!!!!!!!!!!!
			break;
		}
	}
	else {
		return DefWindowProc(hWnd, uMsg, wParam, lParam);
	}

	/*
	if( uMsg == WM_LBUTTONDOWN ){
		//#replacing comment out#g_Camera->HandleMessages( hWnd, WM_RBUTTONDOWN, wParam, lParam );
		if( s_ikkind == 2 ){
			g_LightControl[g_nActiveLight].HandleMessages( hWnd, WM_RBUTTONDOWN, wParam, lParam );
		}
	}else if( uMsg == WM_LBUTTONDBLCLK ){
	}else if( uMsg == WM_LBUTTONUP ){
		//#replacing comment out#g_Camera->HandleMessages( hWnd, WM_RBUTTONUP, wParam, lParam );
		if( s_ikkind == 2 ){
			g_LightControl[g_nActiveLight].HandleMessages( hWnd, WM_RBUTTONUP, wParam, lParam );
		}
	}else if( uMsg == WM_RBUTTONDOWN ){
	}else if( uMsg == WM_RBUTTONUP ){
	}else if( uMsg == WM_RBUTTONDBLCLK ){
	}else if( uMsg == WM_MBUTTONDOWN ){
	}else if( uMsg == WM_MBUTTONUP ){
	}else if( uMsg == WM_MOUSEWHEEL ){
		//if( (g_keybuf[VK_CONTROL] & 0x80) == 0 ){
		//	float mdelta = (float)GET_WHEEL_DELTA_WPARAM(wParam);
		//	//deltadist = mdelta * g_camdist * 0.00010f;
		//	deltadist = mdelta * g_camdist * 0.0010f;
		//
		//	g_camdist += deltadist;
		//	if( g_camdist < 0.0001f ){
		//		g_camdist = 0.0001f;
		//	}
		//
		//	ChaVector3 camvec = g_camEye - g_camtargetpos;
		//	ChaVector3Normalize( &camvec, &camvec );
		//	g_camEye = g_camtargetpos + g_camdist * camvec;
		//	ChaMatrixLookAtRH( &s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec );
		//}
	}else{
		//#replacing comment out#g_Camera->HandleMessages( hWnd, uMsg, wParam, lParam );
		if( s_ikkind == 2 ){
			g_LightControl[g_nActiveLight].HandleMessages( hWnd, uMsg, wParam, lParam );
		}
	}
	*/




	//if ((s_doneinit == 1) && (g_undertrackingRMenu == 1)) {
	//	OnDSUpdate();
	//}


	return 0;
}


//--------------------------------------------------------------------------------------
// As a convenience, DXUT inspects the incoming windows messages for
// keystroke messages and decodes the message parameters to pass relevant keyboard
// messages to the application.  The framework does not remove the underlying keystroke 
// messages, which are still passed to the application's MsgProc callback.
//--------------------------------------------------------------------------------------
//void CALLBACK KeyboardProc( UINT nChar, bool bKeyDown, bool bAltDown, void* pUserContext )
void CALLBACK OnKeyboard(UINT nChar, bool bKeyDown, bool bAltDown, void* pUserContext)
{
	if (bKeyDown)
	{
		switch (nChar)
		{
		case VK_F1:
			g_bShowHelp = !g_bShowHelp; break;
		}
	}
}

int RollbackCurBoneNo()
{
	if ((s_curboneno < 0) && (s_saveboneno >= 0)) {
		s_curboneno = s_saveboneno;
		//if (s_model) {
		//	s_model->SetSelectedBoneNo(s_curboneno);
		//}
		if (s_owpTimeline) {
			//2024/04/24
			s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], false);
		}
	}
	return 0;
}

int DestroyTimeLine(int dellist)
{
	if (dellist) {
		EraseKeyList();
	}

	s_tlarray.clear();

	if (s_parentcheck) {
		delete s_parentcheck;
		s_parentcheck = 0;
	}

	return 0;
}

int GetShaderHandle()
{
	//if (!g_pEffect) {
	//	_ASSERT(0);
	//	return 1;
	//}

	//g_hRenderBoneL0 = g_pEffect->GetTechniqueByName("RenderBoneL0");
	//_ASSERT(g_hRenderBoneL0);
	//g_hRenderBoneL1 = g_pEffect->GetTechniqueByName("RenderBoneL1");
	//_ASSERT(g_hRenderBoneL1);
	//g_hRenderBoneL2 = g_pEffect->GetTechniqueByName("RenderBoneL2");
	//_ASSERT(g_hRenderBoneL2);
	//g_hRenderBoneL3 = g_pEffect->GetTechniqueByName("RenderBoneL3");
	//_ASSERT(g_hRenderBoneL3);
	//g_hRenderBoneL4 = g_pEffect->GetTechniqueByName("RenderBoneL4");
	//_ASSERT(g_hRenderBoneL4);
	//g_hRenderBoneL5 = g_pEffect->GetTechniqueByName("RenderBoneL5");
	//_ASSERT(g_hRenderBoneL5);
	//g_hRenderBoneL6 = g_pEffect->GetTechniqueByName("RenderBoneL6");
	//_ASSERT(g_hRenderBoneL6);
	//g_hRenderBoneL7 = g_pEffect->GetTechniqueByName("RenderBoneL7");
	//_ASSERT(g_hRenderBoneL7);
	//g_hRenderBoneL8 = g_pEffect->GetTechniqueByName("RenderBoneL8");
	//_ASSERT(g_hRenderBoneL8);

	//g_hRenderNoBoneL0 = g_pEffect->GetTechniqueByName("RenderNoBoneL0");
	//_ASSERT(g_hRenderNoBoneL0);
	//g_hRenderNoBoneL1 = g_pEffect->GetTechniqueByName("RenderNoBoneL1");
	//_ASSERT(g_hRenderNoBoneL1);
	//g_hRenderNoBoneL2 = g_pEffect->GetTechniqueByName("RenderNoBoneL2");
	//_ASSERT(g_hRenderNoBoneL2);
	//g_hRenderNoBoneL3 = g_pEffect->GetTechniqueByName("RenderNoBoneL3");
	//_ASSERT(g_hRenderNoBoneL3);
	//g_hRenderNoBoneL4 = g_pEffect->GetTechniqueByName("RenderNoBoneL4");
	//_ASSERT(g_hRenderNoBoneL4);
	//g_hRenderNoBoneL5 = g_pEffect->GetTechniqueByName("RenderNoBoneL5");
	//_ASSERT(g_hRenderNoBoneL5);
	//g_hRenderNoBoneL6 = g_pEffect->GetTechniqueByName("RenderNoBoneL6");
	//_ASSERT(g_hRenderNoBoneL6);
	//g_hRenderNoBoneL7 = g_pEffect->GetTechniqueByName("RenderNoBoneL7");
	//_ASSERT(g_hRenderNoBoneL7);
	//g_hRenderNoBoneL8 = g_pEffect->GetTechniqueByName("RenderNoBoneL8");
	//_ASSERT(g_hRenderNoBoneL8);

	//g_hRenderLine = g_pEffect->GetTechniqueByName("RenderLine");
	//_ASSERT(g_hRenderLine);
	//g_hRenderSprite = g_pEffect->GetTechniqueByName("RenderSprite");
	//_ASSERT(g_hRenderSprite);



	//g_hm4x4Mat = g_pEffect->GetVariableByName("g_m4x4Mat")->AsMatrix();
	//_ASSERT(g_hm4x4Mat);
	//g_hmWorld = g_pEffect->GetVariableByName("g_mWorld")->AsMatrix();
	//_ASSERT(g_hmWorld);
	//g_hmVP = g_pEffect->GetVariableByName("g_mVP")->AsMatrix();
	//_ASSERT(g_hmVP);
	//g_hEyePos = g_pEffect->GetVariableByName("g_EyePos")->AsVector();
	//_ASSERT(g_hEyePos);


	////	g_hnNumLight = g_pEffect->GetVariableByName("g_nNumLights" );
	////	_ASSERT( g_hnNumLight );
	//g_hLightDir = g_pEffect->GetVariableByName("g_LightDir")->AsVector();
	//_ASSERT(g_hLightDir);
	//g_hLightDiffuse = g_pEffect->GetVariableByName("g_LightDiffuse")->AsVector();
	//_ASSERT(g_hLightDiffuse);
	////	g_hLightAmbient = g_pEffect->GetVariableByName("g_LightAmbient" );
	////	_ASSERT( g_hLightAmbient );
	//g_hSpriteOffset = g_pEffect->GetVariableByName("g_spriteoffset")->AsVector();
	//_ASSERT(g_hSpriteOffset);
	//g_hSpriteScale = g_pEffect->GetVariableByName("g_spritescale")->AsVector();
	//_ASSERT(g_hSpriteScale);

	//g_hPm3Offset = g_pEffect->GetVariableByName("g_pm3offset")->AsVector();
	//_ASSERT(g_hPm3Offset);
	//g_hPm3Scale = g_pEffect->GetVariableByName("g_pm3scale")->AsVector();
	//_ASSERT(g_hPm3Scale);

	//g_hdiffuse = g_pEffect->GetVariableByName("g_diffuse")->AsVector();
	//_ASSERT(g_hdiffuse);
	//g_hambient = g_pEffect->GetVariableByName("g_ambient")->AsVector();
	//_ASSERT(g_hambient);
	//g_hspecular = g_pEffect->GetVariableByName("g_specular")->AsVector();
	//_ASSERT(g_hspecular);
	//g_hpower = g_pEffect->GetVariableByName("g_power")->AsScalar();
	//_ASSERT(g_hpower);
	//g_hemissive = g_pEffect->GetVariableByName("g_emissive")->AsVector();
	//_ASSERT(g_hemissive);
	//g_hMeshTexture = g_pEffect->GetVariableByName("g_MeshTexture")->AsShaderResource();
	//_ASSERT(g_hMeshTexture);


	///*
	//// Obtain variables
	//g_ptxDiffuse = g_pEffect10->GetVariableByName("g_MeshTexture")->AsShaderResource();
	//g_pLightDir = g_pEffect10->GetVariableByName("g_LightDir")->AsVector();
	//g_pLightDiffuse = g_pEffect10->GetVariableByName("g_LightDiffuse")->AsVector();
	//g_pmWorldViewProjection = g_pEffect10->GetVariableByName("g_mWorldViewProjection")->AsMatrix();
	//g_pmWorld = g_pEffect10->GetVariableByName("g_mWorld")->AsMatrix();
	//g_pfTime = g_pEffect10->GetVariableByName("g_fTime")->AsScalar();
	//g_pMaterialAmbientColor = g_pEffect10->GetVariableByName("g_MaterialAmbientColor")->AsVector();
	//g_pMaterialDiffuseColor = g_pEffect10->GetVariableByName("g_MaterialDiffuseColor")->AsVector();
	//g_pnNumLights = g_pEffect10->GetVariableByName("g_nNumLights")->AsScalar();

	//// Create our vertex input layout
	//const D3D11_INPUT_ELEMENT_DESC layout[] =
	//{
	//{ "POSITION",  0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
	//{ "NORMAL",    0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	//{ "TEXCOORD",  0, DXGI_FORMAT_R32G32_FLOAT,    0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	//};

	//D3DX11_PASS_DESC PassDesc;
	//V_RETURN(g_pTechRenderSceneWithTexture1Light->GetPassByIndex(0)->GetDesc(&PassDesc));
	//V_RETURN(pd3dDevice->CreateInputLayout(layout, 3, PassDesc.pIAInputSignature,
	//PassDesc.IAInputSignatureSize, &g_pVertexLayout));

	//// Load the mesh
	//V_RETURN(g_Mesh10.Create(pd3dDevice, L"tiny\\tiny.sdkmesh", true));

	//// Set effect variables as needed
	//D3DXCOLOR colorMtrlDiffuse(1.0f, 1.0f, 1.0f, 1.0f);
	//D3DXCOLOR colorMtrlAmbient(0.35f, 0.35f, 0.35f, 0);
	//V_RETURN(g_pMaterialAmbientColor->SetFloatVector((float*)&colorMtrlAmbient));
	//V_RETURN(g_pMaterialDiffuseColor->SetFloatVector((float*)&colorMtrlDiffuse));

	//*/

	return 0;
}

int SetBaseDir()
{
	WCHAR filename[MAX_PATH] = { 0 };
	WCHAR* endptr = 0;

	int ret;
	ret = GetModuleFileNameW(NULL, filename, MAX_PATH);
	if (ret == 0) {
		_ASSERT(0);
		return 1;
	}


	WCHAR* lasten = NULL;
	lasten = wcsrchr(filename, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		DbgOut(L"SetMediaDir : strrchr error !!!\n");
		return 1;
	}

	//*.exeの頭
	*lasten = 0;

	WCHAR* last2en = 0;
	WCHAR* last3en = 0;
	WCHAR* last4en = 0;
	last2en = wcsrchr(filename, TEXT('\\'));//Release, Debugの頭の円かどうか調べる
	if (last2en) {
		*last2en = 0;
		last3en = wcsrchr(filename, TEXT('\\'));//Release, Debugかどうか調べるフォルダの前にフォルダがあるかどうか
		if (last3en) {
			if ((wcscmp(last2en + 1, L"debug") == 0) ||
				(wcscmp(last2en + 1, L"Debug") == 0) ||
				(wcscmp(last2en + 1, L"DEBUG") == 0) ||
				(wcscmp(last2en + 1, L"release") == 0) ||
				(wcscmp(last2en + 1, L"Release") == 0) ||
				(wcscmp(last2en + 1, L"RELEASE") == 0)
				) {

				*last3en = 0;
				last4en = wcsrchr(filename, TEXT('\\'));//x64かどうか調べるフォルダの前にフォルダがあるかどうか
				if (last4en) {
					if (wcscmp(last3en + 1, L"x64") != 0) {
						*last3en = TEXT('\\');
					}
				}
			}
			else {
				*last2en = TEXT('\\');
			}
		}
	}

	size_t leng;
	ZeroMemory(g_basedir, sizeof(WCHAR) * MAX_PATH);
	wcscpy_s(g_basedir, MAX_PATH, filename);
	g_basedir[MAX_PATH - 1] = 0L;
	leng = wcslen(g_basedir);
	if ((leng >= 1) && (leng <= (MAX_PATH - 2))) {//１文字追加分を考慮
		if (wcscmp(g_basedir + leng - 1, L"\\") != 0) {
			wcscat_s(g_basedir, MAX_PATH, L"\\");
		}
	}
	else {
		_ASSERT(0);
	}
	DbgOut(L"SetBaseDir : %s\r\n", g_basedir);

	return 0;
}


int OpenMNLFile()
{
	if (!s_model) {
		return 0;
	}

	if (g_tmpmqopath[0] == 0L) {
		return 0;
	}

	CMNLFile mnlfile;
	CallF(mnlfile.LoadMNLFile(g_tmpmqopath, s_model), return 1);

	CallF(OnAnimMenu(true, 0), return 1);

	return 0;
}


int OpenGcoFile()
{
	if (!s_bpWorld) {
		return 0;
	}
	if (!s_gplane) {
		return 0;
	}

	if (g_tmpmqopath[0] == 0L) {
		return 0;
	}

	CGColiFile gcofile;
	CallF(gcofile.LoadGColiFile(s_gplane, g_tmpmqopath, s_bpWorld), return 1);

	s_bpWorld->RemakeG();
	ChaVector3 tra(0.0f, 0.0f, 0.0f);
	ChaVector3 mult(s_bpWorld->m_gplanesize.x, 1.0f, s_bpWorld->m_gplanesize.y);
	CallF(s_gplane->MultDispObj(mult, tra), return 1);

	return 0;
}


int OpenImpFile()
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	if (g_tmpmqopath[0] == 0L) {
		return 0;
	}

	CImpFile impfile;
	CallF(impfile.LoadImpFile(g_tmpmqopath, s_model), return 1);

	int impnum = s_model->GetImpInfoSize();
	if (impnum > 0) {
		OnImpMenu(impnum - 1);
	}
	else {
		OnImpMenu(-1);
	}

	return 0;
}


int OpenREFile()
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	if (g_tmpmqopath[0] == 0L) {
		return 0;
	}

	if (s_model->GetRigidElemInfoSize() >= (MAXRENUM - 1)) {
		::DSMessageBox(s_3dwnd, L"Overflow Loading(Limit under 99 files)", L"warning!!!", MB_OK);
		return 0;
	}

	CRigidElemFile refile;
	CallF(refile.LoadRigidElemFile(g_tmpmqopath, s_model), return 1);


	int renum = s_model->GetRigidElemInfoSize();
	if (renum > 0) {

		//RgidElemFileのLoad時にしている
		//if (s_model && (renum == 1)) {//初回のref読み込み後にRigidElemを作成
		//	int chkret;
		//	chkret = s_model->CreateRigidElem();
		//	_ASSERT(!chkret);
		//}

		OnREMenu(renum - 1, 0);
		OnRgdMenu(renum - 1, 0);
	}
	else {
		OnREMenu(-1, 0);
		OnRgdMenu(-1, 0);
	}

	return 0;
}

int SaveGcoFile()
{
	if (!s_bpWorld) {
		return 0;
	}

	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SAVEGCODLG),
		s_3dwnd, (DLGPROC)SaveGcoDlgProc);
	if ((dlgret != IDOK) || !s_Gconame[0]) {
		return 0;
	}

	CGColiFile gcofile;
	CallF(gcofile.WriteGColiFile(s_Gconame, s_bpWorld), return 1);

	return 0;


}

int SaveImpFile()
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}
	if (s_rgdindexmap[s_model] < 0) {
		::DSMessageBox(s_3dwnd, L"Save Only RagdollImpulse.\nRetry after Setting of Ragdoll", L"error!!!", MB_OK);
		return 0;
	}


	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SAVEIMPDLG),
		s_3dwnd, (DLGPROC)SaveImpDlgProc);
	if ((dlgret != IDOK) || !s_Impname[0]) {
		return 0;
	}

	CImpFile impfile;
	CallF(impfile.WriteImpFile(s_Impname, s_model), return 1);

	int impnum = s_model->GetImpInfoSize();
	if (impnum > 0) {
		OnImpMenu(impnum - 1);
	}
	else {
		OnImpMenu(-1);
	}

	return 0;


}

int SaveREFile()
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SAVEREDLG),
		s_3dwnd, (DLGPROC)SaveREDlgProc);
	if ((dlgret != IDOK) || !s_REname[0]) {
		return 0;
	}

	CRigidElemFile refile;
	CallF(refile.WriteRigidElemFile(s_REname, s_model, s_model->GetCurReIndex()), return 1);

	return 0;
}


void FindF(std::vector<wstring>& out, const wstring& directory, const wstring& findext)
{
	HANDLE dir;
	WIN32_FIND_DATA fileData;

	if ((dir = FindFirstFile((directory + L"/*").c_str(), &fileData)) == INVALID_HANDLE_VALUE)
	{
		return; /* No files found */
	}

	do
	{
		const wstring fileName = fileData.cFileName;
		const wstring fullFileName = directory + L"\\" + fileName;
		const bool isDirectory = (fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

		if (fileName[0] == L'.')
			continue;

		if (!isDirectory)
		{
			//WCHAR pattern[20] = L".bvh";
			//WCHAR npattern[20] = L".bvh.";
			WCHAR pattern[20] = { 0L };
			WCHAR wpath[MAX_PATH] = { 0L };
			wcscpy_s(pattern, 20, findext.c_str());
			wcscpy_s(wpath, MAX_PATH, fullFileName.c_str());

			const WCHAR* pfind;
			pfind = wcsstr(wpath, pattern);
			if (pfind) {
				wpath[MAX_PATH - 1] = 0L;
				pattern[20 - 1] = 0L;
				size_t pathleng = wcslen(wpath);
				size_t patternleng = wcslen(pattern);
				if ((patternleng > 0) && (pathleng > 0) && (pathleng < MAX_PATH) && (pathleng > patternleng)) {
					WCHAR chkterm = *(pfind + patternleng);
					if (chkterm == 0L) {//patternの次の文字がNULLの場合
						out.push_back(fullFileName);
					}
				}
				else {
					_ASSERT(0);
				}
			}
		}
		else
		{
			FindF(out, fullFileName, findext);
		}

	} while (FindNextFile(dir, &fileData));

	FindClose(dir);

	return;
}


int CALLBACK BrowseCallbackProc(HWND   hWnd, UINT   uMsg, LPARAM lParam, LPARAM lpData)
{
	WCHAR firstdir[MAX_PATH] = { 0L };

	switch (uMsg) {

		// 初期ディレクトリの設定
	case BFFM_INITIALIZED:
		firstdir[0] = 0L;
		GetBatchHistoryDir(firstdir, MAX_PATH);
		if (firstdir[0] != 0L) {
			SendMessage(hWnd, BFFM_SETSELECTION, (WPARAM)TRUE, (LPARAM)firstdir);
			SendMessage(hWnd, BFFM_SETEXPANDED, (WPARAM)TRUE, (LPARAM)firstdir);
		}
		else {
			// ドキュメントが初期フォルダ
			if (lpData) {
				SendMessage(hWnd, BFFM_SETSELECTION, (WPARAM)TRUE, (LPARAM)lpData);
				SendMessage(hWnd, BFFM_SETEXPANDED, (WPARAM)TRUE, (LPARAM)lpData);
			}
		}
		//初期フォルダ（ドキュメント）を展開
		//SendMessage(hWnd, BFFM_SETEXPANDED, (WPARAM)TRUE, (LPARAM)lpData);
		break;

		// 無効なフォルダ名を入力された場合
	case BFFM_VALIDATEFAILED:
		MessageBox(NULL, L"無効なフォルダ名です", L"", MB_OK);
		return TRUE;
	}
	return FALSE;
}


//########### retarget batch　ここから

int RetargetFile(char* fbxpath)
{
	//RenderContext* pRenderContext = DXUTGetD3D11DeviceContext();

	char directorypath[MAX_PATH] = { 0 };
	ZeroMemory(directorypath, sizeof(char) * MAX_PATH);
	char* pfind;
	pfind = strrchr(fbxpath, '\\');
	if (pfind) {

		if (s_chascene && (s_chascene->GetModelNum() > 0)) {
			//OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
			bool forceflag = true;
			bool callundo = false;
			OnChangeModel(s_chascene->GetModelNum() - 1, forceflag, callundo);
		}

		unsigned int dirpathlen;
		dirpathlen = (unsigned int)(pfind - fbxpath + 1);
		strncpy_s(directorypath, MAX_PATH, fbxpath, dirpathlen);

		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, fbxpath, MAX_PATH, g_tmpmqopath, MAX_PATH);
		CModel* newmodel = 0;
		std::vector<std::string> ikstopname;
		ikstopname.clear();
		bool grassflag = false;
		newmodel = OpenFBXFile(false, false, 0, 1, ikstopname, grassflag);
		if (newmodel) {
			//s_model = s_convbone_model_batch;


			if(s_smoothBefRetarget && newmodel->ExistCurrentMotion()){
				//##############################################################################
				//2023/10/12 retarget前にsmoothするオプション RetargetBatch()のダイアログで選択
				//ノイズによって　180度裏返り機能の閾値を越えないようにする
				//##############################################################################
				s_model = newmodel;
				MOTINFO curmi = newmodel->GetCurMotInfo();
				if (curmi.motid > 0) {
					int saveFilterState = s_filterState;
					double savestart = s_buttonselectstart;
					double saveend = s_buttonselectend;

					s_filterState = 1;
					s_buttonselectstart = 1.0;
					s_buttonselectend = curmi.frameleng - 1.0;

					FilterNoDlg(false, s_model, curmi.motid);

					s_filterState = saveFilterState;
					s_buttonselectstart = savestart;
					s_buttonselectend = saveend;
				}


			}


			//OnModelMenu(false, s_convbone_model_batch_selindex, 1);
			bool forceflag = true;//2024/06/26 各ダイアログ作成のためにforceflag必要
			bool callundo = false;
			//OnChangeModel(s_convbone_model_batch_selindex, forceflag, callundo);
			OnChangeModel(s_convbone_model_batch, forceflag, callundo);

			s_model = s_convbone_model_batch;
			s_retargetdlg.SetModel(s_convbone_model_batch);
			s_retargetdlg.SetRetargetBvh(newmodel);
			////s_maxboneno = s_convbone_bvh->GetBoneListSize();
			////s_maxboneno = s_convbone_bvh->GetBoneForMotionSize();
			//s_maxboneno = s_convbone_bvh->GetMaxBoneNo();

			if (s_model && s_retargetdlg.GetRetargetModel() && s_retargetdlg.GetRetargetBvh()) {
				WCHAR wretargetfilename[MAX_PATH] = { 0L };
				char retargetfilename[MAX_PATH] = { 0 };
				sprintf_s(retargetfilename, MAX_PATH, "%sretarget.rtg", directorypath);
				MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, retargetfilename, MAX_PATH, wretargetfilename, MAX_PATH);

				int result1;
				result1 = LoadRetargetFile(wretargetfilename);
				if (result1 == 0) {
					int result2;
					result2 = RetargetMotion();
					if (result2 != 0) {
						_ASSERT(0);
					}
				}

				//if (s_convbone_model_batch && s_convbone_model_batch->GetCurMotInfo()) {
				//	int motid = s_convbone_model_batch->GetCurMotInfo()->motid;
				//	double startframe = 1.0;
				//	double endframe = s_convbone_model_batch->GetCurMotInfo()->frameleng - 1.0;
				//	s_convbone_model->ModifyEuler360Req(g_limitdegflag, s_convbone_model->GetTopBone(false),
				//		motid, startframe, endframe);
				//}

				//int modelindex = (int)s_modelindex.size() - 1;
				//OnDelModel(modelindex);

			}
		}
	}
	return 0;
}


unsigned __stdcall ThreadFunc_Retarget(LPVOID lpThreadParam)
{

	int outnum = (int)s_retargetout.size();

	InterlockedExchange(&s_retargetnum, (LONG)outnum);
	InterlockedExchange(&s_retargetcnt, 0);
	InterlockedExchange(&s_befretargetnum, 0);
	InterlockedExchange(&s_befretargetcnt, 0);

	int outcnt;
	for (outcnt = 0; outcnt < outnum; outcnt++) {
		//FBXファイル
		char fbxpath[MAX_PATH] = { 0 };
		WideCharToMultiByte(CP_UTF8, 0, s_retargetout[outcnt].c_str(), -1, fbxpath, MAX_PATH, NULL, NULL);
		//strcat_s(fbxpath, MAX_PATH, ".fbx");

		int result;
		result = RetargetFile(fbxpath);
		if (result == 0) {
			InterlockedExchange(&s_retargetcnt, (LONG)outcnt);
		}
		else {
			//InterlockedExchange(&g_retargetbatchflag, 0);
			break;
		}

		//if (g_retargetbatchflag != 1) {
		if (InterlockedAdd(&g_retargetbatchflag, 0) != 1) {
			break;
		}
	}

	InterlockedExchange(&g_retargetbatchflag, (LONG)3);


	//#########################################
	//watch thread state at OnFrameBatchThread
	//#########################################


	return 0;
}


int RetargetBatch()
{
	if (!s_model) {
		_ASSERT(0);
		return 0;
	}


	if (InterlockedAdd(&g_retargetbatchflag, 0) != 0) {//if already under calc, return 0.
		return 0;
	}


	//2023/10/12
	int optionret;
	optionret = (int)::MessageBox(g_mainhwnd, L"リターゲット前にSmooth処理をしますか？\nDo you want to smooth before retargeting?\nN or Y.", L"Select Option", 
		MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2);
	if (optionret == IDYES) {
		s_smoothBefRetarget = true;
	}
	else {
		s_smoothBefRetarget = false;
	}



	s_limiteuldlg.SetSaveLimitDegFlag(g_limitdegflag);
	//ChangeLimitDegFlag(false, true, true);//2023/10/23 1.2.0.27_RC2にて　コメントアウト
	
	
	//g_limitdegflag = false;
	//if (s_LimitDegCheckBox) {
	//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
	//}


	//if (!s_convbone_model || !s_convbone_bvh) {
	//}
	//if (s_model != s_convbone_model) {
	//}

	s_convbone_model_batch = s_model;
	s_convbone_model_batch_selindex = s_curmodelmenuindex;


	s_saveretargetmodel = s_curmodelmenuindex;//終了時にOnModelMenuを呼ぶために保存


	BROWSEINFO bi;
	ZeroMemory(&bi, sizeof(BROWSEINFO));
	LPITEMIDLIST curlpidl = 0;
	WCHAR dispname[MAX_PATH] = { 0L };
	WCHAR selectname[MAX_PATH] = { 0L };
	int iImage = 0;

	//GetBatchHistoryDir(dispname, MAX_PATH);
	//if (selectname[0] != 0) {
	//	LPITEMIDLIST pidl;
	//	IMalloc* pMalloc;
	//	SHGetMalloc(&pMalloc);
	//	if (SUCCEEDED(SHGetSpecialFolderLocation(s_3dwnd, CSIDL_DESKTOPDIRECTORY, &pidl)))
	//	{
	//		// パスに変換する
	//		SHGetPathFromIDList(pidl, selectname);
	//		// 取得したIDLを解放する (CoTaskMemFreeでも可)
	//		pMalloc->Free(pidl);
	//		//SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
	//	}
	//	pMalloc->Release();
	//}

	bi.hwndOwner = s_3dwnd;
	bi.pidlRoot = NULL;//!!!!!!!
	bi.pszDisplayName = dispname;
	//bi.lpszTitle = L"保存フォルダを選択してください。";
	bi.lpszTitle = L"SelectDirectoryForBatch";
	//bi.ulFlags = BIF_EDITBOX | BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
	bi.ulFlags = BIF_RETURNONLYFSDIRS;// | BIF_NEWDIALOGSTYLE;//BIF_NEWDIALOGSTYLEを指定すると固まる　謎
	bi.lpfn = BrowseCallbackProc;
	bi.lParam = 0;
	bi.iImage = iImage;

	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

	curlpidl = SHBrowseForFolder(&bi);

	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	////UnhookWinEvent(hhook);
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;

	if (curlpidl) {
		//::DSMessageBox( m_hWnd, dispname, "フォルダー名", MB_OK );

		BOOL bret;
		bret = SHGetPathFromIDList(curlpidl, selectname);
		if (bret == FALSE) {
			_ASSERT(0);
			if (curlpidl)
				CoTaskMemFree(curlpidl);

			//ChangeLimitDegFlag(s_savelimitdegflag, true, true);//2023/10/23 1.2.0.27_RC2にて　コメントアウト


			//g_limitdegflag = s_savelimitdegflag;
			//if (s_LimitDegCheckBox) {
			//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
			//}

			return 1;
		}

		if (curlpidl)
			CoTaskMemFree(curlpidl);


		//selectname
		wstring target;
		string filenamepattern;
		//vector<wstring> out;
		wstring findext;

		s_retargetout.clear();
		target = selectname;
		findext = L".fbx";

		SaveBatchHistory(selectname);

		FindF(s_retargetout, target, findext);
		int outnum = (int)s_retargetout.size();
		InterlockedExchange(&s_retargetnum, (LONG)outnum);
		InterlockedExchange(&s_retargetcnt, 0);
		InterlockedExchange(&s_befretargetnum, 0);
		InterlockedExchange(&s_befretargetcnt, 0);

		if (outnum > 0)
		{
			InterlockedExchange(&g_retargetbatchflag, (LONG)1);

			CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_DIALOG2), NULL, (DLGPROC)RetargetBatchDlgProc);
			RECT rect;
			GetWindowRect(s_LtimelineWnd->getHWnd(), &rect);
			SetWindowPos(s_retargetbatchwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);
			ShowWindow(s_retargetbatchwnd, SW_SHOW);
			UpdateWindow(s_retargetbatchwnd);

			unsigned int threadaddr1 = 0;
			s_retargethandle1 = (HANDLE)_beginthreadex(
				NULL, 0, &ThreadFunc_Retarget,
				(void*)0,
				0, &threadaddr1);


			//WiatForしない場合には先に閉じてもOK
			if ((s_retargethandle1 != 0) && (s_retargethandle1 != INVALID_HANDLE_VALUE)) {
				CloseHandle(s_retargethandle1);
			}

		}
	}

	//InterlockedExchange(&g_retargetbatchflag, 0);//スレッドを立ててすぐに出ていくのでここではフラグはそのまま


	//ChangeLimitDegFlag(s_savelimitdegflag, true, true);//OnFrameBatchThread()で行うので　ここでは呼ばない


	return 0;
}


//########## retarget batch ここまで


unsigned __stdcall ThreadFunc_Bvh2Fbx(LPVOID lpThreadParam)
{
	int outnum = (int)s_bvh2fbxout.size();
	int outcnt;

	InterlockedExchange(&s_progressnum, (LONG)outnum);
	InterlockedExchange(&s_progresscnt, (LONG)0);
	if (s_bvh2fbxbatchwnd) {
		HWND hProg;
		hProg = GetDlgItem(s_bvh2fbxbatchwnd, IDC_PROGRESS1);
		if (hProg) {
			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, 100));
			SendMessage(hProg, PBM_SETPOS, (WPARAM)0, 0);
			UpdateWindow(s_bvh2fbxbatchwnd);
		}
	}


	for (outcnt = 0; outcnt < outnum; outcnt++) {

		InterlockedExchange(&s_progresscnt, (LONG)outcnt);

		//bvhファイルを読み込む
		CBVHFile* bvhfile = new CBVHFile();
		if (!bvhfile) {
			//g_bvh2fbxbatchflag = 0;
			break;
		}
		int ret;
		ret = bvhfile->LoadBVHFile(s_LtimelineWnd->getHWnd(), (wchar_t*)(s_bvh2fbxout[outcnt].c_str()), g_tmpmqomult);
		if (ret) {
			_ASSERT(0);
			if (bvhfile) {
				delete bvhfile;
				bvhfile = 0;
			}
			break;
		}

		//FBXファイルに書き出す
		char fbxpath[MAX_PATH] = { 0 };
		WideCharToMultiByte(CP_UTF8, 0, s_bvh2fbxout[outcnt].c_str(), -1, fbxpath, MAX_PATH, NULL, NULL);
		strcat_s(fbxpath, MAX_PATH, ".fbx");
		SYSTEMTIME localtime;
		GetLocalTime(&localtime);
		char fbxdate[MAX_PATH] = { 0L };
		sprintf_s(fbxdate, MAX_PATH, "CommentForEGP_%04u%02u%02u%02u%02u%02u",
			localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);

		int result;
		result = BVH2FBXFile(s_psdk, bvhfile, fbxpath, fbxdate);
		if (result == 0) {
			s_bvh2fbxcnt = outcnt;
		}
		else {
			if (bvhfile) {
				delete bvhfile;
				bvhfile = 0;
			}
			break;
		}

		if (bvhfile) {
			delete bvhfile;
			bvhfile = 0;
		}

		//if (g_bvh2fbxbatchflag != 1) {
		if (InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 1) {
			break;
		}
	}

	InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)3);

	//#########################################
	//watch thread state at OnFrameBatchThread
	//#########################################

	return 0;
}

//unsigned __stdcall ThreadFunc_Bvh2FbxDisp(LPVOID lpThreadParam)
//{
//
//	if (s_bvh2fbxbatchwnd != 0) {
//		SetWindowTextW(s_bvh2fbxbatchwnd, L"bvh to FBX Batch");
//	}
//
//	while (g_bvh2fbxbatchflag == 1) {
//		if (s_bvh2fbxbatchwnd != 0) {
//			SendMessage(s_bvh2fbxbatchwnd, WM_USER_FOR_BATCH_PROGRESS, 0, 0);
//			InvalidateRect(s_bvh2fbxbatchwnd, NULL, TRUE);
//			UpdateWindow(s_bvh2fbxbatchwnd);
//		}
//		Sleep(20);
//	}
//
//	return 0;
//}


int BVH2FBXBatch()
{
	if (InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) {//if already under calc, return 0.
		return 0;
	}

	BROWSEINFO bi;
	ZeroMemory(&bi, sizeof(BROWSEINFO));
	LPITEMIDLIST curlpidl = 0;
	WCHAR dispname[MAX_PATH] = { 0L };
	WCHAR selectname[MAX_PATH] = { 0L };
	int iImage = 0;

	//GetBatchHistoryDir(dispname, MAX_PATH);
	//if (selectname[0] != 0) {
	//	LPITEMIDLIST pidl;
	//	IMalloc* pMalloc;
	//	SHGetMalloc(&pMalloc);
	//	if (SUCCEEDED(SHGetSpecialFolderLocation(s_3dwnd, CSIDL_DESKTOPDIRECTORY, &pidl)))
	//	{
	//		// パスに変換する
	//		SHGetPathFromIDList(pidl, selectname);
	//		// 取得したIDLを解放する (CoTaskMemFreeでも可)
	//		pMalloc->Free(pidl);
	//		//SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
	//	}
	//	pMalloc->Release();
	//}

	bi.hwndOwner = s_3dwnd;
	bi.pidlRoot = NULL;//!!!!!!!
	bi.pszDisplayName = dispname;
	//bi.lpszTitle = L"保存フォルダを選択してください。";
	bi.lpszTitle = L"SelectDirectoryForBatch";
	//bi.ulFlags = BIF_EDITBOX | BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
	bi.ulFlags = BIF_RETURNONLYFSDIRS;// | BIF_NEWDIALOGSTYLE;//BIF_NEWDIALOGSTYLEを指定すると固まる　謎
	bi.lpfn = BrowseCallbackProc;
	bi.lParam = 0;
	bi.iImage = iImage;

	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

	curlpidl = SHBrowseForFolder(&bi);

	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	//UnhookWinEvent(hhook);
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;

	if (curlpidl) {
		//::DSMessageBox( m_hWnd, dispname, "フォルダー名", MB_OK );

		BOOL bret;
		bret = SHGetPathFromIDList(curlpidl, selectname);
		if (bret == FALSE) {
			_ASSERT(0);
			if (curlpidl)
				CoTaskMemFree(curlpidl);
			return 1;
		}

		if (curlpidl)
			CoTaskMemFree(curlpidl);


		//selectname
		wstring target;
		string filenamepattern;
		//vector<wstring> out;
		wstring findext;

		s_bvh2fbxout.clear();
		target = selectname;
		findext = L".bvh";

		SaveBatchHistory(selectname);

		FindF(s_bvh2fbxout, target, findext);
		int outnum = (int)s_bvh2fbxout.size();
		InterlockedExchange(&s_bvh2fbxnum, (LONG)outnum);
		InterlockedExchange(&s_bvh2fbxcnt, 0);
		InterlockedExchange(&s_befbvh2fbxnum, 0);
		InterlockedExchange(&s_befbvh2fbxcnt, 0);

		if (outnum > 0)
		{

			InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)1);//start thread


			CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_DIALOG2), NULL, (DLGPROC)bvh2FbxBatchDlgProc);
			RECT rect;
			GetWindowRect(s_LtimelineWnd->getHWnd(), &rect);
			SetWindowPos(s_bvh2fbxbatchwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);
			ShowWindow(s_bvh2fbxbatchwnd, SW_SHOW);
			UpdateWindow(s_bvh2fbxbatchwnd);

			unsigned int threadaddr1 = 0;
			s_bvh2fbxhandle1 = (HANDLE)_beginthreadex(
				NULL, 0, &ThreadFunc_Bvh2Fbx,
				(void*)0,
				0, &threadaddr1);

			//WiatForしない場合には先に閉じてもOK
			if (s_bvh2fbxhandle1 && (s_bvh2fbxhandle1 != INVALID_HANDLE_VALUE)) {
				CloseHandle(s_bvh2fbxhandle1);
			}
		}
	}


	return 0;
}

int BVH2FBX()
{

	int dlgret;
	s_filterindex = 5;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_OPENMQODLG),
		s_3dwnd, (DLGPROC)OpenMqoDlgProc);
	if ((dlgret != IDOK) || (g_tmpmqopath[0] == 0L)) {
		return 0;
	}


	//WCHAR savepath[MULTIPATH];//stack size warning
	WCHAR* tmpsavepath = new WCHAR[MULTIPATH];
	if (!tmpsavepath) {
		_ASSERT(0);
		return 1;
	}
	ZeroMemory(tmpsavepath, sizeof(WCHAR) * MULTIPATH);
	MoveMemory(tmpsavepath, g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);


	//bvhファイルを読み込む
	CBVHFile bvhfile;
	int ret;
	ret = bvhfile.LoadBVHFile(s_3dwnd, g_tmpmqopath, g_tmpmqomult);
	if (ret) {
		_ASSERT(0);
		if(tmpsavepath)
			delete[] tmpsavepath;
		return 1;
	}

	Savebvh2FBXHistory(tmpsavepath);
	if (tmpsavepath)
		delete[] tmpsavepath;


	//FBXファイルに書き出す
	char fbxpath[MAX_PATH] = { 0 };
	WideCharToMultiByte(CP_UTF8, 0, g_tmpmqopath, -1, fbxpath, MAX_PATH, NULL, NULL);
	strcat_s(fbxpath, MAX_PATH, ".fbx");
	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	char fbxdate[MAX_PATH] = { 0L };
	sprintf_s(fbxdate, MAX_PATH, "CommentForEGP_%04u%02u%02u%02u%02u%02u",
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	CallF(BVH2FBXFile(s_psdk, &bvhfile, fbxpath, fbxdate), return 1);


	return 0;
}

int OpenFile()
{
	s_nowloading = true;


	//大きいフレーム一のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	InitTimelineSelection();



	////CurrentDirectoryがMameMediaになっていたときにはTestディレクトリに変える
	//WCHAR curdir[MAX_PATH] = { 0L };
	//ZeroMemory(curdir, sizeof(WCHAR) * MAX_PATH);
	//GetCurrentDirectory(MAX_PATH, curdir);
	//WCHAR* findpat = wcsstr(curdir, L"\\MameMedia");
	//if (findpat) {
	//	WCHAR initialdir[MAX_PATH] = { 0L };
	//	wcscpy_s(initialdir, MAX_PATH, g_basedir);
	//	wcscat_s(initialdir, MAX_PATH, L"..\\Test\\");
	//	SetCurrentDirectoryW(initialdir);
	//}
	SetCurrentDirectoryW(g_basedir);


	int dlgret;
	s_filterindex = 1;
	s_grassflag = false;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_OPENMQODLG),
		s_3dwnd, (DLGPROC)OpenMqoDlgProc);
	if ((dlgret != IDOK) || (g_tmpmqopath[0] == 0L)) {
		s_nowloading = false;
		return 0;
	}


	//WCHAR savepath[MULTIPATH];//stack size warning
	WCHAR* tmpsavepath = new WCHAR[MULTIPATH];
	if (!tmpsavepath) {
		_ASSERT(0);
		s_nowloading = false;
		return 1;
	}
	ZeroMemory(tmpsavepath, sizeof(WCHAR) * MULTIPATH);
	MoveMemory(tmpsavepath, g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);

	size_t leng;
	int namecnt = 0;
	tmpsavepath[MULTIPATH - 1] = 0L;
	leng = wcslen(tmpsavepath);
	if ((leng <= 0) && (leng >= MULTIPATH)) {
		_ASSERT(0);
		s_nowloading = false;
		if (tmpsavepath)
			delete[] tmpsavepath;
		return 0;
	}

	WCHAR* topchar = tmpsavepath + leng;
	if (*topchar == TEXT('\0')) {
		WCHAR* extptr = 0;
		extptr = wcsrchr(g_tmpmqopath, TEXT('.'));
		if (!extptr) {
			s_nowloading = false;
			if (tmpsavepath)
				delete[] tmpsavepath;
			return 0;
		}
		int result = 0;
		CModel* newmodel = 0;
		int cmpcha, cmpfbx, cmpmqo, cmpref, cmpimp, cmpgco, cmpmnl;
		cmpcha = wcscmp(extptr, L".cha");
		cmpfbx = wcscmp(extptr, L".fbx");
		cmpmqo = wcscmp(extptr, L".mqo");
		cmpref = wcscmp(extptr, L".ref");
		cmpimp = wcscmp(extptr, L".imp");
		cmpgco = wcscmp(extptr, L".gco");
		cmpmnl = wcscmp(extptr, L".mnl");
		if (cmpcha == 0) {
			result = OpenChaFile();
			s_filterindex = 1;
		}
		else if (cmpfbx == 0) {
			if (s_chascene && (s_chascene->GetModelNum() > 0)) {
				//OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
				bool forceflag = true;//2024/06/26 各ダイアログ作成のためにforceflag必要
				bool callundo = true;
				OnChangeModel(s_chascene->GetModelNum() - 1, forceflag, callundo);
			}
			std::vector<std::string> ikstopname;
			ikstopname.clear();
			newmodel = OpenFBXFile(false, true, 0, 1, ikstopname, s_grassflag);
			if (newmodel) {
				result = 0;
			}
			else {
				result = 1;
			}
			s_filterindex = 1;
		}
		else if (cmpmqo == 0) {
			if (s_chascene && (s_chascene->GetModelNum() > 0)) {
				//OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
				bool forceflag = true;//2024/06/26 各ダイアログ作成のためにforceflag必要
				bool callundo = true;
				OnChangeModel(s_chascene->GetModelNum() - 1, forceflag, callundo);
			}

			newmodel = OpenMQOFile();
			if (newmodel) {
				result = 0;
			}
			else {
				result = 1;
			}
			s_filterindex = 1;
		}
		else if (cmpref == 0) {
			result = OpenREFile();
			s_filterindex = 2;
		}
		else if (cmpimp == 0) {
			result = OpenImpFile();
			s_filterindex = 3;
		}
		else if (cmpgco == 0) {
			result = OpenGcoFile();
			s_filterindex = 4;
		}
		else if (cmpmnl == 0) {
			result = OpenMNLFile();
			s_filterindex = 6;
		}

		if (result != 0) {
			WCHAR strerror[MAX_PATH * 2] = { 0L };
			swprintf_s(strerror, MAX_PATH * 2, L"%s の\n読み込みに失敗しました。", g_tmpmqopath);
			MessageBox(g_mainhwnd, strerror, L"エラー", MB_OK);
			s_nowloading = false;

			if (tmpsavepath)
				delete[] tmpsavepath;
			return 1;
		}

	}
	else {
		size_t leng2;
		while (*topchar != TEXT('\0')) {
			tmpsavepath[MULTIPATH - 1] = 0L;
			//leng2 = wcslen(topchar);
			swprintf_s(g_tmpmqopath, MULTIPATH, L"%s\\%s", tmpsavepath, topchar);

			WCHAR* extptr = 0;
			extptr = wcsrchr(g_tmpmqopath, TEXT('.'));
			if (!extptr) {
				s_nowloading = false;
				if (tmpsavepath)
					delete[] tmpsavepath;
				return 0;
			}
			int result = 0;
			CModel* newmodel = 0;
			int cmpfbx, cmpmqo;
			cmpfbx = wcscmp(extptr, L".fbx");
			cmpmqo = wcscmp(extptr, L".mqo");
			if (cmpfbx == 0) {
				//WCHAR* nexttopchar = topchar + leng2 + 1;
				//if (*nexttopchar != TEXT('\0')) {
				if (s_chascene && (s_chascene->GetModelNum() > 0)) {
					//OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
					bool forceflag = true;//2024/06/26 各ダイアログ作成のためにforceflag必要
					bool callundo = true;
					OnChangeModel(s_chascene->GetModelNum() - 1, forceflag, callundo);
				}

				std::vector<std::string> ikstopname;
				ikstopname.clear();
				newmodel = OpenFBXFile(false, true, 0, 1, ikstopname, s_grassflag);
				if (newmodel) {
					result = 0;
				}
				else {
					result = 1;
				}
				//}
				//else {
				//	//最終のFBXに対してのみinittimelineをする
				//	OpenFBXFile(0, 1);
				//}
				s_filterindex = 1;
			}
			else if (cmpmqo == 0) {
				if (s_chascene && (s_chascene->GetModelNum() > 0)) {
					//OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
					bool forceflag = true;//2024/06/26 各ダイアログ作成のためにforceflag必要
					bool callundo = true;
					OnChangeModel(s_chascene->GetModelNum() - 1, forceflag, callundo);
				}

				newmodel = OpenMQOFile();
				if (newmodel) {
					result = 0;
				}
				else {
					result = 1;
				}
				s_filterindex = 1;
			}

			if (result != 0) {
				WCHAR strerror[MAX_PATH * 2] = { 0L };
				swprintf_s(strerror, MAX_PATH * 2, L"%s の\n読み込みに失敗しました。", g_tmpmqopath);
				MessageBox(g_mainhwnd, strerror, L"エラー", MB_OK);
				s_nowloading = false;
				if (tmpsavepath)
					delete[] tmpsavepath;
				return 1;
			}

			tmpsavepath[MULTIPATH - 1] = 0L;
			leng2 = wcslen(topchar);
			if ((leng2 > 0) && (leng2 < MULTIPATH)) {
				topchar = topchar + leng2 + 1;
				namecnt++;
			}
			else {
				WCHAR strerror[MAX_PATH * 2] = { 0L };
				swprintf_s(strerror, MAX_PATH * 2, L"%s の\n読み込みに失敗しました。", g_tmpmqopath);
				MessageBox(g_mainhwnd, strerror, L"エラー", MB_OK);
				s_nowloading = false;
				if (tmpsavepath)
					delete[] tmpsavepath;
				return 1;
			}
		}
	}

	s_nowloading = false;

	//ChangeCurrentBone();

	if (tmpsavepath)
		delete[] tmpsavepath;


	//s_camtargetOnceflag = 1;//set cameratarget to selected joint ONCE


	return 0;
}

CModel* OpenMQOFile()
{
	//RenderContext* pRenderContext = DXUTGetD3D11DeviceContext();


	//大きいフレーム一のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	InitTimelineSelection();


	static int modelcnt = 0;
	WCHAR modelname[MAX_PATH] = { 0L };
	WCHAR* lasten;
	lasten = wcsrchr(g_tmpmqopath, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return 0;
	}
	wcscpy_s(modelname, MAX_PATH, lasten + 1);
	WCHAR* extptr;
	extptr = wcsrchr(modelname, TEXT('.'));
	if (!extptr) {
		_ASSERT(0);
		return 0;
	}
	*extptr = 0L;
	WCHAR modelfolder[MAX_PATH] = { 0L };
	swprintf_s(modelfolder, MAX_PATH, L"%s_%d", modelname, modelcnt);
	modelcnt++;


	if (!g_texbank) {
		g_texbank = new CTexBank(s_pdev);
		if (!g_texbank) {
			_ASSERT(0);
			return 0;
		}
	}
	//if (s_model && (s_curmodelmenuindex >= 0) && s_chascene && (s_chascene->GetModelNum() != 0)) {
	//	s_chascene->SetTimelineArray(s_curmodelmenuindex, s_tlarray);
	//	s_chascene->SetLineno2Boneno(s_curmodelmenuindex, s_lineno2boneno, s_boneno2lineno);
	//}

	DestroyTimeLine(1);

	// Load the mesh
	CModel* newmodel;
	newmodel = new CModel();
	if (!newmodel) {
		_ASSERT(0);
		return 0;
	}
	newmodel->SetLoadingMotionCount(0);//2022/11/01

	int ret;
	ret = newmodel->LoadMQO(s_pdev, g_tmpmqopath, modelfolder, g_tmpmqomult, 0);
	if (ret) {
		delete newmodel;
		if (s_owpTimeline) {
			refreshTimeline(*s_owpTimeline);
		}
		return 0;
	}
	else {
		s_model = newmodel;
	}
	//CallF(s_model->MakeDispObj(), return 0);
	CallF(s_model->DbgDump(), return 0);

	int mindex;
	if (s_chascene) {
		mindex = s_chascene->GetModelNum();
	}
	else {
		mindex = 0;
	}
	MODELELEM modelelem;
	modelelem.modelptr = s_model;
	modelelem.motmenuindex = 0;
	if (s_chascene) {
		s_chascene->AddModelElem(modelelem);
	}


	//   CDXUTComboBox* pComboBox = g_SampleUI.GetComboBox( IDC_COMBO_BONE );
	   //pComboBox->RemoveAllItems();

	   //map<int, CBone*>::iterator itrbone;
	   //for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	   //	ULONG boneno = (ULONG)itrbone->first;
	   //	CBone* curbone = itrbone->second;
	   //	if( curbone && (boneno >= 0) ){
	   //		char* nameptr = (char*)curbone->GetBoneName();
	   //		WCHAR wname[256];
	   //		ZeroMemory( wname, sizeof( WCHAR ) * 256 );
	   //		MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, nameptr, 256, wname, 256 );
	   //		pComboBox->AddItem( wname, ULongToPtr( boneno ) );
	   //	}
	   //}

	   //s_totalmb.center.SetParams( 0.0f, 0.0f, 0.0f );
	   //s_totalmb.max.SetParams( 0.0f, 0.0f, 0.0f );
	   //s_totalmb.min.SetParams( 0.0f, 0.0f, 0.0f );
	   //s_totalmb.r = 0.0f;
	CalcTotalBound();


	CallF(AddMotion(0), return 0);

	if (s_chascene) {
		s_chascene->SetTimelineArray(mindex, s_tlarray);
		s_chascene->SetLineno2Boneno(mindex, s_lineno2boneno, s_boneno2lineno);
	}
	else {
		_ASSERT(0);
	}

	//	CallF( OnModelMenu( mindex, 0 ), return 0 );


	DispModelPanel();

	return newmodel;
}

int SetCameraModel()
{
	CModel* savecameramodel = s_cameramodel;

	s_cameramodel = 0;

	if (s_chascene) {
		s_cameramodel = s_chascene->GetTheLastCameraModel();
	}



	//カメラモデルが無い場合には　スプライトスイッチもオフにしておく
	if (!s_cameramodel && (g_cameraanimmode == 1)) {
		ChangeCameraMode(1);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2
	}


	//モデル読み込み中　かつ　カメラモデルがある場合　カメラアニメスイッチを強制オン
	if (s_nowloading && s_cameramodel && (g_cameraanimmode == 0)) {
		ChangeCameraMode(2);
	}


	//2024/06/23
	//新しくファイルを追加読込してカメラモデルが変わった場合　カメラパネル作成し直し
	if (savecameramodel != s_cameramodel) {
		DispCameraPanel();
	}


	return 0;
}

void CalcTotalBound()
{

	//s_totalmb.center.SetParams(0.0f, 0.0f, 0.0f);
	//s_totalmb.max.SetParams(50.0f, 50.0f, 50.0f);
	//s_totalmb.min.SetParams(-50.0f, -50.0f, -50.0f);
	//s_totalmb.r = (float)ChaVector3LengthDbl(&s_totalmb.max);


	SetCameraModel();

	if (s_chascene) {
		s_chascene->CalcTotalModelBound();//計算する　重い
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	FLOAT fObjectRadius;
	if (s_chascene) {
		MODELBOUND totalmb;
		totalmb.Init();
		totalmb = s_chascene->GetTotalModelBound();
		if (totalmb.IsValid()) {
			g_vCenter = totalmb.center;
			fObjectRadius = totalmb.r;
		}
		else {
			g_vCenter.SetParams(0.0f, 0.0f, 0.0f);
			fObjectRadius = 10.0f;
		}
	}
	else {
		_ASSERT(0);
		g_vCenter.SetParams(0.0f, 0.0f, 0.0f);
		fObjectRadius = 10.0f;
	}
	if (fObjectRadius < 0.1f) {
		fObjectRadius = 10.0f;
	}

	s_cammvstep = (float)fmax(0.01f, fmin(500.0f, fObjectRadius));//2023/05/19

	//DbgOut(L"fbx : totalmb : r %f, center (%f, %f, %f)\r\n",
	//	s_totalmb.r, s_totalmb.center.x, s_totalmb.center.y, s_totalmb.center.z);

	//for (int i = 0; i < LIGHTNUMMAX; i++)
	//	g_LightControl[i].SetRadius(fObjectRadius);


	g_projnear = (float)fmax(0.01f, fmin(10.0f, fObjectRadius * 0.01f));
	g_initcamdist = (float)fmax(0.1f, fmin(s_maxcamdist, fObjectRadius * 3.0f));
	g_projfar = g_initcamdist * 100.0f;
	//s_fAspectRatio = 1.0f;//ここでは更新しない
	g_fovy = (float)(PI / 4);
	g_camtargetpos = g_vCenter;
	ChaVector3 dirz;
	dirz.SetParams(0.0f, 0.0f, 1.0);
	g_camEye = g_vCenter + dirz * g_initcamdist;
	//ChangeCameraMode(1);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2.  この関数の上の方のSetCameraModel()で制御するので　ここはコメントアウト


	g_camdist = g_initcamdist;

	g_befcamEye = g_camEye;
	g_befcamtargetpos = g_camtargetpos;

	SetCamera3DFromEyePos();
}


CModel* OpenFBXFile(bool callfromcha, bool dorefreshtl, int skipdefref, int inittimelineflag, std::vector<std::string> ikstopname, bool srcgrassflag)
{
	static int s_dbgcnt = 0;
	s_dbgcnt++;

	s_grassflag = srcgrassflag;

	//RenderContext* pRenderContext = DXUTGetD3D11DeviceContext();


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}


	//大きいフレーム一のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	InitTimelineSelection();


	//int dlgret;
	//dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_CHECKAXISTYPE),
	//	s_3dwnd, (DLGPROC)CheckAxisTypeProc);
	//if (dlgret != IDOK){
	//	return 0;
	//}

	g_camtargetpos.SetParams(0.0f, 0.0f, 0.0f);
	g_befcamtargetpos = g_camtargetpos;


	static int modelcnt = 0;

	WCHAR fbxpath0[MAX_PATH] = { 0L };
	wcscpy_s(fbxpath0, MAX_PATH, g_tmpmqopath);

	WCHAR modelname[MAX_PATH] = { 0L };
	WCHAR* lasten;
	lasten = wcsrchr(g_tmpmqopath, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return 0;
	}
	wcscpy_s(modelname, MAX_PATH, lasten + 1);
	WCHAR* extptr;
	extptr = wcsrchr(modelname, TEXT('.'));
	if (!extptr) {
		_ASSERT(0);
		return 0;
	}
	*extptr = 0L;
	WCHAR modelfolder[MAX_PATH] = { 0L };
	swprintf_s(modelfolder, MAX_PATH, L"%s_%d", modelname, modelcnt);
	modelcnt++;


	WCHAR tbofilename[MAX_PATH] = { 0L };
	swprintf_s(tbofilename, MAX_PATH, L"%s.tbo", g_tmpmqopath);


	if (!g_texbank) {
		g_texbank = new CTexBank(s_pdev);
		if (!g_texbank) {
			_ASSERT(0);
			return 0;
		}
	}
	//if (s_model && (s_curmodelmenuindex >= 0) && s_chascene && (s_chascene->GetModelNum() != 0)) {
	//	s_chascene->SetTimelineArray(s_curmodelmenuindex, s_tlarray);
	//	s_chascene->SetLineno2Boneno(s_curmodelmenuindex, s_lineno2boneno, s_boneno2lineno);
	//}



	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	DestroyTimeLine(1);

	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	// Load the mesh
	CModel* newmodel;
	newmodel = new CModel();
	if (!newmodel) {
		_ASSERT(0);
		return 0;
	}
	newmodel->SetLoadingMotionCount(0);//2022/11/01


	if (s_grassflag) {
		//2024/05/11
		newmodel->SetGrassFlag(true);
		newmodel->SetInstancingNum(GRASSINDEXMAX);
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	_ASSERT(s_btWorld);
	newmodel->SetBtWorld(s_btWorld);
	FbxScene* pScene = 0;
	FbxImporter* pImporter = 0;
	//skipdefref FBX単体読み込みの場合にはdefault_ref.refは存在しない。その場合skipdefrefには０が代入され、CModel::LoadFBX内でdefault_ref.refの中でメモリからデフォルト値が設定される
	int ret;
	BOOL motioncachebatchflag = FALSE;
	ret = newmodel->LoadFBX(skipdefref, s_pdev, g_tmpmqopath, modelfolder, g_tmpmqomult, s_psdk, &pImporter, &pScene, s_forcenewaxis, motioncachebatchflag);
	if (ret) {
		_ASSERT(0);
		delete newmodel;
		if (s_owpTimeline) {
			refreshTimeline(*s_owpTimeline);
		}
		return 0;
	}
	else {
		s_model = newmodel;

		if (srcgrassflag && (callfromcha == false)) {//chaファイル読込時にはChaFile内でCGrassElemを作成してセットする
			CGrassElem* newgrasselem = new CGrassElem(newmodel);
			if (!newgrasselem) {
				_ASSERT(0);
				abort();
				return 0;
			}
			s_grassElemVec.push_back(newgrasselem);
		}
	}

	if (callfromcha == true) {
		//ChaFile.cppで　*.cha fileの記述から読み取る
		std::vector<std::string>::iterator itrname;
		for (itrname = ikstopname.begin(); itrname != ikstopname.end(); itrname++) {
			string curname = *itrname;
			newmodel->AddIKStopName(curname.c_str());
		}
	}
	else {
		//set default IKStopName
		newmodel->AddIKStopName("Shoulder");
		newmodel->AddIKStopName("UpperLeg");
	}
	newmodel->SetIKStopFlag();


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	//CallF(s_model->MakeDispObj(), return 0);

	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	int mindex;
	if (s_chascene) {
		mindex = s_chascene->GetModelNum();
	}
	else {
		mindex = 0;
	}
	MODELELEM modelelem;
	modelelem.modelptr = s_model;
	modelelem.motmenuindex = 0;
	if (s_chascene) {
		s_chascene->AddModelElem(modelelem);
	}

	//   CDXUTComboBox* pComboBox = g_SampleUI.GetComboBox( IDC_COMBO_BONE );
	   //pComboBox->RemoveAllItems();

	   //map<int, CBone*>::iterator itrbone;
	   //for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	   //	ULONG boneno = (ULONG)itrbone->first;
	   //	CBone* curbone = itrbone->second;
	   //	if( curbone && (boneno >= 0) ){
	   //		char* nameptr = (char*)curbone->GetBoneName();
	   //		WCHAR wname[256];
	   //		MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, nameptr, 256, wname, 256 );
	   //		pComboBox->AddItem( wname, ULongToPtr( boneno ) );
	   //	}
	   //}

	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}


	//CalcTotalBound();//下で呼んでる

	//if (s_chascene) {
	//	s_chascene->SetTimelineArray(mindex, s_tlarray);
	//	s_chascene->SetLineno2Boneno(mindex, s_lineno2boneno, s_boneno2lineno);
	//}
	//else {
	//	_ASSERT(0);
	//}



	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	//CallF(OnModelMenu(dorefreshtl, mindex, 0), return 0);
	bool forceflag = true;
	bool callundo = true;
	OnChangeModel(mindex, forceflag, callundo);//2024/06/26 各ダイアログ作成のためにforceflag必要


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}


	//FrameCopyDlgはOnModelMenu()にてまだ無いときに作成される
	//tboファイルのLoadはOnModelMenu()よりも後で
	CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg(false);
	if (curcpdlg) {
		bool result = curcpdlg->LoadWithProjectFile(tbofilename);//LoadTboFile
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	//CallF( s_model->LoadFBXAnim( s_psdk, pImporter, pScene, OnAddMotion ), return 0 );
	CallF(s_model->LoadFBXAnim(s_psdk, pScene, NULL, motioncachebatchflag), return 0);
	//if( (int)s_modelindex.size() >= 2 )
	//	_ASSERT( 0 );




//::MessageBox(g_mainhwnd, L"check 1", L"check!!!", MB_OK);

	CalcTotalBound();

	if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
		int cameraindex = 0;
		OnCameraMenu(true, cameraindex, 1);
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	//if( s_model->GetMotInfoSize() >= 2 ){
	//	OnDelMotion( 0 );//初期状態のダミーモーションを削除
	//}

//::MessageBox(g_mainhwnd, L"check 2", L"check!!!", MB_OK);

	//OnAnimMenuでCreateRigidElemを呼ぶ前に、default_ref.refを読む
	if (skipdefref == 1) {//プロジェクトファイルから呼ばれて、かつ、default_ref.refが存在する場合
		if (s_model->GetMotInfoSize() > 0) {
			MOTINFO firstmi = s_model->GetMotInfo(1);
			if (firstmi.motid > 0) {
				s_model->SetCurrentMotion(firstmi.motid);

				WCHAR savetmpmqopath[MAX_PATH];
				wcscpy_s(savetmpmqopath, MAX_PATH, g_tmpmqopath);
				WCHAR* lastenref;
				lastenref = wcsrchr(g_tmpmqopath, TEXT('\\'));
				if (lastenref) {
					*lastenref = 0L;
					wcscat_s(g_tmpmqopath, MAX_PATH, L"\\default_ref.ref");
					int chkret;
					chkret = OpenREFile();
					_ASSERT(chkret == 0);


					wcscpy_s(g_tmpmqopath, MAX_PATH, savetmpmqopath);
				}
			}
		}
	}

	//::MessageBox(g_mainhwnd, L"check 3", L"check!!!", MB_OK);


		//if (inittimelineflag == 1)//inittimelineflag は 最後のキャラの時に１
	{
		int lastmotid = -1;
		int motnum = s_model->GetMotInfoSize();
		if (motnum > 0) {
			int motindex;
			for (motindex = 0; motindex < motnum; motindex++) {

				//WCHAR strchk[256] = { 0L };
				//swprintf_s(strchk, 256, L"check 3 : %d / %d", motno, motnum);
				//::MessageBox(g_mainhwnd, strchk, L"check!!!", MB_OK);

				//MOTINFO curmi = s_model->GetMotInfo(motno + 1);
				MOTINFO curmi = s_model->GetMotInfoByIndex(motindex);//2024/06/27
				if (curmi.motid > 0) {
					lastmotid = curmi.motid;
					s_model->SetCurrentMotion(lastmotid);
					//OnAddMotion(curmi->motid, (motno == 0));
					// 
					//Main.cppのOnAddMotion()は　メニューの追加のみ
					//
					OnAddMotion(curmi.motid, (motindex == (motnum - 1)));//最後のモーション!!!!!! 2021/08/19

					if (s_nowloading && s_3dwnd) {
						OnRenderNowLoading();
					}

				}
			}


			//2024/06/09
			//ファイルを開いた直後には、ボーンモーション編集可能なモーションを選択しておく
			//カメラアニメしか無い場合は次の処理はしない
			bool cameraanimflag = false;
			MOTINFO firstvalidmi = s_model->GetFirstValidMotInfo(cameraanimflag);
			if (firstvalidmi.motid > 0) {
				int selindex = s_chascene->MotID2SelIndex(s_chascene->FindModelIndex(s_model), firstvalidmi.motid);
				if (selindex >= 0) {
					OnAnimMenu(dorefreshtl, selindex);
				}
			}

		}
		//s_model->SetCurrentMotion(lastmotid);
	}
	//}

//::MessageBox(g_mainhwnd, L"check 4", L"check!!!", MB_OK);


	//2023/10/27
	// モーション無しのfbxを読み込んだ場合　motidは作成されるがモーションポイントは１つも無い
	// そのために　motnum == 0のときに　AddMotion()を呼んで　InitMPする
	// CModel::AddMotion()からInitMPが呼ばれるためには　GetLoadedFlag() == trueである必要
	// よってモデルとアニメ読み込み後　かつ motnum == 0処理よりも前に　SetLoadedFlag(true)する必要
	// 下方から移動
	s_model->SetLoadedFlag(true);


	//Handle a model not has motion.
	int motnum = s_model->GetMotInfoSize();
	//if ((motnum == 0) && (s_model->GetNoBoneFlag() == false)) {
	if (motnum == 0) {
		CallF(AddMotion(0), return 0);//モーション無しfbxを読み込んだ場合のInitMP呼び出しでモーションポイント作成
		if (s_chascene) {
			s_chascene->SetTimelineArray(mindex, s_tlarray);
			s_chascene->SetLineno2Boneno(mindex, s_lineno2boneno, s_boneno2lineno);
		}
		else {
			_ASSERT(0);
			return 0;
		}
	}




	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	//::MessageBox(g_mainhwnd, L"check 5", L"check!!!", MB_OK);

	OnRgdMorphMenu(0);

	//	SetCapture( s_3dwnd );

	if (s_model && s_model->ExistCurrentMotion()) {
		MOTINFO curmi = s_model->GetCurMotInfo();
		if (curmi.motid > 0) {
			s_curmotid = curmi.motid;
		}
	}
	else {
		//_ASSERT(0);
		s_curmotid = 0;
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	if (s_model->GetOldAxisFlagAtLoading() == 0) {
		CLmtFile lmtfile;
		WCHAR lmtname[MAX_PATH];
		swprintf_s(lmtname, MAX_PATH, L"%s.lmt", g_tmpmqopath);
		char fbxcomment[MAX_PATH] = { 0 };
		int chkretcomment;
		chkretcomment = s_model->GetFbxComment(fbxcomment, MAX_PATH);
		if (chkretcomment == 0) {
			int chkret1;
			chkret1 = lmtfile.LoadLmtFile(lmtname, s_model, fbxcomment);
			//_ASSERT(chkret1 == 0);
		}
		WCHAR rigname[MAX_PATH] = { 0L };
		swprintf_s(rigname, MAX_PATH, L"%s.rig", g_tmpmqopath);
		CRigFile rigfile;
		int chkret2;
		chkret2 = rigfile.LoadRigFile(rigname, s_model);
		//_ASSERT(chkret2 == 0);
	}

	//::MessageBox(g_mainhwnd, L"check 6", L"check!!!", MB_OK);


	s_model->SetMotionSpeed(g_dspeed);

	DispModelPanel();


	//OnAnimMenuで呼ぶ
	//if (skipdefref == 0) {
	//	s_model->CreateBtObject(1);//初回
	//	s_model->CalcBoneEul(-1);
	//}

	CBone* hipsbone = nullptr;
	s_model->GetHipsBoneReq(s_model->GetTopBone(false), &hipsbone);
	if (hipsbone) {
		g_befcamtargetpos = g_camtargetpos;
		g_camtargetpos = hipsbone->GetChildWorld();
		s_curboneno = hipsbone->GetBoneNo();
	}

#ifndef NDEBUG
	CallF(s_model->DbgDump(), return 0);
#endif

	g_dbgloadcnt++;

	//s_model->DestroyScene();

	//2023/10/27
	// モーション無しのfbxを読み込んだ場合　motidは作成されるがモーションポイントは１つも無い
	// そのために　motnum == 0のときに　AddMotion()を呼んで　InitMPする
	// CModel::AddMotion()からInitMPが呼ばれるためには　GetLoadedFlag() == trueである必要
	// よってモデルとアニメ読み込み後　かつ motnum == 0処理よりも前に　SetLoadedFlag(true)する必要
	// 上方へ移動
	//s_model->SetLoadedFlag(true);

	//ShowRigidWnd(true);

//::MessageBox(g_mainhwnd, L"check 7", L"check!!!", MB_OK);



	//2022/11/23
	//VRoidの髪の毛ジョイントが多く　顔がみえなくなるので　読み込み時に自動的に　頭のジョイントマークをスキップ設定
	CBone* vroidheadjoint = s_model->FindBoneByName("J_Bip_C_Head");
	if (vroidheadjoint) {
		SkipJointMarkReq(1, vroidheadjoint, false);
		s_model->SetBtObjectVec();//2024/06/16
	}


	if (s_nowloading && s_3dwnd) {
		OnRenderNowLoading();
	}

	OrgWindowListenMouse(true);

	//::MessageBox(g_mainhwnd, L"check 8", L"check!!!", MB_OK);


	SetTimelineHasRigFlag();


	//############################
	//############################

		//読み込み処理が成功してから履歴を保存する。fbxファイル。
	size_t savepathlen;
	fbxpath0[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(fbxpath0);
	if ((savepathlen > 4) && (savepathlen < MAX_PATH)) {
		WCHAR* pwext;
		pwext = fbxpath0 + ((size_t)savepathlen - 1) - 3;
		if (wcscmp(pwext, L".fbx") == 0) {
			SYSTEMTIME localtime;
			GetLocalTime(&localtime);
			WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
			swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProj_%04u%02u%02u%02u%02u%02u.txt",
				s_temppath,
				localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
			HANDLE hfile;
			hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				//int pathlen;
				//pathlen = (int)wcslen(saveprojpath);
				//if ((pathlen > 0) && (pathlen < MAX_PATH)) {
				if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
					DWORD writelen = 0;
					WriteFile(hfile, fbxpath0, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
					_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
				}
				CloseHandle(hfile);
			}
		}
	}

	return newmodel;
}

int InitCurMotion(int selectflag, double expandmotion)
{

	//モーション初期化はunlimitedに対して行う
	bool limitdegflag = false;

	//MOTINFO curmi = GetEditTargetMotInfo();

	//モーションプロパティ機能はモーションパネルで選択中のモーションに対して処理をする
	//カメラパネル内のモーションはモーションパネル内にも存在するので　カメラモーションの長さを変える場合にも　モーションパネルで選択して実行する
	MOTINFO curmi = s_model->GetCurMotInfo();
	if (curmi.motid > 0) {
		if (s_model) {
			if (s_model->ExistCurrentMotion()) {
				//CallF(s_model->FillUpEmptyMotion(curmi->motid), return 0);
				CBone* topbone = s_model->GetTopBone(false);
				if (topbone && (s_model->GetNoBoneFlag() == false)) {
					double motleng = s_model->GetCurrentMotLeng();
					//_ASSERT(0);

					if (selectflag == 1) {//called from tool panel : init selected time range

						bool firstflag = true;
						double startframe = 0.0;
						double endframe = 0.0;
						list<KeyInfo>::iterator itrcp;
						for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
							if (firstflag) {
								startframe = itrcp->time;
								firstflag = false;
							}
							endframe = itrcp->time;
						}

						s_model->InitMpFrame(limitdegflag, curmi.motid, topbone, startframe, endframe);

					}
					else if (expandmotion > 0) {//モーション長を長くした際に、長くなった分の初期化をする
						double oldframeleng = expandmotion;

						//////if (topbone) {
						////	//topbone->ResizeIndexedMotionPointReq(curmi->motid, motleng);
						//////}

						//double frame;
						//for (frame = oldframeleng; frame < motleng; frame += 1.0) {
						//	if (topbone) {
						//		s_model->SetMotionFrame(frame);
						//		s_model->InitMPReq(limitdegflag, topbone, curmi->motid, frame);
						//	}
						//}

						if (oldframeleng < motleng) {
							s_model->InitMpFrame(limitdegflag, curmi.motid, topbone, oldframeleng, RoundingTime(motleng - 1.0));
						}

						int errorcount = 0;
						s_model->CreateIndexedMotionPoint(
							curmi.motid, motleng, &errorcount);
						if (errorcount != 0) {
							_ASSERT(0);
						}
					}
					else {
						//double frame;
						//for (frame = 0.0; frame < motleng; frame += 1.0) {
						//	if (topbone) {
						//		s_model->SetMotionFrame(frame);
						//		s_model->InitMPReq(limitdegflag, topbone, curmi->motid, frame);
						//	}
						//}

						s_model->InitMpFrame(limitdegflag, curmi.motid, topbone, 0.0, RoundingTime(motleng - 1.0));

						int errorcount = 0;
						s_model->CreateIndexedMotionPoint(
							curmi.motid, motleng, &errorcount);
						if (errorcount != 0) {
							_ASSERT(0);
						}
					}


					////LimitEulを表示時には　worldへの変更をlimitedに反映させる
					//if (g_limitdegflag == true) {
					//	bool allframeflag = true;//全フレーム
					//	bool setcursorflag = false;
					//	bool onpasteflag = false;
					//	CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, s_editmotionflag, onpasteflag);
					//}

				}
			}
			else {
				_ASSERT(0);
			}
		}
		else {
			_ASSERT(0);
		}
	}
	else {
		_ASSERT(0);
	}

	return 0;
};

int AddTimeLine(int newmotid, bool dorefreshtl)
{
	EnterCriticalSection(&s_CritSection_LTimeline);

	//EraseKeyList();
	////if (s_model && s_model->GetBoneListSize() > 0) {
	//if (s_model && (s_model->GetBoneForMotionSize() > 0)) {
	if (s_model && s_chascene) {
		if (!s_owpTimeline) {
			//OWP_Timeline* owpTimeline = 0;
			//タイムラインのGUIパーツを生成
			bool shortlabel = false;
			bool heightwheel = true;
			int labelheight;
			if (g_4kresolution) {
				labelheight = 28;
			}
			else {
				labelheight = 19;
			}
			s_owpTimeline = new OWP_Timeline(heightwheel, shortlabel, labelheight, L"testmotion", 100.0, 4.0);
			s_owpTimeline->setDispKeyFlag(false);//高速化のためkey表示無し

			// カーソル移動時のイベントリスナーに
			// カーソル移動フラグcursorFlagをオンにするラムダ関数を登録する
			s_owpTimeline->setCursorListener([]() {
				if (s_model) {
					s_cursorFlag = true;
					if (s_undoFlag || s_redoFlag) {
						s_cursorUnderUndo = true;
					}
				}
				});

			// キー選択時のイベントリスナーに
			// キー選択フラグselectFlagをオンにするラムダ関数を登録する
			//s_owpTimeline->setSelectListener([](){ s_selectFlag = true; });//LTimelineへ移動

			s_owpTimeline->setMouseRUpListener([]() {
				if (s_model) {
					s_timelineRUpFlag = true;
				}
				});

			//// キー移動時のイベントリスナーに
			//// キー移動フラグkeyShiftFlagをオンにして、キー移動量をコピーするラムダ関数を登録する
			//s_owpTimeline->setKeyShiftListener([]() {
			//	if (s_model) {
			//		s_keyShiftFlag = true;
			//		s_keyShiftTime = s_owpTimeline->getShiftKeyTime();
			//	}
			//});

			//// キー削除時のイベントリスナーに
			//// 削除されたキー情報をスタックするラムダ関数を登録する
			s_owpTimeline->setKeyDeleteListener([](const KeyInfo& keyInfo) {
				//s_deletedKeyInfoList.push_back(keyInfo);
				});


			//ウィンドウにタイムラインを関連付ける
			s_timelineWnd->addParts(*s_owpTimeline);


			//１クリック目問題対応
			s_timelineWnd->refreshPosAndSize();//2022/09/20


			//		s_owpTimeline->timeSize = 4.0;
			//		s_owpTimeline->callRewrite();						//再描画
			//		s_owpTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開
		}

		if (s_owpTimeline) {
			int currentmodelindex = s_chascene->FindModelIndex(s_model);
			if (currentmodelindex >= 0) {
				//#######################################################
				//2024/06/27 s_tlarrayの操作前にカレントモデルのtlarrayを取得
				//#######################################################
				s_chascene->GetTimelineArray(currentmodelindex, s_tlarray);

				int nextindex;
				nextindex = (int)s_tlarray.size();

				TLELEM newtle;
				newtle.menuindex = nextindex;
				newtle.motionid = newmotid;
				s_tlarray.push_back(newtle);

				s_chascene->SetTimelineArray(currentmodelindex, s_tlarray);
				s_model->SetCurrentMotion(newmotid);
			}
		}

		if (s_LtimelineWnd && s_owpPlayerButton) {
			if (!s_LTSeparator) {
				s_LTSeparator = new OWP_Separator(s_LtimelineWnd, false, 0.38, false);//LongTimelineは登録GUIによるサイズ計算はしない(GDI描画)　contentsSize引数はfalse
				s_LtimelineWnd->addParts(*s_LTSeparator);

				if (s_owpLTimeline) {
					delete s_owpLTimeline;
					s_owpLTimeline = 0;
				}
				bool shortlabel = true;
				bool heightwheel = false;
				int labelheight;
				if (g_4kresolution) {
					labelheight = 22;
				}
				else {
					labelheight = 18;
				}
				s_owpLTimeline = new OWP_Timeline(heightwheel, shortlabel, labelheight, L"EditRangeTimeLine");
				if (s_owpLTimeline) {
					s_owpLTimeline->setDispKeyFlag(true);
					//s_LtimelineWnd->addParts(*s_owpLTimeline);//playerbuttonより後
					s_LTSeparator->addParts1(*s_owpLTimeline);
					s_owpLTimeline->setCursorListener([]() {
						if (s_model) {
							s_LcursorFlag = true;
						}
						});
					s_owpLTimeline->setSelectListener([]() {
						if (s_model && (s_selectFlag == false)) {
							s_selectFlag = true;
						}
						});
					s_owpLTimeline->setMouseMDownListener([]() {
						if (s_model) {
							s_timelinembuttonFlag = true;
							//if (s_mbuttoncnt == 0) {
							//	s_mbuttoncnt = 1;
							//}
							//else {
							//	s_mbuttoncnt = 0;
							//}
						}
						});
					s_owpLTimeline->setMouseWheelListener([]() {
						if (s_model) {
							if ((g_keybuf['S'] & 0x80) == 0) {//Scroll の S
								if (s_timelinewheelFlag == false) {
									s_timelinewheelFlag = true;
									s_timelineshowposFlag = false;
									s_LcursorFlag = true;
								}
							}
							else {
								if (s_timelineshowposFlag == false) {
									s_timelinewheelFlag = false;
									s_timelineshowposFlag = true;
								}
							}
						}
						});
					s_owpLTimeline->setMouseRDownListener([]() {
						if (s_model) {
							if (!s_LTimelineApplyFrameFlag) {
								s_LTimelineApplyFrameFlag = true;
							}
						}
						});
					s_owpLTimeline->setMouseRUpListener([]() {
						if (s_model) {
							//if (!s_LTimelineApplyFrameFlag) {
							//	s_LTimelineApplyFrameFlag = true;
							//}
							s_utApplyRateFlag = true;//g_applyrateのUNDOトリガー
						}
						});
					s_owpLTimeline->setMouseRMoveListener([]() {
						if (s_model) {
							if (!s_LTimelineApplyFrameFlag) {
								s_LTimelineApplyFrameFlag = true;
							}
						}
						});


					if (s_parentcheck) {
						delete s_parentcheck;
						s_parentcheck = 0;
					}
					s_parentcheck = new OWP_CheckBoxA(L"ParentEuler", 1, 15, false);//parentcheck ON by default
					//s_LtimelineWnd->addParts(*s_parentcheck);
					//s_LTSeparator->addParts2(*s_parentcheck);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!parentwindow libfbxdll error 2021/03/04 comment out tmp
					//s_parentcheck->setButtonListener([]() { 
					//	if (s_model) {
					//		refreshEulerGraph();
					//	}
					//});


					if (s_owpEulerGraph) {
						delete s_owpEulerGraph;
						s_owpEulerGraph = 0;
					}
					s_owpEulerGraph = new OWP_EulerGraph(L"EulerGraph");
					if (s_owpEulerGraph) {
						//s_LtimelineWnd->addParts(*s_owpEulerGraph);
						s_LTSeparator->addParts2(*s_owpEulerGraph);
					}

					//OrgWinGUI::WindowSize graphsize = OrgWinGUI::WindowSize(s_LTSeparator->getSize().x - 8, 60);
					//s_owpEulerGraph->setSize(graphsize);
					//OrgWinGUI::WindowPos graphpos = OrgWinGUI::WindowPos(0, 16);
					//s_owpEulerGraph->setPos(graphpos);
					//s_owpEulerGraph->setCursorListener([]() { 
					//	if (s_model) {
					//		s_LcursorFlag = true;
					//	}
					//});

					//2022/09/20 １クリック目がおかしくなる不具合を解消
					s_LtimelineWnd->setPos(WindowPos(s_toolwidth, s_2ndposy));
					s_LtimelineWnd->setSizeMin(OrgWinGUI::WindowSize(100, 100));
					s_LtimelineWnd->setSize(WindowSize(s_longtimelinewidth, s_longtimelineheight));
					s_LtimelineWnd->refreshPosAndSize();//2022/09/20
				}
				
			}
		}

		//タイムラインのキーを設定
		if (s_owpTimeline) {
			if (dorefreshtl) {
				refreshTimeline(*s_owpTimeline);
			}
			s_owpLTimeline->selectClear();
		}

	}


	LeaveCriticalSection(&s_CritSection_LTimeline);

	return 0;
}


int UpdateEditedEuler()
{
	//オイラーグラフのキーを作成しなおす場合にはrefreshEulerGraph()


	//ツールボタンからも呼ぶ
	//if (s_pickinfo.buttonflag == 0) {
	//	return 0;
	//}


	if (s_owpEulerGraph) {
		if (g_edittarget != EDITTARGET_CAMERA) {
			s_owpEulerGraph->SetCurrentModel(s_model);
		}
		else {
			s_owpEulerGraph->SetCurrentModel(s_cameramodel);
		}
	}

	if (!s_model || !s_owpLTimeline || !s_owpEulerGraph) {
		return 0;
	}


	if (!s_model->ExistCurrentMotion()) {
		return 0;
	}

	//if (s_model && (s_model->GetLoadedFlag() == false)) {
	//	return 0;
	//}


	//2023/10/13
	int eultiptime = (int)(s_owpEulerGraph->getCurrentTime() + 0.0001);


	CModel* pmodel = 0;
	CMQOObject* pmqoobj = 0;
	int channelindex = -1;
	bool blendshapemode;
	blendshapemode = InBlendShapeMode(&pmodel, &pmqoobj, &channelindex);
	if (blendshapemode) {
		s_owpEulerGraph->setInBlendShapeMode(true);

		int curtime;
		float minval = -100.0;
		float maxval = 100.0;

		int curmotid = pmodel->GetCurrentMotID();
		MOTINFO curmi = s_model->GetCurMotInfo();
		if (curmi.motid > 0) {
			int startframe, endframe, frameleng;
			frameleng = IntTime(curmi.frameleng);
			startframe = IntTime(s_owpLTimeline->getShowPosTime());
			endframe = (int)(min(frameleng, startframe + s_owpEulerGraph->getShowposWidth()));

			int firstframe;
			firstframe = max((startframe - 1), 0);

			for (curtime = startframe; curtime <= endframe; curtime++) {
				float currentvalue = pmqoobj->GetShapeAnimWeight(curmotid, curtime, channelindex);

				bool needCallRewrite = false;
				s_owpEulerGraph->setKey(needCallRewrite, _T("X"), (double)curtime, currentvalue);

				//2023/10/13
				if (curtime == eultiptime) {
					ChaVector3 eultip;
					eultip.SetParams(currentvalue, 0.0f, 0.0f);
					s_owpEulerGraph->setEulTip(eultip);
				}
			}

			s_owpEulerGraph->setEulMinMax(s_ikkind, minval, maxval);

			if (g_motionbrush_value) {

				double scalemin, scalemax;
				if (minval != maxval) {
					scalemin = minval;
					scalemax = maxval;
				}
				else {
					//Eulerが全て０　例えば全フレームを選択してツールの姿勢初期化を実行した後など
					//仮のminとmaxを指定
					scalemin = minval;
					scalemax = maxval + 10.0;
				}

				unsigned int scaleindex;
				//for (scaleindex = 0; scaleindex < curmi->frameleng; scaleindex++) {
				for (scaleindex = (unsigned int)startframe; scaleindex <= (unsigned int)endframe; scaleindex++) {

					double curscalevalue;
					if ((scaleindex >= (unsigned int)g_motionbrush_startframe) && (scaleindex <= (unsigned int)g_motionbrush_endframe) && (scaleindex < (unsigned int)g_motionbrush_frameleng)) {
						curscalevalue = (double)(*(g_motionbrush_value + scaleindex));// *(scalemax - scalemin) + scalemin;
						curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
					}
					else {
						curscalevalue = 0.0;// *(scalemax - scalemin) + scalemin;
						curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
					}
					bool needCallRewrite = false;
					s_owpEulerGraph->setKey(needCallRewrite, _T("S"), (double)scaleindex, curscalevalue);//setkey
				}

			}

			s_owpEulerGraph->MakePointBuf();//2024/06/29
			//_ASSERT(0);
			s_owpEulerGraph->callRewrite();
			//s_owpEulerGraph->draw();
		}

	}
	else {
		s_owpEulerGraph->setInBlendShapeMode(false);//false

		int frameleng = 0;
		int graphmotid = 0;
		CBone* opebone = nullptr;
		opebone = GetEditTargetOpeBone(&graphmotid, &frameleng);

		if (opebone) {
			int curtime;
			float minval = 0.0f;
			float maxval = 0.0f;
			int minfirstflag, maxfirstflag;
			bool isset = false;

			//refreshEulerGraphは全範囲でminとmaxを設定。UpdateEditedEulerはstartframeからendframeまで。
			s_owpEulerGraph->getEulMinMax(&isset, &minval, &maxval);
			if (isset == true) {
				minfirstflag = 0;
				maxfirstflag = 0;
			}
			else {
				minfirstflag = 1;
				maxfirstflag = 1;
			}

			int startframe, endframe;
			startframe = IntTime(s_owpLTimeline->getShowPosTime());
			endframe = (int)(min(frameleng, startframe + IntTime(s_owpEulerGraph->getShowposWidth())));

			int firstframe;
			firstframe = max((startframe - 1), 0);

			ChaVector3 befeul;
			befeul.SetParams(0.0f, 0.0f, 0.0f);
			int ret;
			ret = s_owpEulerGraph->getEuler((double)firstframe, &befeul);
			if (ret) {
				befeul.SetParams(0.0f, 0.0f, 0.0f);
			}


			int graphkind = 0;
			if ((s_ikkind == 0) || (s_cameraeditkind == CAMERAANIMEDIT_ROT) || (s_cameraeditkind == CAMERAANIMEDIT_TWIST)) {//回転
				graphkind = 0;
			}
			else if ((s_ikkind == 1) || (s_cameraeditkind == CAMERAANIMEDIT_MV) || (s_cameraeditkind == CAMERAANIMEDIT_DIST)) {//移動
				graphkind = 1;
			}
			else if (s_ikkind == 2) {//スケール
				graphkind = 2;
			}


			for (curtime = startframe; curtime <= endframe; curtime++) {
				const WCHAR* wbonename = opebone->GetWBoneName();
				ChaVector3 orgeul;
				orgeul.SetParams(0.0f, 0.0f, 0.0f);
				ChaVector3 cureul;
				cureul.SetParams(0.0f, 0.0f, 0.0f);
				//cureul = opebone->CalcFBXEul(curmi->motid, (double)curtime, &befeul);
				//befeul = cureul;//!!!!!!!

				CMotionPoint* curmp = opebone->GetMotionPoint(graphmotid, (double)curtime);
				if (curmp) {
					if (graphkind == 0) {//回転
						//opebone->GetWorldMat(curmi->motid, (double)curtime, 0, &cureul);
						cureul = opebone->GetLocalEul(g_limitdegflag, graphmotid, (double)curtime, 0);
					}
					else if (graphkind == 1) {//移動
						cureul = opebone->CalcLocalTraAnim(g_limitdegflag, graphmotid, (double)curtime);
					}
					else if (graphkind == 2) {//スケール
						cureul = opebone->CalcLocalScaleAnim(g_limitdegflag, graphmotid, (double)curtime);
					}
				}
				else {
					cureul.x = 0.0;
					cureul.y = 0.0;
					cureul.z = 0.0;
					//befeul = cureul;//!!!!!!!
				}
				if ((curtime == 0.0) || (curtime == 1.0) || IsValidNewEul(cureul, befeul)) {
					befeul = cureul;
				}

				bool needCallRewrite = false;
				s_owpEulerGraph->setKey(needCallRewrite, _T("X"), (double)curtime, cureul.x);
				s_owpEulerGraph->setKey(needCallRewrite, _T("Y"), (double)curtime, cureul.y);
				s_owpEulerGraph->setKey(needCallRewrite, _T("Z"), (double)curtime, cureul.z);


				//2023/10/13
				if (curtime == eultiptime) {
					s_owpEulerGraph->setEulTip(cureul);
				}


				if (minfirstflag == 1) {
					minval = (float)fmin(cureul.z, fmin(cureul.x, cureul.y));
					minfirstflag = 0;
				}
				if (minval > cureul.x) {
					minval = cureul.x;
				}
				if (minval > cureul.y) {
					minval = cureul.y;
				}
				if (minval > cureul.z) {
					minval = cureul.z;
				}

				if (maxfirstflag == 1) {
					maxval = (float)fmax(cureul.z, fmax(cureul.x, cureul.y));
					maxfirstflag = 0;
				}
				if (maxval < cureul.x) {
					maxval = cureul.x;
				}
				if (maxval < cureul.y) {
					maxval = cureul.y;
				}
				if (maxval < cureul.z) {
					maxval = cureul.z;
				}

			}

			s_owpEulerGraph->setEulMinMax(graphkind, minval, maxval);

			if (g_motionbrush_value) {

				double scalemin, scalemax;
				if (minval != maxval) {
					scalemin = minval;
					scalemax = maxval;
				}
				else {
					//Eulerが全て０　例えば全フレームを選択してツールの姿勢初期化を実行した後など
					//仮のminとmaxを指定
					scalemin = minval;
					scalemax = maxval + 10.0;
				}

				unsigned int scaleindex;
				//for (scaleindex = 0; scaleindex < curmi->frameleng; scaleindex++) {
				for (scaleindex = (unsigned int)startframe; scaleindex <= (unsigned int)endframe; scaleindex++) {

					double curscalevalue;
					if ((scaleindex >= (unsigned int)g_motionbrush_startframe) && (scaleindex <= (unsigned int)g_motionbrush_endframe) && (scaleindex < (unsigned int)g_motionbrush_frameleng)) {
						curscalevalue = (double)(*(g_motionbrush_value + scaleindex));// *(scalemax - scalemin) + scalemin;
						curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
					}
					else {
						curscalevalue = 0.0;// *(scalemax - scalemin) + scalemin;
						curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
					}
					bool needCallRewrite = false;
					s_owpEulerGraph->setKey(needCallRewrite, _T("S"), (double)scaleindex, curscalevalue);//setkey
				}


			}

			s_owpEulerGraph->MakePointBuf();//2024/06/29
			//_ASSERT(0);
			s_owpEulerGraph->callRewrite();
			//s_owpEulerGraph->draw();
		}
	}

	return 0;
}

int refreshEulerGraph()
{
	//オイラーグラフのキーを作成しなおさない場合はUpdateEditedEuler()


	if (s_owpEulerGraph) {
		if (g_edittarget != EDITTARGET_CAMERA) {
			s_owpEulerGraph->SetCurrentModel(s_model);
		}
		else {
			s_owpEulerGraph->SetCurrentModel(s_cameramodel);
		}		
	}

	if (!s_model || !s_owpLTimeline || !s_owpEulerGraph) {
		return 0;
	}

	//if (s_model && (s_model->GetLoadedFlag() == false)) {
	//	return;
	//}

	if (!s_model->ExistCurrentMotion()) {
		return 0;
	}


	//2023/10/13
	int eultiptime = (int)(s_owpEulerGraph->getCurrentTime() + 0.0001);


	if (s_model) {

		//if (!g_motionbrush_value || (g_motionbrush_frameleng != frameleng)) {
		int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
		if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
			_ASSERT(0);
			::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
			PostQuitMessage(result);
		}
		//}

		//int result = CreateMotionBrush(0, (double)(frameleng - 1), true);
		//_ASSERT(result == 0);

		s_owpEulerGraph->setDispScale(1.0);//倍率初期化
		s_owpEulerGraph->setDispOffset(0.0);//位置オフセット

		s_owpEulerGraph->deleteKey();
		s_owpEulerGraph->deleteLine();


		CModel* pmodel = 0;
		CMQOObject* pmqoobj = 0;
		int channelindex = -1;
		bool blendshapemode;
		blendshapemode = InBlendShapeMode(&pmodel, &pmqoobj, &channelindex);
		if (blendshapemode) {
			s_owpEulerGraph->setInBlendShapeMode(true);
			s_owpEulerGraph->newLine(0, 0, _T("X"));
			s_owpEulerGraph->newLine(0, 0, _T("S"));
			//s_owpLTimeline->setMaxTime( s_model->m_curmotinfo->frameleng - 1.0 );
			s_owpEulerGraph->setMaxTime(s_model->GetCurrentMaxFrame());//左端の１マスを選んだ状態がフレーム０を選んだ状態だから　-1 しない。


			int curtime;
			float minval = -100.0;
			float maxval = 100.0;

			int curmotid = pmodel->GetCurrentMotID();
			int frameleng = IntTime(s_model->GetCurrentMaxFrame());

			for (curtime = 0; curtime < frameleng; curtime++) {
				float currentvalue = pmqoobj->GetShapeAnimWeight(curmotid, curtime, channelindex);

				bool needCallRewrite = false;
				s_owpEulerGraph->newKey(needCallRewrite, _T("X"), (double)curtime, currentvalue);

				//2023/10/13
				if (curtime == eultiptime) {
					ChaVector3 eultip;
					eultip.SetParams(currentvalue, 0.0f, 0.0f);
					s_owpEulerGraph->setEulTip(eultip);
				}
			}

			s_owpEulerGraph->setEulMinMax(s_ikkind, minval, maxval);

			if (g_motionbrush_value) {

				double scalemin, scalemax;
				if (minval != maxval) {
					scalemin = minval;
					scalemax = maxval;
				}
				else {
					//Eulerが全て０　例えば全フレームを選択してツールの姿勢初期化を実行した後など
					//仮のminとmaxを指定
					scalemin = minval;
					scalemax = maxval + 10.0;
				}


				unsigned int scaleindex;
				for (scaleindex = 0; scaleindex < (unsigned int)frameleng; scaleindex++) {
					double curscalevalue;
					//if ((scaleindex >= (unsigned int)g_motionbrush_startframe) && (scaleindex <= (unsigned int)g_motionbrush_endframe) && (scaleindex < (unsigned int)g_motionbrush_frameleng)) {
					curscalevalue = (double)(*(g_motionbrush_value + scaleindex));// *(scalemax - scalemin) + scalemin;
					curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
					//}
					//else {
					//	curscalevalue = 0.0;// *(scalemax - scalemin) + scalemin;
					//	curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
					//}
					bool needCallRewrite = false;
					s_owpEulerGraph->newKey(needCallRewrite, _T("S"), (double)scaleindex, curscalevalue);//newkey
				}
			}

			s_owpEulerGraph->MakePointBuf();//2024/06/29
			s_owpEulerGraph->callRewrite();
		}
		else {

			s_owpEulerGraph->setInBlendShapeMode(false);
			s_owpEulerGraph->newLine(0, 0, _T("X"));
			s_owpEulerGraph->newLine(0, 0, _T("Y"));
			s_owpEulerGraph->newLine(0, 0, _T("Z"));
			s_owpEulerGraph->newLine(0, 0, _T("S"));
			////s_owpLTimeline->setMaxTime( s_model->m_curmotinfo->frameleng - 1.0 );
			//s_owpEulerGraph->setMaxTime(s_model->GetCurrentMaxFrame());//左端の１マスを選んだ状態がフレーム０を選んだ状態だから　-1 しない。

			int frameleng = 100;
			int graphmotid = 0;
			CBone* opebone = nullptr;
			opebone = GetEditTargetOpeBone(&graphmotid, &frameleng);

			s_owpEulerGraph->setMaxTime((double)frameleng);//左端の１マスを選んだ状態がフレーム０を選んだ状態だから　-1 しない。

			if (opebone) {

				int curtime;
				float minval = 0.0;
				float maxval = 0.0;
				int minfirstflag = 1;
				int maxfirstflag = 1;

				double firstframe = 0.0;
				ChaVector3 befeul;
				befeul.SetParams(0.0f, 0.0f, 0.0f);
				int ret;
				ret = s_owpEulerGraph->getEuler(firstframe, &befeul);
				if (ret) {
					befeul.SetParams(0.0f, 0.0f, 0.0f);
				}


				int graphkind = 0;
				if ((s_ikkind == 0) || (s_cameraeditkind == CAMERAANIMEDIT_ROT) || (s_cameraeditkind == CAMERAANIMEDIT_TWIST)) {//回転
					graphkind = 0;
				}
				else if ((s_ikkind == 1) || (s_cameraeditkind == CAMERAANIMEDIT_MV) || (s_cameraeditkind == CAMERAANIMEDIT_DIST)) {//移動
					graphkind = 1;
				}
				else if (s_ikkind == 2) {//スケール
					graphkind = 2;
				}

				for (curtime = 0; curtime < frameleng; curtime++) {
					const WCHAR* wbonename = opebone->GetWBoneName();
					ChaVector3 orgeul;
					orgeul.SetParams(0.0f, 0.0f, 0.0f);
					ChaVector3 cureul;
					cureul.SetParams(0.0f, 0.0f, 0.0f);
					//cureul = opebone->CalcFBXEul(curmi->motid, (double)curtime, &befeul);
					//befeul = cureul;//!!!!!!!

					CMotionPoint* curmp = opebone->GetMotionPoint(graphmotid, (double)curtime);
					if (curmp) {
						if (graphkind == 0) {//回転
							//opebone->GetWorldMat(curmi->motid, (double)curtime, 0, &cureul);
							cureul = opebone->GetLocalEul(g_limitdegflag,
								graphmotid, (double)curtime, 0);
						}
						else if (graphkind == 1) {//移動
							cureul = opebone->CalcLocalTraAnim(g_limitdegflag,
								graphmotid, (double)curtime);
						}
						else if (graphkind == 2) {//スケール
							cureul = opebone->CalcLocalScaleAnim(g_limitdegflag,
								graphmotid, (double)curtime);
						}
					}
					else {
						cureul.x = 0.0;
						cureul.y = 0.0;
						cureul.z = 0.0;
						//befeul = cureul;
					}
					if ((curtime == 0.0) || (curtime == 1.0) || IsValidNewEul(cureul, befeul)) {
						befeul = cureul;
					}

					bool needCallRewrite = false;
					s_owpEulerGraph->newKey(needCallRewrite, _T("X"), (double)curtime, cureul.x);
					s_owpEulerGraph->newKey(needCallRewrite, _T("Y"), (double)curtime, cureul.y);
					s_owpEulerGraph->newKey(needCallRewrite, _T("Z"), (double)curtime, cureul.z);
					//s_owpEulerGraph->newKey(_T("S"), (double)curtime, 0.0);


					//2023/10/13
					if (curtime == eultiptime) {
						s_owpEulerGraph->setEulTip(cureul);
					}


					if (minfirstflag == 1) {
						minval = (float)fmin(cureul.z, fmin(cureul.x, cureul.y));
						minfirstflag = 0;
					}
					if (minval > cureul.x) {
						minval = cureul.x;
					}
					if (minval > cureul.y) {
						minval = cureul.y;
					}
					if (minval > cureul.z) {
						minval = cureul.z;
					}

					if (maxfirstflag == 1) {
						maxval = (float)fmax(cureul.z, fmax(cureul.x, cureul.y));
						maxfirstflag = 0;
					}
					if (maxval < cureul.x) {
						maxval = cureul.x;
					}
					if (maxval < cureul.y) {
						maxval = cureul.y;
					}
					if (maxval < cureul.z) {
						maxval = cureul.z;
					}

				}

				s_owpEulerGraph->setEulMinMax(graphkind, minval, maxval);

				if (g_motionbrush_value) {

					double scalemin, scalemax;
					if (minval != maxval) {
						scalemin = minval;
						scalemax = maxval;
					}
					else {
						//Eulerが全て０　例えば全フレームを選択してツールの姿勢初期化を実行した後など
						//仮のminとmaxを指定
						scalemin = minval;
						scalemax = maxval + 10.0;
					}


					unsigned int scaleindex;
					for (scaleindex = 0; scaleindex < (unsigned int)frameleng; scaleindex++) {
						double curscalevalue;
						//if ((scaleindex >= (unsigned int)g_motionbrush_startframe) && (scaleindex <= (unsigned int)g_motionbrush_endframe) && (scaleindex < (unsigned int)g_motionbrush_frameleng)) {
						curscalevalue = (double)(*(g_motionbrush_value + scaleindex));// *(scalemax - scalemin) + scalemin;
						curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
						//}
						//else {
						//	curscalevalue = 0.0;// *(scalemax - scalemin) + scalemin;
						//	curscalevalue = (curscalevalue * 0.5 + 0.5) * (scalemax - scalemin) + scalemin;
						//}
						bool needCallRewrite = false;
						s_owpEulerGraph->newKey(needCallRewrite, _T("S"), (double)scaleindex, curscalevalue);//newkey
					}
				}
				s_owpEulerGraph->MakePointBuf();//2024/06/29
				s_owpEulerGraph->callRewrite();
			}
		}
		//s_owpEulerGraph->setCurrentTime(0.0, false);

	}

	return 0;
}


//タイムラインにモーションデータのキーを設定する
void refreshTimeline(OWP_Timeline& timeline) 
{
	if (s_owpEulerGraph) {
		s_owpEulerGraph->SetCurrentModel(s_model);
	}

	if (!s_model || !s_owpLTimeline || !s_owpEulerGraph) {
		return;
	}

	//if (s_model && (s_model->GetLoadedFlag() == false)) {
	//	return;
	//}

	MOTINFO curmi = GetEditTargetMotInfo();
	if (curmi.motid <= 0) {
		return;
	}

	


	int savecurrentline;// = timeline.getCurrentLine();
	if (s_curboneno >= 0) {
		const WCHAR* pbonename = s_model->GetWBoneName(s_curboneno);
		if (pbonename) {
			savecurrentline = timeline.getLineIndex(pbonename);
		}
		else {
			savecurrentline = 0;
		}
	}
	else {
		savecurrentline = 0;
	}

	int saveshowposline = timeline.getShowPosLine();


	//時刻幅を設定
	if (s_model) {
		timeline.setMaxTime(curmi.frameleng);

		s_owpLTimeline->deleteKey();
		s_owpLTimeline->deleteLine();

		s_owpLTimeline->newLine(0, 0, false, false, s_strcurrent);
		//s_owpLTimeline->newKey( s_strcurrent, 0.0, 0 );
		s_owpLTimeline->newLine(0, 0, false, false, s_streditrange);
		s_owpLTimeline->newLine(0, 0, false, false, s_strmark);
		//s_owpLTimeline->newKey( s_strmark, 0.0, 0 );

		//s_owpLTimeline->setMaxTime( s_model->m_curmotinfo->frameleng - 1.0 );
		s_owpLTimeline->setMaxTime(curmi.frameleng);//左端の１マスを選んだ状態がフレーム０を選んだ状態だから　-1 しない。


		int itime;
		for (itime = 0; itime < IntTime(curmi.frameleng); itime++) {
			s_owpLTimeline->newKey(s_streditrange, (double)itime, 0);
		}
	}

	//すべての行をクリア
	timeline.deleteKey();
	timeline.deleteLine();

	s_lineno2boneno.clear();
	s_boneno2lineno.clear();


	CBone* topbone = s_model->GetTopBone();

	if (s_model && s_model->GetTopBone()) {
		CallF(s_model->FillTimeLine(timeline, s_lineno2boneno, s_boneno2lineno), return);
	}
	else {
		WCHAR label[256];
		swprintf_s(label, 256, L"dummy%d", 0);
		timeline.newLine(0, 0, false, false, label);
	}

	//選択時刻を設定
	timeline.setCurrentLine(0);
	s_owpLTimeline->setCurrentTime(1.0, true);
	//timeline.setCurrentTime(0.0);


 //   CDXUTComboBox* pComboBox = g_SampleUI.GetComboBox( IDC_COMBO_BONE );
	//pComboBox->RemoveAllItems();
	//if( s_model ){
	//	map<int, CBone*>::iterator itrbone;
	//	for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	//		ULONG boneno = (ULONG)itrbone->first;
	//		CBone* opebone = itrbone->second;
	//		if( opebone && (boneno >= 0) ){
	//			char* nameptr = (char*)opebone->GetBoneName();
	//			WCHAR wname[256];
	//			MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, nameptr, 256, wname, 256 );
	//			pComboBox->AddItem( wname, ULongToPtr( boneno ) );
	//		}
	//	}
	//}

	timeline.setCurrentLine(savecurrentline);//2024/06/06
	timeline.setShowPosLine(saveshowposline);

	refreshEulerGraph();
	s_owpEulerGraph->setCurrentTime(1.0, false);
}



int AddBoneTra2(ChaVector3 diffvec)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		_ASSERT(0);
		return 0;
	}

	s_model->FKBoneTraUnderFK(g_limitdegflag, &s_editrange, s_curboneno, diffvec);

	s_editmotionflag = s_curboneno;

	return 0;
}

/*
int ImpulseBonePhysics(ChaVector3 diffvec)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()){
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone){
		_ASSERT(0);
		return 0;
	}

	s_model->ImpulseBoneRagdoll(0, &s_editrange, s_curboneno, diffvec);

	s_editmotionflag = s_curboneno;

	return 0;
}
*/

int AddBoneTra(int kind, float srctra)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		_ASSERT(0);
		return 0;
	}

	s_model->FKBoneTraAxisUnderFK(
		g_limitdegflag,
		&s_editrange, s_curboneno, kind, srctra, s_ikselectmat);
	s_editmotionflag = s_curboneno;

	return 0;
}

int AddBoneScale2(ChaVector3 diffvec)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		_ASSERT(0);
		return 0;
	}


	float scaleval;

	float upval = 1.1f;
	float downval = 0.9f;


	if (fabs(diffvec.x) >= fabs(diffvec.y)) {
		if (fabs(diffvec.x) >= fabs(diffvec.z)) {
			//x最大
			if (diffvec.x >= 0.0) {
				scaleval = upval;
			}
			else {
				scaleval = downval;
			}
		}
		else {
			//z最大
			if (diffvec.z >= 0.0) {
				scaleval = upval;
			}
			else {
				scaleval = downval;
			}
		}
	}
	else {
		if (fabs(diffvec.y) >= fabs(diffvec.z)) {
			//y最大
			if (diffvec.y >= 0.0) {
				scaleval = upval;
			}
			else {
				scaleval = downval;
			}
		}
		else {
			//z最大
			if (diffvec.z >= 0.0) {
				scaleval = upval;
			}
			else {
				scaleval = downval;
			}
		}
	}

	ChaVector3 scalevec;
	scalevec.x = scaleval;
	scalevec.y = scaleval;
	scalevec.z = scaleval;

	s_model->FKBoneScale(g_limitdegflag, 0, &s_editrange, s_curboneno, scalevec);

	s_editmotionflag = s_curboneno;

	return 0;
}

int AddBoneScale(int kind, float srcscale)
{
	if (!s_model || (s_curboneno < 0) && !s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		_ASSERT(0);
		return 0;
	}

	float upval = 1.1f;
	float downval = 0.9f;


	float scaleval;
	if (srcscale >= 0.0) {
		scaleval = upval;
	}
	else {
		scaleval = downval;
	}

	s_model->FKBoneScaleAxis(g_limitdegflag,
		0, &s_editrange, s_curboneno, kind, scaleval);


	s_editmotionflag = s_curboneno;

	return 0;
}


int DispMotionWindow()
{
	if (!s_timelineWnd) {
		return 0;
	}

	if (s_dispmw) {
		s_timelineWnd->setVisible(false);
		s_LtimelineWnd->setVisible(false);
		s_dispmw = false;
	}
	else {
		s_timelineWnd->setVisible(true);
		s_LtimelineWnd->setVisible(true);
		s_dispmw = true;
	}

	return 0;
}
int DispToolWindow()
{
	if (!s_toolWnd) {
		return 0;
	}

	if (s_disptool) {
		s_toolWnd->setVisible(false);
		s_disptool = false;
	}
	else {
		s_toolWnd->setVisible(true);
		s_disptool = true;
	}

	return 0;
}
int DispObjPanel()
{
	//#########################
	// not toggle : 2021/10/19
	//#########################


	bool savedispobj = s_dispobj;
	CreateLayerWnd();
	if (!s_layerWnd) {
		return 0;
	}
	if (!(s_layerWnd->getHWnd())) {
		return 0;
	}

	refreshModelPanel();

	if (!savedispobj) {
		s_layerWnd->setListenMouse(false);
		s_layerWnd->setVisible(false);
		s_dispobj = false;
	}
	else {
		s_layerWnd->setListenMouse(true);
		s_layerWnd->setVisible(true);
		s_dispobj = true;

		//RECT dlgrect;
		//GetWindowRect(s_layerWnd->getHWnd(), &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
	}

	return 0;
}
int DispModelPanel()
{
	//#########################
	// not toggle : 2021/10/19
	//#########################


	bool savedispmodel = s_dispmodel;

	if (s_modelpanel.scroll) {
		s_savemodelpanelshowposline = s_modelpanel.scroll->getShowPosLine();
	}
	else {
		s_savemodelpanelshowposline = 0;
	}

	CreateModelPanel();
	if (!s_modelpanel.panel || !(s_modelpanel.panel->getHWnd())) {
		return 0;
	}

	if (!savedispmodel) {
		//s_modelpanel.panel->setListenMouse(false);
		s_modelpanel.panel->setVisible(false);
		s_dispmodel = false;
		s_modelpanel.panel->setListenMouse(false);
	}
	else {
		//s_modelpanel.panel->setListenMouse(true);
		s_modelpanel.panel->setVisible(true);
		s_dispmodel = true;
		s_modelpanel.panel->callRewrite();
		s_modelpanel.panel->setListenMouse(true);

		//RECT dlgrect;
		//GetWindowRect(s_modelpanel.panel->getHWnd(), &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
	}

	//DispMotionPanel();//!!!!!!!!!!!!!
	//DispObjPanel();//!!!!!!!!!!!!!!!!


	return 0;
}

int DispCameraPanel()
{
	bool savedispcamera = s_dispcamera;

	if (s_camerapanel.scroll) {
		s_savecamerapanelshowposline = s_camerapanel.scroll->getShowPosLine();
	}
	else {
		s_savecamerapanelshowposline = 0;
	}

	CreateCameraPanel();
	if (!s_camerapanel.panel || !(s_camerapanel.panel->getHWnd())) {
		return 0;
	}

	if (!savedispcamera) {
		//s_camerapanel.panel->setListenMouse(false);
		s_camerapanel.panel->setVisible(false);
		s_dispcamera = false;
		s_camerapanel.panel->setListenMouse(false);
	}
	else {
		//s_camerapanel.panel->setListenMouse(true);
		s_camerapanel.panel->setVisible(true);
		s_dispcamera = true;
		s_camerapanel.panel->callRewrite();
		s_camerapanel.panel->setListenMouse(true);

		//RECT dlgrect;
		//GetWindowRect(s_camerapanel.panel->getHWnd(), &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
	}


	return 0;
}

int DispMotionPanel()
{
	//#########################
	// not toggle : 2021/10/19
	//#########################


	bool savedispmotion = s_dispmotion;

	if (s_motionpanel.scroll) {
		s_savemotionpanelshowposline = s_motionpanel.scroll->getShowPosLine();
	}
	else {
		s_savemotionpanelshowposline = 0;
	}

	CreateMotionPanel();
	if (!s_motionpanel.panel || !(s_motionpanel.panel->getHWnd())) {
		return 0;
	}

	if (!savedispmotion) {
		//s_motionpanel.panel->setListenMouse(false);
		s_motionpanel.panel->setVisible(false);
		s_dispmotion = false;
		s_motionpanel.panel->setListenMouse(false);
	}
	else {
		//s_motionpanel.panel->setListenMouse(true);
		s_motionpanel.panel->setVisible(true);
		s_dispmotion = true;
		s_motionpanel.panel->callRewrite();
		s_motionpanel.panel->setListenMouse(true);

		//RECT dlgrect;
		//GetWindowRect(s_motionpanel.panel->getHWnd(), &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
	}

	return 0;
}


//int DispConvBoneWindow()
//{
//	if (!s_model){
//		return 0;
//	}
//
//	CreateConvBoneWnd();
//
//	if (!s_convboneWnd){
//		return 0;
//	}
//
//	if (s_dispconvbone){
//		s_convboneWnd->setVisible(false);
//		s_dispconvbone = false;
//	}
//	else{
//		s_convboneWnd->setVisible(true);
//		s_dispconvbone = true;
//	}
//	return 0;
//}


int EraseKeyList()
{
	s_copyKeyInfoList.clear();
	s_copymotvec.clear();
	s_selectKeyInfoList.clear();
	s_deletedKeyInfoList.clear();

	return 0;
}

int AddMotion(const WCHAR* wfilename, double srcmotleng)
{
	if (!s_model) {
		return 0;
	}
	//if (s_model->GetNoBoneFlag() == true) {
	//	return 0;
	//}


	int motnum = (int)s_tlarray.size();
	if (motnum >= MAXMOTIONNUM) {
		::DSMessageBox(s_3dwnd, L"Can't Load More.", L"error!!!", MB_OK);
		//DSMessageBox( s_3dwnd, L"これ以上モーションを読み込めません。", L"モーション数が多すぎます。", MB_OK );
		return 0;
	}

	char motionname[256];
	ZeroMemory(motionname, 256);
	SYSTEMTIME systime;
	GetLocalTime(&systime);
	sprintf_s(motionname, 256, "motion%u%u%u%u%u%u%u",
		systime.wYear,
		systime.wMonth,
		systime.wDay,
		systime.wHour,
		systime.wMinute,
		systime.wSecond,
		systime.wMilliseconds
	);

	int newmotid = -1;
	double motleng;
	if (srcmotleng == 0.0) {
		motleng = 100.0;
	}
	else {
		motleng = srcmotleng;
	}

	s_model->WaitUpdateMatrixFinished();//2022/08/18
	const WCHAR* addwfilename;
	if (wfilename) {
		addwfilename = wfilename;
	}
	else {
		addwfilename = L"ForEmpty";
	}
	//CallF( s_model->AddMotion( motionname, wfilename, motleng, &newmotid ), return 1 );
	CallF(s_model->AddMotion(motionname, addwfilename, motleng, &newmotid), return 1);
	//_ASSERT(0);



	CallF(AddTimeLine(newmotid, true), return 1);


	//2023/02/11
	//OnAnimMenuよりも前 : OnAnimMenu()-->CalcBoneEulよりも前
	//InitCurMotion(0, 0);//2023/10/23 大分前からInitMPReq()はCModel::AddMotionから呼ばれるようになったので不要　2023/10/27 ただしGetLoadedFlag() == trueの必要

	int selindex = (int)s_tlarray.size() - 1;
	CallF(OnAnimMenu(true, selindex), return 1);


	return 0;
}

int OnRgdMorphMenu(int selindex)
{
	s_model->SetRgdMorphIndex(selindex);

	if (selindex < 0) {
		return 0;//!!!!!!!!!
	}

	_ASSERT(s_morphmenu);

	int iAnimSet, cAnimSets;
	cAnimSets = GetMenuItemCount(s_morphmenu);
	for (iAnimSet = 0; iAnimSet < cAnimSets; iAnimSet++)
	{
		RemoveMenu(s_morphmenu, 0, MF_BYPOSITION);
	}

	if (!s_model || !s_owpTimeline) {
		return 0;//!!!!!!!!!!!!!!!!!!
	}


	cAnimSets = (int)s_tlarray.size();

	if (cAnimSets <= 0) {
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	WCHAR wname[256];
	for (iAnimSet = 0; iAnimSet < cAnimSets; iAnimSet++)
	{
		int motid;
		motid = s_tlarray[iAnimSet].motionid;

		MOTINFO curmi = s_model->GetMotInfo(motid);
		if ((curmi.motid > 0) && (curmi.motname[0] != 0)) {
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, curmi.motname, 256, wname, 256);
			AppendMenu(s_morphmenu, MF_STRING, 64000 + iAnimSet, wname);
		}
		else {
			AppendMenu(s_morphmenu, MF_STRING, 64000 + iAnimSet, L"<No Animation Name>");
		}
	}

	if (cAnimSets > 0) {
		CheckMenuItem(s_mainmenu, 64000 + selindex, MF_CHECKED);
	}

	return 0;
}

int OnCameraMenu(bool dorefreshflag, int selindex, int saveundoflag)
{
	if (!s_cameramodel) {
		return 0;
	}


	s_underselectcamera = true;


	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	//大きいフレーム位置のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	//InitTimelineSelection();

	if (!s_model) {
		_ASSERT(0);
		SetMainWindowTitle();
		s_underselectcamera = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;
	}

	s_cameramenuindexmap[s_model] = selindex;

	if (selindex < 0) {
		SetMainWindowTitle();
		s_underselectcamera = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!
	}


	//if (!s_model || !s_owpTimeline) {//LoadFbxAnimの後に呼び出した場合　まだtimelineはNULL
	//	s_curmotid = -1;
	//	SetMainWindowTitle();
	//	s_underselectcamera = false;
	//	if (oldcursor) {
	//		SetCursor(oldcursor);
	//	}
	//	return 0;//!!!!!!!!!!!!!!!!!!
	//}


	MOTINFO camerami = s_cameramodel->GetCameraMotInfoByCameraIndex(selindex);
	if (camerami.motid <= 0) {
		//s_curmotid = -1;
		SetMainWindowTitle();
		s_underselectcamera = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!!!!!!!!!!
	}


	int cameramotid = camerami.motid;
	s_cameramodel->SetCameraMotionId(cameramotid);


	if (s_cameramodel->IsCameraLoaded()) {
		//fbxにカメラが在る場合
		ChaVector3 camdir;
		camdir.SetParams(0.0f, 0.0f, 1.0f);
		s_cameramodel->GetCameraProjParams(cameramotid, &g_projnear, &g_projfar, &g_fovy, &g_camEye, &camdir, &g_cameraupdir);

		g_initcamdist = (float)fmax(0.1f, fmin(s_maxcamdist, g_projfar));
		g_camtargetpos = g_camEye + camdir * g_initcamdist;

		ChangeCameraMode(2);//forcemode 反転をセット:0 強制オフ時:1 強制オン時:2

		g_camdist = g_initcamdist;

		g_befcamEye = g_camEye;
		g_befcamtargetpos = g_camtargetpos;

		////#replacing comment out#g_Camera->SetProjParams(g_fovy, s_fAspectRatio, g_projnear, g_projfar);
		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		//////#replacing comment out#g_Camera->SetRadius(fObjectRadius * 3.0f, fObjectRadius * 0.5f, fObjectRadius * 6.0f);

		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		SetCamera3DFromEyePos();
	}


	//if (saveundoflag == 1) {
	//	//if( s_model ){
	//	//	s_model->SaveUndoMotion(s_curboneno, s_curbaseno, &s_editrange, (double)g_applyrate);
	//	//}
	//	if (s_model) {
	//		PrepairUndo();
	//	}
	//}
	//else {
	//	if (s_model && s_owpLTimeline && s_owpEulerGraph) {
	//		//double curframe = s_model->GetCurMotInfo()->curframe;
	//		double curframe = 1.0;
	//		s_owpLTimeline->setCurrentTime(curframe, true);
	//		s_owpEulerGraph->setCurrentTime(curframe, false);
	//	}
	//}

	//if (s_owpLTimeline) {
	//	s_owpLTimeline->selectClear();
	//}


	//DispModelPanel();
	//refreshModelPanel();
	//DispMotionPanel();
	DispCameraPanel();

	SetMainWindowTitle();


	//InitTimelineSelection();


	if (oldcursor) {
		SetCursor(oldcursor);
	}


	s_underselectcamera = false;


	s_LrefreshEditTarget = 1;//refresh EditTarget, EulerGraph on CameraMode

	return 0;
}



int OnAnimMenu(bool dorefreshflag, int selindex, int saveundoflag)
{

	s_underselectmotion = true;

	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	//大きいフレーム位置のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
	//InitTimelineSelection();
	ClampTimelineSelection();//2024/06/23

	if (!s_model) {
		_ASSERT(0);
		SetMainWindowTitle();
		s_underselectmotion = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;
	}

	s_motmenuindexmap[s_model] = selindex;

	if (selindex < 0) {
		SetMainWindowTitle();
		s_underselectmotion = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!
	}

	_ASSERT(s_animmenu);

	int iAnimSet, cAnimSets;
	cAnimSets = GetMenuItemCount(s_animmenu);
	for (iAnimSet = 0; iAnimSet < cAnimSets; iAnimSet++)
	{
		RemoveMenu(s_animmenu, 0, MF_BYPOSITION);
	}


	if (!s_model || !s_owpTimeline) {
		s_curmotid = -1;
		SetMainWindowTitle();
		s_underselectmotion = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!!!!!!!!!!
	}

	cAnimSets = (int)s_tlarray.size();

	if (cAnimSets <= 0) {
		if (s_owpTimeline && dorefreshflag) {
			refreshTimeline(*s_owpTimeline);
		}
		s_curmotid = -1;
		SetMainWindowTitle();
		s_underselectmotion = false;
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	WCHAR wname[256];
	for (iAnimSet = 0; iAnimSet < cAnimSets; iAnimSet++)
	{
		int motid;
		motid = s_tlarray[iAnimSet].motionid;
		MOTINFO curmi = s_model->GetMotInfo(motid);
		if ((curmi.motid > 0) && (curmi.motname[0] != 0)) {
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, curmi.motname, 256, wname, 256);
			AppendMenu(s_animmenu, MF_STRING, 59900 + iAnimSet, wname);
		}
		else {
			AppendMenu(s_animmenu, MF_STRING, 59900 + iAnimSet, L"<No Animation Name>");
		}
	}

	if (cAnimSets > 0) {
		CheckMenuItem(s_mainmenu, 59900 + selindex, MF_CHECKED);

		int selmotid;
		selmotid = s_tlarray[selindex].motionid;
		if (selmotid > 0) {
			int chkresult;
			chkresult = s_model->SetCurrentMotion(selmotid);
			if (chkresult != 0) {
				_ASSERT(0);
				if (oldcursor) {
					SetCursor(oldcursor);
				}
				return 1;
			}
			//EraseKeyList();
			if (s_owpTimeline) {
				s_owpTimeline->setCurrentLine(0);
				//s_owpTimeline->setCurrentTime( 0.0 );
				s_owpTimeline->setCurrentTime(1.0);
			}
			s_curmotid = selmotid;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			if (dorefreshflag) {
				s_model->CreateBtObject(g_limitdegflag, 1);
				//s_model->CalcBoneEul(-1);

				//2023/10/26　コメントアウト
				//s_model->CalcBoneEul(g_limitdegflag, selmotid);//2021/08/25
			}


			//2023/01/29 初回物理再生のために必要
			//s_savelimitdegflag = g_limitdegflag;
			//g_limitdegflag = true;
			//ClearLimitedWM(s_model);
			//ApplyNewLimitsToWM(s_model);
			//g_limitdegflag = s_savelimitdegflag;


			//2023/02/08
			if (g_limitdegflag == true) {
				ClearLimitedWM(s_model);
				CopyWorldToLimitedWorld(s_model);
				ApplyNewLimitsToWM(s_model);
			}

			if (s_spguisw[SPGUISW_BLENDSHAPE].state && 
				!s_undoFlag && !s_redoFlag && 
				!s_blendshapedlg.GetBlendShapeUnderSelectFromUndo() && 
				!s_blendshapedlg.GetBlendShapeUnderSelectFromRefresh()) {
				//2024/06/30 モデル切替モーション切り替え時に　BlendShapeの操作中ターゲットのグラフを表示
				s_blendshapedlg.SetBlendShapeUnderSelect(true);
			}
		}
	}


	if (s_owpTimeline && dorefreshflag) {
		//タイムラインのキーを設定
		refreshTimeline(*s_owpTimeline);
		//s_owpTimeline->setCurrentTime( 0.0 );
		s_owpTimeline->setCurrentTime(1.0);
	}

	OnSetMotSpeed();//2022/09/16

	//MOTINFO* curmi = s_model->GetCurMotInfo();
	//if (curmi) {
	//	OnAddMotion(curmi->motid);
	//}

	if (saveundoflag == 1) {
		//if( s_model ){
		//	s_model->SaveUndoMotion(s_curboneno, s_curbaseno, &s_editrange, (double)g_applyrate);
		//}
		if ((InterlockedAdd(&g_retargetbatchflag, 0) == 0) && s_model) {

			//#####################################################################
			//2024/06/05
			//モーション変更前のPrepairUndoは、ボーンモーションとカメラアニメについて呼び出す
			//#####################################################################
			PrepairUndo();
		}
	}
	else {
		if (s_model && s_owpLTimeline && s_owpEulerGraph) {
			//double curframe = s_model->GetCurMotInfo()->curframe;
			double curframe = 1.0;
			s_owpLTimeline->setCurrentTime(curframe, true);
			s_owpEulerGraph->setCurrentTime(curframe, false);
		}
	}

	if (s_owpLTimeline) {
		s_owpLTimeline->selectClear();
	}

	DispModelPanel();
	//refreshModelPanel();
	DispMotionPanel();
	DispCameraPanel();

	SetMainWindowTitle();


	//InitTimelineSelection();
	ClampTimelineSelection();//2024/06/23


	s_underselectmotion = false;


	{
		//2024/06/30
		//モーションを切り替えた際に　グラフ上のフレーム選択は引き継がれていたが　モーフ編集するとカレントフレームしかしない状態だったので対策
		s_buttonselectstart = g_motionbrush_startframe;
		s_buttonselectend = g_motionbrush_endframe;
		OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);
		int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
		if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
			_ASSERT(0);
			::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
			PostQuitMessage(result);
		}
	}


	if (s_model->GetInitAxisMatX() == 0) {//OnAnimMenuに移動
		if (s_owpLTimeline) {
			s_owpLTimeline->setCurrentTime(0.0, true);
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->setCurrentTime(0.0, false);
		}
		s_model->SetMotionFrame(0.0);
		ChaMatrix tmpwm = s_model->GetWorldMat();
		s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
		//ここでAxisMatXの初期化
		s_model->CreateBtObject(g_limitdegflag, 1);
		s_model->CalcBtAxismat(2);//2
		s_model->SetInitAxisMatX(1);
	}

	if (oldcursor) {
		SetCursor(oldcursor);
	}

	return 0;
}

int OnChangeModel(int selindex, bool forceflag, bool callundo)
{
	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}

	CModel* setmodel = s_chascene->GetModel(selindex);
	if (setmodel) {
		return OnChangeModel(setmodel, forceflag, callundo);
	}
	else {
		int dbgflag1 = 1;
		return 2;
	}
}
int OnChangeModel(CModel* selmodel, bool forceflag, bool callundo)
{
	if (!s_chascene || !s_model) {
		return 0;
	}

	if (!forceflag && (s_model == selmodel)) {
		//2024/02/09
		//操作中にモーションやカメラの状態が変わるのを出来るだけ防ぐために
		//選択状態が変わらない場合には　OnModelMenuを呼ばないで　すぐに0リターンする
		return 0;
	}

	if (callundo) {
		PrepairUndo_SelectModel(s_model, selmodel);//2024/06/25
	}


	//int modelnum = s_chascene->GetModelNum();
	//int modelindex;
	//int selmodelindex = -1;
	//for (modelindex = 0; modelindex < modelnum; modelindex++) {
	//	CModel* chkmodel = s_chascene->GetModel(modelindex);
	//	if (chkmodel && (chkmodel == selmodel)) {
	//		selmodelindex = modelindex;
	//		break;
	//	}
	//}
	int selmodelindex = s_chascene->FindModelIndex(selmodel);

	if (selmodelindex >= 0) {
		ActivatePanel(0);
		OnModelMenu(true, selmodelindex, 1);
		ActivatePanel(1);
		return 0;
	}
	else {
		return 0;
	}
}

int OnModelMenu(bool dorefreshtl, int selindex, int callbymenu)
{
	s_underselectmodel = true;

	s_customrigbone = 0;
	s_curboneno = -1;//2024/03/03
	s_saveboneno = -1;//2024/08/03 RollBackCurBoneNo()で戻らないように初期化

	//if (s_anglelimitdlg) {
	//	s_underanglelimithscroll = 0;
	//	DestroyWindow(s_anglelimitdlg);
	//	s_anglelimitdlg = 0;
	//}
	if (s_limiteuldlg.GetVisible()) {
		ShowLimitEulerWnd(false);
	}
	if (s_rotaxisdlg) {
		DestroyWindow(s_rotaxisdlg);
		s_rotaxisdlg = 0;
	}
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}
	s_oprigflag = 0;


	if (s_sidemenu_sellock) {
		//AlwaysLockにチェックを入れたままモデルを変えると
		//カメラ距離が急に大きくなり上限値を越えてカメラターゲットが動かなくなることがあった
		//モデル変更時にはAlwaysLockのチェックを外す
		//この処理と上述のs_curboneno, s_savebonenoの初期化も必要
		s_sidemenu_sellock->setValue(false, false);
	}



	//if (callbymenu == 1) {
	//	if (s_model && (s_curmodelmenuindex >= 0) && s_chascene && (s_chascene->GetModelNum() != 0)) {
	//		s_chascene->SetTimelineArray(s_curmodelmenuindex, s_tlarray);
	//		s_chascene->SetLineno2Boneno(s_curmodelmenuindex, s_lineno2boneno, s_boneno2lineno);
	//	}
	//}

	s_curmodelmenuindex = selindex;

	_ASSERT(s_modelmenu);
	int iMdlSet, cMdlSets;
	cMdlSets = GetMenuItemCount(s_modelmenu);
	for (iMdlSet = 0; iMdlSet < cMdlSets; iMdlSet++)
	{
		RemoveMenu(s_modelmenu, 0, MF_BYPOSITION);
	}

	if ((selindex < 0) || !s_model) {
		OrgWindowListenMouse(false);

		s_model = 0;
		s_curboneno = -1;
		SetModel2Dlgs(nullptr);

		if (s_owpTimeline && dorefreshtl) {
			refreshTimeline(*s_owpTimeline);
		}
		//refreshModelPanel();
		s_dispobj = false;
		DispObjPanel();
		refreshModelPanel();
		DispModelPanel();
		DispMotionPanel();
		DispCameraPanel();


		SetMainWindowTitle();
		ShowDispGroupWnd(s_spdispsw[SPDISPSW_DISPGROUP].state);
		ShowLaterTransparentWnd(s_spdispsw[SPDISPSW_LATERTRANSPARENT].state);
		ShowShaderTypeWnd(s_spdispsw[SPDISPSW_SHADERTYPE].state);
		ShowShadowParamsWnd(s_spdispsw[SPDISPSW_SHADOWPARAMS].state);
		ShowGUIDlgBlendShape(s_spguisw[SPGUISW_BLENDSHAPE].state);


		s_underselectmodel = false;
		return 0;//!!!!!!!!!
	}

	if (s_chascene) {
		cMdlSets = s_chascene->GetModelNum();
	}
	else {
		cMdlSets = 0;
	}

	if (cMdlSets <= 0) {
		OrgWindowListenMouse(false);

		s_model = 0;
		SetModel2Dlgs(nullptr);

		if (s_owpTimeline && dorefreshtl) {
			refreshTimeline(*s_owpTimeline);
		}
		s_dispobj = false;
		DispObjPanel();
		refreshModelPanel();
		DispModelPanel();
		DispMotionPanel();
		DispCameraPanel();

		SetMainWindowTitle();
		ShowDispGroupWnd(s_spdispsw[SPDISPSW_DISPGROUP].state);
		ShowLaterTransparentWnd(s_spdispsw[SPDISPSW_LATERTRANSPARENT].state);
		ShowShaderTypeWnd(s_spdispsw[SPDISPSW_SHADERTYPE].state);
		ShowShadowParamsWnd(s_spdispsw[SPDISPSW_SHADOWPARAMS].state);
		ShowGUIDlgBlendShape(s_spguisw[SPGUISW_BLENDSHAPE].state);


		s_underselectmodel = false;
		return 0;//!!!!!!!!!!!!!!!!!!!
	}
	else {
		const WCHAR* wname;
		for (iMdlSet = 0; iMdlSet < cMdlSets; iMdlSet++)
		{
			if (s_chascene) {
				wname = s_chascene->GetModelFileName(iMdlSet);
				if (*wname != 0)
					AppendMenu(s_modelmenu, MF_STRING, 61000 + iMdlSet, wname);
				else
					AppendMenu(s_modelmenu, MF_STRING, 61000 + iMdlSet, L"<No Model Name>");
			}
			else {
				AppendMenu(s_modelmenu, MF_STRING, 61000 + iMdlSet, L"<No Model Name>");
			}
		}

		CheckMenuItem(s_mainmenu, 61000 + selindex, MF_CHECKED);

		if (s_chascene) {
			s_model = s_chascene->GetModel(selindex);
		}
		else {
			_ASSERT(0);
			s_model = 0;
		}

		SetModel2Dlgs(s_model);

		if (s_model && s_chascene) {
			s_chascene->GetTimelineArray(selindex, s_tlarray);
			s_motmenuindexmap[s_model] = s_chascene->GetMotMenuIndex(selindex);
			s_chascene->GetLineno2Boneno(selindex, s_lineno2boneno, s_boneno2lineno);

			//s_dispobj = false;
			DispObjPanel();
			refreshModelPanel();
			ShowDispGroupWnd(s_spdispsw[SPDISPSW_DISPGROUP].state);
			ShowLaterTransparentWnd(s_spdispsw[SPDISPSW_LATERTRANSPARENT].state);
			ShowShaderTypeWnd(s_spdispsw[SPDISPSW_SHADERTYPE].state);
			ShowShadowParamsWnd(s_spdispsw[SPDISPSW_SHADOWPARAMS].state);
			ShowGUIDlgBlendShape(s_spguisw[SPGUISW_BLENDSHAPE].state);

			OnAnimMenu(dorefreshtl, s_motmenuindexmap[s_model]);
		}


		//大きいフレーム位置のまま小さいフレーム長のデータを読み込んだ時にエラーにならないように。
		//InitTimelineSelection();
		ClampTimelineSelection();//2024/06/23




		if (s_model) {
			if (s_model->GetRigidElemInfoSize() > 0) {
				int result1 = OnREMenu(0, 0);
				if (result1) {
					s_underselectmodel = false;
					return 0;
				}
				int result2 = OnRgdMenu(0, 0);
				if (result2) {
					s_underselectmodel = false;
					return 0;
				}
				int result3 = OnImpMenu(0);
				if (result3) {
					s_underselectmodel = false;
					return 0;
				}
			}
			else {
				int result1 = OnREMenu(-1, 0);
				if (result1) {
					s_underselectmodel = false;
					return 0;
				}
				int result2 = OnRgdMenu(-1, 0);
				if (result2) {
					s_underselectmodel = false;
					return 0;
				}
				int result3 = OnImpMenu(-1);
				if (result3) {
					s_underselectmodel = false;
					return 0;
				}
			}
		}
		else {
			int result1 = OnREMenu(-1, 0);
			if (result1) {
				s_underselectmodel = false;
				return 0;
			}
			int result2 = OnRgdMenu(-1, 0);
			if (result2) {
				s_underselectmodel = false;
				return 0;
			}
			int result3 = OnImpMenu(-1);
			if (result3) {
				s_underselectmodel = false;
				return 0;
			}
		}


		//g_SampleUI.GetSlider(IDC_SPEED)->SetValue((int)(g_dspeed * 100.0f));
		//WCHAR sz[100];
		//swprintf_s(sz, 100, L"Speed: %0.4f", g_dspeed);
		//g_SampleUI.GetStatic(IDC_SPEED_STATIC)->SetText(sz);

		//SetModel2Dlgs()へ移動		
		////if (!g_bvh2fbxbatchflag && !g_motioncachebatchflag && !g_retargetbatchflag) {
		////if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 0) && (InterlockedAdd(&g_motioncachebatchflag, 0) == 0) && (InterlockedAdd(&g_retargetbatchflag, 0) == 0)) {
		//if (!s_retargetdlg.GetRetargetRetargetGUIFlag() && //2024/06/27 GUIからのリターゲット実行中に設定を初期化しないようにスキップ
		//	((s_dispconvbone == true) && 
		//	(InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 0) && (InterlockedAdd(&g_retargetbatchflag, 0) == 0))
		//	) {
		//	CreateConvBoneWnd();//!!!!!!!!!!!!! モデル選択変更によりリターゲットウインドウ作り直し
		//}

		SetTimelineHasRigFlag();

		SetMainWindowTitle();

		
	}

	s_underselectmodel = false;

	return 0;
}

int OnREMenu(int selindex, int callbymenu)
{
	if (!s_model) {
		_ASSERT(0);
		SetMainWindowTitle();
		return 0;
	}
	s_reindexmap[s_model] = selindex;

	_ASSERT(s_remenu);
	int iReSet, cReSets;
	cReSets = GetMenuItemCount(s_remenu);
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		RemoveMenu(s_remenu, 0, MF_BYPOSITION);
	}

	if ((selindex < 0) || !s_model) {
		AppendMenu(s_remenu, MF_STRING, 62000, L"NotLoaded");
		SetMainWindowTitle();
		return 0;//!!!!!!!!!
	}

	cReSets = s_model->GetRigidElemInfoSize();
	if (cReSets <= 0) {
		if (s_model) {
			s_reindexmap[s_model] = -1;
		}
		AppendMenu(s_remenu, MF_STRING, 62000, L"NotLoaded");
		SetMainWindowTitle();
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	WCHAR wname[MAX_PATH];
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		ZeroMemory(wname, sizeof(WCHAR) * MAX_PATH);
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s_model->GetRigidElemInfo(iReSet).filename, MAX_PATH, wname, MAX_PATH);
		AppendMenu(s_remenu, MF_STRING, 62000 + iReSet, wname);
		DbgOut(L"OnREMenu : addmenu %s\r\n", wname);
	}

	if (cReSets > 0) {
		CheckMenuItem(s_mainmenu, 62000 + selindex, MF_CHECKED);
	}

	CallF(s_model->SetCurrentRigidElem(s_reindexmap[s_model]), return 1);

	s_rigidparamsdlg.SetModel(s_model, s_curboneno, s_reindexmap, s_rgdindexmap);

	SetMainWindowTitle();

	return 0;
}

int OnRgdMenu(int selindex, int callbymenu)
{
	if (s_model) {
		s_model->SetRgdIndex(selindex);
	}
	else {
		_ASSERT(0);
		return 0;
	}
	s_rgdindexmap[s_model] = selindex;

	_ASSERT(s_rgdmenu);
	int iReSet, cReSets;
	cReSets = GetMenuItemCount(s_rgdmenu);
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		RemoveMenu(s_rgdmenu, 0, MF_BYPOSITION);
	}

	if ((selindex < 0) || !s_model) {
		AppendMenu(s_rgdmenu, MF_STRING, 63000, L"NotLoaded");
		return 0;//!!!!!!!!!
	}

	cReSets = s_model->GetRigidElemInfoSize();
	if (cReSets <= 0) {
		s_rgdindexmap[s_model] = -1;
		AppendMenu(s_rgdmenu, MF_STRING, 63000, L"NotLoaded");
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	WCHAR wname[MAX_PATH];
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		ZeroMemory(wname, sizeof(WCHAR) * MAX_PATH);
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s_model->GetRigidElemInfo(iReSet).filename, MAX_PATH, wname, MAX_PATH);
		AppendMenu(s_rgdmenu, MF_STRING, 63000 + iReSet, wname);
	}

	if (cReSets > 0) {
		CheckMenuItem(s_mainmenu, 63000 + selindex, MF_CHECKED);
	}

	//	CallF( s_model->SetCurrentRigidElem( s_curreindex ), return 1 );

	return 0;
}
int OnImpMenu(int selindex)
{
	if (s_model) {
		s_model->SetCurImpIndex(selindex);
	}

	_ASSERT(s_impmenu);
	int iReSet, cReSets;
	cReSets = GetMenuItemCount(s_impmenu);
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		RemoveMenu(s_impmenu, 0, MF_BYPOSITION);
	}

	if ((selindex < 0) || !s_model) {
		AppendMenu(s_impmenu, MF_STRING, 64500, L"NotLoaded");
		return 0;//!!!!!!!!!
	}

	cReSets = s_model->GetImpInfoSize();
	if (cReSets <= 0) {
		s_model->SetCurImpIndex(0);
		AppendMenu(s_impmenu, MF_STRING, 64500, L"NotLoaded");
		return 0;//!!!!!!!!!!!!!!!!!!!
	}

	WCHAR wname[MAX_PATH];
	for (iReSet = 0; iReSet < cReSets; iReSet++)
	{
		ZeroMemory(wname, sizeof(WCHAR) * MAX_PATH);
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s_model->GetImpInfo(iReSet).c_str(), -1, wname, MAX_PATH);
		AppendMenu(s_impmenu, MF_STRING, 64500 + iReSet, wname);
	}

	if (cReSets > 0) {
		CheckMenuItem(s_mainmenu, 64500 + selindex, MF_CHECKED);
	}

	return 0;
}

int OnDelMotion(int delmenuindex, bool ondelbutton)//default : ondelbutton = false
{
	//if (s_underdelmotion == true) {
	//	//再入防止
	//	return 0;
	//}

	//s_underdelmotion = true;

	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}


	int tlnum = (int)s_tlarray.size();
	if ((tlnum <= 0) || (delmenuindex < 0) || (delmenuindex >= tlnum)) {
		//s_underdelmotion = false;
		return 0;
	}
	if ((ondelbutton == true) && (tlnum <= 1)) {
		//s_underdelmotion = false;
		return 0;
	}

	int delmotid = s_tlarray[delmenuindex].motionid;
	int result;
	s_model->WaitUpdateMatrixFinished();//2022/08/18
	result = s_model->DeleteMotion(delmotid);
	//if (result) {
	//	//s_underdelmotion = false;
	//	return 1;
	//}
	SetCameraModel();


	//vector<TLELEM> tmptlarray;
	//tmptlarray = s_tlarray;
	//s_tlarray.clear();
	//int tlno;
	//int settlcount = 0;
	//for (tlno = 0; tlno < tlnum; tlno++) {
	//	if (tlno != delmenuindex) {
	//		s_tlarray[settlcount] = tmptlarray[tlno];
	//		settlcount++;
	//	}
	//}
	int tlno;
	//for (tlno = delmenuindex; tlno < (tlnum - 1); tlno++) {
	//	s_tlarray[tlno] = s_tlarray[tlno + 1];
	//}
	std::vector<TLELEM>::iterator itrtl = s_tlarray.begin();
	for (tlno = 0; tlno < delmenuindex; tlno++) {
		itrtl++;
	}
	s_tlarray.erase(itrtl);
	//s_tlarray.pop_back();


	//2022/09/13
	int currentmodelindex = s_chascene->FindModelIndex(s_model);
	if (s_chascene && (currentmodelindex >= 0)) {
		s_chascene->SetTimelineArray(currentmodelindex, s_tlarray);
	}


	int newtlnum = (int)s_tlarray.size();
	if (newtlnum == 0) {
		AddMotion(L"forempty", 100.0);
	}
	OnAnimMenu(true, 0);

	DispMotionPanel();
	DispCameraPanel();

	//s_underdelmotion = false;

	return 0;
}

int OnDispModel(int modelcnt)
{
	int mdlnum;
	if (s_chascene) {
		mdlnum = s_chascene->GetModelNum();
	}
	else {
		mdlnum = 0;
	}
	if ((mdlnum <= 0) || (modelcnt < 0) || (modelcnt >= mdlnum)) {
		return 0;
	}

	CModel* dispmodel;
	if (s_chascene) {
		dispmodel = s_chascene->GetModel(modelcnt);
	}
	else {
		dispmodel = 0;
	}
	if (dispmodel && s_modelpanel.checkvec[modelcnt] && s_modelpanel.panel) {
		dispmodel->SetModelDisp(s_modelpanel.checkvec[modelcnt]->getValue());
		s_modelpanel.panel->callRewrite();
	}

	return 0;
}

int OnDelModel(int delmenuindex, bool ondelbutton)//default : ondelbutton == false
{
	//s_underdelmodel = true;
	if (!s_chascene) {
		_ASSERT(0);
		return 0;
	}

	StopBt();//2023/11/03

	int mdlnum;
	mdlnum = s_chascene->GetModelNum();
	if ((mdlnum <= 0) || (delmenuindex < 0) || (delmenuindex >= mdlnum)) {
		//s_underdelmodel = false;
		return 0;
	}

	if (mdlnum == 1) {
		OnDelAllModel();//psdk rootnode初期化
		//s_underdelmodel = false;
		return 0;
	}

	s_chascene->DelModel(delmenuindex, s_grassElemVec);

	SetCameraModel();

	if (s_chascene->ModelEmpty()) {
		s_curboneno = -1;
		s_model = 0;
		s_curmodelmenuindex = -1;
		s_tlarray.clear();
		s_motmenuindexmap.clear();
		s_cameramenuindexmap.clear();
		s_lineno2boneno.clear();
		s_boneno2lineno.clear();
	}
	else {
		s_curboneno = -1;
		s_model = s_chascene->GetModel(0);
		if (s_model) {
			s_motmenuindexmap[s_model] = s_chascene->GetMotMenuIndex(0);
		}
		s_chascene->GetTimelineArray(0, s_tlarray);
		s_chascene->GetLineno2Boneno(0, s_lineno2boneno, s_boneno2lineno);
	}

	//OnModelMenu(true, 0, 0);
	bool forceflag = true;
	bool callundo = true;
	OnChangeModel(0, forceflag, callundo);

	DispModelPanel();

	if (!s_model) {
		OrgWindowListenMouse(false);
	}

	//s_underdelmodel = false;

	return 0;
}

int OnDelAllModel()
{
	if (!s_chascene) {
		_ASSERT(0);
		return 0;
	}

	StopBt();//2023/11/03

	OrgWindowListenMouse(false);

	s_chascene->DelAllModel();

	//SetCameraModel();
	s_cameramodel = 0;//2023/06/02

	s_curboneno = -1;
	s_model = 0;
	s_curmodelmenuindex = -1;
	s_tlarray.clear();
	s_motmenuindexmap.clear();
	s_cameramenuindexmap.clear();
	s_lineno2boneno.clear();
	s_boneno2lineno.clear();

	DestroyGrassElem();//2024/05/13

	OnModelMenu(true, -1, 0);

	DispModelPanel();

	return 0;
}






int refreshModelPanel()
{
	if (!s_layerWnd || !s_owpLayerTable) {
		return 0;
	}

	//すべての行をクリア
	s_owpLayerTable->deleteLine();

	WCHAR label[256];
	int objnum = 0;

	if (s_model) {
		objnum = s_model->GetMqoObjectSize();
	}
	else {
		objnum = 0;
	}

	if (objnum > 0) {
		map<int, CMQOObject*>::iterator itrobj;
		for (itrobj = s_model->GetMqoObjectBegin(); itrobj != s_model->GetMqoObjectEnd(); itrobj++) {
			CMQOObject* curobj = itrobj->second;
			WCHAR wname[256];
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (char*)curobj->GetName(), 256, wname, 256);
			s_owpLayerTable->newLine(wname, (void*)curobj);
			s_owpLayerTable->setVisible(wname, (curobj->GetDispFlag() > 0), true);
		}
	}
	else {
		wcscpy_s(label, 256, L"dummy name");
		s_owpLayerTable->newLine(label, 0);
	}

	//if (s_modelpanel.radiobutton && ((int)s_modelindex.size() > 0) && (s_curmodelmenuindex >= 0)) {
	//	//if( s_curmodelmenuindex >= 0 ){
	//	s_modelpanel.modelindex = s_curmodelmenuindex;
	//	s_modelpanel.radiobutton->setSelectIndex(s_modelpanel.modelindex);
	//	//}
	//}

	return 0;
}

//int refreshMotionPanel()
//{
//	if (s_motionpanel.radiobutton && ((int)s_modelindex.size() > 0) && (s_curmodelmenuindex >= 0)) {
//		if (s_model && (s_model->GetMotInfoSize() > 0) && s_motmenuindexmap[s_model] >= 0) {
//			s_motionpanel.radiobutton->setSelectIndex(s_motmenuindexmap[s_model]);
//		}
//	}
//
//	return 0;
//}


float CalcSelectScale()
{
	if (!s_model) {
		return 0.0f;
	}

	MODELBOUND mb;
	mb.Init();
	//s_model->GetModelBound(&mb);//計算する　非常に重い
	mb = s_model->GetCalclatedModelBound();
	double modelr;
	if (mb.IsValid()) {
		modelr = (double)mb.r;

	}
	else {
		modelr = 10.0;
	}
	
	s_selectscale = (float)fmax(0.01f, fmin(2.0f, (float)(modelr * 0.0020)));//2023/05/19
	if (s_oprigflag == 1) {
		s_selectscale *= 0.125f;
		//s_selectscale *= 0.50f;
	}

	s_selectscale *= ((float)s_selectuserscale * 0.01f);//2023/09/07


	//if (g_4kresolution) {
	//	s_selectscale *= 0.5f;
	//}


	//ChaMatrix selm;
	//selm = s_selm;
	//ChaMatrixNormalizeRot(&selm);
	//ChaVector3 orgcenterpos = curboneptr->GetJointFPos();
	//ChaVector3 orgedgepos.SetParams(orgcenterpos.x, orgcenterpos.y + 100.0f, orgcenterpos.z);
	//ChaVector3 dispcenterpos, dispedgepos;
	//ChaVector3TransformCoord(&dispcenterpos, &orgcenterpos, &selm);
	//ChaVector3TransformCoord(&dispedgepos, &orgedgepos, &selm);
	//double lineleng = (dispedgepos.x - dispcenterpos.x) * (dispedgepos.x - dispcenterpos.x) + (dispedgepos.y - dispcenterpos.y) * (dispedgepos.y - dispcenterpos.y);
	//if (lineleng > 0.00001) {
	//	lineleng = sqrt(lineleng);
	//	//s_selectscale = 0.0020f / lineleng;
	//	//s_selectscale = (modelr * 0.015f * 0.75f) / (lineleng * 100.0f);
	//	s_selectscale = (float)((modelr * 0.40) / lineleng);// *(g_camdist / g_initcamdist);
	//	if (s_oprigflag == 1) {
	//		s_selectscale *= 0.25f;
	//		//s_selectscale *= 0.50f;
	//	}
	//	if (g_4kresolution) {
	//		s_selectscale *= 0.5f;
	//	}
	//}
	//else {
	//	//s_selectscaleの計算はしない。s_selectscaleは前回の計算値を使用。
	//}

	return s_selectscale;
}


int RenderSelectMark(myRenderer::RenderingEngine* re, RenderContext* pRenderContext, int renderflag)
{
	if (!re || !pRenderContext) {
		_ASSERT(0);
		return 1;
	}

	if (!s_model) {
		return 0;
	}

	if (s_camtargetdisp == false) {
		if (s_curboneno < 0) {
			return 0;
		}

		if (!s_model->ExistCurrentMotion()) {
			return 0;
		}

		CBone* curboneptr = s_model->GetBoneByID(s_curboneno);
		if (curboneptr) {
			if (s_onragdollik == 0) {
				int multworld = 1;
				//s_selm = curboneptr->CalcManipulatorMatrix(1, multworld, curmi->motid, curmi->curframe);
				int calccapsuleflag = 0;
				//s_selm_posture = s_selm;
				//s_selm_posture = curboneptr->CalcManipulatorPostureMatrix(calccapsuleflag, 0, multworld, 0);

				if (curboneptr && curboneptr->GetParent(false) && curboneptr->GetParent(false)->IsSkeleton()) {
					curboneptr->GetParent(false)->CalcAxisMatX_Manipulator(g_limitdegflag, g_boneaxis, 0, curboneptr, &s_selm, 0);
				}
				else {
					s_selm.SetIdentity();
				}
				s_selm_posture = s_selm;
			}


			CalcSelectScale();//s_selectscaleにセット

			ChaMatrix scalemat;
			ChaMatrixIdentity(&scalemat);
			ChaMatrixScaling(&scalemat, s_selectscale, s_selectscale, s_selectscale);

			ChaVector3 bonepos = curboneptr->GetWorldPos(g_limitdegflag, s_model->GetCurrentMotID(), s_model->GetCurrentFrame());

			//s_selectmat = scalemat * s_selm;
			//s_selectmat = s_selm;
			s_selectmat = s_selm * s_model->GetWorldMat();//2023/03/34
			ChaMatrixNormalizeRot(&s_selectmat);
			s_selectmat = scalemat * s_selectmat;

			s_selectmat.SetTranslation(bonepos);

			//s_selectmat_posture = scalemat * s_selm_posture;
			s_selectmat_posture = s_selm_posture;
			ChaMatrixNormalizeRot(&s_selectmat_posture);
			s_selectmat_posture = scalemat * s_selectmat_posture;

			s_selectmat_posture.SetTranslation(bonepos);

			if (renderflag) {
				//g_hmVP->SetMatrix(s_matVP.GetDataPtr());

				//g_hmWorld->SetMatrix(s_selectmat.GetDataPtr());
				RenderSelectFunc(re);


				//g_hmWorld->SetMatrix(s_selectmat_posture.GetDataPtr());
				if (s_oprigflag == 0) {
					RenderSelectPostureFunc(re);
				}
				else {
					if (curboneptr == s_customrigbone) {
					}
					else {
						RenderSelectPostureFunc(re);
					}
				}


				//s_pdev->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
				//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmp, 1);

			}
		}
	}
	else {
		//#############################################
		//2024/02/25
		//ShadowメニューのCamDistチェックボックスオンのとき
		//cameraTarget位置にSelectPostureを表示
		//#############################################

		CalcSelectScale();//s_selectscaleにセット

		ChaMatrix scalemat;
		ChaMatrixIdentity(&scalemat);
		float adjustmult = 1.0f;
		ChaMatrixScaling(&scalemat, s_selectscale * adjustmult, s_selectscale * adjustmult, s_selectscale * adjustmult);

		s_selm = scalemat;
		s_selm.SetTranslation(g_camtargetpos);
		s_selectmat = s_selm;
		s_selectmat_posture = s_selm;

		RenderSelectFunc(re);
		RenderSelectPostureFunc(re);
	}


	return 0;
}

int RenderSelectFunc(myRenderer::RenderingEngine* re)
{
	if (!s_select || !s_chascene) {
		return 0;
	}

	s_chascene->UpdateMatrixOneModel(s_select, g_limitdegflag, &s_selectmat, &s_matView, &s_matProj, 0.0, 0);
	if (s_dispselect) {
		int lightflag = 1;
		//ChaVector4 diffusemult.SetParams(1.0f, 1.0f, 1.0f, 0.7f);
		//ChaVector4 diffusemult.SetParams(0.6f, 0.6f, 0.6f, 0.3f);
		//ChaVector4 diffusemult.SetParams(0.6f, 0.6f, 0.6f, 1.0f);
		ChaVector4 diffusemult;
		diffusemult.SetParams(0.6f, 0.6f, 0.6f, 0.6f);
		bool forcewithalpha = true;
		int btflag = 0;
		bool zcmpalways = true;
		bool zenable = false;
		s_chascene->RenderOneModel(s_select, forcewithalpha, re, lightflag, diffusemult, btflag, zcmpalways, zenable);
		//s_select->OnRender(withalpha, pRenderContext, lightflag, diffusemult);
	}
	//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmp, 1);

	return 0;

}

int RenderSelectPostureFunc(myRenderer::RenderingEngine* re)
{
	if (!s_select_posture || !s_chascene) {
		return 0;
	}

	s_chascene->UpdateMatrixOneModel(s_select_posture, g_limitdegflag, &s_selectmat_posture, &s_matView, &s_matProj, 0.0, 0);
	if (s_dispselect) {
		int lightflag = 1;
		//ChaVector4 diffusemult.SetParams(1.0f, 1.0f, 1.0f, 1.0f);
		//ChaVector4 diffusemult.SetParams(1.0f, 1.0f, 1.0f, 0.7f);
		ChaVector4 diffusemult;
		diffusemult.SetParams(0.6f, 0.6f, 0.6f, 0.3f);
		bool forcewithalpha = true;
		int btflag = 0;
		bool zcmpalways = true;
		bool zenable = false;
		s_chascene->RenderOneModel(s_select_posture, forcewithalpha, re, lightflag, diffusemult, btflag, zcmpalways, zenable);
		//s_select_posture->OnRender(withalpha, pRenderContext, lightflag, diffusemult);
	}
	//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmp, 1);

	return 0;

}

CFrameCopyDlg* GetCurrentFrameCopyDlg(bool cameraflag)
{
	if (!s_model) {
		_ASSERT(0);
		return 0;
	}

	CModel* srcmodel;
	if (cameraflag) {
		srcmodel = s_cameramodel;
	}
	else {
		srcmodel = s_model;
	}

	CFrameCopyDlg* curcpdlg = 0;
	map<CModel*, CFrameCopyDlg*>::iterator itrfinddlg;
	itrfinddlg = s_selbonedlgmap.find(srcmodel);
	if (itrfinddlg == s_selbonedlgmap.end()) {
		return 0;
	}
	else {
		return itrfinddlg->second;
	}
}


void ResetRigModelNum()
{
	s_rigsphere_num = 0;
	s_rigringX_num = 0;
	s_rigringY_num = 0;
	s_rigringZ_num = 0;
}
CModel* GetCurRigModel(CUSTOMRIG currig, int* pinstanceno, ChaVector4* prigmat)
{
	if (!pinstanceno || !prigmat) {
		_ASSERT(0);
		return nullptr;
	}

	*pinstanceno = -1;//error値で初期化
	prigmat->SetParams(1.0f, 1.0f, 1.0f, 1.0f);//error値で初期化


	//int rigopemarkno = currig.shapemult;
	int rigshapekind = currig.shapekind;
	int rigaxis = currig.dispaxis;
	int rigcolor = currig.rigcolor;

	//if ((rigopemarkno >= 0) && (rigopemarkno <= RIGMULTINDEXMAX) &&
	if((rigshapekind >= RIGSHAPE_SPHERE) && (rigshapekind < RIGSHAPE_MAX) &&
		(rigaxis >= 0) && (rigaxis <= 2) && 
		(rigcolor >= 0) && (rigcolor < RIGCOLOR_MAX)) {

		float alpha;
		if (rigshapekind == RIGSHAPE_SPHERE) {
			alpha = 0.79f;//ZCmpAlways
		}
		else {
			alpha = 1.0f;//ZCmp
		}

		if (rigcolor == RIGCOLOR_RED) {
			s_matrigmat.SetParams(1.0f, 0.5f, 0.5f, alpha);
		}
		else if (rigcolor == RIGCOLOR_GREEN) {
			s_matrigmat.SetParams(0.0f, 1.0f, 0.0f, alpha);
		}
		else if (rigcolor == RIGCOLOR_BLUE) {
			s_matrigmat.SetParams(15.0f / 255.0f, 200.0f / 255.0f, 1.0f, alpha);
		}
		else {
			_ASSERT(0);
			s_matrigmat.SetParams(1.0f, 0.5f, 0.5f, alpha);
		}

		CModel* currigmodel;
		if (rigshapekind == RIGSHAPE_SPHERE) {
			if (s_rigsphere_num >= RIGMULTINDEXMAX) {
				_ASSERT(0);
				return nullptr;
			}

			currigmodel = s_rigopemark_sphere;
			*pinstanceno = s_rigsphere_num;
			*prigmat = s_matrigmat;

			////s_rigmaterial_sphere[s_rigsphere_num]->SetDif4F(s_matrigmat);
			//s_rigmaterial_sphere[s_rigsphere_num]->SetTempDiffuseMult(s_matrigmat);
			//s_rigmaterial_sphere[s_rigsphere_num]->SetTempDiffuseMultFlag(true);

			s_rigsphere_num++;
		}
		else if (rigshapekind == RIGSHAPE_RINGX) {
			if (s_rigringX_num >= RIGMULTINDEXMAX) {
				_ASSERT(0);
				return nullptr;
			}

			currigmodel = s_rigopemark_ringX;
			*pinstanceno = s_rigringX_num;
			*prigmat = s_matrigmat;

			////s_rigmaterial_ringX[s_rigringX_num]->SetDif4F(s_matrigmat);
			//s_rigmaterial_ringX[s_rigringX_num]->SetTempDiffuseMult(s_matrigmat);
			//s_rigmaterial_ringX[s_rigringX_num]->SetTempDiffuseMultFlag(true);

			s_rigringX_num++;
		}
		else if (rigshapekind == RIGSHAPE_RINGY) {
			if (s_rigringY_num >= RIGMULTINDEXMAX) {
				_ASSERT(0);
				return nullptr;
			}

			currigmodel = s_rigopemark_ringY;
			*pinstanceno = s_rigringY_num;
			*prigmat = s_matrigmat;

			////s_rigmaterial_ringY[s_rigringY_num]->SetDif4F(s_matrigmat);
			//s_rigmaterial_ringY[s_rigringY_num]->SetTempDiffuseMult(s_matrigmat);
			//s_rigmaterial_ringY[s_rigringY_num]->SetTempDiffuseMultFlag(true);

			s_rigringY_num++;
		}
		else if (rigshapekind == RIGSHAPE_RINGZ) {
			if (s_rigringZ_num >= RIGMULTINDEXMAX) {
				_ASSERT(0);
				return nullptr;
			}

			currigmodel = s_rigopemark_ringZ;
			*pinstanceno = s_rigringZ_num;
			*prigmat = s_matrigmat;

			////s_rigmaterial_ringZ[s_rigringZ_num]->SetDif4F(s_matrigmat);
			//s_rigmaterial_ringZ[s_rigringZ_num]->SetTempDiffuseMult(s_matrigmat);
			//s_rigmaterial_ringZ[s_rigringZ_num]->SetTempDiffuseMultFlag(true);

			s_rigringZ_num++;
		}
		else {
			_ASSERT(0);
			return 0;
		}

		return currigmodel;
	}
	else {
		return 0;
	}

}

int RenderGrass(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!pRenderContext) {
		_ASSERT(0);
		return 1;
	}
	if (s_grassElemVec.empty()) {
		return 0;
	}

	int grasselemnum = (int)s_grassElemVec.size();

	int grasselemindex;
	for (grasselemindex = 0; grasselemindex < grasselemnum; grasselemindex++) {
		CGrassElem* curgrasselem = s_grassElemVec[grasselemindex];
		if (curgrasselem && curgrasselem->GetGrass()) {
			//１つのモデルに複数メッシュがある場合でも　１つのモデルに対して１回リセット
			curgrasselem->ResetInstancingParams();
		}
	}

	for (grasselemindex = 0; grasselemindex < grasselemnum; grasselemindex++) {
		CGrassElem* curgrasselem = s_grassElemVec[grasselemindex];
		if (curgrasselem && curgrasselem->GetGrass()) {
			//ChaMatrix tmpwm = curgrasselem->GetGrass()->GetWorldMat();
			ChaMatrix tmpwm;
			tmpwm.SetIdentity();//2024/06/16
			curgrasselem->GetGrass()->UpdateMatrix(false,
				&tmpwm, &s_matView, &s_matProj, true, 0);

			curgrasselem->SetInstancingParams(s_matVP);
			curgrasselem->RenderInstancingModel(s_chascene);
		}
	}

	return 0;
}

int RenderRigMarkFunc(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!pRenderContext) {
		_ASSERT(0);
		return 1;
	}


	if (!s_model) {
		return 0;
	}

	//g_hmVP->SetMatrix(s_matVP.GetDataPtr());

	ResetRigModelNum();
	s_rigopemark_sphere->ResetInstancingParams();
	s_rigopemark_ringX->ResetInstancingParams();
	s_rigopemark_ringY->ResetInstancingParams();
	s_rigopemark_ringZ->ResetInstancingParams();

	int rendercount = 0;
	if (s_model->ExistCurrentMotion()) {
		int curmotid = s_model->GetCurrentMotID();
		//double curframe = s_model->GetCurrentFrame();
		double renderframe = s_model->GetRenderSlotFrame();//2024/03/29 表示用スロットのフレーム

		std::map<int, CBone*>::iterator itrbone;
		for (itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++) {
			CBone* curbone = (CBone*)itrbone->second;
			if (curbone && (curbone->IsSkeleton())) {
				int rigno;
				for (rigno = 0; rigno < MAXRIGNUM; rigno++) {
					CUSTOMRIG currig = curbone->GetCustomRig(rigno);
					if (currig.useflag == 2) {//0: free, 1: allocated, 2: valid
					//if (currig.rigboneno > 0) {
						CModel* currigmodel;
						int instancingno;
						ChaVector4 rigmaterial;
						currigmodel = GetCurRigModel(currig, &instancingno, &rigmaterial);
						if (currigmodel && (instancingno >= 0) && (instancingno < RIGMULTINDEXMAX)) {
							ChaMatrix rigmat;
							ChaMatrixIdentity(&rigmat);
							//rigmat = CalcRigMat(&currig, curbone, curmotid, curframe, currig.dispaxis, currig.disporder, currig.posinverse);
							rigmat = CalcRigMat(&currig, curbone, curmotid, renderframe, currig.dispaxis, currig.disporder, currig.posinverse);//2024/03/29 renderframe

							//currigmodel->UpdateMatrix(g_limitdegflag, &rigmat, &s_matVP);
							currigmodel->SetInstancingParams(instancingno, rigmat, s_matVP, rigmaterial);

							rendercount++;
						}
					}
				}
			}
		}

		//pRenderContext->OMSetDepthStencilState(g_pDSStateZCmp, 1);
	}

	{
		int lightflag = 0;
		ChaVector4 diffusemult;
		diffusemult.SetParams(1.0f, 1.0f, 1.0f, g_rigmark_alpha);//2024/01/12 alpha
		bool forcewithalpha = true;
		int btflag = 0;
		bool zcmpalways = false;
		bool zenable = true;

		if (s_rigsphere_num > 0) {
			s_chascene->RenderInstancingModel(s_rigopemark_sphere, forcewithalpha, lightflag, diffusemult, btflag, 
				zcmpalways, zenable,
				RENDERKIND_INSTANCING_LINE);
		}
		if (s_rigringX_num > 0) {
			s_chascene->RenderInstancingModel(s_rigopemark_ringX, forcewithalpha, lightflag, diffusemult, btflag, 
				zcmpalways, zenable,
				RENDERKIND_INSTANCING_LINE);
		}
		if (s_rigringY_num > 0) {
			s_chascene->RenderInstancingModel(s_rigopemark_ringY, forcewithalpha, lightflag, diffusemult, btflag, 
				zcmpalways, zenable,
				RENDERKIND_INSTANCING_LINE);
		}
		if (s_rigringZ_num > 0) {
			s_chascene->RenderInstancingModel(s_rigopemark_ringZ, forcewithalpha, lightflag, diffusemult, btflag, 
				zcmpalways, zenable,
				RENDERKIND_INSTANCING_LINE);
		}
	}


	return 0;
}
int CalcTargetPos(ChaVector3* dstpos)
{
	ChaVector3 start3d, end3d;
	CalcPickRay(&start3d, &end3d);

	//カメラの面とレイとの交点(targetpos)を求める。
	ChaVector3 sb, se, n;
	sb = s_pickinfo.objworld - start3d;
	se = end3d - start3d;
	n = g_camtargetpos - g_camEye;

	float t;
	t = ChaVector3Dot(&sb, &n) / ChaVector3Dot(&se, &n);

	ChaVector3 targetwm = start3d * (1.0f - t) + end3d * t;
	ChaVector3 targetlocal; 
	ChaMatrix invmodelwm;
	if (s_model) {
		//########################################################
		//2023/03/24
		//model座標系で計算：modelのWorldMatの影響を無くして計算
		//########################################################

		invmodelwm = ChaMatrixInv(s_model->GetWorldMat());
		ChaVector3TransformCoord(&targetlocal, &targetwm, &invmodelwm);
	}
	else {
		targetlocal = targetwm;
	}

	*dstpos = targetlocal;

	return 0;
}

int CalcPickRay(ChaVector3* startptr, ChaVector3* endptr)
{
	s_pickinfo.diffmouse.x = (float)(s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x);
	s_pickinfo.diffmouse.y = (float)(s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y);

	ChaVector3 mousesc;
	//以下2行。相対位置で動かすことができるが、マウスが可動でボーンが可動でないような位置への操作があると、その後の操作と結果の関係が不自然にみえる。
	mousesc.x = s_pickinfo.objscreen.x + s_pickinfo.diffmouse.x;
	mousesc.y = s_pickinfo.objscreen.y + s_pickinfo.diffmouse.y;

	//以下２行。常にマウス位置を目標にする。
	//mousesc.x = s_pickinfo.mousepos.x;
	//mousesc.y = s_pickinfo.mousepos.y;
	mousesc.z = s_pickinfo.objscreen.z;

	ChaVector3 startsc, endsc;
	float rayx, rayy;
	rayx = mousesc.x / (s_pickinfo.winx / 2.0f) - 1.0f;
	rayy = 1.0f - mousesc.y / (s_pickinfo.winy / 2.0f);

	startsc.SetParams(rayx, rayy, 0.0f);
	endsc.SetParams(rayx, rayy, 1.0f);

	ChaMatrix mView;
	ChaMatrix mProj;
	
	mProj.SetParams(g_camera3D->GetProjectionMatrix());
	mView.SetParams(g_camera3D->GetViewMatrix(false));
	ChaMatrix mVP, invmVP;
	mVP = mView * mProj;
	ChaMatrixInverse(&invmVP, NULL, &mVP);//2023/03/24 model座標系　model->GetWorldMat()の効果は打ち消しておく

	ChaVector3TransformCoord(startptr, &startsc, &invmVP);
	ChaVector3TransformCoord(endptr, &endsc, &invmVP);

	return 0;
}

////s_openfilehwnd
////UINT CALLBACK OFNHookProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
////UINT CALLBACK GetFileNameHook(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
////UINT_PTR CALLBACK GetFileNameHook(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
////{
////
////	static int s_getfilenametimer = 338;
////
////	WORD loword;
////	WORD hiword;
////
////	switch (msg) {
////	case WM_INITDIALOG:
////		SetTimer(hDlgWnd, s_getfilenametimer, 20, NULL);
////		s_openfilehwnd = hDlgWnd;
////		return FALSE;
////	case WM_COMMAND:
////		switch (LOWORD(wp)) {
////		case IDOK:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDOK);
////			return TRUE;
////			break;
////		case IDCANCEL:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDCANCEL);
////			return TRUE;
////			break;
////		default:
////			return FALSE;
////		}
////	case WM_LBUTTONDOWN:
////		loword = LOWORD(wp);
////		hiword = HIWORD(wp);
////		break;
////	case WM_LBUTTONUP:
////		loword = LOWORD(wp);
////		hiword = HIWORD(wp);
////
////		switch (LOWORD(wp)) {
////		case IDOK:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDOK);
////			return TRUE;
////			break;
////		case IDCANCEL:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDCANCEL);
////			return TRUE;
////			break;
////		default:
////			return FALSE;
////		}
////		break;
////	case WM_NOTIFY:
/////*
////WM_NOTIFYメッセージは、標準のコントロールやユーザーの操作によるさまざまな通知メッセージが送られたときに送られてきます。
////lParamにはOFNOTIFY構造体のアドレスが入っていてこれを調べると通知メッセージの種類がわかります。
////この構造体の説明はここでは省略します。通知メッセージとしては、
////CDN_INITDONE          ダイアログ配置が終わったことを知らせます。
////CDN_FILEOK            ＯＫボタンが押されたことを知らせます。
////CDN_FOLDERCHANGE      開いているフォルダが変わったことを知らせます。
////CDN_HELP              ＨＥＬＰボタンが押されたことを知らせます。
////CDN_SELCHANGE         別のファイルが選ばれたことを知らせます。
////CDN_SHAREVIOLATION    共有違反が発生したことを知らせます。
////CDN_TYPECHANGE        ファイルの種類が変更されたことを知らせます。
////また、ダイアログの状態を知るためには次のようなメッセージを送ります。
////それぞれのメッセージについては各自で調べてください（今回こればっか、手抜きだというのがばれてしまう）。
////CDM_GETFILEPATH       選択されているファイルのパス（フォルダ名＋ファイル名）を取得します。
////CDM_GETSPEC           選択されているファイルのファイル名だけを取得します。
////CDM_GETFOLDERPATH     現在のフォルダのパスを取得します。
////CDM_GETFOLDERIDLIST   現在のフォルダのItem-ID-Listを取得します。
////CDM_HIDECONTROL       指定したコントロールを隠します。
////CDM_SETCONTROLTEXT    指定したコントロールにテキストを設定します。
////CDM_SETDEFEXT         表示するファイルの拡張子を設定します。*/
////		loword = LOWORD(wp);
////		hiword = HIWORD(wp);
////
////		switch (LOWORD(wp)) {
////		case IDOK:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDOK);
////			return TRUE;
////			break;
////		case IDCANCEL:
////			s_openfilehwnd = 0;
////			KillTimer(hDlgWnd, s_getfilenametimer);
////			EndDialog(hDlgWnd, IDCANCEL);
////			return TRUE;
////			break;
////		default:
////			return FALSE;
////		}
////		break;
////	case WM_TIMER:
////		OnDSUpdate();
////		return FALSE;
////		break;
////	default:
////		DefWindowProc(hDlgWnd, msg, wp, lp);
////		return FALSE;
////	}
////	return TRUE;
////
////
////}


void SetDlgHistory(HWND hDlgWnd, std::vector<wstring> vecopenfilename, int pagenum, int currentpage)
{

	int radionum = 0;
	int startno = 0;


	//ページングはここで行う
	int numhistory2 = (int)vecopenfilename.size();
	int fullpagenum = numhistory2 / OPENHISTORYMAXNUM;//満たされているページの数
	int pagenum2 = fullpagenum;//端数込みのページ数
	if ((numhistory2 - fullpagenum * OPENHISTORYMAXNUM) > 0) {
		pagenum2++;
	}


	if (pagenum2 != pagenum) {
		_ASSERT(0);
		return;//!!!!!!!!!!!!!!!!!
	}


	if (pagenum > 0) {
		int setpage;
		if (currentpage < 0) {
			setpage = 0;
		}
		else if ((currentpage + 1) <= pagenum) {
			setpage = currentpage;
		}
		else {
			setpage = currentpage % pagenum;
		}

		int restnum;

		startno = setpage * OPENHISTORYMAXNUM;//!!!!!!!!!!!!!!!!!!!
		restnum = numhistory2 - startno;
		//dispnum2 = min(restnum, OPENHISTORYMAXNUM);
		//endno = startno + dispnum2 - 1;
		radionum = min(restnum, OPENHISTORYMAXNUM);//!!!!!!!!!!!!!!!!!!!

	}
	else {
		startno = 0;
		radionum = 0;
	}


	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI51), L"");
	if (radionum != 0) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI51), vecopenfilename[startno + 0].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI51), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI52), L"");
	if (radionum >= 2) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI52), vecopenfilename[startno + 1].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI52), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI53), L"");
	if (radionum >= 3) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI53), vecopenfilename[startno + 2].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI53), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI54), L"");
	if (radionum >= 4) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI54), vecopenfilename[startno + 3].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI54), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI55), L"");
	if (radionum >= 5) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI55), vecopenfilename[startno + 4].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI55), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI56), L"");
	if (radionum >= 6) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI56), vecopenfilename[startno + 5].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI56), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI57), L"");
	if (radionum >= 7) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI57), vecopenfilename[startno + 6].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI57), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI58), L"");
	if (radionum >= 8) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI58), vecopenfilename[startno + 7].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI58), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI59), L"");
	if (radionum >= 9) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI59), vecopenfilename[startno + 8].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI59), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI60), L"");
	if (radionum >= 10) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI60), vecopenfilename[startno + 9].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI60), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI61), L"");
	if (radionum >= 11) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI61), vecopenfilename[startno + 10].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI61), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI62), L"");
	if (radionum >= 12) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI62), vecopenfilename[startno + 11].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI62), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI63), L"");
	if (radionum >= 13) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI63), vecopenfilename[startno + 12].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI63), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI64), L"");
	if (radionum >= 14) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI64), vecopenfilename[startno + 13].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI64), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI65), L"");
	if (radionum >= 15) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI65), vecopenfilename[startno + 14].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI65), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI66), L"");
	if (radionum >= 16) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI66), vecopenfilename[startno + 15].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI66), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI67), L"");
	if (radionum >= 17) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI67), vecopenfilename[startno + 16].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI67), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI68), L"");
	if (radionum >= 18) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI68), vecopenfilename[startno + 17].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI68), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI69), L"");
	if (radionum >= 19) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI69), vecopenfilename[startno + 18].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI69), L"Loading History not Exist.");
	}

	SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI70), L"");
	if (radionum >= 20) {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI70), vecopenfilename[startno + 19].c_str());
	}
	else {
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_RADI70), L"Loading History not Exist.");
	}


	if (pagenum > 0) {
		int disppage;
		disppage = currentpage % pagenum + 1;
		WCHAR strpages[256] = { 0L };
		swprintf_s(strpages, 256, L"%03d / %03d Pages", disppage, pagenum);
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_PAGES), strpages);
	}
	else {
		WCHAR strpages[256] = { 0L };
		swprintf_s(strpages, 256, L"0 / 0 NoPages");
		SetWindowTextW(GetDlgItem(hDlgWnd, IDC_PAGES), strpages);
	}

}




LRESULT CALLBACK OpenMqoDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hDlgWnd;//2024/01/03
	//ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"project(*.cha)chara(*.fbx)\0*.cha;*.fbx\0Rigid(*.ref)\0*.ref\0Impulse(*.imp)\0*.imp\0Ground(*.gco)\0*.gco\0BVH(*.bvh)\0*.bvh\0MNL(*.mnl)\0*.mnl\0Retarget(*.rtg)\0*.rtg\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = s_filterindex;
	//ofn.lpstrFile = g_tmpmqopath;
	ofn.lpstrFile = NULL;
	ofn.nMaxFile = MULTIPATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	//ofn.lpstrTitle = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";

	////ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT | OFN_ENABLEHOOK;
	////ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	////ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT | OFN_EXPLORER;
	//##########################################################################
	//2024/02/24
	//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
	//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
	//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
	//ゲームパッド対応時にもマウスは必要という方針に変更
	//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
	//##########################################################################
	ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = NULL;
	ofn.lCustData = NULL;
	//ofn.lpfnHook = GetFileNameHook;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	WCHAR strmult[256];
	wcscpy_s(strmult, 256, L"1.000");
	WCHAR wfilename[MAX_PATH] = { 0L };

	static int s_openmqoproctimer = 336;
	static bool s_refokflag = false;
	static int s_filter_cha = 1;
	static WCHAR s_beffolder[MAX_PATH] = { 0L };
	static bool s_underrefflag = false;//参照中に参照ボタンを押さないように

	static int pagenum = 1;//2023/07/22
	static int currentpage = 0;//2023/07/22
	static int testcurrentpage = 0;//2023/07/22
	



	switch (msg) {
	case WM_INITDIALOG:
	{
		pagenum = 1;
		currentpage = 0;
		testcurrentpage = 0;


		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		s_refokflag = false;
		g_tmpmqomult = 1.0f;
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);
		ZeroMemory(wfilename, sizeof(WCHAR) * MAX_PATH);
		SetDlgItemText(hDlgWnd, IDC_MULT, strmult);
		SetDlgItemText(hDlgWnd, IDC_FILEPATH, L"PushRefButtonToSelectFile.");

		if (s_filterindex != 7) {
			if (s_filter_cha == 1) {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, TRUE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, FALSE, 0);
			}
			else {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, TRUE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, FALSE, 0);
			}
		}
		else {
			SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, FALSE, 0);
			SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, FALSE, 0);
			SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, TRUE, 0);
		}


		if (s_filterindex == 5) {
			//bvh2FBXの単体ファイル履歴

			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), FALSE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), FALSE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), FALSE);

			std::vector<wstring> vecopenfilename;
			pagenum = GetbvhHistoryDir(vecopenfilename);

			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
		}
		else if (s_filterindex == 7) {
			//retarget fileの単体ファイル履歴

			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), FALSE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), FALSE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), TRUE);

			std::vector<wstring> vecopenfilename;
			pagenum = GetRtgHistoryDir(vecopenfilename);

			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
		}
		else {
			//cha, fbxファイル履歴

			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), TRUE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), TRUE);
			EnableWindow(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), FALSE);

			std::vector<wstring> vecopenfilename;
			pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);

			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
		}

		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		SetTimer(hDlgWnd, s_openmqoproctimer, 20, NULL);
		s_mqodlghwnd = hDlgWnd;
	}
	return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			GetDlgItemText(hDlgWnd, IDC_MULT, strmult, 256);
			g_tmpmqomult = (float)_wtof(strmult);
			if (s_refokflag == false) {
				UINT ischecked1 = 0;
				UINT ischecked2 = 0;
				UINT ischecked3 = 0;
				UINT ischecked4 = 0;
				UINT ischecked5 = 0;
				UINT ischecked6 = 0;
				UINT ischecked7 = 0;
				UINT ischecked8 = 0;
				UINT ischecked9 = 0;
				UINT ischecked10 = 0;
				UINT ischecked11 = 0;
				UINT ischecked12 = 0;
				UINT ischecked13 = 0;
				UINT ischecked14 = 0;
				UINT ischecked15 = 0;
				UINT ischecked16 = 0;
				UINT ischecked17 = 0;
				UINT ischecked18 = 0;
				UINT ischecked19 = 0;
				UINT ischecked20 = 0;
				ischecked1 = IsDlgButtonChecked(hDlgWnd, IDC_RADI51);
				ischecked2 = IsDlgButtonChecked(hDlgWnd, IDC_RADI52);
				ischecked3 = IsDlgButtonChecked(hDlgWnd, IDC_RADI53);
				ischecked4 = IsDlgButtonChecked(hDlgWnd, IDC_RADI54);
				ischecked5 = IsDlgButtonChecked(hDlgWnd, IDC_RADI55);
				ischecked6 = IsDlgButtonChecked(hDlgWnd, IDC_RADI56);
				ischecked7 = IsDlgButtonChecked(hDlgWnd, IDC_RADI57);
				ischecked8 = IsDlgButtonChecked(hDlgWnd, IDC_RADI58);
				ischecked9 = IsDlgButtonChecked(hDlgWnd, IDC_RADI59);
				ischecked10 = IsDlgButtonChecked(hDlgWnd, IDC_RADI60);
				ischecked11 = IsDlgButtonChecked(hDlgWnd, IDC_RADI61);
				ischecked12 = IsDlgButtonChecked(hDlgWnd, IDC_RADI62);
				ischecked13 = IsDlgButtonChecked(hDlgWnd, IDC_RADI63);
				ischecked14 = IsDlgButtonChecked(hDlgWnd, IDC_RADI64);
				ischecked15 = IsDlgButtonChecked(hDlgWnd, IDC_RADI65);
				ischecked16 = IsDlgButtonChecked(hDlgWnd, IDC_RADI66);
				ischecked17 = IsDlgButtonChecked(hDlgWnd, IDC_RADI67);
				ischecked18 = IsDlgButtonChecked(hDlgWnd, IDC_RADI68);
				ischecked19 = IsDlgButtonChecked(hDlgWnd, IDC_RADI69);
				ischecked20 = IsDlgButtonChecked(hDlgWnd, IDC_RADI70);
				if (ischecked1 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI51, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked2 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI52, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked3 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI53, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked4 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI54, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked5 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI55, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked6 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI56, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked7 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI57, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked8 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI58, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked9 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI59, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked10 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI60, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked11 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI61, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked12 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI62, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked13 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI63, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked14 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI64, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked15 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI65, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked16 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI66, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked17 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI67, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked18 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI68, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked19 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI69, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else if (ischecked20 == BST_CHECKED) {
					WCHAR checkedpath[MAX_PATH] = { 0L };
					GetDlgItemTextW(hDlgWnd, IDC_RADI70, checkedpath, MAX_PATH);
					if (wcscmp(L"Loading History not Exist.", checkedpath) != 0) {
						wcscpy_s(g_tmpmqopath, MAX_PATH, checkedpath);
					}
					else {
						g_tmpmqopath[0] = 0L;
					}
				}
				else {
					g_tmpmqopath[0] = 0L;
				}
			}
			if (g_tmpmqopath[0]) {
				//GetDlgItemText( hDlgWnd, IDC_FILEPATH, g_tmpmqopath, MULTIPATH );
				s_mqodlghwnd = 0;
				KillTimer(hDlgWnd, s_openmqoproctimer);
				EndDialog(hDlgWnd, IDOK);
			}
			return TRUE;
			break;
		case IDCANCEL:
			s_mqodlghwnd = 0;
			g_tmpmqopath[0] = 0L;
			wfilename[0] = 0L;
			KillTimer(hDlgWnd, s_openmqoproctimer);
			EndDialog(hDlgWnd, IDCANCEL);
			return TRUE;
			break;

		case IDC_CHECK_GRASS:
		{
			UINT ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_GRASS);
			if (ischecked == BST_CHECKED) {
				s_grassflag = true;
			}
			else {
				s_grassflag = false;
			}
		}
		break;

		case IDC_REFMQO:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

				//##########################################################################
				//2024/02/24
				//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
				//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
				//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
				//ゲームパッド対応時にもマウスは必要という方針に変更
				//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
				//##########################################################################
				ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

				//###############################
				//前回の場所を初期ディレクトリに
				//###############################
				//ofn.lpstrInitialDir = g_tmpmqopath;
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				wcscpy_s(wfilename, MAX_PATH, s_beffolder);
				ofn.lpstrInitialDir = s_beffolder;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}

				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;
		case IDC_REFDESKTOP:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
				//##########################################################################
				//2024/02/24
				//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
				//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
				//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
				//ゲームパッド対応時にもマウスは必要という方針に変更
				//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
				//##########################################################################
				ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;


				//###############################
				//デスクトップを初期ディレクトリに
				//###############################
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				WCHAR waFolderPath[MAX_PATH];
				SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_DESKTOP, 0);
				ofn.lpstrInitialDir = waFolderPath;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}

				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;
		case IDC_REFMYDOC:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
				//##########################################################################
				//2024/02/24
				//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
				//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
				//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
				//ゲームパッド対応時にもマウスは必要という方針に変更
				//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
				//##########################################################################
				ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;


				//#########################################
				//ドキュメントフォルダを初期ディレクトリに
				//#########################################
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				WCHAR waFolderPath[MAX_PATH];
				SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PERSONAL, 0);
				ofn.lpstrInitialDir = waFolderPath;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}


				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;
		case IDC_REFTEST:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
				//##########################################################################
				//2024/02/24
				//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
				//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
				//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
				//ゲームパッド対応時にもマウスは必要という方針に変更
				//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
				//##########################################################################
				ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;


				//#################################
				//Testフォルダを初期ディレクトリに
				//#################################
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				WCHAR waFolderPath[MAX_PATH];
				//SHGetSpecialFolderPath(NULL, waFolderPath, CSIDL_PROGRAMS, 0);//これではAppDataのパスになってしまう
				swprintf_s(waFolderPath, MAX_PATH, L"C:\\Program Files\\OchakkoLAB\\AdditiveIK1.0.0.29\\Test\\");
				ofn.lpstrInitialDir = waFolderPath;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}


				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;
		case IDC_REFPG:
		{
			if (s_underrefflag == false) {
				s_underrefflag = true;

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
				//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

				//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
				//##########################################################################
				//2024/02/24
				//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
				//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
				//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
				//ゲームパッド対応時にもマウスは必要という方針に変更
				//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
				//##########################################################################
				ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;


				//#####################################
				//プログラムの場所を初期ディレクトリに
				//#####################################
				g_tmpmqopath[0] = 0L;
				wfilename[0] = 0L;
				//ofn.lpstrInitialDir = g_basedir;

				//2023/10/02 １つ上のディレクトリに
				WCHAR waFolderPath[MAX_PATH];
				wcscpy_s(waFolderPath, MAX_PATH, g_basedir);
				WCHAR* lasten = wcsrchr(waFolderPath, TEXT('\\'));
				if (lasten) {
					*lasten = 0L;//pathの最終文字としての'\\'
					WCHAR* lasten2 = wcsrchr(waFolderPath, TEXT('\\'));
					if (lasten2) {
						*(lasten2 + 1) = 0L;//pathの最終文字は'\\'なので　+1
					}
				}
				ofn.lpstrInitialDir = waFolderPath;
				ofn.lpstrFile = wfilename;

				if (GetOpenFileNameW(&ofn) == IDOK) {
					wcscpy_s(g_tmpmqopath, MAX_PATH, wfilename);
					SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
					s_refokflag = true;
				}
				wcscpy_s(s_beffolder, MAX_PATH, wfilename);
				WCHAR* lastenptr = wcsrchr(s_beffolder, TEXT('\\'));
				if (lastenptr) {
					*lastenptr = 0L;
				}


				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
				//UnhookWinEvent(hhook);

				s_getfilenamehwnd = 0;
				s_getfilenametreeview = 0;

				s_underrefflag = false;
			}
		}
		break;



		case IDC_FILTER_CHA:
			currentpage = 0;

			if (s_filterindex != 7) {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, TRUE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, FALSE, 0);
				s_filter_cha = 1;

				if (s_filterindex == 5) {
					//bvh2FBXの単体ファイル履歴
					std::vector<wstring> vecopenfilename;
					pagenum = GetbvhHistoryDir(vecopenfilename);
					SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
				}
				else {
					//cha, fbxファイル履歴
					std::vector<wstring> vecopenfilename;
					pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);
					SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
				}
			}
			break;


		case IDC_FILTER_FBX:
			currentpage = 0;

			if (s_filterindex != 7) {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, TRUE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, FALSE, 0);

				s_filter_cha = 2;

				if (s_filterindex == 5) {
					//bvh2FBXの単体ファイル履歴
					std::vector<wstring> vecopenfilename;
					pagenum = GetbvhHistoryDir(vecopenfilename);
					SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
				}
				else {
					//cha, fbxファイル履歴
					std::vector<wstring> vecopenfilename;
					pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);
					SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
				}
			}
			break;

		case IDC_FILTER_RTG:
			currentpage = 0;

			if (s_filterindex == 7) {
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_CHA), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_FBX), BM_SETSTATE, FALSE, 0);
				SendMessage(GetDlgItem(hDlgWnd, IDC_FILTER_RTG), BM_SETSTATE, TRUE, 0);

				//Retarget fileの単体ファイル履歴
				std::vector<wstring> vecopenfilename;
				pagenum = GetRtgHistoryDir(vecopenfilename);
				SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
			}
			break;
		case IDC_PREVPAGE:
		{
			//##############
			//get history
			//##############

			std::vector<wstring> vecopenfilename;
			if (s_filterindex == 5) {
				//bvh2FBXの単体ファイル履歴
				pagenum = GetbvhHistoryDir(vecopenfilename);
			}
			else if (s_filterindex == 7) {
				//Retarget fileの単体ファイル履歴
				pagenum = GetRtgHistoryDir(vecopenfilename);
			}
			else {
				//cha, fbxファイル履歴
				pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);
			}

			//###################
			//change currentpage
			//###################
			if (pagenum >= 1) {
				if (currentpage >= 1) {
					currentpage--;
				}
				else {
					currentpage = pagenum - 1;
				}
			}
			else {
				currentpage = 0;
			}

			//##################
			//set paged history
			//##################
			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);
		}
		break;

		case IDC_NEXTPAGE:
		{
			//##############
			//get history
			//##############

			std::vector<wstring> vecopenfilename;
			if (s_filterindex == 5) {
				//bvh2FBXの単体ファイル履歴
				pagenum = GetbvhHistoryDir(vecopenfilename);
			}
			else if (s_filterindex == 7) {
				//Retarget fileの単体ファイル履歴
				pagenum = GetRtgHistoryDir(vecopenfilename);
			}
			else {
				//cha, fbxファイル履歴
				pagenum = GetchaHistoryDir(vecopenfilename, s_filter_cha);
			}

			//###################
			//change currentpage
			//###################
			if (pagenum >= 1) {
				if (currentpage < (pagenum - 1)) {
					currentpage++;
				}
				else {
					currentpage = 0;
				}
			}
			else {
				currentpage = 0;
			}

			//##################
			//set paged history
			//##################
			SetDlgHistory(hDlgWnd, vecopenfilename, pagenum, currentpage);

		}
		break;

		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_mqodlghwnd = 0;
		g_tmpmqopath[0] = 0L;
		KillTimer(hDlgWnd, s_openmqoproctimer);
		EndDialog(hDlgWnd, IDCANCEL);
		return TRUE;
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;
}


LRESULT CALLBACK OpenBvhDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = hDlgWnd;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"BVH(*.bvh)\0*.bvh\0chara(*.fbx)\0*.fbx\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 0;
	ofn.lpstrFile = g_tmpmqopath;
	ofn.nMaxFile = MULTIPATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	////ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	//##########################################################################
	//2024/02/24
	//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
	//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
	//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
	//ゲームパッド対応時にもマウスは必要という方針に変更
	//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
	//##########################################################################
	ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = NULL;
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	WCHAR strmult[256];
	wcscpy_s(strmult, 256, L"1.000");
	WCHAR strfilter[256];
	wcscpy_s(strfilter, 256, L"100.0");

	static int s_openbvhproctimer = 352;


	switch (msg) {
	case WM_INITDIALOG:

		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		g_tmpmqomult = 1.0f;
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);
		SetDlgItemText(hDlgWnd, IDC_MULT, strmult);
		SetDlgItemText(hDlgWnd, IDC_EDITFILTER, strfilter);
		SetDlgItemText(hDlgWnd, IDC_FILEPATH, L"PushRefButtonToSelectFile.");

		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		SetTimer(hDlgWnd, s_openbvhproctimer, 20, NULL);
		s_bvhdlghwnd = hDlgWnd;

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_bvhdlghwnd = 0;
			KillTimer(hDlgWnd, s_openbvhproctimer);

			GetDlgItemText(hDlgWnd, IDC_MULT, strmult, 256);
			g_tmpmqomult = (float)_wtof(strmult);
			//GetDlgItemText( hDlgWnd, IDC_FILEPATH, g_tmpmqopath, MULTIPATH );
			GetDlgItemText(hDlgWnd, IDC_EDITFILTER, strfilter, 256);
			g_tmpbvhfilter = (float)_wtof(strfilter);

			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_bvhdlghwnd = 0;
			KillTimer(hDlgWnd, s_openbvhproctimer);

			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFMQO:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
			//##########################################################################
			//2024/02/24
			//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
			//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
			//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
			//ゲームパッド対応時にもマウスは必要という方針に変更
			//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
			//##########################################################################
			ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				SetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath);
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);

			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_bvhdlghwnd = 0;
		KillTimer(hDlgWnd, s_openbvhproctimer);

		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}

LRESULT CALLBACK CheckAxisTypeProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
		SetDlgItemText(hDlgWnd, IDC_FILENAME, g_tmpmqopath);
		SendMessage(GetDlgItem(hDlgWnd, IDC_AXISCHECK1), BM_SETCHECK, (WPARAM)0, 0L);
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			if (IsDlgButtonChecked(hDlgWnd, IDC_AXISCHECK1) == BST_CHECKED) {
				s_forcenewaxis = 1;
			}
			else {
				s_forcenewaxis = 0;
			}

			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
		}
		break;
	case WM_CLOSE:
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		return FALSE;
	}
	return TRUE;

}


LRESULT CALLBACK MotPropDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	//static WCHAR s_tmpmotname[256] = {0L};
	//static double s_tmpmotframeleng = 100.0f;
	//static int s_tmpmotloop = 0;

	WCHAR strframeleng[256];

	static int s_motproptimerid = 345;


	switch (msg) {
	case WM_INITDIALOG:
	{
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model) {
			MOTINFO curmi = s_model->GetCurMotInfo();
			if (curmi.motid > 0) {
				MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
					curmi.motname, 256, s_tmpmotname, 256);
				SetDlgItemText(hDlgWnd, IDC_MOTNAME, s_tmpmotname);

				s_tmpmotframeleng = curmi.frameleng;
				swprintf_s(strframeleng, 256, L"%f", s_tmpmotframeleng);
				SetDlgItemText(hDlgWnd, IDC_FRAMELENG, strframeleng);

				s_tmpmotloop = curmi.loopflag;
				SendMessage(GetDlgItem(hDlgWnd, IDC_LOOP), BM_SETCHECK, (WPARAM)s_tmpmotloop, 0L);
			}
		}

		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		s_motpropdlghwnd = hDlgWnd;
		SetTimer(hDlgWnd, s_motproptimerid, 20, NULL);
	}
	//SetDlgItemText( hDlgWnd, IDC_MULT, strmult );
	return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			GetDlgItemText(hDlgWnd, IDC_MOTNAME, s_tmpmotname, 256);

			GetDlgItemText(hDlgWnd, IDC_FRAMELENG, strframeleng, 256);
			s_tmpmotframeleng = (float)_wtof(strframeleng);

			if (IsDlgButtonChecked(hDlgWnd, IDC_LOOP) == BST_CHECKED) {
				s_tmpmotloop = 1;
			}
			else {
				s_tmpmotloop = 0;
			}

			KillTimer(hDlgWnd, s_motproptimerid);
			s_motpropdlghwnd = 0;
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			KillTimer(hDlgWnd, s_motproptimerid);
			s_motpropdlghwnd = 0;
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		break;
	case WM_CLOSE:
		KillTimer(hDlgWnd, s_motproptimerid);
		s_motpropdlghwnd = 0;
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}



LRESULT CALLBACK RetargetBatchDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR strnumcnt[1024] = { 0L };
	HWND hProg;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		s_retargetbatchwnd = hDlgWnd;

		swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (s_retargetcnt + 1), s_retargetnum);
		SetDlgItemTextW(s_retargetbatchwnd, IDC_STRBVH2FBXBATCH, strnumcnt);
		hProg = GetDlgItem(s_retargetbatchwnd, IDC_PROGRESS1);
		if (hProg) {
			//プログレスバーの範囲         
			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, 100));
			//ステップの範囲を設定 
			SendMessage(hProg, PBM_SETSTEP, 1, 0);
			//現在位置を設定  
			SendMessage(hProg, PBM_SETPOS, 0, 0);
		}

		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			if (s_retargetbatchwnd) {
				DestroyWindow(s_retargetbatchwnd);
				s_retargetbatchwnd = 0;
			}
			InterlockedExchange(&g_retargetbatchflag, 2);
			//EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			if (s_retargetbatchwnd) {
				DestroyWindow(s_retargetbatchwnd);
				s_retargetbatchwnd = 0;
			}
			InterlockedExchange(&g_retargetbatchflag, 2);
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			break;
		}
		break;
	case WM_USER_FOR_BATCH_PROGRESS:
		break;
	case WM_CLOSE:
		if (s_retargetbatchwnd) {
			DestroyWindow(s_retargetbatchwnd);
			s_retargetbatchwnd = 0;
		}
		InterlockedExchange(&g_retargetbatchflag, 2);
		//EndDialog(hDlgWnd, IDOK);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}



LRESULT CALLBACK ProgressDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	//static int s_timerid = 371;

	WCHAR strnumcnt[1024] = { 0L };
	HWND hProg;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		s_progresswnd = hDlgWnd;

		swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (s_progresscnt + 1), s_progressnum);
		SetDlgItemTextW(s_progresswnd, IDC_STRBVH2FBXBATCH, strnumcnt);
		hProg = GetDlgItem(s_progresswnd, IDC_PROGRESS1);
		if (hProg) {
			//プログレスバーの範囲         
			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, 100));
			//ステップの範囲を設定 
			SendMessage(hProg, PBM_SETSTEP, 1, 0);
			//現在位置を設定  
			SendMessage(hProg, PBM_SETPOS, 0, 0);
		}

		//SetTimer(hDlgWnd, s_timerid, 100, NULL);
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			//if (s_progresswnd) {
			//	if (s_timerid != 0) {
			//		KillTimer(s_progresswnd, s_timerid);
			//		s_timerid = 0;
			//	}
			//	DestroyWindow(s_progresswnd);
			//	s_progresswnd = 0;
			//}
			//InterlockedExchange(&g_progressflag, 2);
			////EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			//if (s_progresswnd) {
			//	if (s_timerid != 0) {
			//		KillTimer(s_progresswnd, s_timerid);
			//		s_timerid = 0;
			//	}
			//	DestroyWindow(s_progresswnd);
			//	s_progresswnd = 0;
			//}
			//InterlockedExchange(&g_progressflag, 2);
			////EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			break;
		}
		break;
	case WM_USER_FOR_BATCH_PROGRESS:
		//case WM_TIMER:
		//	swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (s_progresscnt + 1), s_progressnum);
		//	SetDlgItemTextW(s_progresswnd, IDC_STRBVH2FBXBATCH, strnumcnt);

		//	if (s_progresswnd) {
		//		//HWND hProg;
		//		hProg = GetDlgItem(s_progresswnd, IDC_PROGRESS1);
		//		if (hProg) {
		//			//プログレスバーの範囲を0-300にする           
		//			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, s_progressnum));
		//			//現在位置を設定  
		//			SendMessage(hProg, PBM_SETPOS, (s_progresscnt + 1), 0);
		//			//ステップの範囲を設定 
		//			//SendMessage(hProg, PBM_SETSTEP, 1, 0);
		//		}
		//		UpdateWindow(s_progresswnd);
		//	}
		break;
	case WM_CLOSE:
		if (s_progresswnd) {
			//if (s_timerid != 0) {
			//	KillTimer(s_progresswnd, s_timerid);
			//	s_timerid = 0;
			//}
			DestroyWindow(s_progresswnd);
			s_progresswnd = 0;
		}
		//InterlockedExchange(&g_progressflag, 2);
		//EndDialog(hDlgWnd, IDOK);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}




LRESULT CALLBACK bvh2FbxBatchDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	WCHAR strnumcnt[1024] = { 0L };
	HWND hProg;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		s_bvh2fbxbatchwnd = hDlgWnd;

		swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (s_bvh2fbxcnt + 1), s_bvh2fbxnum);
		SetDlgItemTextW(s_bvh2fbxbatchwnd, IDC_STRBVH2FBXBATCH, strnumcnt);
		hProg = GetDlgItem(s_bvh2fbxbatchwnd, IDC_PROGRESS1);
		if (hProg) {
			//プログレスバーの範囲         
			SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, s_bvh2fbxnum));
			//ステップの範囲を設定 
			SendMessage(hProg, PBM_SETSTEP, 1, 0);
			//現在位置を設定  
			SendMessage(hProg, PBM_SETPOS, 0, 0);
		}

		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			if (s_bvh2fbxbatchwnd) {
				DestroyWindow(s_bvh2fbxbatchwnd);
				s_bvh2fbxbatchwnd = 0;
			}
			InterlockedExchange(&g_bvh2fbxbatchflag, 2);
			//EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			if (s_bvh2fbxbatchwnd) {
				DestroyWindow(s_bvh2fbxbatchwnd);
				s_bvh2fbxbatchwnd = 0;
			}
			InterlockedExchange(&g_bvh2fbxbatchflag, 2);
			//EndDialog(hDlgWnd, IDCANCEL);
			break;
		default:
			break;
		}
		break;
	case WM_CLOSE:
		if (s_bvh2fbxbatchwnd) {
			DestroyWindow(s_bvh2fbxbatchwnd);
			s_bvh2fbxbatchwnd = 0;
		}
		InterlockedExchange(&g_bvh2fbxbatchflag, 2);
		//EndDialog(hDlgWnd, IDOK);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;
}


LRESULT CALLBACK SaveGcoDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR buf[MAX_PATH];
	ZeroMemory(buf, sizeof(WCHAR) * MAX_PATH);
	if (s_Gconame[0] != 0) {
		wcscpy_s(buf, MAX_PATH, s_Gconame);
	}

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	//buf[0] = 0L;
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = NULL;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"Ground File(*.gco)\0*.gco\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	////ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	//ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	//##########################################################################
	//2024/02/24
	//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
	//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
	//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
	//ゲームパッド対応時にもマウスは必要という方針に変更
	//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
	//##########################################################################
	ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = L"gco";
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;


	static int s_savegcoproctimer = 356;

	switch (msg) {
	case WM_INITDIALOG:

		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model && s_model->GetTopBone()) {
			SetDlgItemText(hDlgWnd, IDC_FILENAME, s_Gconame);
		}

		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		SetTimer(hDlgWnd, s_savegcoproctimer, 20, NULL);
		s_savegcodlghwnd = hDlgWnd;

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_savegcodlghwnd = 0;
			KillTimer(hDlgWnd, s_savegcoproctimer);

			GetDlgItemText(hDlgWnd, IDC_FILENAME, s_Gconame, MAX_PATH);
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_savegcodlghwnd = 0;
			KillTimer(hDlgWnd, s_savegcoproctimer);

			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFFILE:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
			//##########################################################################
			//2024/02/24
			//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
			//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
			//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
			//ゲームパッド対応時にもマウスは必要という方針に変更
			//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
			//##########################################################################
			ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				//buf[0] = 0;
				SetDlgItemText(hDlgWnd, IDC_FILENAME, buf);
				buf[MAX_PATH - 1] = 0;
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);

			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_savegcodlghwnd = 0;
		KillTimer(hDlgWnd, s_savegcoproctimer);

		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;

}

LRESULT CALLBACK SaveImpDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR buf[MAX_PATH];
	ZeroMemory(buf, sizeof(WCHAR) * MAX_PATH);
	if (s_Impname[0] != 0) {
		wcscpy_s(buf, MAX_PATH, s_Impname);
	}

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	//buf[0] = 0L;
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = NULL;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"Impulse File(*.imp)\0*.imp\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	////ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	//ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	//##########################################################################
	//2024/02/24
	//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
	//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
	//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
	//ゲームパッド対応時にもマウスは必要という方針に変更
	//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
	//##########################################################################
	ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = L"imp";
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	static int s_saveimpproctimer = 355;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model && s_model->GetTopBone()) {
			SetDlgItemText(hDlgWnd, IDC_FILENAME, s_Impname);
		}
		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		SetTimer(hDlgWnd, s_saveimpproctimer, 20, NULL);
		s_saveimpdlghwnd = hDlgWnd;

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_saveimpdlghwnd = 0;
			KillTimer(hDlgWnd, s_saveimpproctimer);

			GetDlgItemText(hDlgWnd, IDC_FILENAME, s_Impname, MAX_PATH);
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_saveimpdlghwnd = 0;
			KillTimer(hDlgWnd, s_saveimpproctimer);

			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFFILE:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
			//##########################################################################
			//2024/02/24
			//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
			//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
			//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
			//ゲームパッド対応時にもマウスは必要という方針に変更
			//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
			//##########################################################################
			ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				//buf[0] = 0;
				SetDlgItemText(hDlgWnd, IDC_FILENAME, buf);
				buf[MAX_PATH - 1] = 0;
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);

			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_saveimpdlghwnd = 0;
		KillTimer(hDlgWnd, s_saveimpproctimer);

		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;

}


LRESULT CALLBACK SaveREDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR buf[MAX_PATH];
	ZeroMemory(buf, sizeof(WCHAR) * MAX_PATH);
	if (s_REname[0] != 0) {
		wcscpy_s(buf, MAX_PATH, s_REname);
	}

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	//buf[0] = 0L;
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = NULL;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"RigidElem File(*.ref)\0*.ref\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	////ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	//ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	//##########################################################################
	//2024/02/24
	//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
	//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
	//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
	//ゲームパッド対応時にもマウスは必要という方針に変更
	//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
	//##########################################################################
	ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = L"ref";
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	static int s_savereproctimer = 354;

	switch (msg) {
	case WM_INITDIALOG:

		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model && s_model->GetTopBone()) {
			SetDlgItemText(hDlgWnd, IDC_FILENAME, s_REname);
		}
		RECT dlgrect;
		GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		SetTimer(hDlgWnd, s_savereproctimer, 20, NULL);
		s_saveredlghwnd = hDlgWnd;

		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_saveredlghwnd = 0;
			KillTimer(hDlgWnd, s_savereproctimer);

			GetDlgItemText(hDlgWnd, IDC_FILENAME, s_REname, MAX_PATH);
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_saveredlghwnd = 0;
			KillTimer(hDlgWnd, s_savereproctimer);

			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFFILE:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
			//##########################################################################
			//2024/02/24
			//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
			//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
			//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
			//ゲームパッド対応時にもマウスは必要という方針に変更
			//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
			//##########################################################################
			ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				//buf[0] = 0;
				SetDlgItemText(hDlgWnd, IDC_FILENAME, buf);
				buf[MAX_PATH - 1] = 0;
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);


			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}

		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_saveredlghwnd = 0;
		KillTimer(hDlgWnd, s_savereproctimer);

		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
		break;
	}
	return TRUE;

}


LRESULT CALLBACK ExportXDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR buf[MAX_PATH];
	ZeroMemory(buf, sizeof(WCHAR) * MAX_PATH);
	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	//buf[0] = 0L;
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = NULL;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"x File (*.x)\0*.x\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	////ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	//ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	//##########################################################################
	//2024/02/24
	//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
	//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
	//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
	//ゲームパッド対応時にもマウスは必要という方針に変更
	//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
	//##########################################################################
	ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = NULL;
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	WCHAR strmult[256];
	wcscpy_s(strmult, 256, L"1.000");

	static int s_exportxproctimer = 360;

	switch (msg) {
	case WM_INITDIALOG:
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		g_tmpmqomult = 1.0f;
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);
		SetDlgItemText(hDlgWnd, IDC_MULT, strmult);
		SetDlgItemText(hDlgWnd, IDC_FILEPATH, L"PushRefButtonToSelectFile.");

		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		SetTimer(hDlgWnd, s_exportxproctimer, 20, NULL);
		s_exportxdlghwnd = hDlgWnd;
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_exportxdlghwnd = 0;
			KillTimer(hDlgWnd, s_exportxproctimer);
			GetDlgItemText(hDlgWnd, IDC_MULT, strmult, 256);
			g_tmpmqomult = (float)_wtof(strmult);
			GetDlgItemText(hDlgWnd, IDC_FILEPATH, g_tmpmqopath, MULTIPATH);
			EndDialog(hDlgWnd, IDOK);
			break;
		case IDCANCEL:
			s_exportxdlghwnd = 0;
			KillTimer(hDlgWnd, s_exportxproctimer);
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFX:
		{
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
			//##########################################################################
			//2024/02/24
			//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
			//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
			//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
			//ゲームパッド対応時にもマウスは必要という方針に変更
			//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
			//##########################################################################
			ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;

			if (GetOpenFileNameW(&ofn) == IDOK) {
				//buf[0] = 0;
				SetDlgItemText(hDlgWnd, IDC_FILEPATH, buf);
				buf[MAX_PATH - 1] = 0;
			}

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);

			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_exportxdlghwnd = 0;
		KillTimer(hDlgWnd, s_exportxproctimer);
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;

	}
	return TRUE;
}



void ActivatePanel(int state)
{
	if (!s_timelineWnd || !s_toolWnd || !s_layerWnd || !s_modelpanel.panel || !s_motionpanel.panel || !s_camerapanel.panel)
		return;


	if (state == 1) {
		if (s_dispmw && s_timelineWnd) {
			s_timelineWnd->setVisible(false);
			s_timelineWnd->setVisible(true);
		}
		if (s_disptool && s_toolWnd) {
			s_toolWnd->setVisible(true);
		}
		if (s_dispobj && s_layerWnd) {
			s_layerWnd->setVisible(true);
		}

	}
	else if (state == 0) {
		if (s_timelineWnd) {
			s_timelineWnd->setVisible(false);
		}
		if (s_toolWnd) {
			s_toolWnd->setVisible(false);
		}

		if (s_layerWnd) {
			s_layerWnd->setVisible(false);
		}
		s_dispobj = false;
	}

	DispModelPanel();
}


int DestroyModelPanel()
{
	if (s_modelpanel.panel) {
		s_modelpanel.panel->setVisible(false);
		delete s_modelpanel.panel;
		s_modelpanel.panel = 0;
	}
	if (s_modelpanel.scroll) {
		delete s_modelpanel.scroll;
		s_modelpanel.scroll = 0;
	}
	if (s_modelpanel.radiobutton) {
		delete s_modelpanel.radiobutton;
		s_modelpanel.radiobutton = 0;
	}
	if (s_modelpanel.separator) {
		delete s_modelpanel.separator;
		s_modelpanel.separator = 0;
	}
	if (s_modelpanel.separator2) {
		delete s_modelpanel.separator2;
		s_modelpanel.separator2 = 0;
	}
	if (!(s_modelpanel.checkvec.empty())) {
		int checknum = (int)s_modelpanel.checkvec.size();
		int checkno;
		for (checkno = 0; checkno < checknum; checkno++) {
			delete s_modelpanel.checkvec[checkno];
		}
	}
	s_modelpanel.checkvec.clear();
	if (!(s_modelpanel.delbutton.empty())) {
		int buttonnum = (int)s_modelpanel.delbutton.size();
		int buttonno;
		for (buttonno = 0; buttonno < buttonnum; buttonno++) {
			delete s_modelpanel.delbutton[buttonno];
		}
	}
	s_modelpanel.delbutton.clear();

	s_modelpanel.modelindex = -1;

	return 0;
}

int CreateModelPanel()
{

	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	if (s_modelpanel.panel) {
		s_firstmodelpanelpos = false;
		s_modelpanelpos = s_modelpanel.panel->getPos();
	}
	DestroyModelPanel();


	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}

	int modelnum = s_chascene->GetModelNum();
	//if (modelnum <= 0) {
	//	return 0;
	//}

	int classcnt = 0;
	WCHAR clsname[256];
	swprintf_s(clsname, 256, L"ModelPanel%d", classcnt);

	HWND parentwnd;
	int istopmost;
	if (g_4kresolution) {
		parentwnd = g_mainhwnd;
		istopmost = 0;
		//istopmost = 1;
	}
	else {
		parentwnd = NULL;
		istopmost = 1;
	}

	if (g_4kresolution) {
		//4Kの場合には　位置固定フレームに埋め込み
		s_modelpanelpos = WindowPos(s_timelinewidth, TOPSLIDERSWNDH);
	}
	else if (s_firstmodelpanelpos) {
		RECT wnd3drect;
		if (g_mainhwnd) {
			GetWindowRect(g_mainhwnd, &wnd3drect);
			s_modelpanelpos = WindowPos(wnd3drect.left + 100, wnd3drect.top + 500);
		}
		else {
			s_modelpanelpos = WindowPos(200, s_2ndposy);
		}
	}
	s_firstmodelpanelpos = false;


	s_modelpanel.panel = new OrgWindow(
		istopmost,
		clsname,		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		//WindowPos(s_toolwidth, TOPSLIDERSWNDH),		//位置
		s_modelpanelpos,
		WindowSize(s_modelwindowwidth, s_modelwindowheight),	//サイズ
		L"ModelPanel",	//タイトル
		//g_mainhwnd,					//親ウィンドウハンドル
		//false,
		parentwnd,
		true,					//表示・非表示状態
		//70,50,70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否

	if (s_modelpanel.panel) {
		s_modelpanel.panel->setVisible(false);//作成中
		s_modelpanel.panel->setSizeMin(WindowSize(150, 150));		// 最小サイズを設定


		//スクロールウインドウ
		s_modelpanel.scroll = new OWP_ScrollWnd(L"ModelPanelScroll", true, 20);
		if (!s_modelpanel.scroll) {
			_ASSERT(0);
			return 1;
		}
		//要素数が変わったときには指定し忘れないように！！！
		s_modelpanel.scroll->setLineDataSize(modelnum + 3);
		s_modelpanel.scroll->setSize(WindowSize(s_modelwindowwidth, s_modelwindowheight - 30));
		s_modelpanel.panel->addParts(*(s_modelpanel.scroll));
		s_modelpanel.panel->setPos(s_modelpanelpos);
		s_modelpanel.scroll->setPos(WindowPos(0, 30));

		int modelcnt;

		if (modelnum > 0) {

			for (modelcnt = 0; modelcnt < modelnum; modelcnt++) {
				CModel* curmodel = s_chascene->GetModel(modelcnt);
				if (curmodel) {

					//2024/07/12
					//文字を大きくした影響で
					//モデル名がdeleteボタン側にはみ出すことが多くなった
					//文字数制限をして表示がはみ出さないように.
					WCHAR printname[64] = { 0L };
					//ShortenNameW(curmodel->GetFileName(), printname, 64, 21);
					ShortenNameW(curmodel->GetFileName(), printname, 64, 25);

					if (modelcnt == 0) {
						bool limitnamelen = true;
						s_modelpanel.radiobutton = new OWP_RadioButton(printname, limitnamelen, 20);
						if (!s_modelpanel.radiobutton) {
							_ASSERT(0);
							return 1;
						}
					}
					else {
						if (s_modelpanel.radiobutton) {
							s_modelpanel.radiobutton->addLine(printname);
						}
					}
				}
				else {
					_ASSERT(0);
				}
			}

			//s_modelpanel.separator =  new OWP_Separator(s_modelpanel.panel, false);// セパレータ1（境界線による横方向2分割）
			s_modelpanel.separator = new OWP_Separator(s_modelpanel.panel, true, 0.70, true, s_modelpanel.scroll);// セパレータ1（境界線による横方向2分割）
			if (!s_modelpanel.separator) {
				_ASSERT(0);
				return 1;
			}
			s_modelpanel.separator->setSize(WindowSize(s_modelwindowwidth, s_modelwindowheight));
			s_modelpanel.separator->setPos(OrgWinGUI::WindowPos(0, 0));

			// セパレータ2（境界線による横方向2分割）
			s_modelpanel.separator2 = new OWP_Separator(s_modelpanel.panel, true, 0.5, true, s_modelpanel.scroll);// セパレータ2（境界線による横方向2分割）
			if (!s_modelpanel.separator2) {
				_ASSERT(0);
				return 1;
			}
			s_modelpanel.separator2->setSize(WindowSize(s_modelwindowwidth / 2, s_modelwindowheight));
			s_modelpanel.separator2->setPos(OrgWinGUI::WindowPos(0, 0));


			for (modelcnt = 0; modelcnt < modelnum; modelcnt++) {
				CModel* curmodel = s_chascene->GetModel(modelcnt);
				if (curmodel) {
					OWP_CheckBoxA* owpCheckBox = new OWP_CheckBoxA(L"Show", curmodel->GetModelDisp(), 20, false);
					if (owpCheckBox) {
						s_modelpanel.checkvec.push_back(owpCheckBox);
						OWP_Button* owpButton = new OWP_Button(L"del", 20);
						if (owpButton) {
							s_modelpanel.delbutton.push_back(owpButton);
						}
						else {
							_ASSERT(0);
							return 1;
						}
					}
					else {
						_ASSERT(0);
						return 1;
					}
				}
			}


			//s_modelpanel.panel->addParts(*(s_modelpanel.separator));
			if (s_modelpanel.scroll) {
				s_modelpanel.scroll->addParts(*(s_modelpanel.separator));
			}
			if (s_modelpanel.separator) {
				if (s_modelpanel.radiobutton) {
					s_modelpanel.separator->addParts1(*(s_modelpanel.radiobutton));
				}
				if (s_modelpanel.separator2) {
					s_modelpanel.separator->addParts2(*(s_modelpanel.separator2));
				}
			}


			for (modelcnt = 0; modelcnt < modelnum; modelcnt++) {
				if (s_modelpanel.separator2) {
					OWP_CheckBoxA* curcb = s_modelpanel.checkvec[modelcnt];
					if (curcb) {
						s_modelpanel.separator2->addParts1(*curcb);
					}
					OWP_Button* curbutton = s_modelpanel.delbutton[modelcnt];
					if (curbutton) {
						s_modelpanel.separator2->addParts2(*curbutton);
					}
				}
			}

			s_modelpanel.modelindex = s_curmodelmenuindex;
			if (s_modelpanel.radiobutton) {
				s_modelpanel.radiobutton->setSelectIndex(s_modelpanel.modelindex, false);
			}

			//s_modelpanel.scroll->inView(s_modelpanel.modelindex);
			if (s_modelpanel.scroll) {
				s_modelpanel.scroll->setShowPosLine(s_savemodelpanelshowposline);
			}


			//s_modelpanel.scroll->addParts(*(s_modelpanel.separator));
			//s_modelpanel.panel->addParts(*(s_modelpanel.scroll));


			s_modelpanel.scroll->autoResize();
			s_modelpanel.separator->autoResize();
			s_modelpanel.separator2->autoResize();

		}


		//if (s_modelpanel.panel && s_modelpanel.scroll) {
		//	if (s_modelpanel.separator) {
		//		s_modelpanel.scroll->addParts(*(s_modelpanel.separator));
		//	}
		//	s_modelpanel.panel->addParts(*(s_modelpanel.scroll));
		//	s_modelpanel.scroll->setPos(OrgWinGUI::WindowPos(0, 30));
		//}


		//s_modelpanel.panel->setVisible(0);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	////////////
		if (s_modelpanel.panel) {
			s_modelpanel.panel->setCloseListener([]() {
				if (s_model) {
					s_closemodelFlag = true;
				}
				});
		}

		for (modelcnt = 0; modelcnt < modelnum; modelcnt++) {
			if (s_modelpanel.checkvec[modelcnt]) {
				s_modelpanel.checkvec[modelcnt]->setButtonListener([modelcnt]() {
					if (s_model && s_chascene) {
						if (modelcnt < s_chascene->GetModelNum()) {
							CModel* curmodel = s_chascene->GetModel(modelcnt);
							if ((s_underdelmotion == false) && (s_opedelmotioncnt < 0) && //Motion削除と同時は禁止 
								!s_underdelmodel && (s_opedelmodelcnt < 0) && 
								curmodel && !s_underdispmodel) {

								//ここでOnDelModelを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
								s_underdispmodel = true;
								s_opedispmodelcnt = modelcnt;
							}
						}
					}
				});
			}


			if (s_modelpanel.delbutton[modelcnt]) {
				s_modelpanel.delbutton[modelcnt]->setButtonListener([modelcnt]() {
					if (s_model && s_chascene) {
						if ((modelcnt < s_chascene->GetModelNum()) && (s_chascene->GetModelNum() >= 2)) {//全部消すときはメインメニューから
							CModel* curmodel = s_chascene->GetModel(modelcnt);
							if ((s_underdelmotion == false) && (s_opedelmotioncnt < 0) && //Motion削除と同時は禁止 
								(s_opedelmodelcnt < 0) && curmodel && !s_underdelmodel) {
								s_underdelmodel = true;
								//bool ondelbutton = true;
								//OnDelModel(modelcnt, ondelbutton);//s_modelpanel.modelindexはs_modelのindexなので違う

								//ここでOnDelModelを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
								s_opedelmodelcnt = modelcnt;

								s_model = 0;//カレントモデルに影響しないように

								Sleep(100);//ボタン連打でメニューのモーション数が実際より減ることがあったので
							}
						}
					}
				});
			}
		}

		if (s_modelpanel.radiobutton) {
			s_modelpanel.radiobutton->setSelectListener([]() {
				if (s_model && s_chascene) {
					int curindex = s_modelpanel.radiobutton->getSelectIndex();
					if ((s_opeselectmodelcnt < 0) && !s_underselectmodel && 
						(s_underdelmotion == false) && (s_opedelmotioncnt < 0) &&
						(curindex >= 0) && (curindex < s_chascene->GetModelNum())) {

						//s_modelpanel.modelindex = curindex;
						//OnModelMenu(true, s_modelpanel.modelindex, 1);
						//s_modelpanel.panel->callRewrite();

						//ここでOnModelMenuを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
						s_underselectmodel = true;
						s_opeselectmodelcnt = curindex;
					}
				}
			});
		}

		//if (s_firstmodelpanelpos) {
		//	if (g_4kresolution) {
		//		s_modelpanelpos = WindowPos(s_toolwidth, TOPSLIDERSWNDH);
		//	}
		//	else {
		//		RECT wnd3drect;
		//		if (g_mainhwnd) {
		//			GetWindowRect(g_mainhwnd, &wnd3drect);
		//			s_modelpanelpos = WindowPos(wnd3drect.left + 100, wnd3drect.top + 500);
		//		}
		//		else {
		//			s_modelpanelpos = WindowPos(200, s_2ndposy);
		//		}
		//	}
		//	s_firstmodelpanelpos = false;
		//}
		//s_modelpanel.panel->setPos(s_modelpanelpos);

		////s_modelpanel.panel->setSize(WindowSize(200, 100));//880
		//s_modelpanel.panel->setSize(WindowSize(s_modelwindowwidth, s_modelwindowheight));


		s_rcmodelpanel.top = s_modelpanelpos.y;
		s_rcmodelpanel.bottom = s_modelpanelpos.y + s_modelwindowheight;
		s_rcmodelpanel.left = s_modelpanelpos.x;
		s_rcmodelpanel.right = s_modelpanelpos.x + s_modelwindowwidth;

		//if (g_4kresolution) {
		//	//4K時は　フレーム組み込み表示
		//	s_modelpanel.panel->setVisible(true);
		//	s_dispmodel = true;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
		//}
		//else {
		if (s_modelpanel.panel) {
			s_modelpanel.panel->setVisible(false);
		}
	}
	else {
		_ASSERT(0);
		return 1;
	}
	s_dispmodel = false;//!!!!!!!!!!!!!!!!! modelpanelのdispflag
	//}

	return 0;
}

int DestroyCameraPanel()
{
	if (s_camerapanel.panel) {
		s_camerapanel.panel->setVisible(false);
		delete s_camerapanel.panel;
		s_camerapanel.panel = 0;
	}
	if (s_camerapanel.scroll) {
		delete s_camerapanel.scroll;
		s_camerapanel.scroll = 0;
	}
	if (s_camerapanel.radiobutton) {
		delete s_camerapanel.radiobutton;
		s_camerapanel.radiobutton = 0;
	}
	if (s_camerapanel.separator) {
		delete s_camerapanel.separator;
		s_camerapanel.separator = 0;
	}
	if (!(s_camerapanel.delbutton.empty())) {
		int buttonnum = (int)s_camerapanel.delbutton.size();
		int buttonno;
		for (buttonno = 0; buttonno < buttonnum; buttonno++) {
			delete s_camerapanel.delbutton[buttonno];
		}
	}
	s_camerapanel.delbutton.clear();

	s_camerapanel.modelindex = -1;

	return 0;
}

int CreateCameraPanel()
{
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	SetCameraModel();

	if (s_camerapanel.panel) {
		s_firstcamerapanelpos = false;
		s_camerapanelpos = s_camerapanel.panel->getPos();
	}
	DestroyCameraPanel();

	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}

	int modelnum = s_chascene->GetModelNum();
	//if (modelnum <= 0) {
	//	return 0;
	//}
	//if (!s_model) {
	//	return 0;
	//}
	int cameranum;
	if (s_cameramodel) {
		cameranum = s_cameramodel->GetCameraMotInfoSize();
	}
	else {
		cameranum = 0;
	}

	//if (motionnum <= 0) {
	//	return 0;
	//}

	int classcnt = 0;
	WCHAR clsname[256];
	swprintf_s(clsname, 256, L"CameraPanel%d", classcnt);

	HWND parentwnd;
	int istopmost;
	if (g_4kresolution) {
		parentwnd = g_mainhwnd;
		istopmost = 0;
		//istopmost = 1;
	}
	else {
		parentwnd = NULL;
		istopmost = 1;
	}


	if (g_4kresolution) {
		//4Kの場合には　位置固定フレームに埋め込み
		s_camerapanelpos = WindowPos(s_timelinewidth, TOPSLIDERSWNDH + s_modelwindowheight + s_motionwindowheight);
	}
	else if (s_firstcamerapanelpos) {
		RECT wnd3drect;
		if (g_mainhwnd) {
			GetWindowRect(g_mainhwnd, &wnd3drect);
			s_camerapanelpos = WindowPos(wnd3drect.left + 500 + 500, wnd3drect.top + 500);
		}
		else {
			s_motionpanelpos = WindowPos(700, s_2ndposy);
		}
	}
	s_firstcamerapanelpos = false;


	s_camerapanel.panel = new OrgWindow(
		istopmost,
		clsname,		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		s_camerapanelpos,		//位置
		WindowSize(s_camerawindowwidth, s_camerawindowheight),	//サイズ
		L"CameraPanel",	//タイトル
		//g_mainhwnd,					//親ウィンドウハンドル
		//false,
		parentwnd,
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否
	if (s_camerapanel.panel) {
		s_camerapanel.panel->setSizeMin(WindowSize(150, 150));		// 最小サイズを設定



		if (s_cameramodel) {
			int cameracnt = 0;
			int minum;
			int miindex;
			minum = s_cameramodel->GetMotInfoSize();
			for (miindex = 0; miindex < minum; miindex++) {
				MOTINFO curmi = s_cameramodel->GetMotInfoByIndex(miindex);
				if (curmi.cameramotion) {//!!!!!
					WCHAR wmotname[MAX_PATH] = { 0L };
					MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, curmi.motname, 256, wmotname, MAX_PATH);
					if (cameracnt == 0) {
						bool limitnamelen = true;
						s_camerapanel.radiobutton = new OWP_RadioButton(wmotname, limitnamelen, 20);
						if (!s_camerapanel.radiobutton) {
							_ASSERT(0);
							return 1;
						}
					}
					else {
						if (s_camerapanel.radiobutton) {
							if (wmotname[0] != 0L) {
								s_camerapanel.radiobutton->addLine(wmotname);
							}
							else {
								s_camerapanel.radiobutton->addLine(L"NoName");
							}
						}
					}

					cameracnt++;
				}
			}

			//スクロールウインドウ
			s_camerapanel.scroll = new OWP_ScrollWnd(L"CameraPanelScroll", true, 20);
			if (!s_camerapanel.scroll) {
				_ASSERT(0);
				return 1;
			}
			//要素数が変わったときには指定し忘れないように！！！
			s_camerapanel.scroll->setLineDataSize(cameranum + 3);
			s_camerapanel.scroll->setSize(WindowSize(s_camerawindowwidth, s_camerawindowheight - 30));
			s_camerapanel.panel->addParts(*(s_camerapanel.scroll));
			s_camerapanel.panel->setPos(s_camerapanelpos);
			s_camerapanel.scroll->setPos(WindowPos(0, 30));

			s_camerapanel.separator = new OWP_Separator(s_camerapanel.panel, true, 0.8, true, s_camerapanel.scroll);									// セパレータ1（境界線による横方向2分割）
			if (!s_camerapanel.separator) {
				_ASSERT(0);
				return 1;
			}
			//s_camerapanel.separator->setSize(WindowSize(s_camerawindowwidth, s_camerawindowheight));
			//s_camerapanel.scroll->addParts(*(s_camerapanel.separator));
			if (s_camerapanel.separator) {
				s_camerapanel.scroll->addParts(*(s_camerapanel.separator));
				if (s_camerapanel.radiobutton) {
					s_camerapanel.separator->addParts1(*(s_camerapanel.radiobutton));//add once
				}
			}


			for (miindex = 0; miindex < minum; miindex++) {
				MOTINFO curmi = s_cameramodel->GetMotInfoByIndex(miindex);
				if (curmi.cameramotion) {
					OWP_Button* owpButton = new OWP_Button(L"delete", 20);
					if (owpButton) {
						s_camerapanel.delbutton.push_back(owpButton);
						s_camerapanel.separator->addParts2(*owpButton);
					}
					else {
						_ASSERT(0);
						return 1;
					}
				}
			}


			s_camerapanel.modelindex = s_curmodelmenuindex;
			//s_camerapanel.radiobutton->setSelectIndex(0);
			if (s_cameramodel) {
				if (s_camerapanel.radiobutton) {
					int cameramotid = s_cameramodel->GetCameraMotionId();
					if (cameramotid > 0) {
						int cameramotindex = s_cameramodel->MotionID2CameraIndex(cameramotid);
						if (cameramotindex >= 0) {
							s_cameramenuindexmap[s_cameramodel] = cameramotindex;
							s_camerapanel.radiobutton->setSelectIndex(cameramotindex, false);//!!!!
						}
					}
				}
				//s_camerapanel.scroll->inView(s_motmenuindexmap[s_cameramodel]);
				if (s_camerapanel.scroll) {
					s_camerapanel.scroll->setShowPosLine(s_savecamerapanelshowposline);
				}
			}
			else {
				_ASSERT(0);
				return 1;
			}

		}
		else {
			//_ASSERT(0);
			return 0;//s_cameramodel == NULL : 0 return
		}


		if (s_camerapanel.panel) {
			s_camerapanel.panel->setVisible(false);//作成中非表示

			s_camerapanel.panel->setCloseListener([]() {
				if (s_cameramodel) {
					s_closecameraFlag = true;
				}
				});

		}

		if (s_cameramodel) {
			int delmenuindex = 0;
			for (delmenuindex = 0; delmenuindex < s_cameramodel->GetCameraMotInfoSize(); delmenuindex++) {
				if (s_camerapanel.delbutton[delmenuindex]) {
					s_camerapanel.delbutton[delmenuindex]->setButtonListener([delmenuindex]() {
						if ((s_underdelmodel == false) && (s_opedelmodelcnt < 0) && //Model削除と同時は禁止
							!s_underdelmotion && s_cameramodel && (s_cameramodel->GetCameraMotInfoSize() >= 2)) {//全部消すときはメインメニューから

							MOTINFO camerami = s_cameramodel->GetCameraMotInfoByCameraIndex(delmenuindex);
							if (camerami.motid > 0) {
								int delmotid = camerami.motid;
								int deleteindex = s_cameramodel->MotionID2Index(delmotid);
								if (deleteindex >= 0) {
									s_opedelmotioncnt = deleteindex;
									s_underdelmotion = true;
									Sleep(100);//ボタン連打でメニューのモーション数が実際より減ることがあったので
								}
							}

							//ここでOnDelMotionを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ

						}
						});
				}
				else {
					_ASSERT(0);
					return 1;
				}
			}
		}

		if (s_camerapanel.radiobutton) {
			s_camerapanel.radiobutton->setSelectListener([]() {
				if (s_cameramodel) {
					int curindex = s_camerapanel.radiobutton->getSelectIndex();
					if ((s_opeselectcameracnt < 0) && !s_underselectcamera && (curindex >= 0) && (curindex < s_cameramodel->GetCameraMotInfoSize())) {
						s_opeselectcameracnt = curindex;
						s_underselectcamera = true;
						//int cameraindex = curindex;
						//OnAnimMenu(true, cameraindex, 1);
						//s_camerapanel.panel->callRewrite();

						//ここでOnAnimMenuを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
					}
				}
				});
		}

		//s_motionpanel.panel->setPos(s_motionpanelpos);
		//s_motionpanel.panel->setSize(WindowSize(s_motionwindowwidth, s_motionwindowheight));

		s_rccamerapanel.top = s_camerapanelpos.y;
		s_rccamerapanel.bottom = s_camerapanelpos.y + s_camerawindowheight;
		s_rccamerapanel.left = s_camerapanelpos.x;
		s_rccamerapanel.right = s_camerapanelpos.x + s_camerawindowwidth;

		if (g_4kresolution) {
			//4K時は　フレーム組み込み表示
			if (s_camerapanel.panel) {
				s_camerapanel.panel->setVisible(true);
			}
			s_dispcamera = true;//!!!!!!!!!!!!!!!!! camerapanelのdispflag
		}
		else {
			if (s_camerapanel.panel) {
				s_camerapanel.panel->setVisible(false);
			}
			s_dispcamera = false;//!!!!!!!!!!!!!!!!! camerapanelのdispflag
		}
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;
}


int DestroyMotionPanel()
{
	if (s_motionpanel.panel) {
		s_motionpanel.panel->setVisible(false);
		delete s_motionpanel.panel;
		s_motionpanel.panel = 0;
	}
	if (s_motionpanel.scroll) {
		delete s_motionpanel.scroll;
		s_motionpanel.scroll = 0;
	}
	if (s_motionpanel.radiobutton) {
		delete s_motionpanel.radiobutton;
		s_motionpanel.radiobutton = 0;
	}
	if (s_motionpanel.separator) {
		delete s_motionpanel.separator;
		s_motionpanel.separator = 0;
	}
	if (!(s_motionpanel.delbutton.empty())) {
		int buttonnum = (int)s_motionpanel.delbutton.size();
		int buttonno;
		for (buttonno = 0; buttonno < buttonnum; buttonno++) {
			delete s_motionpanel.delbutton[buttonno];
		}
	}
	s_motionpanel.delbutton.clear();

	s_motionpanel.modelindex = -1;

	return 0;
}

int CreateMotionPanel()
{
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	if (s_motionpanel.panel) {
		s_firstmotionpanelpos = false;
		s_motionpanelpos = s_motionpanel.panel->getPos();
	}
	DestroyMotionPanel();


	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}

	int modelnum = s_chascene->GetModelNum();
	//if (modelnum <= 0) {
	//	return 0;
	//}
	//if (!s_model) {
	//	return 0;
	//}
	int motionnum;
	if (s_model) {
		motionnum = s_model->GetMotInfoSize();
	}
	else {
		motionnum = 0;
	}
	
	//if (motionnum <= 0) {
	//	return 0;
	//}

	int classcnt = 0;
	WCHAR clsname[256];
	swprintf_s(clsname, 256, L"MotionPanel%d", classcnt);

	HWND parentwnd;
	int istopmost;
	if (g_4kresolution) {
		parentwnd = g_mainhwnd;
		istopmost = 0;
		//istopmost = 1;
	}
	else {
		parentwnd = NULL;
		istopmost = 1;
	}


	if (g_4kresolution) {
		//4Kの場合には　位置固定フレームに埋め込み
		s_motionpanelpos = WindowPos(s_timelinewidth, TOPSLIDERSWNDH + s_modelwindowheight);
	}
	else if (s_firstmotionpanelpos) {
		RECT wnd3drect;
		if (g_mainhwnd) {
			GetWindowRect(g_mainhwnd, &wnd3drect);
			s_motionpanelpos = WindowPos(wnd3drect.left + 500, wnd3drect.top + 500);
		}
		else {
			s_motionpanelpos = WindowPos(600, s_2ndposy);
		}
	}
	s_firstmotionpanelpos = false;


	s_motionpanel.panel = new OrgWindow(
		istopmost,
		clsname,		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		s_motionpanelpos,		//位置
		WindowSize(s_motionwindowwidth, s_motionwindowheight),	//サイズ
		L"MotionPanel",	//タイトル
		//g_mainhwnd,					//親ウィンドウハンドル
		//false,
		parentwnd,
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否
	if (s_motionpanel.panel) {
		s_motionpanel.panel->setSizeMin(WindowSize(150, 150));		// 最小サイズを設定

		//スクロールウインドウ
		//2023/10/15 Separatorに渡すので　Separatorよりも先に作成
		s_motionpanel.scroll = new OWP_ScrollWnd(L"MotionPanelScroll", true, 20);
		if (!s_motionpanel.scroll) {
			_ASSERT(0);
			return 1;
		}
		//要素数が変わったときには指定し忘れないように！！！
		s_motionpanel.scroll->setLineDataSize(motionnum + 3);
		s_motionpanel.scroll->setSize(WindowSize(s_motionwindowwidth, s_motionwindowheight - 30));
		s_motionpanel.panel->addParts(*(s_motionpanel.scroll));
		s_motionpanel.panel->setPos(s_motionpanelpos);
		s_motionpanel.scroll->setPos(WindowPos(0, 30));



		if (s_model) {
			s_motionpanel.separator = new OWP_Separator(s_motionpanel.panel, true, 0.8, true, s_motionpanel.scroll);// セパレータ1（境界線による横方向2分割）
			if (!s_motionpanel.separator) {
				_ASSERT(0);
				return 1;
			}


			int motioncnt = 0;
			int minum;
			int miindex;
			minum = s_model->GetMotInfoSize();
			for (miindex = 0; miindex < minum; miindex++) {
				MOTINFO curmi = s_model->GetMotInfoByIndex(miindex);

				WCHAR wmotname[MAX_PATH] = { 0L };
				MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, curmi.motname, 256, wmotname, MAX_PATH);
				if (motioncnt == 0) {
					bool limitnamelen = true;
					s_motionpanel.radiobutton = new OWP_RadioButton(wmotname, limitnamelen, 20);
					if (!s_motionpanel.radiobutton) {
						_ASSERT(0);
						return 1;
					}
				}
				else {
					if (s_motionpanel.radiobutton) {
						if (wmotname[0] != 0L) {
							s_motionpanel.radiobutton->addLine(wmotname);
						}
						else {
							s_motionpanel.radiobutton->addLine(L"NoName");
						}
					}
				}

				motioncnt++;
			}

			s_motionpanel.separator->setSize(WindowSize(s_motionwindowwidth, s_motionwindowheight));
			s_motionpanel.scroll->addParts(*(s_motionpanel.separator));
			if (s_motionpanel.radiobutton) {
				s_motionpanel.separator->addParts1(*(s_motionpanel.radiobutton));//add once
			}


			for (miindex = 0; miindex < minum; miindex++) {
				MOTINFO curmi = s_model->GetMotInfoByIndex(miindex);
				OWP_Button* owpButton = new OWP_Button(L"delete", 20);
				if (owpButton) {
					s_motionpanel.delbutton.push_back(owpButton);
					s_motionpanel.separator->addParts2(*owpButton);
				}
				else {
					_ASSERT(0);
					return 1;
				}
			}


			s_motionpanel.modelindex = s_curmodelmenuindex;
			//s_motionpanel.radiobutton->setSelectIndex(0);
			if (s_model) {
				if (s_motionpanel.radiobutton) {
					s_motionpanel.radiobutton->setSelectIndex(s_motmenuindexmap[s_model], false);//!!!!
				}
				//s_motionpanel.scroll->inView(s_motmenuindexmap[s_model]);
				if (s_motionpanel.scroll) {
					s_motionpanel.scroll->setShowPosLine(s_savemotionpanelshowposline);
				}
			}
			else {
				_ASSERT(0);
				return 1;
			}

		}
		else {
			//_ASSERT(0);
			return 0;//s_model == NULL : 0 return
		}


		if (s_motionpanel.panel) {
			s_motionpanel.panel->setVisible(false);//作成中非表示

			s_motionpanel.panel->setCloseListener([]() {
				if (s_model) {
					s_closemotionFlag = true;
				}
				});

		}

		if (s_model) {
			int delmenuindex = 0;
			for (delmenuindex = 0; delmenuindex < s_model->GetMotInfoSize(); delmenuindex++) {
				if (s_motionpanel.delbutton[delmenuindex]) {
					s_motionpanel.delbutton[delmenuindex]->setButtonListener([delmenuindex]() {
						if ((s_underdelmodel == false) && (s_opedelmodelcnt < 0) && //Model削除と同時は禁止
							(s_opedelmotioncnt < 0) && !s_underdelmotion && 
							s_model && (s_model->GetMotInfoSize() >= 2)) {//全部消すときはメインメニューから
							s_opedelmotioncnt = delmenuindex;
							s_underdelmotion = true;
							//bool ondelbutton = true;
							//OnDelMotion(delmenuindex, ondelbutton);

							//ここでOnDelMotionを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ

							Sleep(100);//ボタン連打でメニューのモーション数が実際より減ることがあったので
						}
						});
				}
				else {
					_ASSERT(0);
					return 1;
				}
			}
		}

		if (s_motionpanel.radiobutton) {
			s_motionpanel.radiobutton->setSelectListener([]() {
				if (s_model) {
					int curindex = s_motionpanel.radiobutton->getSelectIndex();
					if ((s_opeselectmotioncnt < 0) && !s_underselectmotion && (curindex >= 0) && (curindex < s_model->GetMotInfoSize())) {
						s_opeselectmotioncnt = curindex;
						s_underselectmotion = true;
						//int motionindex = curindex;
						//OnAnimMenu(true, motionindex, 1);
						//s_motionpanel.panel->callRewrite();

						//ここでOnAnimMenuを呼ぶとOrgWindowの関数を実行中にparentWindowがNULLになるなどしてエラーになる.フラグを立ててループで呼ぶ
					}
				}
				});
		}

		//s_motionpanel.panel->setPos(s_motionpanelpos);
		//s_motionpanel.panel->setSize(WindowSize(s_motionwindowwidth, s_motionwindowheight));

		s_rcmotionpanel.top = s_motionpanelpos.y;
		s_rcmotionpanel.bottom = s_motionpanelpos.y + s_motionwindowheight;
		s_rcmotionpanel.left = s_motionpanelpos.x;
		s_rcmotionpanel.right = s_motionpanelpos.x + s_motionwindowwidth;

		if (g_4kresolution) {
			//4K時は　フレーム組み込み表示
			if (s_motionpanel.panel) {
				s_motionpanel.panel->setVisible(true);
			}
			s_dispmotion = true;//!!!!!!!!!!!!!!!!! motionpanelのdispflag
		}
		else {
			if (s_motionpanel.panel) {
				s_motionpanel.panel->setVisible(false);
			}
			s_dispmotion = false;//!!!!!!!!!!!!!!!!! motionpanelのdispflag
		}
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;
}

//int SetConvBoneModel()
//{
//	int modelnum = (int)s_modelindex.size();
//	if (modelnum <= 0){
//		return 0;
//	}
//
//	HWND parwnd;
//	//parwnd = s_convboneWnd->getHWnd();
//	parwnd = s_3dwnd;
//
//	CRMenuMain* rmenu;
//	rmenu = new CRMenuMain(IDR_RMENU);
//	if (!rmenu){
//		return 1;
//	}
//	int ret;
//	ret = rmenu->Create(parwnd, MENUOFFSET_SETCONVBONEMODEL);
//	if (ret){
//		return 1;
//	}
//
//	HMENU submenu = rmenu->GetSubMenu();
//
//	int menunum;
//	menunum = GetMenuItemCount(submenu);
//	int menuno;
//	for (menuno = 0; menuno < menunum; menuno++)
//	{
//		RemoveMenu(submenu, 0, MF_BYPOSITION);
//	}
//
//	int modelno;
//	for (modelno = 0; modelno < modelnum; modelno++){
//		CModel* curmodel = s_modelindex[modelno].modelptr;
//		if (curmodel){
//			const WCHAR* modelname = curmodel->GetFileName();
//			if (modelname){
//				int setmenuid = ID_RMENU_0 + modelno + MENUOFFSET_SETCONVBONEMODEL;
//				AppendMenu(submenu, MF_STRING, setmenuid, modelname);
//			}
//		}
//	}
//
//
//	POINT pt;
//	GetCursorPos(&pt);
//	//::ScreenToClient(parwnd, &pt);
//
//	s_cursubmenu = rmenu->GetSubMenu();
//
//	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
//	int menuid;
//	menuid = rmenu->TrackPopupMenu(pt);
//	//if ((menuid >= ID_RMENU_0) && (menuid < (ID_RMENU_0 + modelnum))) {
//	//	int modelindex = menuid - ID_RMENU_0;
//	//	s_convbone_model = s_modelindex[modelindex].modelptr;
//
//	//	WCHAR strmes[1024];
//	//	if (!s_convbone_model) {
//	//		swprintf_s(strmes, 1024, L"convbone : sel model : modelptr NULL !!!");
//	//		::DSMessageBox(NULL, strmes, L"check", MB_OK);
//	//	}
//	//	else {
//	//		swprintf_s(strmes, 1024, L"%s", s_convbone_model->GetFileName());
//	//		s_cbselmodel->setName(strmes);
//	//	}
//	//}
//
//
//	rmenu->Destroy();
//	delete rmenu;
//	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
//
//	return 0;
//}

int SetConvBoneBvh()
{

	if (!s_chascene) {
		_ASSERT(0);
		return 0;
	}

	int modelnum = s_chascene->GetModelNum();

	if (modelnum <= 0) {
		return 0;
	}

	HWND parwnd;
	//parwnd = s_convboneWnd->getHWnd();
	parwnd = s_3dwnd;


	//###############################
	//joint対応表リセット 2022/09/13
	//###############################
	InitJointPair2ConvBoneWnd();


	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_SETCONVBONEBVH);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}

	int modelno;
	for (modelno = 0; modelno < modelnum; modelno++) {
		CModel* curmodel = s_chascene->GetModel(modelno);
		if (curmodel) {
			const WCHAR* modelname = curmodel->GetFileName();
			if (modelname) {
				int setmenuid = ID_RMENU_0 + modelno + MENUOFFSET_SETCONVBONEBVH;
				AppendMenu(submenu, MF_STRING, setmenuid, modelname);
			}
		}
	}


	POINT pt;
	GetCursorPos(&pt);
	//::ScreenToClient(parwnd, &pt);

	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	if (s_retargetdlg.GetVisible()) {
		//2023/10/15
		//OrgWindowのLisner関数でコンテクストメニューを出した場合　メニュー終了時にLBUTTONUPを呼び出す必要有り
		//呼び出さなかった場合　SetCaptureとReleaseCaptureのバランスが崩れて　スクロールバーを画面外でBUTTONUPしたときに処理されない
		::SendMessage(s_retargetdlg.GetHWnd(), WM_LBUTTONUP, 0, 0);
	}

	return 0;
}
int SetConvBone(int cbno)
{
	s_retargetdlg.SetRetargetBvhBoneCBNo(cbno);

	if (!s_chascene) {
		_ASSERT(0);
		return 1;
	}

	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}

	if (!s_retargetdlg.GetRetargetModel() || !s_retargetdlg.GetRetargetBvh()) {
		return 0;
	}

	HWND parwnd;
	//parwnd = s_convboneWnd->getHWnd();
	parwnd = s_3dwnd;
	//parwnd = NULL;


	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	//ret = rmenu->Create(parwnd, MENUOFFSET_SETCONVBONE);
	ret = rmenu->Create(parwnd, 0);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}

	int setmenuid0 = ID_RMENU_0 + 0;
	AppendMenu(submenu, MF_STRING, setmenuid0, L"NotSet");

	int bvhcbno = 0;
	int maxboneno = 0;
	map<int, CBone*>::iterator itrbone;
	for (itrbone = s_retargetdlg.GetRetargetBvh()->GetBoneListBegin(); 
		itrbone != s_retargetdlg.GetRetargetBvh()->GetBoneListEnd(); itrbone++) {
		CBone* curbone = itrbone->second;
		if (curbone && (curbone->IsSkeleton())) {
			int boneno = curbone->GetBoneNo();

			//s_bvhbone_bonenomap[bvhcbno] = boneno;//2024/07/07 メニューのインデックス-->ボーン番号　変換表
			s_retargetdlg.SetRetargetBvhBoneCBNo(bvhcbno, boneno);//2024/07/07 メニューのインデックス-->ボーン番号　変換表

			//int setmenuid = ID_RMENU_0 + boneno + 1;
			int setmenuid = ID_RMENU_0 + bvhcbno + 1;//2024/07/07
			AppendMenu(submenu, MF_STRING, setmenuid, curbone->GetWBoneName());
			if (boneno > maxboneno) {
				maxboneno = boneno;
			}

			bvhcbno++;//2024/07/07
		}
	}
	////s_maxboneno = s_convbone_bvh->GetBoneListSize();
	////s_maxboneno = s_convbone_bvh->GetBoneForMotionSize();
	//s_maxboneno = s_convbone_bvh->GetMaxBoneNo();

	POINT pt;
	GetCursorPos(&pt);
	//::ScreenToClient(parwnd, &pt);

	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int menuid;
	//menuid = rmenu->TrackPopupMenu(pt);
	menuid = rmenu->TrackPopupMenuReturnCmd(pt);//2024/07/07

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	if (s_retargetdlg.GetVisible()) {
		//2023/10/15
		//OrgWindowのLisner関数でコンテクストメニューを出した場合　メニュー終了時にLBUTTONUPを呼び出す必要有り
		//呼び出さなかった場合　SetCaptureとReleaseCaptureのバランスが崩れて　スクロールバーを画面外でBUTTONUPしたときに処理されない
		::SendMessage(s_retargetdlg.GetHWnd(), WM_LBUTTONUP, 0, 0);
	}

	int bvhbone_cbno = s_retargetdlg.GetRetargetBvhBoneCBNo();
	if ((menuid >= (ID_RMENU_0)) && (menuid < (ID_RMENU_0 + MAXBONENUM))) {
		if ((bvhbone_cbno >= 0) && (bvhbone_cbno < MAXBONENUM)) {
			if (menuid == (ID_RMENU_0 + 0)) {
				//未設定
				s_retargetdlg.SetConvBone_NoSet();
			}
			else {
				int bvhcbno = menuid - ID_RMENU_0 - 1;
				s_retargetdlg.SetConvBone_Set(bvhcbno);
			}
		}

	}

	return 0;
}

int InitJointPair2ConvBoneWnd()
{

	s_retargetdlg.InitJointPair2ConvBoneWnd();

	return 0;
}

int SetJointPair2ConvBoneWnd()
{
	if (!s_model) {
		return 0;
	}

	int result = s_retargetdlg.SetJointPair2ConvBoneWnd();
	return result;
}


int SaveMotionNameListFile()
{

	ChangeCurDirFromMameMediaToTest();

	//OPENFILENAME ofn;//stack size warning (MULTIPATH)
	OPENFILENAME* ofn = (OPENFILENAME*)malloc(sizeof(OPENFILENAME));
	if (!ofn) {
		_ASSERT(0);
		return 1;
	}
	ZeroMemory(ofn, sizeof(OPENFILENAME));

	ofn->lStructSize = sizeof(OPENFILENAME);
	//ofn->hwndOwner = hDlgWnd;
	ofn->hwndOwner = s_3dwnd;
	ofn->hInstance = 0;
	ofn->lpstrFilter = L"Retarget(*.mnl)\0*.mnl\0";
	ofn->lpstrCustomFilter = NULL;
	ofn->nMaxCustFilter = 0;
	ofn->nFilterIndex = 0;
	ofn->lpstrFile = g_tmpmqopath;
	ofn->nMaxFile = MULTIPATH;
	ofn->lpstrFileTitle = NULL;
	ofn->nMaxFileTitle = 0;
	ofn->lpstrInitialDir = NULL;
	ofn->lpstrTitle = L"GetFileNameDlg";
	//ofn->Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	ofn->Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn->nFileOffset = 0;
	ofn->nFileExtension = 0;
	ofn->lpstrDefExt = NULL;
	ofn->lCustData = NULL;
	ofn->lpfnHook = NULL;
	ofn->lpTemplateName = NULL;

	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);


	WCHAR* pext;
	pext = wcsstr(g_tmpmqopath, L".mnl");
	if (!pext) {
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MAX_PATH);//異なる拡張子のファイル名が残っている場合があるから
	}

	if (GetOpenFileNameW(ofn) == IDOK) {
		CMNLFile mnlfile;
		int result;
		result = mnlfile.WriteMNLFile(g_tmpmqopath, s_model);
	}

	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	//UnhookWinEvent(hhook);
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;


	if (ofn) {
		free(ofn);
		ofn = 0;
	}

	return 0;
}



int SaveRetargetFile()
{

	ChangeCurDirFromMameMediaToTest();

	int result = 0;
	WCHAR savepath[MULTIPATH];
	ZeroMemory(savepath, sizeof(WCHAR) * MULTIPATH);


	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize = sizeof(OPENFILENAME);
	//ofn.hwndOwner = hDlgWnd;
	ofn.hwndOwner = s_3dwnd;
	ofn.hInstance = 0;
	ofn.lpstrFilter = L"Retarget(*.rtg)\0*.rtg\0";
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 0;
	ofn.lpstrFile = g_tmpmqopath;
	ofn.nMaxFile = MULTIPATH;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.lpstrTitle = L"GetFileNameDlg";
	////ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	//ofn.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	//##########################################################################
	//2024/02/24
	//OFN_EXPLORERを指定してエクスプローラタイプのダイアログにすると
	//現状のゲームパッド対応コードでは目的のGUIコントロールを取得することが出来なかった
	//ゲームパッド対応はモーション遷移テストやキャラクターの移動などに限定して使用していく予定
	//ゲームパッド対応時にもマウスは必要という方針に変更
	//2024/02/24時点では一時的にゲームパッド対応コードをコメントアウトしている
	//##########################################################################
	ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpstrDefExt = NULL;
	ofn.lCustData = NULL;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;

	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);


	WCHAR* pext;
	pext = wcsstr(g_tmpmqopath, L".rtg");
	if (!pext) {
		ZeroMemory(g_tmpmqopath, sizeof(WCHAR) * MAX_PATH);//異なる拡張子のファイル名が残っている場合があるから
	}

	if (GetOpenFileNameW(&ofn) == IDOK) {

		MoveMemory(savepath, g_tmpmqopath, sizeof(WCHAR) * MAX_PATH);//MULTIPATHではない

		std::map<CBone*, CBone*> convbonemap;
		s_retargetdlg.GetRetargetConvBoneMap(convbonemap);

		CRetargetFile rtgfile;
		result = rtgfile.WriteRetargetFile(g_tmpmqopath, 
			s_retargetdlg.GetRetargetModel(), s_retargetdlg.GetRetargetBvh(), convbonemap);
		if (result != 0) {
			::MessageBox(NULL, L"保存に失敗しました。\n書き込み禁止ディレクトリの可能性があります。\n保存場所を変えて再試行してみてください。", L"エラー", MB_OK);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
			_ASSERT(0);
			return 1;
		}
	}


	//履歴を保存
	if ((result == 0) && (savepath[0] != 0L)) {
		SaveRtgHistory(savepath);
	}


	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	//UnhookWinEvent(hhook);
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;

	return 0;
}
int LoadRetargetFile(WCHAR* srcfilename)
{
	if (!s_retargetdlg.GetRetargetModel() || !s_retargetdlg.GetRetargetBvh()) {
		_ASSERT(0);
		return 1;
	}

	ChangeCurDirFromMameMediaToTest();

	
	//s_convbonemap.clear();
	InitJointPair2ConvBoneWnd();


	//OPENFILENAME ofn;
	//ofn.lStructSize = sizeof(OPENFILENAME);
	////ofn.hwndOwner = hDlgWnd;
	//ofn.hwndOwner = s_3dwnd;
	//ofn.hInstance = 0;
	//ofn.lpstrFilter = L"Retarget(*.rtg)\0*.rtg\0";
	//ofn.lpstrCustomFilter = NULL;
	//ofn.nMaxCustFilter = 0;
	//ofn.nFilterIndex = 0;
	//ofn.lpstrFile = g_tmpmqopath;
	//ofn.nMaxFile = MULTIPATH;
	//ofn.lpstrFileTitle = NULL;
	//ofn.nMaxFileTitle = 0;
	//ofn.lpstrInitialDir = NULL;
	//ofn.lpstrTitle = L"GetFileNameDlg";
	////ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ALLOWMULTISELECT;
	//ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	//ofn.nFileOffset = 0;
	//ofn.nFileExtension = 0;
	//ofn.lpstrDefExt = NULL;
	//ofn.lCustData = NULL;
	//ofn.lpfnHook = NULL;
	//ofn.lpTemplateName = NULL;

	int result = 0;

	if (srcfilename == 0) {
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
		//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
		InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

		int dlgret;
		s_filterindex = 7;
		dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_OPENMQODLG),
			s_3dwnd, (DLGPROC)OpenMqoDlgProc);
		if ((dlgret != IDOK) || (g_tmpmqopath[0] == 0L)) {

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			return 0;
		}


		//WCHAR savepath[MULTIPATH];//stack size warning
		WCHAR* tmpsavepath = new WCHAR[MULTIPATH];
		if (!tmpsavepath) {
			_ASSERT(0);
			return 1;
		}
		ZeroMemory(tmpsavepath, sizeof(WCHAR) * MULTIPATH);
		MoveMemory(tmpsavepath, g_tmpmqopath, sizeof(WCHAR) * MULTIPATH);


		//rtgファイルを読み込む
		CRetargetFile rtgfile;
		std::map<CBone*, CBone*> convbonemap;
		result = rtgfile.LoadRetargetFile(g_tmpmqopath, 
			s_retargetdlg.GetRetargetModel(), s_retargetdlg.GetRetargetBvh(), convbonemap);
		if (result == 0) {

			s_retargetdlg.SetRetargetConvBoneMap(convbonemap);

			if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
				SetJointPair2ConvBoneWnd();
			}
		}

		SaveRtgHistory(tmpsavepath);
		if (tmpsavepath)
			delete[] tmpsavepath;


		//if (GetOpenFileNameW(&ofn) == IDOK) {
		//	CRetargetFile rtgfile;
		//	result = rtgfile.LoadRetargetFile(g_tmpmqopath, s_convbone_model, s_convbone_bvh, s_convbonemap);
		//	if (result == 0) {
		//		//if (g_retargetbatchflag == 0) {
		//		if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
		//			SetJointPair2ConvBoneWnd();
		//		}
		//	}
		//}

		InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
		//UnhookWinEvent(hhook);
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;

	}
	else {
		//s_getfilenamehwnd = 0;
		//s_getfilenametreeview = 0;
		//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
		//InterlockedExchange(&g_undertrackingRMenu, (LONG)1);


		//ファイル名指定時はそのまま開く
		//バッチからも呼ばれる

		CRetargetFile rtgfile;
		std::map<CBone*, CBone*> convbonemap;
		result = rtgfile.LoadRetargetFile(srcfilename,
			s_retargetdlg.GetRetargetModel(), s_retargetdlg.GetRetargetBvh(), convbonemap);
		if (result == 0) {
			
			s_retargetdlg.SetRetargetConvBoneMap(convbonemap);

			if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
				SetJointPair2ConvBoneWnd();
			}
		}

		//InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
		////UnhookWinEvent(hhook);
		//s_getfilenamehwnd = 0;
		//s_getfilenametreeview = 0;
	}
	return result;
}


int RetargetMotion()
{
	//static CModel* s_convbone_model = 0;
	//static CModel* s_convbone_model_batch = 0;
	//static CModel* s_convbone_bvh = 0;

	if (!s_retargetdlg.GetRetargetModel() || !s_retargetdlg.GetRetargetBvh()) {
		return 0;
	}

	if (s_model != s_retargetdlg.GetRetargetModel()) {
		::DSMessageBox(NULL, L"Retry After Selectiong ShapeModel using ModelMenu Of MainWindow.", L"error!!!", MB_OK);
		s_retargetdlg.GetRetargetModel()->SetUnderRetarget(false);
		s_retargetdlg.GetRetargetBvh()->SetUnderRetarget(false);
		return 1;
	}


	//2024/06/22_2
	//src, dst両方にリターゲットフラグを立てて　UpdateMatrixにて強制的に視野内と判定する必要有(いくつかの処理がスキップされないように)
	s_retargetdlg.GetRetargetModel()->SetUnderRetarget(true);
	s_retargetdlg.GetRetargetBvh()->SetUnderRetarget(true);


	//2024/06/21
	//UnderRetagetFlagをtrueにした状態でUpdateMatrixを呼んでからリターゲット処理をする
	ChaMatrix modelwm = s_retargetdlg.GetRetargetModel()->GetWorldMat();
	s_retargetdlg.GetRetargetModel()->UpdateMatrix(false, &modelwm, &s_matView, &s_matProj, true, 0);
	ChaMatrix bvhwm = s_retargetdlg.GetRetargetBvh()->GetWorldMat();
	s_retargetdlg.GetRetargetBvh()->UpdateMatrix(false, &bvhwm, &s_matView, &s_matProj, true, 0);



	//2024/06/27 呼んでもエラーにならないようにしたが　冗長なのでコメントアウト
	//bool forceflag = true;
	//bool callundo = false;
	//OnChangeModel(s_convbone_model, forceflag, callundo);


	std::map<CBone*, CBone*> convbonemap;
	s_retargetdlg.GetRetargetConvBoneMap(convbonemap);
	int result = s_retargetdlg.GetRetargetModel()->Retarget(
		s_retargetdlg.GetRetargetBvh(), s_matView, s_matProj, convbonemap, AddMotion);
	if (result) {
		_ASSERT(0);
		//g_underRetargetFlag = false;
		s_retargetdlg.GetRetargetModel()->SetUnderRetarget(false);
		s_retargetdlg.GetRetargetBvh()->SetUnderRetarget(false);
		return 1;
	}
	//g_underRetargetFlag = false;
	s_retargetdlg.GetRetargetModel()->SetUnderRetarget(false);
	s_retargetdlg.GetRetargetBvh()->SetUnderRetarget(false);


	if (g_limitdegflag == true) {
		CopyWorldToLimitedWorld(s_model);
		ApplyNewLimitsToWM(s_model);
	}


	return 0;

}


int SetCamera6Angle()
{

	ChaVector3 weye, wdiff;
	weye = g_camEye;
	wdiff = g_camtargetpos - weye;
	float camdist = (float)ChaVector3LengthDbl(&wdiff);

	ChaVector3 neweye;
	float delta = 0.10f;

	if (g_keybuf[VK_F1] & 0x80) {
		neweye.x = g_camtargetpos.x;
		neweye.y = g_camtargetpos.y;
		neweye.z = g_camtargetpos.z - camdist;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);

	}
	else if (g_keybuf[VK_F2] & 0x80) {
		neweye.x = g_camtargetpos.x;
		neweye.y = g_camtargetpos.y;
		neweye.z = g_camtargetpos.z + camdist;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}
	else if (g_keybuf[VK_F3] & 0x80) {
		neweye.x = g_camtargetpos.x - camdist;
		neweye.y = g_camtargetpos.y;
		neweye.z = g_camtargetpos.z;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}
	else if (g_keybuf[VK_F4] & 0x80) {
		neweye.x = g_camtargetpos.x + camdist;
		neweye.y = g_camtargetpos.y;
		neweye.z = g_camtargetpos.z;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}
	else if (g_keybuf[VK_F5] & 0x80) {
		neweye.x = g_camtargetpos.x;
		neweye.y = g_camtargetpos.y + camdist;
		neweye.z = g_camtargetpos.z + delta;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}
	else if (g_keybuf[VK_F6] & 0x80) {
		neweye.x = g_camtargetpos.x;
		neweye.y = g_camtargetpos.y - camdist;
		neweye.z = g_camtargetpos.z - delta;

		////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
		////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		g_befcamEye = g_camEye;
		g_camEye = neweye;
		//!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
		//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
	}

	ChaVector3 diffv;
	diffv = g_camEye - g_camtargetpos;
	g_camdist = (float)ChaVector3LengthDbl(&diffv);

	SetCamera3DFromEyePos();

	return 0;
}

int OnAddMotion(int srcmotid, bool dorefreshtl)
{
	static int s_dbgcnt = 0;
	s_dbgcnt++;

	//MOTINFO* newmotinfo = s_model->GetMotInfo( srcmotid );

//WCHAR strchk[256] = { 0L };
//swprintf_s(strchk, 256, L"check OnAddMotion : 1 : %d, %d", srcmotid, (int)dorefreshtl);
//::MessageBox(g_mainhwnd, strchk, L"check!!!", MB_OK);

	CallF(AddTimeLine(srcmotid, dorefreshtl), return 1);

	//swprintf_s(strchk, 256, L"check OnAddMotion : 2 : %d, %d", srcmotid, (int)dorefreshtl);
	//::MessageBox(g_mainhwnd, strchk, L"check!!!", MB_OK);

	int selindex = (int)s_tlarray.size() - 1;
	CallF(OnAnimMenu(dorefreshtl, selindex), return 1);

	//swprintf_s(strchk, 256, L"check OnAddMotion : 3 : %d, %d", srcmotid, (int)dorefreshtl);
	//::MessageBox(g_mainhwnd, strchk, L"check!!!", MB_OK);


	return 0;

}

int StopBt()
{
	if (!s_chascene) {
		_ASSERT(0);
		return 0;
	}

	s_chascene->StopBt();


	//g_previewFlag = 0;

	//2022/11/07 btrec終了時にも　timeline表示を正常にするために　playerbuttonのpreviewstopと同じ処理をする
	s_LstopFlag = true; s_LcursorFlag = true; g_previewFlag = 0;



	////g_limitdegflag = s_savelimitdegflag;
	////if (s_LimitDegCheckBox) {
	////	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
	////}

	return 0;
}


int StartBt(CModel* curmodel, BOOL isfirstmodel, int flag, int btcntzero)
{
	if (!s_model || !curmodel || !s_chascene) {
		return 0;
	}

	if (s_model->GetNoBoneFlag()) {
		return 0;
	}
	if (!s_owpTimeline || !s_owpLTimeline || !s_owpEulerGraph) {
		return 0;
	}

	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//previewmodeがglobalなのでmodelごとにモードを設定するようにはなっていない。
	//ひとまず、全モデルへの適用という形をとってエラーにならないようにする。
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


	double curframe = 1.0;//初期値、start時の揺れに影響？

	if (flag == 1) {
		//まず物理IKを停止する。
		//プレビューを止めないとtimelineはスタートフレームになるが姿勢がスタートフレームにならない。
		//flag == 0で呼ぶとシミュが動かない。

		s_chascene->StopBt();

		g_previewFlag = 0;//!!!!!!!!!!!!!!!!!!!!!!!!!!!

		s_previewrange = s_editrange;
		//double rangestart;
		if (s_previewrange.IsSameStartAndEnd()) {
			//rangestart = 1.0;
			curframe = 1.0;
		}
		else {
			if (g_previewFlag == 5) {
				int tmpleng;
				double tmpstart, tmpend;
				s_previewrange.GetRange(&tmpleng, &tmpstart, &tmpend);
				curframe = s_previewrange.GetApplyFrame();
			}
			else {
				//rangestart = s_previewrange.GetStartFrame();
				curframe = s_previewrange.GetStartFrame();
			}
		}

		s_owpLTimeline->setCurrentTime(curframe, true);
		s_owpEulerGraph->setCurrentTime(curframe, false);

		OnFramePreviewStop();
	}

	static int resetflag = 0;//!!!!!!!!!!!!!!!!!!!! static 
	static int createflag = 0;//!!!!!!!!!!!!!!!!!!!! static 

	if (isfirstmodel == TRUE) {
		if ((flag == 0) && (g_previewFlag != 4)) {
			//F9キー
			g_previewFlag = 4;
			createflag = 1;
			resetflag = 0;//2021/06/18
		}
		else if (flag == 1) {
			//F10キー
			g_previewFlag = 5;
			createflag = 1;
			resetflag = 0;//2021/06/18
		}
		else if (flag == 2) {
			//spaceキー
			if (g_previewFlag == 4) {
				createflag = 1;//2021/06/18
				resetflag = 1;
			}
			else if (g_previewFlag == 5) {
				createflag = 1;//2021/06/18
				resetflag = 0;
			}
		}
		else {
			g_previewFlag = 0;
		}
	}


	int modelnum = s_chascene->GetModelNum();
	int modelcount;
	for (modelcount = 0; modelcount < modelnum; modelcount++) {
		CModel* pmodel = s_chascene->GetModel(modelcount);

		if (pmodel) {

			//if ((flag == 0) && (g_previewFlag != 4)){
				//F9キー
			if (btcntzero == 1) {
				pmodel->ZeroBtCnt();
				pmodel->SetCreateBtFlag(false);
			}
			//}
			//else if (flag == 1){
			//	//F10キー
			//	if (btcntzero == 1){
			//		curmodel->ZeroBtCnt();
			//		curmodel->SetCreateBtFlag(false);
			//	}
			//}


			//double curframe;
			if (flag == 0) {// bt simu
				if (resetflag == 1) {
					curframe = s_owpTimeline->getCurrentTime();
					//curmodel->GetMotionFrame(&curframe);
				}
				else {
					s_previewrange = s_editrange;
					//double rangestart;
					if (s_previewrange.IsSameStartAndEnd()) {
						//rangestart = 1.0;
						curframe = 1.0;
					}
					else {
						if (g_previewFlag == 5) {
							int tmpleng;
							double tmpstart, tmpend;
							s_previewrange.GetRange(&tmpleng, &tmpstart, &tmpend);
							curframe = s_previewrange.GetApplyFrame();
						}
						else {
							//rangestart = s_previewrange.GetStartFrame();
							curframe = s_previewrange.GetStartFrame();
						}
					}
					//curframe = 1.0;//!!!!!!!!!!

					//curframe = s_editrange.GetStartFrame();
					//curframe = s_buttonselectstart;

					s_owpLTimeline->setCurrentTime(curframe, false);
					s_owpEulerGraph->setCurrentTime(curframe, false);
				}
			}
			else if (flag == 2) {//2021/06/18
				if (resetflag == 1) {
					//curframe = s_owpTimeline->getCurrentTime();
					curframe = pmodel->GetCurrentFrame();
					s_owpLTimeline->setCurrentTime(curframe, false);
					s_owpEulerGraph->setCurrentTime(curframe, false);
				}
			}

			if ((g_previewFlag == 4) || (g_previewFlag == 5)) {

				if (g_previewFlag == 4) {
					//curmodel->SetCurrentRigidElem(s_curreindex);//s_curreindexをmodelごとに持つ必要あり！！！
					pmodel->SetCurrentRigidElem(s_reindexmap[pmodel]);//s_curreindexをmodelごとに持つ必要あり！！！

					//決め打ち
					s_btWorld->setGravity(btVector3(0.0f, -9.8f, 0.0f)); // 重力加速度の設定　//SetBtKinFlagReqにて剛体ごとにも設定



					//s_btWorld->setGravity(btVector3(0.0, 0.0, 0.0)); // 重力加速度の設定
					s_bpWorld->setGlobalERP(btScalar(g_erp));// ERP



					//s_model->SetAllKData(-1, s_curreindex, 3, 3, 800.0, 20.0);
					//curmodel->SetAllKData(-1, s_curreindex, 3, 3, 1000.0, 30.0);


					//決め打ち
					//curmodel->SetAllMassDataByBoneLeng(-1, s_curreindex, 30.0);//!!!!!!!! Mass自動設定中 !!!!!


					pmodel->SetMotionFrame(curframe);

					//vector<MODELELEM>::iterator itrmodel2;
					//for (itrmodel2 = s_modelindex.begin(); itrmodel2 != s_modelindex.end(); itrmodel2++) {
					//	CModel* updatemodel = itrmodel2->modelptr;
					//	if (updatemodel) {
					//		ChaMatrix tmpwm = updatemodel->GetWorldMat();
					//		updatemodel->UpdateMatrix(&tmpwm, &s_matVP);
					//	}
					//}
					ChaMatrix tmpwm = pmodel->GetWorldMat();
					pmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);

					//curmodel->SetCurrentRigidElem(s_curreindex);//s_curreindexをmodelごとに持つ必要あり！！！reの内容を変えてから呼ぶ
					//s_curreindex = 1;
					pmodel->SetMotionSpeed(g_dspeed);
				}
				else if (g_previewFlag == 5) {
					s_rectime = 0.0;
					s_reccnt = 0;

					pmodel->SetCurrentRigidElem(s_rgdindexmap[pmodel]);//s_rgdindexをmodelごとに持つ必要あり！！！

					s_btWorld->setGravity(btVector3(0.0, 0.0, 0.0)); // 重力加速度の設定

					//s_bpWorld->setGlobalERP(btScalar(g_erp));// ERP

				//ラグドールの時のERPは決め打ち
					s_bpWorld->setGlobalERP(0.0);// ERP
					//s_bpWorld->setGlobalERP(1.0);// ERP
					//s_bpWorld->setGlobalERP(0.2);// ERP
					//s_bpWorld->setGlobalERP(0.001);// ERP
					//s_bpWorld->setGlobalERP(1.0e-8);// ERP


					//s_bpWorld->setGlobalERP(0.00020);// ERP
					//s_bpWorld->setGlobalERP(0.00030);// ERP
					//s_bpWorld->setGlobalERP(g_erp);// ERP
					//s_bpWorld->setGlobalERP(0.00040);// ERP
					//s_bpWorld->setGlobalERP(0.0010);// ERP
					//s_bpWorld->setGlobalERP(0.80);// ERP


					//s_bpWorld->setGlobalERP(0.0010);// ERP
					//s_bpWorld->setGlobalERP(0.0020);// ERP
					//s_bpWorld->setGlobalERP(0.0040);// ERP !!!!

					//s_bpWorld->setGlobalERP(0.0100);// ERP
					//s_bpWorld->setGlobalERP(0.0200);// ERP
					//s_bpWorld->setGlobalERP(0.0400);// ERP

					//s_bpWorld->setGlobalERP(g_erp);// ERP



					pmodel->SetMotionFrame(curframe);

					//vector<MODELELEM>::iterator itrmodel3;
					//for (itrmodel3 = s_modelindex.begin(); itrmodel3 != s_modelindex.end(); itrmodel3++) {
					//	CModel* updatemodel = itrmodel3->modelptr;
					//	if (updatemodel) {
					//		ChaMatrix tmpwm = updatemodel->GetWorldMat();
					//		updatemodel->UpdateMatrix(&tmpwm, &s_matVP);
					//	}
					//}
					ChaMatrix tmpwm = pmodel->GetWorldMat();
					pmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);


					//curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 1000.0, 0.1);

					//決め打ち
					pmodel->SetAllKData(-1, s_rgdindexmap[pmodel], 3, 3, 1500.0, 30.0);

					//curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 800.0, 30.0);

/*
					curmodel->SetColTypeAll(s_rgdindex, COL_CONE_INDEX);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!
					//curmodel->SetColTypeAll(s_rgdindex, COL_CAPSULE_INDEX);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!



				//ラグドールの時のバネは決め打ち
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 1e4, 10.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 230.0, 30.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 600.0, 60.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 600.0, 30.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 600.0, 10.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 400.0, 10.0);

					//s_model->SetAllMassData(-1, s_rgdindex, 1e-9);
					//s_model->SetAllMassData(-1, s_rgdindex, 0.5);
					//s_model->SetAllMassData(-1, s_rgdindex, 1.0);
					//s_model->SetAllMassData(-1, s_rgdindex, 10.0);


					//if (s_physicskind == 0) {
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 800.0, 30.0);
						curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 800.0, 20.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 1600.0, 20.0);
					//}
					//else {
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 1000.0, 60.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 2000.0, 60.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 10000.0, 60.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 13000.0, 200.0);
					//	//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 40000.0, 100.0);
					//	curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 1000.0, 30.0);
					//}

					//curmodel->SetAllKData(-1, s_rgdindex, 3, 3, 0.0, 20.0);

					//s_model->SetAllMassData(-1, s_rgdindex, 100.0);
					//s_model->SetAllMassData(-1, s_rgdindex, 30.0);
					//s_model->SetAllKData(-1, s_rgdindex, 3, 3, 800.0, 30.0);
*/
//決め打ち
					pmodel->SetAllMassDataByBoneLeng(-1, s_rgdindexmap[pmodel], 30.0);

					//curmodel->SetAllMassData(-1, s_rgdindex, 1.0);


					pmodel->SetMotionSpeed(g_dspeed);
				}

				s_btstartframe = curframe;

				//CallF(curmodel->CreateBtObject(s_coldisp, 0), return 1);
				CallF(pmodel->CreateBtObject(g_limitdegflag, 1), return 1);


				//if( g_previewFlag == 4 ){

				//pmodel->BulletSimulationStart();





				//s_bpWorld->clientResetScene();
				//if( s_model ){
				//	s_model->ResetBt();
				//}
				//int firstflag = 1;
				//s_model->Motion2Bt(firstflag, s_coldisp, s_btstartframe, &s_matW, &s_matVP);
				//int rgdollflag = 0;
				//double difftime = 0.0;
				//s_model->SetBtMotion(rgdollflag, s_btstartframe, &s_matW, &s_matVP);
				//s_model->ResetBt();



				//UpdateBtSimu(curframe, curmodel);




				//}

				//if( g_previewFlag == 5 ){
				//	s_model->SetBtImpulse();
				//}


				//if (pmodel->GetRgdMorphIndex() >= 0) {
				//	MOTINFO* morphmi = pmodel->GetRgdMorphInfo();
				//	if (morphmi) {
				//		//morphmi->curframe = 0.0;
				//		morphmi->curframe = s_btstartframe;
				//	}
				//}

			}
		}
	}

	//curmodel : 引数で渡されたmodel
	if (s_model && (curmodel == s_model)) {
		PrepairUndo();//物理REC様に保存
	}


	//全モデルシミュ開始
	s_chascene->StartBt();


	return 0;
}


int SaveProject()
{
	if (!s_bpWorld || !s_chascene) {
		return 0;
	}

	if (s_chascene->ModelEmpty()) {
		return 0;
	}

	int dlgret;
	dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SAVECHADLG),
		s_3dwnd, (DLGPROC)SaveChaDlgProc);
	if ((dlgret != IDOK) || !s_projectname[0] || !s_projectdir[0] || !s_chasavename[0]) {
		return 0;
	}

	//###################################################################
	//limitdegflagは　ダイアログで指定した　g_bakelimiteulonsave　を使う
	//###################################################################

	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));


	int modelnum = s_chascene->GetModelNum();
	int modelcount;
	for (modelcount = 0; modelcount < modelnum; modelcount++) {
		CModel* curmodel = s_chascene->GetModel(modelcount);

		if (curmodel && s_owpLTimeline && s_owpEulerGraph) {
			s_owpLTimeline->setCurrentTime(0.0, true);
			s_owpEulerGraph->setCurrentTime(0.0, false);
			curmodel->SetMotionFrame(0.0);
			ChaMatrix tmpwm = curmodel->GetWorldMat();
			curmodel->UpdateMatrix(g_bakelimiteulonsave, &tmpwm, &s_matView, &s_matProj, true, 0);

			//ここでAxisMatXの初期化
			curmodel->CreateBtObject(g_bakelimiteulonsave, 1);
			curmodel->CalcBtAxismat(2);//2
			curmodel->SetInitAxisMatX(1);
		}
	}


	WCHAR saveprojpath[MAX_PATH] = { 0L };
	swprintf_s(saveprojpath, MAX_PATH, L"%s\\%s\\%s.cha", s_projectdir, s_projectname, s_projectname);

	vector<MODELELEM> writemodelindex;
	s_chascene->GetModelIndex(writemodelindex);
	CChaFile chafile;
	int result = chafile.WriteChaFile(g_bakelimiteulonsave, s_bpWorld, s_projectdir, s_projectname,
		writemodelindex, (float)g_dspeed, s_selbonedlgmap, s_grassElemVec);
	if (result) {
		::MessageBox(g_mainhwnd, L"保存に失敗しました。", L"Error", MB_OK);
		if (oldcursor) {
			SetCursor(oldcursor);
		}
		return 1;
	}


	//書き込み処理が成功してから履歴を保存する。chaファイルだけ。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	if ((savepathlen > 4) && (savepathlen < MAX_PATH)) {
		WCHAR* pwext;
		pwext = saveprojpath + ((size_t)savepathlen - 1) - 3;
		if (wcscmp(pwext, L".cha") == 0) {
			SYSTEMTIME localtime;
			GetLocalTime(&localtime);
			WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
			swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProj_%04u%02u%02u%02u%02u%02u.txt",
				s_temppath,
				localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
			HANDLE hfile;
			hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				//int pathlen;
				//pathlen = (int)wcslen(saveprojpath);
				//if ((pathlen > 0) && (pathlen < MAX_PATH)) {
				if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
					DWORD writelen = 0;
					WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
					_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
				}
				CloseHandle(hfile);
			}
		}
	}


	//2024/06/17 各パネル選択状態がずれないように
	if (s_model) {
		bool forceflag = true;
		bool callundo = true;
		OnChangeModel(s_model, forceflag, callundo);
	}


	if (oldcursor) {
		SetCursor(oldcursor);
	}


	return 0;
}


LRESULT CALLBACK SaveChaDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	//	static WCHAR s_projectname[64] = {0L};
	//	static WCHAR s_projectdir[MAX_PATH] = {0L};

	BROWSEINFO bi;
	ZeroMemory(&bi, sizeof(BROWSEINFO));
	LPITEMIDLIST curlpidl = 0;
	WCHAR dispname[MAX_PATH] = { 0L };
	WCHAR selectname[MAX_PATH] = { 0L };
	int iImage = 0;

	static int s_savechaproctimer = 351;


	switch (msg) {
	case WM_INITDIALOG:

		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		//if (s_model && s_model->ExistCurrentMotion()) {
		if (s_model) {
			if (s_chasavename[0]) {
				SetDlgItemText(hDlgWnd, IDC_PROJNAME, s_chasavename);
			}
			if (s_chasavedir[0]) {
				SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_chasavedir);
			}
			else {
				if (s_projectdir[0]) {
					SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
				}
				else {
					LPITEMIDLIST pidl;

					HWND hWnd = NULL;

					IMalloc* pMalloc;
					if (SUCCEEDED(SHGetMalloc(&pMalloc))) {
						if (SUCCEEDED(SHGetSpecialFolderLocation(s_3dwnd, CSIDL_DESKTOPDIRECTORY, &pidl)))
						{
							// パスに変換する
							SHGetPathFromIDList(pidl, s_projectdir);
							// 取得したIDLを解放する (CoTaskMemFreeでも可)
							pMalloc->Free(pidl);
							SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
						}
						pMalloc->Release();
					}
				}
			}

			if (g_bakelimiteulonsave) {
				CheckDlgButton(hDlgWnd, IDC_CHECK1, BST_CHECKED);
			}
			else {
				CheckDlgButton(hDlgWnd, IDC_CHECK1, BST_UNCHECKED);
			}


			RECT dlgrect;
			GetWindowRect(hDlgWnd, &dlgrect);
			SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

			s_savechadlghwnd = hDlgWnd;
			SetTimer(hDlgWnd, s_savechaproctimer, 20, NULL);

		}
		return FALSE;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
		{


			s_savechadlghwnd = 0;
			KillTimer(hDlgWnd, s_savechaproctimer);

			GetDlgItemText(hDlgWnd, IDC_PROJNAME, s_projectname, 64);
			GetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir, MAX_PATH);
			wcscpy_s(s_chasavename, 64, s_projectname);
			wcscpy_s(s_chasavedir, MAX_PATH, s_projectdir);


			UINT ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK1);
			if (ischecked == BST_CHECKED) {
				g_bakelimiteulonsave = true;
			}
			else {
				g_bakelimiteulonsave = false;
			}

			EndDialog(hDlgWnd, IDOK);
		}
		break;
		case IDCANCEL:
			s_savechadlghwnd = 0;
			KillTimer(hDlgWnd, s_savechaproctimer);

			s_projectname[0] = 0L;
			s_projectdir[0] = 0L;
			EndDialog(hDlgWnd, IDCANCEL);
			break;
		case IDC_REFDIR:
		{
			bi.hwndOwner = hDlgWnd;
			bi.pidlRoot = NULL;//!!!!!!!
			bi.pszDisplayName = dispname;
			//bi.lpszTitle = L"保存フォルダを選択してください。";
			bi.lpszTitle = L"SelectDirectoryForSave";
			//bi.ulFlags = BIF_EDITBOX | BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
			bi.ulFlags = BIF_RETURNONLYFSDIRS;// | BIF_NEWDIALOGSTYLE;//BIF_NEWDIALOGSTYLEを指定すると固まる　謎
			bi.lpfn = NULL;
			bi.lParam = 0;
			bi.iImage = iImage;


			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;
			//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
			//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
			InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

			curlpidl = SHBrowseForFolder(&bi);

			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);
			s_getfilenamehwnd = 0;
			s_getfilenametreeview = 0;

			if (curlpidl) {
				//::DSMessageBox( m_hWnd, dispname, "フォルダー名", MB_OK );

				BOOL bret;
				bret = SHGetPathFromIDList(curlpidl, selectname);
				if (bret == FALSE) {
					_ASSERT(0);
					if (curlpidl)
						CoTaskMemFree(curlpidl);
					return 1;
				}

				if (curlpidl)
					CoTaskMemFree(curlpidl);

				wcscpy_s(s_projectdir, MAX_PATH, selectname);
				SetDlgItemText(hDlgWnd, IDC_DIRNAME, s_projectdir);
			}
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_TIMER:
		OnDSUpdate();
		return FALSE;
		break;
	case WM_CLOSE:
		s_savechadlghwnd = 0;
		KillTimer(hDlgWnd, s_savechaproctimer);

		s_projectname[0] = 0L;
		s_projectdir[0] = 0L;
		EndDialog(hDlgWnd, IDCANCEL);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}


int PostOpenChaFile()
{
	//2024/04/17 常駐スライダーなどにchaファイル読込値を反映する

	if (s_owpEditRateSlider) {
		s_owpEditRateSlider->setValue(g_physicsmvrate, false);
	}
	if (s_owpSpeedSlider) {
		s_owpSpeedSlider->setValue(g_dspeed, false);
	}
	
	ChangeCameraDist(g_camdist , s_moveeyepos, false);


	s_bulletdlg.CreateBulletWnd();//作成済でない場合に作成
	s_bulletdlg.ParamsToDlg();


	if (s_chascene && 
		((g_boneaxis < BONEAXIS_CURRENT) || (g_boneaxis > BONEAXIS_BINDPOSE))) {//g_boneaxisがchafileで設定されなかった場合
		//2024/04/22
		s_chascene->InitializeBoneAxisKind();
	}


	return 0;
}


int OpenChaFile()
{

	//g_tmpmqopathはプロジェクト読み込み時にプロジェクトファイル内に記述されているファイル名に変わっていくので先に保存しておく。
	WCHAR saveprojpath[MAX_PATH] = { 0L };
	wcscpy_s(saveprojpath, MAX_PATH, g_tmpmqopath);

	//先に履歴を保存する。chaファイルだけ。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	if ((savepathlen > 4) && (savepathlen < MAX_PATH)) {
		WCHAR* pwext;
		pwext = saveprojpath + ((size_t)savepathlen - 1) - 3;
		if (wcscmp(pwext, L".cha") == 0) {
			SYSTEMTIME localtime;
			GetLocalTime(&localtime);
			WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
			swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProj_%04u%02u%02u%02u%02u%02u.txt",
				s_temppath,
				localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
			HANDLE hfile;
			hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				//int pathlen;
				//pathlen = (int)wcslen(saveprojpath);
				if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
					DWORD writelen = 0;
					WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
					_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
				}
				CloseHandle(hfile);
			}
		}
	}


	WCHAR* lasten = 0;
	g_tmpmqopath[MAX_PATH - 1] = 0L;
	lasten = wcsrchr(g_tmpmqopath, TEXT('\\'));
	if (lasten && (*(lasten + 1) != 0L)) {
		size_t leng = wcslen(lasten + 1);
		if ((leng > 0) && (leng < 64)) {
			wcscpy_s(s_chasavename, 64, lasten + 1);
			WCHAR* peri = wcsrchr(s_chasavename, TEXT('.'));
			if (peri) {
				*peri = 0L;
			}
		}
	}
	else {
		//s_chasavenameは更新しない
	}
	//念のために終端
	s_chasavename[64 - 1] = 0L;


	WCHAR tmpdir[MAX_PATH];
	wcscpy_s(tmpdir, MAX_PATH, g_tmpmqopath);
	WCHAR* lastend = 0;
	lastend = wcsrchr(tmpdir, TEXT('\\'));
	if (lastend) {
		*lastend = 0L;
		WCHAR* lastend2 = 0;
		lastend2 = wcsrchr(tmpdir, TEXT('\\'));
		if (lastend2) {
			*lastend2 = 0L;
			int dirleng = (int)(lastend2 - tmpdir);
			if (dirleng < MAX_PATH) {
				wcscpy_s(s_chasavedir, MAX_PATH, tmpdir);
			}
		}
	}

	if (!s_bpWorld) {
		//ChaMatrix inimat;
		//ChaMatrixIdentity( &inimat );
		//s_bpWorld = new BPWorld(NULL, inimat, "BtPiyo", // ウィンドウのタイトル
		//				460, 460,         // ウィンドウの幅と高さ [pixels]
		//				NULL);    // モニタリング用関数へのポインタ  
		//_ASSERT( s_bpWorld );
		char strtitle[256];
		strcpy_s(strtitle, 256, "BpPiyo");
		s_bpWorld = new BPWorld(NULL, s_matWorld, strtitle, // ウィンドウのタイトル
			460, 460,         // ウィンドウの幅と高さ [pixels]
			NULL);    // モニタリング用関数へのポインタ  
		_ASSERT(s_bpWorld);


		s_bpWorld->enableFixedTimeStep(false);
		//s_bpWorld->enableFixedTimeStep(false);
		//s_bpWorld->setTimeStep(0.015);// seconds
		s_bpWorld->setGlobalERP(btScalar(g_erp));// ERP
									   //s_bpWorld->start();// ウィンドウを表示して，シミュレーションを開始する
		s_btWorld = s_bpWorld->getDynamicsWorld();
		s_bpWorld->setNumThread(g_numthread);

	}

	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));




	CChaFile chafile;
	int ret = chafile.LoadChaFile(g_limitdegflag, g_tmpmqopath,
		OpenFBXFile, OpenREFile, OpenImpFile, OpenGcoFile,
		OnREMenu, OnRgdMenu, OnRgdMorphMenu, OnImpMenu,
		s_grassElemVec);
	if (ret == 1) {
		_ASSERT(0);
		SetCursor(oldcursor);
		return 1;
	}
	//OnAddMotion(s_model->GetCurMotInfo()->motid);

	PostOpenChaFile();//2024/04/17 常駐スライダーなどにchaファイル読込値を反映する

	SetCursor(oldcursor);


	//ChangeCurrentBone();

	return 0;
}

int OnSetMotSpeed()
{
	//s_model->GetCurMotInfo()->speed = s_model->GetTmpMotSpeed();//!!!!!!!!!!!!!!!!!!!
	//g_dspeed = s_model->GetTmpMotSpeed();

	if (!s_model || !s_chascene) {
		return 0;
	}
	if (!s_model->ExistCurrentMotion()) {
		return 0;
	}
	//if (!g_SampleUI.GetSlider(IDC_SPEED)) {
	//	return 0;
	//}
	//if (!g_SampleUI.GetStatic(IDC_SPEED_STATIC)) {
	//	return 0;
	//}


	//スライダーからspeedの値を取得
	if (s_topSlidersWnd && s_owpSpeedSlider) {
		double val = s_owpSpeedSlider->getValue();
		g_dspeed = val;
	}
	//if (s_guidlg[GUIDLG_DISP_AND_LIMITS]) {
	//	HWND speedwnd = GetDlgItem(s_guidlg[GUIDLG_DISP_AND_LIMITS], IDC_SLIDER_SPEED);
	//	if (speedwnd && IsWindow(speedwnd)) {
	//		int cursliderpos = (int)SendMessage(speedwnd, TBM_GETPOS, 0, 0);
	//		g_dspeed = (float)((double)cursliderpos / 100.0);
	//	}
	//}


	////SetMotionSpeed() : モーションごとのスピード
	////SetTmpMotSpeed() : モーションが変わってもスライダー指定のスピード
	////モーションが変わってもスライダー指定のスピードを維持するようにする
	////g_dspeed = s_model->GetCurMotInfo()->speed;
	//g_dspeed = s_model->GetTmpMotSpeed();
	s_chascene->SetMotionSpeed(-1, g_dspeed);


	//g_SampleUI.GetSlider(IDC_SPEED)->SetValue((int)(g_dspeed * 100.0f));
	//WCHAR sz[100];
	//swprintf_s(sz, 100, L"Motion Speed: %0.4f", g_dspeed);
	//g_SampleUI.GetStatic(IDC_SPEED_STATIC)->SetText(sz);

	return 0;
}


int SetSpParams()
{
	SetSpSel3DParams();
	SetSpAimBarParams();
	SetSpMenuAimBarParams();//CreateTopSlidersWndよりも後
	SetSpAxisParams();
	SetSpUndoParams();
	SetSpGUISWParams();
	SetSpIkModeSWParams();
	SetSpRefPosSWParams();
	SetSpDispSWParams();
	SetSpRigidSWParams();
	SetSpRetargetSWParams();
	SetSpEffectSWParams();
	SetSpCamParams();
	SetSpRigParams();
	SetSpCpLW2WParams();
	SetSpSmoothParams();
	SetSpUpperBarParams();
	SetSpLimitEulSWParams();
	SetSpScrapingSWParams();
	SetSpConstExeParams();
	SetSpConstRefreshParams();
	//SetSpBtParams();
	SetSpMouseHereParams();
	SetSpMouseCenterParams();//SetSpCamParamsよりも後で呼ぶ　位置を参照しているから
	SetSpCameraModeSWParams();
	SetSpCameraInheritSWParams();
	
	SetSpRet2PrevParams();
	

	
	{//SetSpCameraInheritSWParams()よりも後で呼ぶ
		SetSpCameraCommandParams();

		SetSpCopyParams();
		SetSpSymCopyParams();
		SetSpPasteParams();
		SetSpCopyHistoryParams();

		SetSpInterpolateParams();
		SetSpInitParams();
		SetSpScaleInitParams();
		SetSpPropertyParams();

		SetSpZeroFrameParams();
		SetSpCameraDollyParams();
		SetSpModelPosDirParams();
		SetSpMaterialRateParams();
	}

	return 0;
}
int SetSpUndoParams()
{


	int spashift = 6;
	//s_spundo[0].dispcenter.x = (int)( s_mainwidth * 0.57f );
	//s_spundo[0].dispcenter.y = (int)( 30.0f * ( (float)s_mainheight / 620.0 ) );
	//s_spundo[0].dispcenter.x = s_mainwidth - 50 - 10 - (32 + 12) * 4;
	//s_spundo[0].dispcenter.y = 16 + 10;
	s_spundo[0].dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_spundo[0].dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 3;
	//spashift = (int)( (float)spashift * ( (float)s_mainwidth / 600.0 ) );

	s_spundo[1].dispcenter.x = s_spundo[0].dispcenter.x;
	s_spundo[1].dispcenter.y = s_spundo[0].dispcenter.y + (int)s_spsize + spashift;

	//{
	//	s_spaxis[0].dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	//	s_spaxis[0].dispcenter.y = (int)s_sptopmargin;
	//	//spashift = (int)( (float)spashift * ( (float)s_mainwidth / 600.0 ) );
	//
	//	s_spaxis[1].dispcenter.x = s_spaxis[0].dispcenter.x;
	//	s_spaxis[1].dispcenter.y = s_spaxis[0].dispcenter.y + (int)s_spsize + spashift;
	//
	//	s_spaxis[2].dispcenter.x = s_spaxis[0].dispcenter.x;
	//	s_spaxis[2].dispcenter.y = s_spaxis[1].dispcenter.y + (int)s_spsize + spashift;;
	//}


	int spacnt;
	for (spacnt = 0; spacnt < 2; spacnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spundo[spacnt].dispcenter.x);
		disppos.y = (float)(s_spundo[spacnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsize, s_spsize);
		//CallF(s_spundo[spacnt].sprite->SetPos(disppos), return 1);
		//CallF(s_spundo[spacnt].sprite->SetSize(dispsize), return 1);
		s_spundo[spacnt].sprite.UpdateScreen(disppos, dispsize);
		s_spundo[spacnt].sprite_pushed.UpdateScreen(disppos, dispsize);
	}

	return 0;

}


int SetSpAxisParams()
{

	int spashift = 6;
	//s_spaxis[0].dispcenter.x = (int)( s_mainwidth * 0.57f );
	//s_spaxis[0].dispcenter.y = (int)( 30.0f * ( (float)s_mainheight / 620.0 ) );
	//s_spaxis[0].dispcenter.x = s_mainwidth - 50 - 10 - (32 + 12) * 4;
	//s_spaxis[0].dispcenter.y = 16 + 10;
	s_spaxis[0].dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_spaxis[0].dispcenter.y = (int)s_sptopmargin;
	//spashift = (int)( (float)spashift * ( (float)s_mainwidth / 600.0 ) );

	s_spaxis[1].dispcenter.x = s_spaxis[0].dispcenter.x;
	s_spaxis[1].dispcenter.y = s_spaxis[0].dispcenter.y + (int)s_spsize + spashift;

	s_spaxis[2].dispcenter.x = s_spaxis[0].dispcenter.x;
	s_spaxis[2].dispcenter.y = s_spaxis[1].dispcenter.y + (int)s_spsize + spashift;;

	int spacnt;
	for (spacnt = 0; spacnt < SPAXISNUM; spacnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spaxis[spacnt].dispcenter.x);
		disppos.y = (float)(s_spaxis[spacnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsize, s_spsize);
		//CallF(s_spaxis[spacnt].sprite->SetPos(disppos), return 1);
		//CallF(s_spaxis[spacnt].sprite->SetSize(dispsize), return 1);
		s_spaxis[spacnt].sprite.UpdateScreen(disppos, dispsize);
		s_spaxis[spacnt].sprite_pushed.UpdateScreen(disppos, dispsize);
	}

	return 0;

}

int SetSpDispSWParams()
{


	//float spgwidth = 140.0f;
	float spgwidth = 124.0f;
	float spgheight = 28.0f;
	int spgshift = 6;
	s_spdispsw[SPDISPSW_LIGHTS].dispcenter.x = s_guibarX0;
	//s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y = 486;


	//s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y = 486 - TOPSLIDERSWNDH;
	if (g_4kresolution) {
		s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y = 486 * 2 - TOPSLIDERSWNDH + 32;
	}
	else {
		s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y = 486 - TOPSLIDERSWNDH;
	}


	s_spdispsw[SPDISPSW_DISPGROUP].dispcenter.x = s_spdispsw[SPDISPSW_LIGHTS].dispcenter.x + (int)spgwidth + spgshift;
	s_spdispsw[SPDISPSW_DISPGROUP].dispcenter.y = s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y;

	s_spdispsw[SPDISPSW_LATERTRANSPARENT].dispcenter.x = s_spdispsw[SPDISPSW_DISPGROUP].dispcenter.x + (int)spgwidth + spgshift;
	s_spdispsw[SPDISPSW_LATERTRANSPARENT].dispcenter.y = s_spdispsw[SPDISPSW_DISPGROUP].dispcenter.y;

	s_spdispsw[SPDISPSW_SHADERTYPE].dispcenter.x = s_spdispsw[SPDISPSW_LATERTRANSPARENT].dispcenter.x + (int)spgwidth + spgshift;
	s_spdispsw[SPDISPSW_SHADERTYPE].dispcenter.y = s_spdispsw[SPDISPSW_LATERTRANSPARENT].dispcenter.y;

	s_spdispsw[SPDISPSW_SHADOWPARAMS].dispcenter.x = s_spdispsw[SPDISPSW_SHADERTYPE].dispcenter.x + (int)spgwidth + spgshift;
	s_spdispsw[SPDISPSW_SHADOWPARAMS].dispcenter.y = s_spdispsw[SPDISPSW_SHADERTYPE].dispcenter.y;

	int spgcnt;
	for (spgcnt = 0; spgcnt < SPDISPSWNUM; spgcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spdispsw[spgcnt].dispcenter.x);
		disppos.y = (float)(s_spdispsw[spgcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(spgwidth, spgheight);

		//CallF(s_spdispsw[spgcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_spdispsw[spgcnt].spriteON->SetSize(dispsize), return 1);
		s_spdispsw[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

		//CallF(s_spdispsw[spgcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_spdispsw[spgcnt].spriteOFF->SetSize(dispsize), return 1);
		s_spdispsw[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	}

	return 0;

}


int SetSpRigidSWParams()
{

	//float spgwidth = 140.0f;
	float spgwidth = 124.0f;
	float spgheight = 28.0f;
	int spgshift = 6;
	s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.x = s_guibarX0;
	//s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y = 486;


	//s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y = 486 - TOPSLIDERSWNDH;
	if (g_4kresolution) {
		s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y = 486 * 2 - TOPSLIDERSWNDH + 32;
	}
	else {
		s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y = 486 - TOPSLIDERSWNDH;
	}


	s_sprigidsw[SPRIGIDSW_IMPULSE].dispcenter.x = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.x + (int)spgwidth + spgshift;
	s_sprigidsw[SPRIGIDSW_IMPULSE].dispcenter.y = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y;

	s_sprigidsw[SPRIGIDSW_GROUNDPLANE].dispcenter.x = s_sprigidsw[SPRIGIDSW_IMPULSE].dispcenter.x + (int)spgwidth + spgshift;
	s_sprigidsw[SPRIGIDSW_GROUNDPLANE].dispcenter.y = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y;

	s_sprigidsw[SPRIGIDSW_DAMPANIM].dispcenter.x = s_sprigidsw[SPRIGIDSW_GROUNDPLANE].dispcenter.x + (int)spgwidth + spgshift;
	s_sprigidsw[SPRIGIDSW_DAMPANIM].dispcenter.y = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y;

	int spgcnt;
	for (spgcnt = 0; spgcnt < SPRIGIDSWNUM; spgcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_sprigidsw[spgcnt].dispcenter.x);
		disppos.y = (float)(s_sprigidsw[spgcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(spgwidth, spgheight);

		//CallF(s_sprigidsw[spgcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_sprigidsw[spgcnt].spriteON->SetSize(dispsize), return 1);
		s_sprigidsw[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

		//CallF(s_sprigidsw[spgcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_sprigidsw[spgcnt].spriteOFF->SetSize(dispsize), return 1);
		s_sprigidsw[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	}

	return 0;

}

int SetSpRetargetSWParams()
{


	//float spgwidth = 140.0f;
	float spgwidth = 124.0f;
	float spgheight = 28.0f;
	int spgshift = 6;
	s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.x = s_guibarX0;


	//s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y = 486 - TOPSLIDERSWNDH;
	if (g_4kresolution) {
		s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y = 486 * 2 - TOPSLIDERSWNDH + 32;
	}
	else {
		s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y = 486 - TOPSLIDERSWNDH;
	}


	s_spretargetsw[SPRETARGETSW_LIMITEULER].dispcenter.x = s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.x + (int)spgwidth + spgshift;
	s_spretargetsw[SPRETARGETSW_LIMITEULER].dispcenter.y = s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y;

	s_spretargetsw[SPRETARGETSW_THRESHOLD].dispcenter.x = s_spretargetsw[SPRETARGETSW_LIMITEULER].dispcenter.x + (int)spgwidth + spgshift;
	s_spretargetsw[SPRETARGETSW_THRESHOLD].dispcenter.y = s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y;

	int sprcnt;
	for (sprcnt = 0; sprcnt < SPRETARGETSWNUM; sprcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spretargetsw[sprcnt].dispcenter.x);
		disppos.y = (float)(s_spretargetsw[sprcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(spgwidth, spgheight);

		//CallF(s_spretargetsw[sprcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_spretargetsw[sprcnt].spriteON->SetSize(dispsize), return 1);
		s_spretargetsw[sprcnt].spriteON.UpdateScreen(disppos, dispsize);
		//CallF(s_spretargetsw[sprcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_spretargetsw[sprcnt].spriteOFF->SetSize(dispsize), return 1);
		s_spretargetsw[sprcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	}

	return 0;

}

int SetSpEffectSWParams()
{


	//float spgwidth = 140.0f;
	float spgwidth = 124.0f;
	float spgheight = 28.0f;
	int spgshift = 6;
	s_speffectsw[SPEFFECTSW_SKY].dispcenter.x = s_guibarX0;


	//s_speffectsw[SPRETARGETSW_RETARGET].dispcenter.y = 486 - TOPSLIDERSWNDH;
	if (g_4kresolution) {
		s_speffectsw[SPEFFECTSW_SKY].dispcenter.y = 486 * 2 - TOPSLIDERSWNDH + 32;
	}
	else {
		s_speffectsw[SPEFFECTSW_SKY].dispcenter.y = 486 - TOPSLIDERSWNDH;
	}


	s_speffectsw[SPEFFECTSW_FOG].dispcenter.x = s_speffectsw[SPEFFECTSW_SKY].dispcenter.x + (int)spgwidth + spgshift;
	s_speffectsw[SPEFFECTSW_FOG].dispcenter.y = s_speffectsw[SPEFFECTSW_SKY].dispcenter.y;

	s_speffectsw[SPEFFECTSW_DOF].dispcenter.x = s_speffectsw[SPEFFECTSW_FOG].dispcenter.x + (int)spgwidth + spgshift;
	s_speffectsw[SPEFFECTSW_DOF].dispcenter.y = s_speffectsw[SPEFFECTSW_FOG].dispcenter.y;

	int sprcnt;
	for (sprcnt = 0; sprcnt < SPEFFECTSWNUM; sprcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_speffectsw[sprcnt].dispcenter.x);
		disppos.y = (float)(s_speffectsw[sprcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(spgwidth, spgheight);

		//CallF(s_speffectsw[sprcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_speffectsw[sprcnt].spriteON->SetSize(dispsize), return 1);
		s_speffectsw[sprcnt].spriteON.UpdateScreen(disppos, dispsize);
		//CallF(s_speffectsw[sprcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_speffectsw[sprcnt].spriteOFF->SetSize(dispsize), return 1);
		s_speffectsw[sprcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	}

	return 0;

}



int SetSpMenuAimBarParams()
{


	////float spgwidth = 140.0f;
	////float spgheight = 6.0f;
	////int spgshift = 6;

	//HMENU mainmenu;
	//mainmenu = GetMenu(g_mainhwnd);
	//int menuno;
	//for (menuno = 0; menuno < SPMENU_MAX; menuno++) {
	//	HMENU submenu = GetSubMenu(mainmenu, menuno);
	//	if (submenu) {
	//		int curmenuitemid;
	//		curmenuitemid = ::GetMenuItemID(submenu, 0);
	//		if (curmenuitemid >= 0) {
	//			RECT rc;
	//			GetMenuItemRect(g_mainhwnd, mainmenu, menuno, &rc);
	//			int spritewidth = rc.right - rc.left;//org:140
	//			int spriteheight = 6;//org:6

	//			POINT point1;
	//			POINT point2;
	//			point1.x = rc.left;
	//			point1.y = rc.top;
	//			point2.x = rc.right;
	//			point2.y = rc.bottom;
	//			::ClientToScreen(g_mainhwnd, &point1);
	//			::ClientToScreen(g_mainhwnd, &point2);
	//			//::ScreenToClient(s_topSlidersWnd->getHWnd(), &point1);
	//			//::ScreenToClient(s_topSlidersWnd->getHWnd(), &point2);

	//			s_spmenuaimbar[menuno].dispcenter.x = point1.x;//screen pos!!!!!!!!!!!
	//			s_spmenuaimbar[menuno].dispcenter.y = 16;

	//			//ChaVector3 disppos;
	//			//disppos.x = (float)(s_spmenuaimbar[menuno].dispcenter.x);
	//			//disppos.y = (float)(s_spmenuaimbar[menuno].dispcenter.y);
	//			//disppos.z = 0.0f;
	//			//ChaVector2 dispsize.SetParams(spritewidth / (float)s_mainwidth * 2.0f, spriteheight / (float)s_mainheight * 2.0f);

	//			//if (s_spmenuaimbar[menuno].spriteON) {
	//			//	CallF(s_spmenuaimbar[menuno].spriteON->SetPos(disppos), return 1);
	//			//	CallF(s_spmenuaimbar[menuno].spriteON->SetSize(dispsize), return 1);
	//			//}
	//			//else {
	//			//	_ASSERT(0);
	//			//}
	//			//if (s_spmenuaimbar[menuno].spriteOFF) {
	//			//	CallF(s_spmenuaimbar[menuno].spriteOFF->SetPos(disppos), return 1);
	//			//	CallF(s_spmenuaimbar[menuno].spriteOFF->SetSize(dispsize), return 1);
	//			//}
	//			//else {
	//			//	_ASSERT(0);
	//			//}

	//		}
	//	}

	//}

	return 0;

}


int SetSpAimBarParams()
{
	////float spgwidth = 140.0f;
	//float spgwidth = 124.0f;
	//float spgheight = 6.0f;
	//int spgshift = 6;
	//s_spaimbar[SPAIMBAR_1].dispcenter.x = s_guibarX0;
	////s_spaimbar[SPAIMBAR_1].dispcenter.y = 486 + (28 / 2) + (6 / 2);


	////s_spaimbar[SPAIMBAR_1].dispcenter.y = 486 + (28 / 2) + (6 / 2) - TOPSLIDERSWNDH;
	//if (g_4kresolution) {
	//	s_spaimbar[SPAIMBAR_1].dispcenter.y = 486 * 2 - TOPSLIDERSWNDH + 32 + 16 + 4;
	//}
	//else {
	//	s_spaimbar[SPAIMBAR_1].dispcenter.y = 486 + (28 / 2) + (6 / 2) - TOPSLIDERSWNDH;
	//}


	//s_spaimbar[SPAIMBAR_2].dispcenter.x = s_spaimbar[SPAIMBAR_1].dispcenter.x + (int)spgwidth + spgshift;
	//s_spaimbar[SPAIMBAR_2].dispcenter.y = s_spaimbar[SPAIMBAR_1].dispcenter.y;

	//s_spaimbar[SPAIMBAR_3].dispcenter.x = s_spaimbar[SPAIMBAR_2].dispcenter.x + (int)spgwidth + spgshift;
	//s_spaimbar[SPAIMBAR_3].dispcenter.y = s_spaimbar[SPAIMBAR_1].dispcenter.y;

	//s_spaimbar[SPAIMBAR_4].dispcenter.x = s_spaimbar[SPAIMBAR_3].dispcenter.x + (int)spgwidth + spgshift;
	//s_spaimbar[SPAIMBAR_4].dispcenter.y = s_spaimbar[SPAIMBAR_1].dispcenter.y;

	//s_spaimbar[SPAIMBAR_5].dispcenter.x = s_spaimbar[SPAIMBAR_4].dispcenter.x + (int)spgwidth + spgshift;
	//s_spaimbar[SPAIMBAR_5].dispcenter.y = s_spaimbar[SPAIMBAR_1].dispcenter.y;

	//int spgcnt;
	//for (spgcnt = 0; spgcnt < SPAIMBARNUM; spgcnt++) {
	//	ChaVector3 disppos;
	//	disppos.x = (float)(s_spaimbar[spgcnt].dispcenter.x);
	//	disppos.y = (float)(s_spaimbar[spgcnt].dispcenter.y);
	//	disppos.z = 0.0f;
	//	ChaVector2 dispsize.SetParams(spgwidth, spgheight);

	//	//CallF(s_spaimbar[spgcnt].spriteON->SetPos(disppos), return 1);
	//	//CallF(s_spaimbar[spgcnt].spriteON->SetSize(dispsize), return 1);
	//	s_spaimbar[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

	//	//CallF(s_spaimbar[spgcnt].spriteOFF->SetPos(disppos), return 1);
	//	//CallF(s_spaimbar[spgcnt].spriteOFF->SetSize(dispsize), return 1);
	//	s_spaimbar[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	//}

	return 0;

}

int SetSpMouseCenterParams()
{
	//float spgwidth = 91.0f;
	//float spgheight = 145.0f;
	//float spgwidth = 50;
	//float spgheight = 67;
	//float spgwidth = 50.0f * 0.6f;
	//float spgheight = 67.0f * 0.6f;
	int spgshift = 6;

	_ASSERT(s_3dwnd);
	RECT clientrect;
	::GetClientRect(s_3dwnd, &clientrect);

	//s_spsel3d.dispcenter.x = (LONG)(clientrect.right - spgwidth / 2 - 20);
	//s_spsel3d.dispcenter.y = (LONG)(clientrect.top + spgheight / 2 + 20);
	//s_mousecenteron.dispcenter.x = s_mainwidth - 50 - 10 - 50 - 6 - (50 + 6) * 6;
	//s_mousecenteron.dispcenter.y = (LONG)(clientrect.top + spgheight / 2 + 20);


	s_mousecenteron.dispcenter.x = s_spcam[2].dispcenter.x + (int)s_spsize + spgshift;// +(int)s_spsize / 2;
	s_mousecenteron.dispcenter.y = s_spcam[2].dispcenter.y;
	//s_spcam[2].dispcenter.x = s_spcam[1].dispcenter.x + (int)(spawidth)+spashift;
	//s_spcam[2].dispcenter.y = s_spcam[0].dispcenter.y;

	ChaVector3 disppos;
	disppos.x = (float)(s_mousecenteron.dispcenter.x);
	disppos.y = (float)(s_mousecenteron.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);

	//CallF(s_mousecenteron.sprite->SetPos(disppos), return 1);
	//CallF(s_mousecenteron.sprite->SetSize(dispsize), return 1);
	s_mousecenteron.sprite.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpSel3DParams()
{

	/*
		float spawidth = 50.0f;
		int spashift = 6;
		//s_spcam[0].dispcenter.x = (int)(s_mainwidth * 0.57f);
		//s_spcam[0].dispcenter.y = (int)(30.0f * ((float)s_mainheight / 620.0)) + (int(spawidth * 1.5f));
		//s_spcam[0].dispcenter.x = s_mainwidth - 50 - 10 - (32 + 12) * 3;
		//s_spcam[0].dispcenter.y = 16 + 10 + (int(spawidth * 1.5f));
		s_spcam[0].dispcenter.x = s_mainwidth - 50 - 10 - 50 - 6 - (50 + 6) * 4;
		s_spcam[0].dispcenter.y = 25 + 10;
	*/


	//float spgwidth = 91.0f;
	//float spgheight = 145.0f;
	//float spgwidth = 91.0f * 0.25f;
	//float spgheight = 145.0f * 0.25f;
	int spgshift = 6;

	_ASSERT(s_3dwnd);
	RECT clientrect;
	::GetClientRect(s_3dwnd, &clientrect);

	//s_spsel3d.dispcenter.x = (LONG)(clientrect.right - spgwidth / 2 - 20);
	//s_spsel3d.dispcenter.y = (LONG)(clientrect.top + spgheight / 2 + 20);
	s_spsel3d.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 7;
	s_spsel3d.dispcenter.y = (LONG)(clientrect.top + (int)s_spsize / 2 + 20);

	ChaVector3 disppos;
	disppos.x = (float)(s_spsel3d.dispcenter.x);
	disppos.y = (float)(s_spsel3d.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);

	//CallF(s_spsel3d.spriteON->SetPos(disppos), return 1);
	//CallF(s_spsel3d.spriteON->SetSize(dispsize), return 1);
	s_spsel3d.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_spsel3d.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_spsel3d.spriteOFF->SetSize(dispsize), return 1);
	s_spsel3d.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpIkModeSWParams()
{

	int spgshift = 6;
	s_spikmodesw[0].dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_spikmodesw[0].dispcenter.y = (int)s_sptopmargin;

	s_spikmodesw[1].dispcenter.x = s_spikmodesw[0].dispcenter.x;
	s_spikmodesw[1].dispcenter.y = s_spikmodesw[0].dispcenter.y + (int)s_spsize + spgshift;

	s_spikmodesw[2].dispcenter.x = s_spikmodesw[1].dispcenter.x;
	s_spikmodesw[2].dispcenter.y = s_spikmodesw[1].dispcenter.y + (int)s_spsize + spgshift;

	int spgcnt;
	for (spgcnt = 0; spgcnt < 3; spgcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spikmodesw[spgcnt].dispcenter.x);
		disppos.y = (float)(s_spikmodesw[spgcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsize, s_spsize);

		//CallF(s_spikmodesw[spgcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_spikmodesw[spgcnt].spriteON->SetSize(dispsize), return 1);
		s_spikmodesw[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

		//CallF(s_spikmodesw[spgcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_spikmodesw[spgcnt].spriteOFF->SetSize(dispsize), return 1);
		s_spikmodesw[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);
	}

	return 0;
}


int SetSpRefPosSWParams()
{
	int spgshift = 6;
	s_sprefpos.dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_sprefpos.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spgshift) * 3;

	ChaVector3 disppos;
	disppos.x = (float)(s_sprefpos.dispcenter.x);
	disppos.y = (float)(s_sprefpos.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);


	//CallF(s_sprefpos.spriteON->SetPos(disppos), return 1);
	//CallF(s_sprefpos.spriteON->SetSize(dispsize), return 1);
	s_sprefpos.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_sprefpos.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_sprefpos.spriteOFF->SetSize(dispsize), return 1);
	s_sprefpos.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpLimitEulSWParams()
{
	int spgshift = 6;
	s_splimiteul.dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_splimiteul.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spgshift) * 6 + spgshift;

	ChaVector3 disppos;
	disppos.x = (float)(s_splimiteul.dispcenter.x);
	disppos.y = (float)(s_splimiteul.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);

	//CallF(s_splimiteul.spriteON->SetPos(disppos), return 1);
	//CallF(s_splimiteul.spriteON->SetSize(dispsize), return 1);
	s_splimiteul.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_splimiteul.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_splimiteul.spriteOFF->SetSize(dispsize), return 1);
	s_splimiteul.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpScrapingSWParams()
{
	int spgshift = 6;
	s_spscraping.dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_spscraping.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spgshift) * 6 + spgshift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spscraping.dispcenter.x);
	disppos.y = (float)(s_spscraping.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);

	//CallF(s_spscraping.spriteON->SetPos(disppos), return 1);
	//CallF(s_spscraping.spriteON->SetSize(dispsize), return 1);
	s_spscraping.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_spscraping.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_spscraping.spriteOFF->SetSize(dispsize), return 1);
	s_spscraping.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpRet2PrevParams()
{
	
	float spretwidth1;
	float spretheight1;
	float spretwidth2;
	float spretheight2;
	int spretshift = 0;

	//プレートメニュー横のカエルボタンの大きさは4K時にも同じ
	spretwidth1 = 32.0;
	spretheight1 = 32.0;

	//ショートカットボタン横のカエルボタンの大きさは4K時は大きく
	if (g_4kresolution) {
		spretwidth2 = 32.0;
		spretheight2 = 32.0;
	}
	else {
		spretwidth2 = 18.0;
		spretheight2 = 18.0;
	}


	{
		//s_spret2prev.dispcenter.x = (LONG)(16.0f + 8.0f);
		s_spret2prev.dispcenter.x = s_guibarX0 - 70 - (LONG)(16.0f + 8.0f);
		//s_spret2prev.dispcenter.y = 486;
		if (g_4kresolution) {
			s_spret2prev.dispcenter.y = 486 * 2 - TOPSLIDERSWNDH + 32;
		}
		else {
			s_spret2prev.dispcenter.y = 486 - TOPSLIDERSWNDH;
		}

		ChaVector3 disppos;
		disppos.x = (float)(s_spret2prev.dispcenter.x);
		disppos.y = (float)(s_spret2prev.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(spretwidth1, spretheight1);

		//CallF(s_spret2prev.sprite->SetPos(disppos), return 1);
		//CallF(s_spret2prev.sprite->SetSize(dispsize), return 1);
		s_spret2prev.sprite.UpdateScreen(disppos, dispsize);
		s_spret2prev.sprite_pushed.UpdateScreen(disppos, dispsize);
	}

	{

		int spgshift = 6;
		//s_spret2prev2.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 4;
		s_spret2prev2.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 5;//2024/03/11
		s_spret2prev2.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


		ChaVector3 disppos;
		disppos.x = (float)(s_spret2prev2.dispcenter.x);
		disppos.y = (float)(s_spret2prev2.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(spretwidth2, spretheight2);

		//CallF(s_spret2prev2.sprite->SetPos(disppos), return 1);
		//CallF(s_spret2prev2.sprite->SetSize(dispsize), return 1);
		s_spret2prev2.sprite.UpdateScreen(disppos, dispsize);
		s_spret2prev2.sprite_pushed.UpdateScreen(disppos, dispsize);
	}

	return 0;
}


int SetSpGUISWParams()
{
	//float spgwidth = 140.0f;
	float spgwidth = 124.0f;
	float spgheight = 28.0f;
	int spgshift = 6;
	s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.x = s_guibarX0;
	//s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y = 486;

	//s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y = 486 * s_winsizemult - TOPSLIDERSWNDH;
	if (g_4kresolution) {
		s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y = 486 * 2 - TOPSLIDERSWNDH + 32 - Float2Int(spgheight) - spgshift;
	}
	else {
		s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y = 486 - TOPSLIDERSWNDH - Float2Int(spgheight) - spgshift;
	}

	s_spguisw[SPGUISW_DISP_AND_LIMITS].dispcenter.x = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.x + (int)spgwidth + spgshift;
	s_spguisw[SPGUISW_DISP_AND_LIMITS].dispcenter.y = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y;

	//s_spguisw[SPGUISW_BRUSHPARAMS].dispcenter.x = s_spguisw[SPGUISW_DISP_AND_LIMITS].dispcenter.x + (int)spgwidth + spgshift;
	//s_spguisw[SPGUISW_BRUSHPARAMS].dispcenter.y = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y;

	//s_spguisw[SPGUISW_BULLETPHYSICS].dispcenter.x = s_spguisw[SPGUISW_BRUSHPARAMS].dispcenter.x + (int)spgwidth + spgshift;
	s_spguisw[SPGUISW_BULLETPHYSICS].dispcenter.x = s_spguisw[SPGUISW_DISP_AND_LIMITS].dispcenter.x + (int)spgwidth + spgshift;
	s_spguisw[SPGUISW_BULLETPHYSICS].dispcenter.y = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y;

	s_spguisw[SPGUISW_PROJ_AND_LOD].dispcenter.x = s_spguisw[SPGUISW_BULLETPHYSICS].dispcenter.x + (int)spgwidth + spgshift;
	s_spguisw[SPGUISW_PROJ_AND_LOD].dispcenter.y = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y;

	s_spguisw[SPGUISW_BLENDSHAPE].dispcenter.x = s_spguisw[SPGUISW_PROJ_AND_LOD].dispcenter.x + (int)spgwidth + spgshift;
	s_spguisw[SPGUISW_BLENDSHAPE].dispcenter.y = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y;

	int spgcnt;
	for (spgcnt = 0; spgcnt < SPGUISWNUM; spgcnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spguisw[spgcnt].dispcenter.x);
		disppos.y = (float)(s_spguisw[spgcnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(spgwidth, spgheight);

		//CallF(s_spguisw[spgcnt].spriteON->SetPos(disppos), return 1);
		//CallF(s_spguisw[spgcnt].spriteON->SetSize(dispsize), return 1);
		s_spguisw[spgcnt].spriteON.UpdateScreen(disppos, dispsize);

		//CallF(s_spguisw[spgcnt].spriteOFF->SetPos(disppos), return 1);
		//CallF(s_spguisw[spgcnt].spriteOFF->SetSize(dispsize), return 1);
		s_spguisw[spgcnt].spriteOFF.UpdateScreen(disppos, dispsize);

	}

	return 0;

}



int SetSpCamParams()
{
	int spashift = 6;
	//s_spcam[0].dispcenter.x = (int)(s_mainwidth * 0.57f);
	//s_spcam[0].dispcenter.y = (int)(30.0f * ((float)s_mainheight / 620.0)) + (int(spawidth * 1.5f));
	//s_spcam[0].dispcenter.x = s_mainwidth - 50 - 10 - (32 + 12) * 3;
	//s_spcam[0].dispcenter.y = 16 + 10 + (int(spawidth * 1.5f));
	s_spcam[0].dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 4;
	//s_spcam[0].dispcenter.y = (int)s_spsize / 2 + 10;
	s_spcam[0].dispcenter.y = (int)s_spsize / 2 + 14;//2024/03/04


	//spashift = (int)((float)spashift * ((float)s_mainwidth / 600.0));

	s_spcam[1].dispcenter.x = s_spcam[0].dispcenter.x + (int)s_spsize + spashift;
	s_spcam[1].dispcenter.y = s_spcam[0].dispcenter.y;

	s_spcam[2].dispcenter.x = s_spcam[1].dispcenter.x + (int)s_spsize + spashift;
	s_spcam[2].dispcenter.y = s_spcam[0].dispcenter.y;

	int spacnt;
	for (spacnt = 0; spacnt < SPR_CAM_MAX; spacnt++) {
		ChaVector3 disppos;
		disppos.x = (float)(s_spcam[spacnt].dispcenter.x);
		disppos.y = (float)(s_spcam[spacnt].dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsize, s_spsize);

		//CallF(s_spcam[spacnt].sprite->SetPos(disppos), return 1);
		//CallF(s_spcam[spacnt].sprite->SetSize(dispsize), return 1);
		s_spcam[spacnt].sprite.UpdateScreen(disppos, dispsize);
		s_spcam[spacnt].sprite_pushed.UpdateScreen(disppos, dispsize);
	}

	return 0;

}

int SetSpCameraModeSWParams()
{
	int spgshift = 6;
	s_spcameramode.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5;
	s_spcameramode.dispcenter.y = (int)s_spsize / 2 + 10;

	ChaVector3 disppos;
	disppos.x = (float)(s_spcameramode.dispcenter.x);
	disppos.y = (float)(s_spcameramode.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);


	dispsize *= 0.70f;//大きくみえるデザインなので　少し小さくして表示　当たり判定は元の大きさ

	//CallF(s_spcameramode.spriteON->SetPos(disppos), return 1);
	//CallF(s_spcameramode.spriteON->SetSize(dispsize), return 1);
	s_spcameramode.spriteON.UpdateScreen(disppos, dispsize);

	//CallF(s_spcameramode.spriteOFF->SetPos(disppos), return 1);
	//CallF(s_spcameramode.spriteOFF->SetSize(dispsize), return 1);
	s_spcameramode.spriteOFF.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpCameraInheritSWParams()
{
	int spgshift = 6;
	s_spcamerainherit.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5 - (int)s_spsize / 2;
	s_spcamerainherit.dispcenter.y = (int)s_spsize / 2 + 10;

	ChaVector3 disppos;
	disppos.x = (float)(s_spcamerainherit.dispcenter.x);
	disppos.y = (float)(s_spcamerainherit.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);


	dispsize *= 0.80f;//大きくみえるデザインなので　少し小さくして表示　当たり判定は元の大きさ


	//CallF(s_spcamerainherit.sprite1->SetPos(disppos), return 1);
	//CallF(s_spcamerainherit.sprite1->SetSize(dispsize), return 1);
	s_spcamerainherit.sprite1.UpdateScreen(disppos, dispsize);

	//CallF(s_spcamerainherit.sprite2->SetPos(disppos), return 1);
	//CallF(s_spcamerainherit.sprite2->SetSize(dispsize), return 1);
	s_spcamerainherit.sprite2.UpdateScreen(disppos, dispsize);
	//CallF(s_spcamerainherit.sprite3->SetPos(disppos), return 1);
	//CallF(s_spcamerainherit.sprite3->SetSize(dispsize), return 1);
	s_spcamerainherit.sprite3.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpCameraCommandParams()
{
	{
		int spgshift = 6;
		s_spcopy_camera.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 4;
		s_spcopy_camera.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;

		ChaVector3 disppos;
		disppos.x = (float)(s_spcopy_camera.dispcenter.x);
		disppos.y = (float)(s_spcopy_camera.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

		s_spcopy_camera.sprite.UpdateScreen(disppos, dispsize);
		s_spcopy_camera.sprite_pushed.UpdateScreen(disppos, dispsize);
	}

	{
		int spgshift = 6;
		s_sppaste_camera.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 3;
		s_sppaste_camera.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;

		ChaVector3 disppos;
		disppos.x = (float)(s_sppaste_camera.dispcenter.x);
		disppos.y = (float)(s_sppaste_camera.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

		s_sppaste_camera.sprite.UpdateScreen(disppos, dispsize);
		s_sppaste_camera.sprite_pushed.UpdateScreen(disppos, dispsize);

	}

	{
		int spgshift = 6;
		s_spinterpolate_camera.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 2;
		s_spinterpolate_camera.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;

		ChaVector3 disppos;
		disppos.x = (float)(s_spinterpolate_camera.dispcenter.x);
		disppos.y = (float)(s_spinterpolate_camera.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

		s_spinterpolate_camera.sprite.UpdateScreen(disppos, dispsize);
		s_spinterpolate_camera.sprite_pushed.UpdateScreen(disppos, dispsize);
	}

	{
		int spgshift = 6;
		s_spinit_camera.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 1;
		s_spinit_camera.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


		ChaVector3 disppos;
		disppos.x = (float)(s_spinit_camera.dispcenter.x);
		disppos.y = (float)(s_spinit_camera.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

		s_spinit_camera.sprite.UpdateScreen(disppos, dispsize);
		s_spinit_camera.sprite_pushed.UpdateScreen(disppos, dispsize);
	}

	{
		int spgshift = 6;
		s_spsmooth_camera.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 0;
		s_spsmooth_camera.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize + 6;


		ChaVector3 disppos;
		disppos.x = (float)(s_spsmooth_camera.dispcenter.x);
		disppos.y = (float)(s_spsmooth_camera.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

		s_spsmooth_camera.sprite.UpdateScreen(disppos, dispsize);
		s_spsmooth_camera.sprite_pushed.UpdateScreen(disppos, dispsize);
	}
	return 0;
}

int SetSpCopyParams()
{

	int spgshift = 6;
	//s_spcopy.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5;
	s_spcopy.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 4;
	//s_spcopy.dispcenter.y = s_spcamerainherit.dispcenter.y + (int)s_spsize + 6;
	s_spcopy.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;

	ChaVector3 disppos;
	disppos.x = (float)(s_spcopy.dispcenter.x);
	disppos.y = (float)(s_spcopy.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spcopy.sprite->SetPos(disppos), return 1);
	//CallF(s_spcopy.sprite->SetSize(dispsize), return 1);
	s_spcopy.sprite.UpdateScreen(disppos, dispsize);
	s_spcopy.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpSymCopyParams()
{
	int spgshift = 6;
	//s_spsymcopy.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5 + (int)s_spsizeSmall + 6;
	s_spsymcopy.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 3;
	//s_spsymcopy.dispcenter.y = s_spcamerainherit.dispcenter.y + (int)s_spsize + 6;
	s_spsymcopy.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


	ChaVector3 disppos;
	disppos.x = (float)(s_spsymcopy.dispcenter.x);
	disppos.y = (float)(s_spsymcopy.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spsymcopy.sprite->SetPos(disppos), return 1);
	//CallF(s_spsymcopy.sprite->SetSize(dispsize), return 1);
	s_spsymcopy.sprite.UpdateScreen(disppos, dispsize);
	s_spsymcopy.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpPasteParams()
{

	int spgshift = 6;
	//s_sppaste.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5 + (int)(s_spsizeSmall + 6) * 2;
	s_sppaste.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 2;
	//s_sppaste.dispcenter.y = s_spcamerainherit.dispcenter.y + (int)s_spsize + 6;
	s_sppaste.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


	ChaVector3 disppos;
	disppos.x = (float)(s_sppaste.dispcenter.x);
	disppos.y = (float)(s_sppaste.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_sppaste.sprite->SetPos(disppos), return 1);
	//CallF(s_sppaste.sprite->SetSize(dispsize), return 1);
	s_sppaste.sprite.UpdateScreen(disppos, dispsize);
	s_sppaste.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpCopyHistoryParams()
{
	int spgshift = 6;
	//s_spcopyhistory.dispcenter.x = s_mainwidth - (int)s_spsize - 10 - (int)s_spsize - 6 - ((int)s_spsize + 6) * 5 + (int)(s_spsizeSmall + 6) * 3;
	s_spcopyhistory.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 1;
	//s_spcopyhistory.dispcenter.y = s_spcamerainherit.dispcenter.y + (int)s_spsize + 6;
	s_spcopyhistory.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


	ChaVector3 disppos;
	disppos.x = (float)(s_spcopyhistory.dispcenter.x);
	disppos.y = (float)(s_spcopyhistory.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spcopyhistory.sprite->SetPos(disppos), return 1);
	//CallF(s_spcopyhistory.sprite->SetSize(dispsize), return 1);
	s_spcopyhistory.sprite.UpdateScreen(disppos, dispsize);
	s_spcopyhistory.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpInterpolateParams()
{
	int spgshift = 6;

	//interpolate
	{
		s_spinterpolate.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 3;
		s_spinterpolate.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;

		ChaVector3 disppos;
		disppos.x = (float)(s_spinterpolate.dispcenter.x);
		disppos.y = (float)(s_spinterpolate.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

		s_spinterpolate.sprite.UpdateScreen(disppos, dispsize);
		s_spinterpolate.sprite_pushed.UpdateScreen(disppos, dispsize);
	}


	//jump interpolate
	{
		s_spjumpinterpolate.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 4;
		s_spjumpinterpolate.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;

		ChaVector3 disppos;
		disppos.x = (float)(s_spjumpinterpolate.dispcenter.x);
		disppos.y = (float)(s_spjumpinterpolate.dispcenter.y);
		disppos.z = 0.0f;
		ChaVector2 dispsize;
		dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

		s_spjumpinterpolate.sprite.UpdateScreen(disppos, dispsize);
		s_spjumpinterpolate.sprite_pushed.UpdateScreen(disppos, dispsize);
	}


	return 0;

}

int SetSpInitParams()
{
	int spgshift = 6;
	s_spinit.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 2;
	s_spinit.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


	ChaVector3 disppos;
	disppos.x = (float)(s_spinit.dispcenter.x);
	disppos.y = (float)(s_spinit.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spinit.sprite->SetPos(disppos), return 1);
	//CallF(s_spinit.sprite->SetSize(dispsize), return 1);
	s_spinit.sprite.UpdateScreen(disppos, dispsize);
	s_spinit.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpScaleInitParams()
{

	int spgshift = 6;
	s_spscaleinit.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 1;
	s_spscaleinit.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


	ChaVector3 disppos;
	disppos.x = (float)(s_spscaleinit.dispcenter.x);
	disppos.y = (float)(s_spscaleinit.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spscaleinit.sprite->SetPos(disppos), return 1);
	//CallF(s_spscaleinit.sprite->SetSize(dispsize), return 1);
	s_spscaleinit.sprite.UpdateScreen(disppos, dispsize);
	s_spscaleinit.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpPropertyParams()
{
	int spgshift = 6;
	s_spproperty.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 0;
	s_spproperty.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


	ChaVector3 disppos;
	disppos.x = (float)(s_spproperty.dispcenter.x);
	disppos.y = (float)(s_spproperty.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spproperty.sprite->SetPos(disppos), return 1);
	//CallF(s_spproperty.sprite->SetSize(dispsize), return 1);
	s_spproperty.sprite.UpdateScreen(disppos, dispsize);
	s_spproperty.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}


int SetSpZeroFrameParams()
{

	int spgshift = 6;
	s_spzeroframe.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 4;
	s_spzeroframe.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;

	ChaVector3 disppos;
	disppos.x = (float)(s_spzeroframe.dispcenter.x);
	disppos.y = (float)(s_spzeroframe.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spzeroframe.sprite->SetPos(disppos), return 1);
	//CallF(s_spzeroframe.sprite->SetSize(dispsize), return 1);
	s_spzeroframe.sprite.UpdateScreen(disppos, dispsize);
	s_spzeroframe.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpCameraDollyParams()
{
	int spgshift = 6;
	s_spcameradolly.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 3;
	s_spcameradolly.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


	ChaVector3 disppos;
	disppos.x = (float)(s_spcameradolly.dispcenter.x);
	disppos.y = (float)(s_spcameradolly.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spcameradolly.sprite->SetPos(disppos), return 1);
	//CallF(s_spcameradolly.sprite->SetSize(dispsize), return 1);
	s_spcameradolly.sprite.UpdateScreen(disppos, dispsize);
	s_spcameradolly.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpModelPosDirParams()
{
	int spgshift = 6;
	s_spmodelposdir.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 2;
	s_spmodelposdir.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


	ChaVector3 disppos;
	disppos.x = (float)(s_spmodelposdir.dispcenter.x);
	disppos.y = (float)(s_spmodelposdir.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spmodelposdir.sprite->SetPos(disppos), return 1);
	//CallF(s_spmodelposdir.sprite->SetSize(dispsize), return 1);
	s_spmodelposdir.sprite.UpdateScreen(disppos, dispsize);
	s_spmodelposdir.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpMaterialRateParams()
{
	int spgshift = 6;
	s_spmaterialrate.dispcenter.x = s_spcam[2].dispcenter.x - ((int)s_spsizeSmall + 6) * 1;
	s_spmaterialrate.dispcenter.y = s_spcameramode.dispcenter.y + (int)s_spsize * 2 + 12;


	ChaVector3 disppos;
	disppos.x = (float)(s_spmaterialrate.dispcenter.x);
	disppos.y = (float)(s_spmaterialrate.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsizeSmall, s_spsizeSmall);

	//CallF(s_spmaterialrate.sprite->SetPos(disppos), return 1);
	//CallF(s_spmaterialrate.sprite->SetSize(dispsize), return 1);
	s_spmaterialrate.sprite.UpdateScreen(disppos, dispsize);
	s_spmaterialrate.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}


int SetSpRigParams()
{
	/*
		//sprefpos
		float spgwidth = 50.0f;
		float spgheight = 50.0f;
		int spgshift = 6;
		s_sprefpos.dispcenter.x = s_mainwidth - 35;
		s_sprefpos.dispcenter.y = 35 + ((int)spgheight + spgshift) * 3;
	*/

	int spashift = 6;
	//spashift = (int)((float)spashift * ((float)s_mainwidth / s_2ndposy));
	//s_sprig[SPRIG_INACTIVE].dispcenter.x = (int)(s_mainwidth * 0.57f) + ((int)(spawidth)+spashift) * 3;
	//s_sprig[SPRIG_INACTIVE].dispcenter.y = (int)(30.0f * ((float)s_mainheight / 620.0));// +(int(spawidth * 1.5f) * 2);
	//s_sprig[SPRIG_INACTIVE].dispcenter.x = s_mainwidth - 50 - 10 - 50 - 6 - 50 - 6;
	//s_sprig[SPRIG_INACTIVE].dispcenter.y = 25 + 10;
	s_sprig[SPRIG_INACTIVE].dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_sprig[SPRIG_INACTIVE].dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 4 + spashift;

	//s_spcam[0].dispcenter.x = s_mainwidth - 50 - 10 - 50 - 6 - (50 + 6) * 4;
	//s_spcam[0].dispcenter.y = 25 + 10;

	s_sprig[SPRIG_ACTIVE].dispcenter.x = s_sprig[SPRIG_INACTIVE].dispcenter.x;
	s_sprig[SPRIG_ACTIVE].dispcenter.y = s_sprig[SPRIG_INACTIVE].dispcenter.y;


	ChaVector3 disppos;
	disppos.x = (float)(s_sprig[0].dispcenter.x);
	disppos.y = (float)(s_sprig[0].dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);

	//CallF(s_sprig[SPRIG_INACTIVE].sprite->SetPos(disppos), return 1);
	//CallF(s_sprig[SPRIG_INACTIVE].sprite->SetSize(dispsize), return 1);
	s_sprig[SPRIG_INACTIVE].sprite.UpdateScreen(disppos, dispsize);
	s_sprig[SPRIG_INACTIVE].sprite_pushed.UpdateScreen(disppos, dispsize);

	//CallF(s_sprig[SPRIG_ACTIVE].sprite->SetPos(disppos), return 1);
	//CallF(s_sprig[SPRIG_ACTIVE].sprite->SetSize(dispsize), return 1);
	s_sprig[SPRIG_ACTIVE].sprite.UpdateScreen(disppos, dispsize);
	s_sprig[SPRIG_ACTIVE].sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpCpLW2WParams()
{
	int spashift = 6;
	s_spcplw2w.dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_spcplw2w.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 5 + spashift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spcplw2w.dispcenter.x);
	disppos.y = (float)(s_spcplw2w.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);

	//CallF(s_spcplw2w.sprite->SetPos(disppos), return 1);
	//CallF(s_spcplw2w.sprite->SetSize(dispsize), return 1);
	s_spcplw2w.sprite.UpdateScreen(disppos, dispsize);
	s_spcplw2w.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpUpperBarParams()
{
	int spashift = 6;
	s_spupperbar.dispcenter.x = s_mainwidth / 2;
	s_spupperbar.dispcenter.y = 0;

	ChaVector3 disppos;
	disppos.x = (float)(s_spupperbar.dispcenter.x);
	disppos.y = (float)(s_spupperbar.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams((float)s_mainwidth, 24.0f);

	//CallF(s_spupperbar.sprite->SetPos(disppos), return 1);
	//CallF(s_spupperbar.sprite->SetSize(dispsize), return 1);
	s_spupperbar.sprite.UpdateScreen(disppos, dispsize);
	s_spupperbar.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;
}

int SetSpSmoothParams()
{
	int spashift = 6;
	s_spsmooth.dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_spsmooth.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 5 + spashift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spsmooth.dispcenter.x);
	disppos.y = (float)(s_spsmooth.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);

	//CallF(s_spsmooth.sprite->SetPos(disppos), return 1);
	//CallF(s_spsmooth.sprite->SetSize(dispsize), return 1);
	s_spsmooth.sprite.UpdateScreen(disppos, dispsize);
	s_spsmooth.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpConstExeParams()
{
	int spashift = 6;
	s_spconstexe.dispcenter.x = s_mainwidth - (int)s_spsidemargin;
	s_spconstexe.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 7 + spashift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spconstexe.dispcenter.x);
	disppos.y = (float)(s_spconstexe.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);

	//CallF(s_spconstexe.sprite->SetPos(disppos), return 1);
	//CallF(s_spconstexe.sprite->SetSize(dispsize), return 1);
	s_spconstexe.sprite.UpdateScreen(disppos, dispsize);
	s_spconstexe.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpConstRefreshParams()
{
	int spashift = 6;
	s_spconstrefresh.dispcenter.x = s_mainwidth - (int)s_spsidemargin - (int)s_spsize - 10;
	s_spconstrefresh.dispcenter.y = (int)s_sptopmargin + ((int)s_spsize + spashift) * 7 + spashift;

	ChaVector3 disppos;
	disppos.x = (float)(s_spconstrefresh.dispcenter.x);
	disppos.y = (float)(s_spconstrefresh.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(s_spsize, s_spsize);

	//CallF(s_spconstrefresh.sprite->SetPos(disppos), return 1);
	//CallF(s_spconstrefresh.sprite->SetSize(dispsize), return 1);
	s_spconstrefresh.sprite.UpdateScreen(disppos, dispsize);
	s_spconstrefresh.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;

}

int SetSpMouseHereParams()
{
	float spawidth = 52.0f;
	int spashift = 50;
	s_spmousehere.dispcenter.x = 0;
	s_spmousehere.dispcenter.y = 0;


	ChaVector3 disppos;
	disppos.x = (float)(s_spmousehere.dispcenter.x);
	disppos.y = (float)(s_spmousehere.dispcenter.y);
	disppos.z = 0.0f;
	ChaVector2 dispsize;
	dispsize.SetParams(spawidth / (float)s_mainwidth * 2.0f, spawidth / (float)s_mainheight * 2.0f);
	//CallF(s_spmousehere.sprite->SetPos(disppos), return 1);
	//CallF(s_spmousehere.sprite->SetSize(dispsize), return 1);
	s_spmousehere.sprite.UpdateScreen(disppos, dispsize);
	s_spmousehere.sprite_pushed.UpdateScreen(disppos, dispsize);

	return 0;
}

//int SetSpBtParams()
//{
//	if (!s_spbt.sprite){
//		return 0;
//	}
//
//	float spawidth = 32.0f;
//	int spashift = 12;
//	spashift = (int)((float)spashift * ((float)s_mainwidth / 600.0));
//	s_spbt.dispcenter.x = (int)(s_mainwidth * 0.57f) + ((int)(spawidth)+spashift) * 3;
//	s_spbt.dispcenter.y = (int)(30.0f * ((float)s_mainheight / 620.0)) + (int(spawidth * 1.5f));// *2);
//
//
//	ChaVector3 disppos;
//	disppos.x = (float)(s_spbt.dispcenter.x);
//	disppos.y = (float)(s_spbt.dispcenter.y);
//	disppos.z = 0.0f;
//	ChaVector2 dispsize.SetParams(spawidth / (float)s_mainwidth * 2.0f, spawidth / (float)s_mainheight * 2.0f);
//	if (s_spbt.sprite) {
//		CallF(s_spbt.sprite->SetPos(disppos), return 1);
//		CallF(s_spbt.sprite->SetSize(dispsize), return 1);
//	}
//	else {
//		_ASSERT(0);
//	}
//
//	return 0;
//
//}

int PickSpUndo(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	if (!s_model) {
		return 0;
	}
	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	int startx = s_spundo[0].dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int spacnt;
		for (spacnt = 0; spacnt < 2; spacnt++) {
			int starty = s_spundo[spacnt].dispcenter.y - (int)s_spsize / 2;
			int endy = starty + (int)s_spsize;

			if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
				switch (spacnt) {
				case 0:
					kind = PICK_UNDO;
					break;
				case 1:
					kind = PICK_REDO;
					break;
				default:
					break;
				}
				break;
			}
		}
	}


	//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
	//	kind, srcpos.x, srcpos.y, starty, endy );
	//int spacnt;
	//for( spacnt = 0; spacnt < 3; spacnt++ ){
	//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spundo[spacnt].dispcenter.x, s_spundo[spacnt].dispcenter.x + 32 );
	//}

	return kind;
}


int PickSpAxis(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	//カメラアニメの編集時にSpAxisをドラッグするので0リターンをコメントアウト
	//if (s_camtargetdisp) {
	//	//カメラターゲット位置にマニピュレータ表示時にはpickしない
	//	return 0;
	//}

	int startx = s_spaxis[0].dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int spacnt;
		for (spacnt = 0; spacnt < SPAXISNUM; spacnt++) {
			int starty = s_spaxis[spacnt].dispcenter.y - (int)s_spsize / 2;
			int endy = starty + (int)s_spsize;

			if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
				switch (spacnt) {
				case 0:
					kind = PICK_SPA_X;
					break;
				case 1:
					kind = PICK_SPA_Y;
					break;
				case 2:
					kind = PICK_SPA_Z;
					break;
				}
				break;
			}
		}
	}


	//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
	//	kind, srcpos.x, srcpos.y, starty, endy );
	//int spacnt;
	//for( spacnt = 0; spacnt < 3; spacnt++ ){
	//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
	//}

	return kind;
}

int PickSpDispSW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}


	//ret2prev
	bool pickfrog = PickSpFrog(srcpos);
	if (pickfrog == true) {
		kind = -2;
		s_spret2prev.ButtonDown();
		s_SpriteButtonDown = true;
	}


	//spguisw
	if (kind == 0) {//カエルボタンを押していないとき
		int starty = s_spdispsw[SPDISPSW_LIGHTS].dispcenter.y - 14;
		int endy = starty + 28;


		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPDISPSWNUM; spgcnt++) {
				int startx = s_spdispsw[spgcnt].dispcenter.x - 70;
				int endx = startx + 124 + 6;

				if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
					switch (spgcnt) {
					case 0:
						kind = 1;
						break;
					case 1:
						kind = 2;
						break;
					case 2:
						kind = 3;
						break;
					case 3:
						kind = 4;
						break;
					case 4:
						kind = 5;
						break;
					default:
						kind = 0;
						break;
					}
					break;
				}
			}
		}


		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}


int PickSpRigidSW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}


	//ret2prev
	bool pickfrog = PickSpFrog(srcpos);
	if (pickfrog == true) {
		kind = -2;
		s_spret2prev.ButtonDown();
		s_SpriteButtonDown = true;
	}


	//spguisw
	if (kind == 0) {//カエルボタンを押していないとき
		int starty = s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].dispcenter.y - 14;
		int endy = starty + 28;


		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPRIGIDSWNUM; spgcnt++) {
				int startx = s_sprigidsw[spgcnt].dispcenter.x - 70;
				int endx = startx + 124 + 6;

				if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
					switch (spgcnt) {
					case 0:
						kind = 1;
						break;
					case 1:
						kind = 2;
						break;
					case 2:
						kind = 3;
						break;
					case 3:
						kind = 4;
						break;
					default:
						kind = 0;
						break;
					}
					break;
				}
			}
		}


		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}

int PickSpRetargetSW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}


	//ret2prev
	bool pickfrog = PickSpFrog(srcpos);
	if (pickfrog == true) {
		kind = -2;
		s_spret2prev.ButtonDown();
		s_SpriteButtonDown = true;
	}


	//spretargetsw
	if (kind == 0) {
		int starty = s_spretargetsw[SPRETARGETSW_RETARGET].dispcenter.y - 14;
		int endy = starty + 28;


		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int sprcnt;
			for (sprcnt = 0; sprcnt < SPRETARGETSWNUM; sprcnt++) {

				int startx = s_spretargetsw[sprcnt].dispcenter.x - 70;
				int endx = startx + 124 + 6;

				if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
					kind = sprcnt + 1;
					return kind;
				}
			}
		}
		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}

int PickSpEffectSW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}


	//ret2prev
	bool pickfrog = PickSpFrog(srcpos);
	if (pickfrog == true) {
		kind = -2;
		s_spret2prev.ButtonDown();
		s_SpriteButtonDown = true;
	}


	//speffectsw
	if (kind == 0) {
		int starty = s_speffectsw[SPEFFECTSW_SKY].dispcenter.y - 14;
		int endy = starty + 28;


		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int sprcnt;
			for (sprcnt = 0; sprcnt < SPEFFECTSWNUM; sprcnt++) {

				int startx = s_speffectsw[sprcnt].dispcenter.x - 70;
				int endx = startx + 124 + 6;

				if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
					kind = sprcnt + 1;
					return kind;
				}
			}
		}
	}
	return kind;
}



int PickSpIkModeSW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}



	//spikmodesw
	if (kind == 0) {
		int startx = s_spikmodesw[0].dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;


		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			int spgcnt;
			for (spgcnt = 0; spgcnt < 3; spgcnt++) {
				int starty = s_spikmodesw[spgcnt].dispcenter.y - (int)s_spsize / 2;
				int endy = starty + (int)s_spsize + 6;

				if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
					switch (spgcnt) {
					case 0:
						kind = 1;
						break;
					case 1:
						kind = 2;
						break;
					case 2:
						kind = 3;
						break;
					default:
						kind = 1;
						break;
					}
					break;
				}
			}
		}


		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}

int PickSpRefPosSW(POINT srcpos)
{
	int ispick = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	//splod
	int startx = s_sprefpos.dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_sprefpos.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}

int PickSpLimitEulSW(POINT srcpos)
{
	int ispick = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	//splod
	int startx = s_splimiteul.dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_splimiteul.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}

int PickSpScrapingSW(POINT srcpos)
{
	int ispick = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	//sprefpos
	int startx = s_spscraping.dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_spscraping.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}

bool PickSpFrog(POINT srcpos)
{

	int spretwidth = 32;//プレートメニュー横のカエルボタンの大きさは４K時にも同じ

	int starty0 = s_spret2prev.dispcenter.y - spretwidth / 2;
	int endy0 = starty0 + spretwidth;
	if ((srcpos.y >= starty0) && (srcpos.y <= endy0)) {
		int startx0 = s_spret2prev.dispcenter.x - spretwidth / 2;
		int endx0 = startx0 + spretwidth;
		if ((srcpos.x >= startx0) && (srcpos.x <= endx0)) {
			return true;
		}
	}

	return false;
}

bool PickSpFrog2(POINT srcpos)
{

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	int spretwidth;
	if (g_4kresolution) {//ショートカットボタン横のカエルボタンは４K時には大きく
		spretwidth = 32;
	}
	else {
		spretwidth = 18;
	}


	int starty0 = s_spret2prev2.dispcenter.y - spretwidth / 2;
	int endy0 = starty0 + spretwidth;
	if ((srcpos.y >= starty0) && (srcpos.y <= endy0)) {
		int startx0 = s_spret2prev2.dispcenter.x - spretwidth / 2;
		int endx0 = startx0 + spretwidth;
		if ((srcpos.x >= startx0) && (srcpos.x <= endx0)) {
			return true;
		}
	}

	return false;
}


int PickSpGUISW(POINT srcpos)
{
	int kind = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}


	//ret2prev
	bool pickfrog = PickSpFrog(srcpos);
	if (pickfrog == true) {
		kind = -2;
		s_spret2prev.ButtonDown();
		s_SpriteButtonDown = true;
	}


	//spguisw
	if (kind == 0) {
		int starty = s_spguisw[SPGUISW_CAMERA_AND_IK].dispcenter.y - 14;
		int endy = starty + 28;


		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPGUISWNUM; spgcnt++) {
				//int startx = s_spguisw[spgcnt].dispcenter.x - 70;
				//int endx = startx + 140 + 6;
				int startx = s_spguisw[spgcnt].dispcenter.x - 62;
				int endx = startx + 124 + 6;

				if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
					switch (spgcnt) {
					case 0:
						kind = (SPGUISW_CAMERA_AND_IK + 2);
						break;
					case 1:
						kind = (SPGUISW_DISP_AND_LIMITS + 2);
						break;
					//case 2:
					//	kind = (SPGUISW_BRUSHPARAMS + 2);
					//	break;
					case 2:
						kind = (SPGUISW_BULLETPHYSICS + 2);
						break;
					case 3:
						kind = (SPGUISW_PROJ_AND_LOD + 2);
						break;
					case 4:
						kind = (SPGUISW_BLENDSHAPE + 2);
						break;
					default:
						kind = 1;
						break;
					}
					break;
				}
			}
		}


		//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
		//	kind, srcpos.x, srcpos.y, starty, endy );
		//int spacnt;
		//for( spacnt = 0; spacnt < 3; spacnt++ ){
		//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
		//}
	}
	return kind;
}

int PickSpCam(POINT srcpos)
{
	int kind = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}

	//if (g_previewFlag == 5){
	//	return 0;
	//}



	int starty = s_spcam[SPR_CAM_I].dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int spacnt;
		for (spacnt = 0; spacnt < SPR_CAM_MAX; spacnt++) {
			int startx = s_spcam[spacnt].dispcenter.x - (int)s_spsize / 2;
			int endx = startx + (int)s_spsize;

			if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
				switch (spacnt) {
				case 0:
					kind = PICK_CAMROT;
					break;
				case 1:
					kind = PICK_CAMMOVE;
					break;
				case 2:
					kind = PICK_CAMDIST;
					break;
				default:
					kind = 0;
					break;
				}
				break;
			}
		}
	}

	//DbgOut( L"pickspaxis : kind %d, mouse (%d, %d), starty %d, endy %d\r\n",
	//	kind, srcpos.x, srcpos.y, starty, endy );
	//int spacnt;
	//for( spacnt = 0; spacnt < 3; spacnt++ ){
	//	DbgOut( L"\tspa %d : startx %d, endx %d\r\n", spacnt, s_spaxis[spacnt].dispcenter.x, s_spaxis[spacnt].dispcenter.x + 32 );
	//}

	return kind;
}

int PickSpCameraModeSW(POINT srcpos)
{
	int ispick = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		return 0;
	}

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	//sprefpos
	int startx = s_spcameramode.dispcenter.x - (int)s_spsize / 2;
	int endx = startx + (int)s_spsize;

	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_spcameramode.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}

int PickSpCameraInheritSW(POINT srcpos)
{
	int ispick = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}

	//if (g_previewFlag != 0) {
	//	return 0;
	//}

	//if (g_previewFlag == 5){
	//	return 0;
	//}

	//sprefpos
	int startx = s_spcamerainherit.dispcenter.x - (int)s_spsize / 2;

	//int endx = startx + (int)s_spsize;
	int endx = startx + (int)s_spsize / 2;//inheritスプライトは半分重ねて表示する　当たり判定をその分狭くする


	if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
		int starty = s_spcamerainherit.dispcenter.y - (int)s_spsize / 2;
		int endy = starty + (int)s_spsize + 6;

		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			ispick = 1;
		}
	}

	return ispick;
}



int PickSpRig(POINT srcpos)
{
	int pickflag = 0;

	//if (g_previewFlag == 5){
	//	return 0;
	//}
	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	int starty = s_sprig[SPRIG_INACTIVE].dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_sprig[SPRIG_INACTIVE].dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpCpLW2W(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spcplw2w.dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spcplw2w.dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpSmooth(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}


	int starty = s_spsmooth.dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spsmooth.dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpConstExe(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spconstexe.dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spconstexe.dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpConstRefresh(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spconstrefresh.dispcenter.y - (int)s_spsize / 2;
	int endy = starty + (int)s_spsize;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spconstrefresh.dispcenter.x - (int)s_spsize / 2;
		int endx = startx + (int)s_spsize;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}

int PickSpCopyCamera(POINT srcpos)
{
	int pickflag = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spcopy_camera.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spcopy_camera.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpPasteCamera(POINT srcpos)
{
	int pickflag = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_sppaste_camera.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_sppaste_camera.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpInitCamera(POINT srcpos)
{
	int pickflag = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spinit_camera.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spinit_camera.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpInterpolateCamera(POINT srcpos)
{
	int pickflag = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spinterpolate_camera.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spinterpolate_camera.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpSmoothCamera(POINT srcpos)
{
	int pickflag = 0;

	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	int starty = s_spsmooth_camera.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spsmooth_camera.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}




int PickSpCopy(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 0) {
		return 0;
	}

	int starty = s_spcopy.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spcopy.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpSymCopy(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 0) {
		return 0;
	}

	int starty = s_spsymcopy.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spsymcopy.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpPaste(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 0) {
		return 0;
	}

	int starty = s_sppaste.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_sppaste.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpCopyHistory(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 0) {
		return 0;
	}

	int starty = s_spcopyhistory.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spcopyhistory.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}


int PickSpInterpolate(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 1) {
		return 0;
	}

	{
		int starty = s_spinterpolate.dispcenter.y - (int)s_spsizeSmall / 2;
		int endy = starty + (int)s_spsizeSmall;
		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int startx = s_spinterpolate.dispcenter.x - (int)s_spsizeSmall / 2;
			int endx = startx + (int)s_spsizeSmall;

			if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
				pickflag = 1;
			}
		}
	}


	if (pickflag == 0) {
		int starty = s_spjumpinterpolate.dispcenter.y - (int)s_spsizeSmall / 2;
		int endy = starty + (int)s_spsizeSmall;
		if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
			int startx = s_spjumpinterpolate.dispcenter.x - (int)s_spsizeSmall / 2;
			int endx = startx + (int)s_spsizeSmall;

			if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
				pickflag = 2;
			}
		}
	}

	return pickflag;
}
int PickSpInit(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 1) {
		return 0;
	}

	int starty = s_spinit.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spinit.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpScaleInit(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 1) {
		return 0;
	}

	int starty = s_spscaleinit.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spscaleinit.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpProperty(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 1) {
		return 0;
	}

	int starty = s_spproperty.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spproperty.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}



int PickSpZeroFrame(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 2) {
		return 0;
	}

	int starty = s_spzeroframe.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spzeroframe.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpCameraDolly(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 2) {
		return 0;
	}

	int starty = s_spcameradolly.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spcameradolly.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpModelPosDir(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 2) {
		return 0;
	}

	int starty = s_spmodelposdir.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spmodelposdir.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}
int PickSpMaterialRate(POINT srcpos)
{
	int pickflag = 0;


	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state == false) {
		//非表示中
		return 0;
	}
	if (g_previewFlag != 0) {
		//preview中は　押さない
		return 0;
	}

	if (s_toolspritemode != 2) {
		return 0;
	}

	int starty = s_spmaterialrate.dispcenter.y - (int)s_spsizeSmall / 2;
	int endy = starty + (int)s_spsizeSmall;

	//SPRIG_INACTIVEとSPRIG_ACTIVEは同じ位置なので当たり判定は１回で良い
	if ((srcpos.y >= starty) && (srcpos.y <= endy)) {
		int startx = s_spmaterialrate.dispcenter.x - (int)s_spsizeSmall / 2;
		int endx = startx + (int)s_spsizeSmall;

		if ((srcpos.x >= startx) && (srcpos.x <= endx)) {
			pickflag = 1;
		}
	}

	return pickflag;
}


//int PickSpBt(POINT srcpos)
//{
//	int pickflag = 0;
//
//	//if (g_previewFlag == 5){
//	//	return 0;
//	//}
//
//
//	if (s_spbt.sprite == 0){
//		return 0;
//	}
//
//	int starty = s_spbt.dispcenter.y - 16;
//	int endy = starty + 32;
//
//	if ((srcpos.y >= starty) && (srcpos.y <= endy)){
//		int startx = s_spbt.dispcenter.x - 16;
//		int endx = startx + 32;
//
//		if ((srcpos.x >= startx) && (srcpos.x <= endx)){
//			pickflag = 1;
//		}
//	}
//
//	return pickflag;
//}

int SetSelectState()
{

	if ((g_previewFlag != 0) && (g_previewFlag != 5)) {
		return 0;
	}

	//if( !s_select || !s_model || g_previewFlag ){
	if (!s_select || !s_model || (g_previewFlag == 5)) {
		return 0;
	}

	if (!s_selectobj_objx || !s_selectobj_objy || !s_selectobj_objz || !s_selectobj_center ||
		!s_selectobj_ringx || !s_selectobj_ringy || !s_selectobj_ringz) {
		return 0;
	}
	if (!s_matred || !s_ringred || !s_matblue || !s_ringblue || !s_matgreen || !s_ringgreen || !s_matyellow || !s_matyellow) {
		return 0;
	}


	if (s_camtargetdisp == false) {
		if (s_ikkind == 0) {
			s_select->SetDispFlag("ringX", 1);
			s_select->SetDispFlag("ringY", 1);
			s_select->SetDispFlag("ringZ", 1);
			s_select->SetDispFlag("planeX", 1);
			s_select->SetDispFlag("planeY", 1);
			s_select->SetDispFlag("planeZ", 1);
		}
		else if ((s_ikkind == 1) || (s_ikkind == 2)) {
			s_select->SetDispFlag("ringX", 0);
			s_select->SetDispFlag("ringY", 0);
			s_select->SetDispFlag("ringZ", 0);
			s_select->SetDispFlag("planeX", 0);
			s_select->SetDispFlag("planeY", 0);
			s_select->SetDispFlag("planeZ", 0);
		}
	}
	else {
		//2024/02/25
		//ShadowメニューのCamDistチェックボックスオンのとき
		s_select->SetDispFlag("ringX", 0);
		s_select->SetDispFlag("ringY", 0);
		s_select->SetDispFlag("ringZ", 0);
		s_select->SetDispFlag("planeX", 0);
		s_select->SetDispFlag("planeY", 0);
		s_select->SetDispFlag("planeZ", 0);
	}
	////////

	UIPICKINFO pickinfo;//!!!!!!!!!!! is not s_pickinfo
	InitPickInfo(&pickinfo);
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	pickinfo.clickpos = ptCursor;
	pickinfo.mousepos = ptCursor;
	pickinfo.mousebefpos = ptCursor;
	pickinfo.diffmouse.SetParams(0.0f, 0.0f);

	//pickinfo.winx = (int)DXUTGetWindowWidth();
	//pickinfo.winy = (int)DXUTGetWindowHeight();
	pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	pickinfo.pickrange = PICKRANGE;
	pickinfo.buttonflag = 0;

	//pickinfo.pickobjno = s_curboneno;
	pickinfo.pickobjno = -1;

	int spakind = 0;
	int spckind = 0;
	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
		spakind = PickSpAxis(ptCursor);
		spckind = PickSpCam(ptCursor);
	}
	if (spakind != 0) {
		pickinfo.pickobjno = s_curboneno;
		pickinfo.buttonflag = spakind;
	}
	else if (spckind != 0) {
		pickinfo.pickobjno = s_curboneno;
		pickinfo.buttonflag = spckind;
	}
	else {

		if (g_shiftkey == false) {
			CallF(PickBone(&pickinfo), return 1);
		}

		if (pickinfo.pickobjno >= 0) {
			pickinfo.buttonflag = PICK_CENTER;//!!!!!!!!!!!!!
		}
		else {
			if (s_dispselect) {
				bool excludeinvface = false;
				int colliobjx, colliobjy, colliobjz, colliringx, colliringy, colliringz;
				colliobjx = 0;
				colliobjy = 0;
				colliobjz = 0;
				colliringx = 0;
				colliringy = 0;
				colliringz = 0;

				colliobjx = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "objX", excludeinvface);
				colliobjy = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "objY", excludeinvface);
				colliobjz = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "objZ", excludeinvface);
				if (s_ikkind == 0) {
					colliringx = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "ringX", excludeinvface);
					colliringy = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "ringY", excludeinvface);
					colliringz = s_select->CollisionNoBoneObj_Mouse(&pickinfo, "ringZ", excludeinvface);
				}
				else {
					colliringx = 0;
					colliringy = 0;
					colliringz = 0;
				}
				if (colliobjx || colliringx || colliobjy || colliringy || colliobjz || colliringz) {
					pickinfo.pickobjno = s_curboneno;
				}

				if (colliobjx || colliringx) {
					pickinfo.buttonflag = PICK_X;
				}
				else if (colliobjy || colliringy) {
					pickinfo.buttonflag = PICK_Y;
				}
				else if (colliobjz || colliringz) {
					pickinfo.buttonflag = PICK_Z;
				}
				else {
					InitPickInfo(&pickinfo);
				}
			}
			else {
				InitPickInfo(&pickinfo);
			}
		}
	}

	if (s_pickinfo.buttonflag != 0) {
		return 0;//!!!!!!!!!!!!!!!!!!!!!!!
	}

	//float hirate = 1.0f;
	//float hirate = 1.25f;
	float hirate = 1.0f;//2023/12/21
	float lowrate = 0.6f;

	//float hia = 0.3f;
	//float hia = 0.7f;
	float hia = 0.50f;//2023/12/21
	//float hia = 0.3f;
	//float lowa = 0.3f;
	float lowa = 0.45f;//23023/12/21

	ChaVector4 hidiffusemult;
	hidiffusemult.SetParams(hirate, hirate, hirate, hia);
	ChaVector4 lowdiffusemult;
	lowdiffusemult.SetParams(lowrate, lowrate, lowrate, lowa);
	//ChaVector4 hidiffusemult.SetParams(hirate, hirate, hirate, hia);
	//ChaVector4 lowdiffusemult.SetParams(hirate, hirate, hirate, lowa);


	if (s_matred && s_ringred && s_matblue && s_ringblue && s_matgreen && s_ringgreen && s_matyellow) {
		if ((pickinfo.pickobjno >= 0) && (s_curboneno == pickinfo.pickobjno)) {

			if ((pickinfo.buttonflag == PICK_X) || (pickinfo.buttonflag == PICK_SPA_X)) {//red
				//s_matred->SetDif4F(s_matredmat * hirate);
				//s_ringred->SetDif4F(s_ringredmat * hirate);
				//s_matred->SetDif4FW(hia);
				//s_ringred->SetDif4FW(hia);

				//s_matblue->SetDif4F(s_matbluemat * lowrate);
				//s_ringblue->SetDif4F(s_ringbluemat * lowrate);
				//s_matblue->SetDif4FW(lowa);
				//s_ringblue->SetDif4FW(lowa);

				//s_matgreen->SetDif4F(s_matgreenmat * lowrate);
				//s_ringgreen->SetDif4F(s_ringgreenmat * lowrate);
				//s_matgreen->SetDif4FW(lowa);
				//s_ringgreen->SetDif4FW(lowa);

				//s_matyellow->SetDif4F(s_matyellowmat * lowrate);
				//s_matyellow->SetDif4FW(lowa);


				s_matred->SetTempDiffuseMult(hidiffusemult);
				s_ringred->SetTempDiffuseMult(hidiffusemult);
				s_matblue->SetTempDiffuseMult(lowdiffusemult);
				s_ringblue->SetTempDiffuseMult(lowdiffusemult);
				s_matgreen->SetTempDiffuseMult(lowdiffusemult);
				s_ringgreen->SetTempDiffuseMult(lowdiffusemult);
				s_matyellow->SetTempDiffuseMult(lowdiffusemult);

				s_matred->SetTempDiffuseMultFlag(true);
				s_ringred->SetTempDiffuseMultFlag(true);
				s_matblue->SetTempDiffuseMultFlag(true);
				s_ringblue->SetTempDiffuseMultFlag(true);
				s_matgreen->SetTempDiffuseMultFlag(true);
				s_ringgreen->SetTempDiffuseMultFlag(true);
				s_matyellow->SetTempDiffuseMultFlag(true);

			}
			else if ((pickinfo.buttonflag == PICK_Y) || (pickinfo.buttonflag == PICK_SPA_Y)) {//green
				//s_matred->SetDif4F(s_matredmat * lowrate);
				//s_ringred->SetDif4F(s_ringredmat * lowrate);
				//s_matred->SetDif4FW(lowa);
				//s_ringred->SetDif4FW(lowa);

				//s_matblue->SetDif4F(s_matbluemat * lowrate);
				//s_ringblue->SetDif4F(s_ringbluemat * lowrate);
				//s_matblue->SetDif4FW(lowa);
				//s_ringblue->SetDif4FW(lowa);

				//s_matgreen->SetDif4F(s_matgreenmat * hirate);
				//s_ringgreen->SetDif4F(s_ringgreenmat * hirate);
				//s_matgreen->SetDif4FW(hia);
				//s_ringgreen->SetDif4FW(hia);

				//s_matyellow->SetDif4F(s_matyellowmat * lowrate);
				//s_matyellow->SetDif4FW(lowa);

				s_matred->SetTempDiffuseMult(lowdiffusemult);
				s_ringred->SetTempDiffuseMult(lowdiffusemult);
				s_matblue->SetTempDiffuseMult(lowdiffusemult);
				s_ringblue->SetTempDiffuseMult(lowdiffusemult);
				s_matgreen->SetTempDiffuseMult(hidiffusemult);
				s_ringgreen->SetTempDiffuseMult(hidiffusemult);
				s_matyellow->SetTempDiffuseMult(lowdiffusemult);

				s_matred->SetTempDiffuseMultFlag(true);
				s_ringred->SetTempDiffuseMultFlag(true);
				s_matblue->SetTempDiffuseMultFlag(true);
				s_ringblue->SetTempDiffuseMultFlag(true);
				s_matgreen->SetTempDiffuseMultFlag(true);
				s_ringgreen->SetTempDiffuseMultFlag(true);
				s_matyellow->SetTempDiffuseMultFlag(true);
			}
			else if ((pickinfo.buttonflag == PICK_Z) || (pickinfo.buttonflag == PICK_SPA_Z)) {//blue
				//s_matred->SetDif4F(s_matredmat * lowrate);
				//s_ringred->SetDif4F(s_ringredmat * lowrate);
				//s_matred->SetDif4FW(lowa);
				//s_ringred->SetDif4FW(lowa);

				//s_matblue->SetDif4F(s_matbluemat * hirate);
				//s_ringblue->SetDif4F(s_ringbluemat * hirate);
				//s_matblue->SetDif4FW(hia);
				//s_ringblue->SetDif4FW(hia);

				//s_matgreen->SetDif4F(s_matgreenmat * lowrate);
				//s_ringgreen->SetDif4F(s_ringgreenmat * lowrate);
				//s_matgreen->SetDif4FW(lowa);
				//s_ringgreen->SetDif4FW(lowa);

				//s_matyellow->SetDif4F(s_matyellowmat * lowrate);
				//s_matyellow->SetDif4FW(lowa);


				s_matred->SetTempDiffuseMult(lowdiffusemult);
				s_ringred->SetTempDiffuseMult(lowdiffusemult);
				s_matblue->SetTempDiffuseMult(hidiffusemult);
				s_ringblue->SetTempDiffuseMult(hidiffusemult);
				s_matgreen->SetTempDiffuseMult(lowdiffusemult);
				s_ringgreen->SetTempDiffuseMult(lowdiffusemult);
				s_matyellow->SetTempDiffuseMult(lowdiffusemult);

				s_matred->SetTempDiffuseMultFlag(true);
				s_ringred->SetTempDiffuseMultFlag(true);
				s_matblue->SetTempDiffuseMultFlag(true);
				s_ringblue->SetTempDiffuseMultFlag(true);
				s_matgreen->SetTempDiffuseMultFlag(true);
				s_ringgreen->SetTempDiffuseMultFlag(true);
				s_matyellow->SetTempDiffuseMultFlag(true);
			}
			else if (pickinfo.buttonflag == PICK_CENTER) {//yellow
				//s_matred->SetDif4F(s_matredmat * lowrate);
				//s_ringred->SetDif4F(s_ringredmat * lowrate);
				//s_matred->SetDif4FW(lowa);
				//s_ringred->SetDif4FW(lowa);

				//s_matblue->SetDif4F(s_matbluemat * lowrate);
				//s_ringblue->SetDif4F(s_ringbluemat * lowrate);
				//s_matblue->SetDif4FW(lowa);
				//s_ringblue->SetDif4FW(lowa);

				//s_matgreen->SetDif4F(s_matgreenmat * lowrate);
				//s_ringgreen->SetDif4F(s_ringgreenmat * lowrate);
				//s_matgreen->SetDif4FW(lowa);
				//s_ringgreen->SetDif4FW(lowa);

				//s_matyellow->SetDif4F(s_matyellowmat * hirate);
				//s_matyellow->SetDif4FW(hia);

				s_matred->SetTempDiffuseMult(lowdiffusemult);
				s_ringred->SetTempDiffuseMult(lowdiffusemult);
				s_matblue->SetTempDiffuseMult(lowdiffusemult);
				s_ringblue->SetTempDiffuseMult(lowdiffusemult);
				s_matgreen->SetTempDiffuseMult(lowdiffusemult);
				s_ringgreen->SetTempDiffuseMult(lowdiffusemult);
				s_matyellow->SetTempDiffuseMult(hidiffusemult);

				s_matred->SetTempDiffuseMultFlag(true);
				s_ringred->SetTempDiffuseMultFlag(true);
				s_matblue->SetTempDiffuseMultFlag(true);
				s_ringblue->SetTempDiffuseMultFlag(true);
				s_matgreen->SetTempDiffuseMultFlag(true);
				s_ringgreen->SetTempDiffuseMultFlag(true);
				s_matyellow->SetTempDiffuseMultFlag(true);
			}
		}
		else {
			//s_matred->SetDif4F(s_matredmat * lowrate);
			//s_ringred->SetDif4F(s_ringredmat * lowrate);
			//s_matred->SetDif4FW(lowa);
			//s_ringred->SetDif4FW(lowa);

			//s_matblue->SetDif4F(s_matbluemat * lowrate);
			//s_ringblue->SetDif4F(s_ringbluemat * lowrate);
			//s_matblue->SetDif4FW(lowa);
			//s_ringblue->SetDif4FW(lowa);

			//s_matgreen->SetDif4F(s_matgreenmat * lowrate);
			//s_ringgreen->SetDif4F(s_ringgreenmat * lowrate);
			//s_matgreen->SetDif4FW(lowa);
			//s_ringgreen->SetDif4FW(lowa);

			//s_matyellow->SetDif4F(s_matyellowmat * lowrate);
			//s_matyellow->SetDif4FW(lowa);

			s_matred->SetTempDiffuseMult(lowdiffusemult);
			s_ringred->SetTempDiffuseMult(lowdiffusemult);
			s_matblue->SetTempDiffuseMult(lowdiffusemult);
			s_ringblue->SetTempDiffuseMult(lowdiffusemult);
			s_matgreen->SetTempDiffuseMult(lowdiffusemult);
			s_ringgreen->SetTempDiffuseMult(lowdiffusemult);
			s_matyellow->SetTempDiffuseMult(lowdiffusemult);

			s_matred->SetTempDiffuseMultFlag(true);
			s_ringred->SetTempDiffuseMultFlag(true);
			s_matblue->SetTempDiffuseMultFlag(true);
			s_ringblue->SetTempDiffuseMultFlag(true);
			s_matgreen->SetTempDiffuseMultFlag(true);
			s_ringgreen->SetTempDiffuseMultFlag(true);
			s_matyellow->SetTempDiffuseMultFlag(true);

		}
	}

	return 0;
}

int CreateTimeLineMark(int topboneno)
{
	if (g_previewFlag != 0) {
		return 0;
	}

	if (s_model && s_owpTimeline && s_owpLTimeline) {
		if (topboneno < 0) {
			CreateMarkReq(s_editmotionflag, 0);
		}
		else {
			CreateMarkReq(topboneno, 0);
		}

		SetTimelineMark();

		s_owpTimeline->callRewrite();
		s_owpTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開

		s_owpLTimeline->callRewrite();
		s_owpLTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開
	}
	return 0;
}

int CreateMotionBrush(double srcstart, double srcend, bool onrefreshflag)
{
	//int keynum;
	double startframe, endframe;
	//s_editrange.GetRange(&keynum, &startframe, &endframe);


	SetBrushName();//2024/03/26


	if (!s_model) {
		//return -1;
		return 2;//2023/10/05 
	}
	if (!s_model->ExistCurrentMotion()) {
		//return -1;
		return 2;//2023/10/05 
	}


	if ((srcstart < 0.0) || (srcend < 0.0)) {
		//_ASSERT(0);
		return 2;//フレーム,フレーム長範囲外は 2 を返す
	}
	if (srcstart > srcend) {
		double tmp = srcstart;
		srcstart = srcend;
		srcend = tmp;
	}


	startframe = srcstart;
	endframe = srcend;


	if (g_motionbrush_value) {
		free(g_motionbrush_value);
		g_motionbrush_value = 0;
	}

	MOTINFO curmi = GetEditTargetMotInfo();
	if (curmi.motid <= 0) {
		return 2;
	}
	int frameleng = IntTime(curmi.frameleng);

	if ((frameleng <= 0) || (frameleng > 100000)) {
		//_ASSERT(0);
		return 2;//フレーム,フレーム長範囲外は 2 を返す
	}

	g_motionbrush_startframe = startframe;
	g_motionbrush_endframe = endframe;
	g_motionbrush_numframe = endframe - startframe + 1;
	g_motionbrush_frameleng = frameleng;

	//g_motionbrush_applyframe = startframe + (endframe - startframe) * g_applyrate * 0.01;
	if (g_applyrate == 0.0) {
		g_motionbrush_applyframe = startframe;
	}
	else if (g_applyrate == 100.0) {
		g_motionbrush_applyframe = endframe;
	}
	else {
		g_motionbrush_applyframe = (double)((int)(startframe + (endframe - startframe) * (g_applyrate / 100.0)));//editrangeと同じ式
	}


	if ((g_motionbrush_applyframe < 0) || (g_motionbrush_applyframe > endframe)) {
		//_ASSERT(0);
		return 2;//フレーム,フレーム長範囲外は 2 を返す
	}

	g_motionbrush_value = (float*)malloc(sizeof(float) * (g_motionbrush_frameleng + 1));
	if (!g_motionbrush_value) {
		_ASSERT(0);
		return -1;
	}
	::memset(g_motionbrush_value, 0, sizeof(float) * (g_motionbrush_frameleng + 1));

	float* tempvalue;
	tempvalue = (float*)malloc(sizeof(float) * (g_motionbrush_frameleng + 1));
	if (!tempvalue) {
		_ASSERT(0);
		return -1;
	}
	::memset(tempvalue, 0, sizeof(float) * (g_motionbrush_frameleng + 1));


	int ret = 0;

	if (s_plugin && (g_motionbrush_method >= 0) && (g_motionbrush_method <= MAXPLUGIN)) {
		s_onselectplugin = 1;


		//このif文はプラグイン内にも推奨
		if ((g_motionbrush_startframe >= 0.0) && (g_motionbrush_startframe < 1e5) &&
			(g_motionbrush_endframe >= g_motionbrush_startframe) && (g_motionbrush_endframe < 1e5) &&
			(g_motionbrush_applyframe >= g_motionbrush_startframe) && (g_motionbrush_applyframe <= g_motionbrush_endframe) &&
			(g_motionbrush_frameleng > g_motionbrush_endframe) && (g_motionbrush_frameleng < 1e5) &&
			//(g_brushrepeats >= 1) && (g_brushrepeats <= 10) &&
			(g_brushrepeats >= 1) && (g_brushrepeats <= 100) && //2024/04/24 repeatsmax 100
			tempvalue) {

			int pluginno;
			for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
				if ((s_plugin + pluginno)->menuid == g_motionbrush_method) {
					//DbgOut( "viewer : OnSelectPlugin : pluginno %d, menuid %d\r\n", pluginno, menuid );
					ret = (s_plugin + pluginno)->CreateMotionBrush(g_motionbrush_startframe, g_motionbrush_endframe, g_motionbrush_applyframe, g_motionbrush_frameleng, g_brushrepeats, g_brushmirrorUflag, g_brushmirrorVflag, g_ifmirrorVDiv2flag, tempvalue);
					if ((ret != 0) && (ret != 2)) {
						_ASSERT(0);
						::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
						PostQuitMessage(ret);
					}
				}
			}

			//ZeroMemory(g_motionbrush_value, sizeof(float) * (unsigned int)g_motionbrush_frameleng);//2022/09/12

			int cpframe;
			for (cpframe = 0; cpframe < (int)g_motionbrush_frameleng; cpframe++) {
				//for (cpframe = (int)g_motionbrush_startframe; cpframe <= (int)g_motionbrush_endframe; cpframe++) {//2022/09/12
				float cpvalue;

				//if ((cpframe >= (int)g_motionbrush_startframe) && (cpframe <= (int)g_motionbrush_endframe)) {
				cpvalue = *(tempvalue + cpframe);
				cpvalue = (float)fmin(1.0f, cpvalue);
				cpvalue = (float)fmax(-1.0f, cpvalue);
				//}
				//else {
				//	cpvalue = 0.0f;
				//}

				*(g_motionbrush_value + cpframe) = cpvalue;
			}

		}
		else {
			//後処理のためにreturnせずにretにセットする
			ret = 2;//フレーム,フレーム長範囲外は 2 を返す
		}

		s_onselectplugin = 0;
	}


	if (tempvalue) {
		free(tempvalue);
		tempvalue = 0;
	}


	//2024/01/19
	//BrushParamsプレートメニューでTopPosを移動した直後のIK中に　3dwndのポーズが変わらない不具合解消のため
	//s_editrangeを更新
	s_buttonselectstart = g_motionbrush_startframe;
	s_buttonselectend = g_motionbrush_endframe;
	//CEditRange::SetApplyRate(g_applyrate);
	OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);


	if (onrefreshflag == false) {//Refresh関数以外から呼び出したとき

		if (s_owpTimeline)
			s_owpTimeline->setMaxTime(frameleng);//!!!!!!!!!!!!!!!!!!!!!
		if (s_owpLTimeline)
			s_owpLTimeline->setMaxTime(frameleng);//!!!!!!!!!!!!!!!!!!!!!

		if (s_owpTimeline)
			s_owpTimeline->setCurrentTime(g_motionbrush_applyframe, false);//!!!!!!!!!!!!!!!!!!!!!
		if (s_owpLTimeline)
			s_owpLTimeline->setCurrentTime(g_motionbrush_applyframe, false);//!!!!!!!!!!!!!!!!!!!!!
		if (s_owpEulerGraph)
			s_owpEulerGraph->setCurrentTime(g_motionbrush_applyframe, false);//!!!!!!!!!!!!!!!!!!!!!

		UpdateEditedEuler();
	}


	//UpdateTopPosText();

	SavePlayingStartEnd();


	return ret;
}

int SetBrushName()
{

	ZeroMemory(g_brushname, sizeof(WCHAR) * MAX_PATH);
	wcscpy_s(g_brushname, MAX_PATH, L"Brush None Yet.");

	int pluginno;
	for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
		if ((s_plugin + pluginno)->menuid == g_motionbrush_method) {
			if ((s_plugin + pluginno)->validflag == 1) {
				wcscpy_s(g_brushname, MAX_PATH, (s_plugin + pluginno)->pluginname);
			}
			break;
		}
	}
	return 0;
}

int SetTimelineMark()
{
	if (!s_model || !s_owpTimeline || !s_owpLTimeline) {
		_ASSERT(0);
		return 0;
	}

	if (g_previewFlag != 0) {
		return 0;
	}


	s_owpTimeline->setRewriteOnChangeFlag(false);		//再描画要求を再開


//	s_owpTimeline->deleteKey();

	//map<int,CBone*>::iterator itrbone;
	//for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	//	CBone* curbone = itrbone->second;
	//	if( curbone ){
	//		int curlineno = s_boneno2lineno[ curbone->GetBoneNo() ];
	//		if( curlineno >= 0 ){
	//			double curframe;
	//			for( curframe = 0.0; curframe < s_model->GetCurMotInfo()->frameleng; curframe += 1.0 ){
	//				KeyInfo chkki = s_owpTimeline->ExistKey( curlineno, curframe );
	//				if( chkki.lineIndex >= 0 ){
	//					s_owpTimeline->deleteKey( curlineno, curframe );
	//				}
	//			}
	//		}
	//	}
	//}

	//map<int, CBone*>::iterator itrbone;
	//for( itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++ ){
	//	CBone* curbone = itrbone->second;
	//	if( curbone ){
	//		int curlineno = s_boneno2lineno[ curbone->GetBoneNo() ];
	//		if( curlineno >= 0 ){
	//			map<int, map<double, int>>::iterator itrcur;
	//			itrcur = curbone->FindMotMarkOfMap( s_model->GetCurMotInfo()->motid );
	//			if( itrcur != curbone->GetMotMarkOfMapBegin() ){
	//				map<double, int>::iterator itrmark;
	//				for( itrmark = itrcur->second.begin(); itrmark != itrcur->second.end(); itrmark++ ){
	//					double curframe = itrmark->first;
	//					s_owpTimeline->newKey( curbone->GetWBoneName(), curframe, 0 );
	//				}
	//			}
	//		}
	//	}
	//}

	s_owpTimeline->callRewrite();
	s_owpTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開

	return 0;
}


void CreateMarkReq(int curboneno, int broflag)
{
	if (curboneno < 0) {
		return;
	}
	CBone* curbone = s_model->GetBoneByID(curboneno);
	if (curbone) {
		if (curbone->IsSkeleton()) {
			int curlineno = s_boneno2lineno[curboneno];
			if (curlineno >= 0) {
				int keynum;
				double startframe, endframe;
				s_editrange.GetRange(&keynum, &startframe, &endframe);
				s_model->AddBoneMotMark(s_owpTimeline, curboneno, curlineno, startframe, endframe, 1);
			}
		}

		if (curbone->GetChild(false)) {
			CreateMarkReq(curbone->GetChild(false)->GetBoneNo(), 1);
		}
		if (broflag && curbone->GetBrother(false)) {
			CreateMarkReq(curbone->GetBrother(false)->GetBoneNo(), 1);
		}

	}

}

int SetLTimelineMark(int curboneno)
{
	if (g_previewFlag != 0) {
		return 0;
	}
	if (!s_model || !s_owpTimeline || !s_owpLTimeline) {
		return 0;
	}


	CModel* pmodel = 0;
	CMQOObject* pmqoobj = 0;
	int channelindex = -1;
	bool blendshapemode;
	blendshapemode = InBlendShapeMode(&pmodel, &pmqoobj, &channelindex);
	if (blendshapemode) {
		int error0 = 0;
		string shapename = pmqoobj->GetShapeName(channelindex, &error0);

		WCHAR markname[256] = { 0L };
		if (error0 == 0) {
			WCHAR wshapename[256] = { 0L };
			ZeroMemory(wshapename, sizeof(WCHAR) * 256);
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, shapename.c_str(), -1, wshapename, 256);
			swprintf_s(markname, 256, L"[BS] : %s", wshapename);
		}
		else {
			wcscpy_s(markname, 256, L"[BS] : Unknown BlendShape");
		}
		if (s_owpPlayerButton) {
			s_owpPlayerButton->setJointName(markname);//2023/01/08
		}
	}
	else if (g_edittarget == EDITTARGET_BONE) {
		if (curboneno >= 0) {
			CBone* opebone = s_model->GetBoneByID(curboneno);
			if (opebone) {
				CBone* parentbone = opebone->GetParent(false);
				if (s_ikkind == 0) {
					//ikkind がROT(0)の場合はIK　それ以外のMV, SCALEの場合にはFK
					if (parentbone && parentbone->IsSkeleton()) {
						opebone = parentbone;
					}
				}

				int opeboneno = opebone->GetBoneNo();
				if (opeboneno >= 0) {
					int curlineno = s_boneno2lineno[opeboneno];
					if (curlineno >= 0) {
						//s_owpLTimeline->deleteLine(2);

						WCHAR markname[256] = { 0L };
						////swprintf_s( markname, 256, L"Mark:%s", opebone->GetWBoneName() );
						if (g_limitdegflag == true) {
							swprintf_s(markname, 256, L"[L] : %s", opebone->GetWBoneName());
						}
						else {
							swprintf_s(markname, 256, L"[W] : %s", opebone->GetWBoneName());
						}

						//s_owpLTimeline->newLine(0, 0, markname, RGB(168, 129, 129));

						if (s_owpPlayerButton) {
							s_owpPlayerButton->setJointName(markname);//2023/01/08
						}

						//if (s_owpTimeline && s_owpLTimeline) {
						//	double frame;
						//	for (frame = 0.0; frame < s_model->GetCurMotInfo()->frameleng; frame += 1.0) {
						//		KeyInfo chkki = s_owpTimeline->ExistKey(curlineno, frame);
						//		if (chkki.lineIndex >= 0) {
						//			s_owpLTimeline->newKey(markname, frame, 0);
						//		}
						//	}
						//}
					}
					else {
						WCHAR markname[256] = { 0L };
						swprintf_s(markname, 256, L"Unknown Bone");
						if (s_owpPlayerButton) {
							s_owpPlayerButton->setJointName(markname);//2023/01/08
						}
					}
				}
				else {
					WCHAR markname[256] = { 0L };
					swprintf_s(markname, 256, L"Unknown Bone");
					if (s_owpPlayerButton) {
						s_owpPlayerButton->setJointName(markname);//2023/01/08
					}
				}
			}
			else {
				WCHAR markname[256] = { 0L };
				swprintf_s(markname, 256, L"Unknown Bone");
				if (s_owpPlayerButton) {
					s_owpPlayerButton->setJointName(markname);//2023/01/08
				}
			}
		}
		else {
			WCHAR markname[256] = { 0L };
			swprintf_s(markname, 256, L"Unknown Bone");
			if (s_owpPlayerButton) {
				s_owpPlayerButton->setJointName(markname);//2023/01/08
			}
		}
	}
	else if (g_edittarget == EDITTARGET_CAMERA) {
		if (s_cameramodel) {
			int cameramotid = s_cameramodel->GetCameraMotionId();
			if (cameramotid > 0) {
				CAMERANODE* cnptr = s_cameramodel->GetCAMERANODE(cameramotid);
				if (cnptr && cnptr->pbone && cnptr->pbone->GetParent(false)) {
					WCHAR markname[256] = { 0L };
					if (g_limitdegflag == true) {
						swprintf_s(markname, 256, L"[L] : %s", cnptr->pbone->GetParent(false)->GetWBoneName());
					}
					else {
						swprintf_s(markname, 256, L"[W] : %s", cnptr->pbone->GetParent(false)->GetWBoneName());
					}
					if (s_owpPlayerButton) {
						s_owpPlayerButton->setJointName(markname);//2023/01/08
					}
				}
				else {
					WCHAR markname[256] = { 0L };
					swprintf_s(markname, 256, L"Unknown CameraAnimNode");
					if (s_owpPlayerButton) {
						s_owpPlayerButton->setJointName(markname);//2023/01/08
					}
				}
			}
			else {
				WCHAR markname[256] = { 0L };
				swprintf_s(markname, 256, L"Camera Anim Not Exist");
				if (s_owpPlayerButton) {
					s_owpPlayerButton->setJointName(markname);//2023/01/08
				}
			}
		}
		else {
			WCHAR markname[256] = { 0L };
			swprintf_s(markname, 256, L"Camera Anim Not Exist");
			if (s_owpPlayerButton) {
				s_owpPlayerButton->setJointName(markname);//2023/01/08
			}
		}
	}
	else {
		WCHAR markname[256] = { 0L };
		swprintf_s(markname, 256, L"Unknown");
		if (s_owpPlayerButton) {
			s_owpPlayerButton->setJointName(markname);//2023/01/08
		}
	}

	if (s_owpLTimeline) {
		s_owpLTimeline->callRewrite();
	}
	if (s_owpTimeline) {
		s_owpTimeline->setRewriteOnChangeFlag(true);		//再描画要求を再開
	}
	return 0;
}

int ExportFBXFile()
{
	if (!s_model || !s_owpLTimeline || !s_chascene) {
		_ASSERT(0);
		return 0;
	}

	g_previewFlag = 0;
	s_owpLTimeline->setCurrentTime(0.0, true);

	int loopstartflag = 1;
	s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matView, &s_matProj, 0.0, loopstartflag);
	
	WCHAR filename[MAX_PATH] = { 0L };
	OPENFILENAME ofn1;
	ZeroMemory(&ofn1, sizeof(OPENFILENAME));
	ofn1.lStructSize = sizeof(OPENFILENAME);
	//ofn1.hwndOwner = s_3dwnd;
	ofn1.hwndOwner = s_3dwnd;
	ofn1.hInstance = 0;
	ofn1.lpstrFilter = L"FBX file(*.fbx)\0";
	ofn1.lpstrCustomFilter = NULL;
	ofn1.nMaxCustFilter = 0;
	ofn1.nFilterIndex = 0;
	ofn1.lpstrFile = filename;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.lpstrFileTitle = NULL;
	ofn1.nMaxFileTitle = 0;
	ofn1.lpstrInitialDir = NULL;
	ofn1.lpstrTitle = L"GetFileNameDlg";
	//ofn1.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	ofn1.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn1.nFileOffset = 0;
	ofn1.nFileExtension = 0;
	ofn1.lpstrDefExt = L"fbx";
	ofn1.lCustData = NULL;
	ofn1.lpfnHook = NULL;
	ofn1.lpTemplateName = NULL;


	{
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
		//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
		InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

		if (GetOpenFileNameW(&ofn1) != IDOK) {
			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);
			return 0;
		}

		InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
		//UnhookWinEvent(hhook);
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
	}



	char fbxpath[MAX_PATH] = { 0 };
	WideCharToMultiByte(CP_UTF8, 0, filename, -1, fbxpath, MAX_PATH, NULL, NULL);


	{
		s_owpLTimeline->setCurrentTime(0.0, true);
		s_model->SetMotionFrame(0.0);
		ChaMatrix tmpwm = s_model->GetWorldMat();
		s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);

		//ここでAxisMatXの初期化
		s_model->CreateBtObject(g_limitdegflag, 1);
		s_model->CalcBtAxismat(2);//2
		s_model->SetInitAxisMatX(1);
	}


	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	char fbxdate[MAX_PATH] = { 0L };
	sprintf_s(fbxdate, MAX_PATH, "CommentForEGP_%04u%02u%02u%02u%02u%02u",
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	//CallF( WriteFBXFile( s_model, fbxpath, s_dummytri, mb, g_tmpmqomult, s_fbxbunki ), return 1 );
	int result = WriteFBXFile(g_limitdegflag, s_psdk, s_model, fbxpath, fbxdate);
	if (result != 0) {
		::MessageBox(NULL, L"保存に失敗しました。\n書き込み禁止ディレクトリの可能性があります。\n保存場所を変えて再試行してみてください。", L"エラー", MB_OK);
		_ASSERT(0);
		return 1;
	}

	if (s_model->GetOldAxisFlagAtLoading() == 0) {
		WCHAR lmtname[MAX_PATH] = { 0L };
		swprintf_s(lmtname, MAX_PATH, L"%s.lmt", filename);
		CLmtFile lmtfile;
		lmtfile.WriteLmtFile(lmtname, s_model, fbxdate);

		WCHAR rigname[MAX_PATH] = { 0L };
		swprintf_s(rigname, MAX_PATH, L"%s.rig", filename);
		CRigFile rigfile;
		rigfile.WriteRigFile(rigname, s_model);

	}


	//2024/06/17 各パネル選択状態がずれないように
	if (s_model) {
		bool forceflag = true;
		bool callundo = true;
		OnChangeModel(s_model, forceflag, callundo);
	}


	return 0;
}

int ExportBntFile()
{
	if (!s_model || !s_owpLTimeline || !s_chascene) {
		_ASSERT(0);
		return 0;
	}

	g_previewFlag = 0;
	s_owpLTimeline->setCurrentTime(0.0, true);

	int loopstartflag = 1;
	s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matView, &s_matProj, 0.0, loopstartflag);



	WCHAR filename[MAX_PATH] = { 0L };
	OPENFILENAME ofn1;
	ZeroMemory(&ofn1, sizeof(OPENFILENAME));
	ofn1.lStructSize = sizeof(OPENFILENAME);
	ofn1.hwndOwner = s_3dwnd;
	ofn1.hInstance = 0;
	ofn1.lpstrFilter = L"BNT file(*.bnt)\0";
	ofn1.lpstrCustomFilter = NULL;
	ofn1.nMaxCustFilter = 0;
	ofn1.nFilterIndex = 0;
	ofn1.lpstrFile = filename;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.lpstrFileTitle = NULL;
	ofn1.nMaxFileTitle = 0;
	ofn1.lpstrInitialDir = NULL;
	ofn1.lpstrTitle = L"GetFileNameDlg";
	//ofn1.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	ofn1.Flags = OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_ENABLESIZING | OFN_ALLOWMULTISELECT;
	ofn1.nFileOffset = 0;
	ofn1.nFileExtension = 0;
	ofn1.lpstrDefExt = L"bnt";
	ofn1.lCustData = NULL;
	ofn1.lpfnHook = NULL;
	ofn1.lpTemplateName = NULL;


	{
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
		//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
		//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
		InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

		if (GetOpenFileNameW(&ofn1) != IDOK) {
			InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			//UnhookWinEvent(hhook);
			return 0;
		}

		InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
		//UnhookWinEvent(hhook);
		s_getfilenamehwnd = 0;
		s_getfilenametreeview = 0;
	}

	//char fbxpath[MAX_PATH] = {0};
	//WideCharToMultiByte( CP_UTF8, 0, filename, -1, fbxpath, MAX_PATH, NULL, NULL );	

	if (s_chascene->ModelEmpty()) {
		_ASSERT(0);
		return 0;
	}
	MODELELEM wme = s_chascene->GetModelElem(0);
	CModel* curmodel = wme.modelptr;
	if (!curmodel) {
		return 0;
	}

	CBntFile bntfile;
	CallF(bntfile.WriteBntFile(g_limitdegflag, filename, wme), return 1);

	return 0;
}





int AddEditRangeHistory()
{
	static int s_historycnt = 0;

	if (!s_editrangehistory) {
		return 0;
	}

	if ((s_editrangehistoryno < 0) || (s_editrangehistoryno >= EDITRANGEHISTORYNUM)) {
		_ASSERT(0);
		s_editrangehistoryno = 0;
	}
	if ((s_editrangesetindex < 0) || (s_editrangesetindex >= EDITRANGEHISTORYNUM)) {
		_ASSERT(0);
		s_editrangesetindex = 0;
	}

	if (s_editrange.IsSameStartAndEnd()) {
		//_ASSERT(0);
		return 0;
	}


	int findflag = 0;
	int erhno;
	for (erhno = 0; erhno < EDITRANGEHISTORYNUM; erhno++) {
		if (*(s_editrangehistory + erhno) == s_editrange) {
			findflag++;
			break;
		}
	}

	if (findflag == 0) {
		s_editrangesetindex += 1;
		if (s_editrangesetindex >= EDITRANGEHISTORYNUM) {
			s_editrangesetindex = 0;
		}

		*(s_editrangehistory + s_editrangesetindex) = s_editrange;
		(s_editrangehistory + s_editrangesetindex)->SetSetFlag(1);
		(s_editrangehistory + s_editrangesetindex)->SetSetCnt(s_historycnt);
		s_historycnt++;

		s_editrangehistoryno = s_editrangesetindex;
	}
	return 0;
}

int RollBackEditRange(int prevrangeFlag, int nextrangeFlag)
{
	if ((s_editrangehistoryno < 0) || (s_editrangehistoryno >= EDITRANGEHISTORYNUM)) {
		_ASSERT(0);
		s_editrangehistoryno = 0;
	}

	int findindex = -1;
	int erhcnt;
	int curindex = s_editrangehistoryno;

	if (prevrangeFlag && (s_editrange.IsSameStartAndEnd())) {
		//prevボタンのとき　範囲が解除されている場合は現状復帰のためインデックスはそのまま
		if ((s_editrangehistory + curindex)->GetSetFlag() == 1) {
			findindex = curindex;
		}
	}
	else {
		for (erhcnt = 0; erhcnt < EDITRANGEHISTORYNUM; erhcnt++) {
			if (prevrangeFlag) {
				curindex -= 1;
			}
			else if (nextrangeFlag) {
				curindex += 1;
			}
			else {
				_ASSERT(0);
				break;
			}
			if (curindex < 0) {
				curindex = EDITRANGEHISTORYNUM - 1;
			}
			if (curindex >= EDITRANGEHISTORYNUM) {
				curindex = 0;
			}
			if ((s_editrangehistory + curindex)->GetSetFlag() == 1) {
				findindex = curindex;
				break;
			}
		}
	}

	if (findindex >= 0) {
		s_editrange = *(s_editrangehistory + findindex);
		s_editrangehistoryno = findindex;
	}

	return 0;
}

int CopyLimitedWorldToWorld(CModel* srcmodel, bool allframeflag, bool setcursorflag, int operatingjointno, bool onpasteflag)
{
	HCURSOR oldcursor = NULL;
	if (setcursorflag) {
		//refreshEUlerGraph処理は時間がかかることがあるので砂時計カーソルにする
		oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
	}

	if (srcmodel) {
		ChaMatrix tmpwm = srcmodel->GetWorldMat();
		if (srcmodel->ExistCurrentMotion()) {
			if (onpasteflag == false) {
				if (operatingjointno >= 0) {
					CBone* opebone = srcmodel->GetBoneByID(operatingjointno);
					if (opebone) {
						double roundingstartframe, roundingendframe;
						if (allframeflag == false) {
							int framenum;
							double startframe, endframe;
							s_editrange.GetRange(&framenum, &startframe, &endframe);
							roundingstartframe = RoundingTime(startframe);
							roundingendframe = RoundingTime(endframe);
						}
						else {
							roundingstartframe = 1.0;
							roundingendframe = srcmodel->GetCurrentMaxFrame();
						}

						double curframe;
						for (curframe = roundingstartframe; curframe <= roundingendframe; curframe += 1.0) {
							srcmodel->SetMotionFrame(curframe);
							srcmodel->CopyLimitedWorldToWorldReq(opebone, srcmodel->GetCurrentMotID(), curframe);
						}
					}
				}
			}
			else {
				vector<CPELEM2>::iterator itrcp;
				for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
					CBone* srcbone = itrcp->bone;
					if (srcbone) {
						double roundingstartframe, roundingendframe;
						if (allframeflag == false) {
							int framenum;
							double startframe, endframe;
							s_editrange.GetRange(&framenum, &startframe, &endframe);
							roundingstartframe = RoundingTime(startframe);
							roundingendframe = RoundingTime(endframe);
						}
						else {
							roundingstartframe = 1.0;
							roundingendframe = srcmodel->GetCurrentMaxFrame();
						}

						double curframe;
						for (curframe = roundingstartframe; curframe <= roundingendframe; curframe += 1.0) {
							srcmodel->SetMotionFrame(curframe);
							srcmodel->CopyLimitedWorldToWorldOne(srcbone, srcmodel->GetCurrentMotID(), curframe);
						}
					}
				}
			}
		}


		if (s_owpLTimeline) {
			double curframe = s_owpLTimeline->getCurrentTime();
			srcmodel->SetMotionFrame(curframe);
			srcmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
		}
	}

	if (setcursorflag && (oldcursor != NULL)) {
		//カーソルを元に戻す
		SetCursor(oldcursor);
	}

	return 0;
}


int CopyWorldToLimitedWorld(CModel* srcmodel)
{

	//呼び出し元で SetCursor 砂時計している

	if (srcmodel) {
		ChaMatrix tmpwm = srcmodel->GetWorldMat();
		//MOTINFO* curmi = srcmodel->GetCurMotInfo();
		//if (curmi) {
		//	double curframe;
		//	//for (curframe = 0.0; curframe < curmi->frameleng; curframe += 1.0) {
		//	for (curframe = 1.0; curframe < curmi->frameleng; curframe += 1.0) {
		//		srcmodel->SetMotionFrame(curframe);
		//		srcmodel->CopyWorldToLimitedWorldReq(srcmodel->GetTopBone(false), curmi->motid, curframe);
		//	}
		//}

		srcmodel->CopyWorldToLimitedWorld();//2023/10/20 MultiThreading


		if (s_owpLTimeline) {
			double curframe = s_owpLTimeline->getCurrentTime();
			srcmodel->SetMotionFrame(curframe);
			srcmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
		}
	}
	return 0;
}


int ApplyNewLimitsToWM(CModel* srcmodel)
{

	//呼び出し元で SetCursor 砂時計している

	if (srcmodel) {

		if (srcmodel->GetNoBoneFlag() == true) {
			return 0;
		}

		ChaMatrix tmpwm = srcmodel->GetWorldMat();
		if (srcmodel->ExistCurrentMotion()) {
			ChaMatrix befeditparentmat;
			befeditparentmat.SetIdentity();
			double curframe2;
			//for (curframe = 0.0; curframe < curmi->frameleng; curframe += 1.0) {
			for (curframe2 = 1.0; curframe2 < srcmodel->GetCurrentMaxFrame(); curframe2 += 1.0) {
				srcmodel->SetMotionFrame(curframe2);
				srcmodel->ApplyNewLimitsToWMReq(srcmodel->GetTopBone(false), srcmodel->GetCurrentMotID(), curframe2, befeditparentmat);
				//srcmodel->UpdateMatrix(&tmpwm, &s_matVP);
			}
		}

		if (s_owpLTimeline) {
			double curframe = s_owpLTimeline->getCurrentTime();
			srcmodel->SetMotionFrame(curframe);
			srcmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
		}
	}

	return 0;
}

int ApplyNewLimitsToWMSelected()
{
	if (s_model) {
		ChaMatrix tmpwm = s_model->GetWorldMat();
		if (s_model->ExistCurrentMotion()) {

			int selectednum;
			double startframe, endframe;
			s_editrange.GetRange(&selectednum, &startframe, &endframe);

			int  istartframe, iendframe;
			istartframe = IntTime(startframe);
			iendframe = IntTime(endframe);
			int curframe;
			for (curframe = istartframe; curframe <= iendframe; curframe++) {
				s_model->SetMotionFrame((double)curframe);
				s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
			}
		}

		if (s_owpLTimeline) {
			double curframe = s_owpLTimeline->getCurrentTime();
			s_model->SetMotionFrame(curframe);
			s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
		}
	}

	return 0;
}

int UpdateAfterEditAngleLimit(int limit2boneflag, bool setcursorflag)//default : setcursorflag = true
{
	HCURSOR oldcursor = NULL;
	if (setcursorflag) {
		//refreshEUlerGraph処理は時間がかかることがあるので砂時計カーソルにする
		oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
	}

	switch (limit2boneflag) {
	case eLIM2BONE_LIM2BONE_ONE:
	case eLIM2BONE_LIM2BONE_DEEPER:
	case eLIM2BONE_LIM2BONE_ALL:
		//s_anglelimit --> limits of bone
		s_limiteuldlg.AngleLimit2Bone(limit2boneflag);
		break;
	case eLIM2BONE_BONE2LIM:
		//limits of bone --> s_anglelimit
		s_limiteuldlg.Bone2AngleLimit(s_curboneno);
		break;
	case eLIM2BONE_NONE:
		break;
	}

	if (s_model) {
		ClearLimitedWM(s_model);
		CopyWorldToLimitedWorld(s_model);
		ApplyNewLimitsToWM(s_model);
	}


	//if (s_model && s_model->GetCurMotInfo()) {
	//	int curmotid = s_model->GetCurMotInfo()->motid;
	//	s_model->CalcBoneEul(curmotid);
	//}

	//読み込みなおし：lowerとupperは大小関係で入れ替わることがあるため適用後読み込みなおす。
	s_limiteuldlg.Bone2AngleLimit(s_curboneno);
	//AngleLimit2Dlg(s_anglelimitdlg);
	ChangeCurrentBone(true);

	//UpdateEditedEuler();//selectした範囲のみ
	refreshEulerGraph();//モーション全体

	//s_underanglelimithscroll = 0;

	if (setcursorflag && (oldcursor != NULL)) {
		//カーソルを元に戻す
		SetCursor(oldcursor);
	}

	return 0;
}

int GetModelWorldMat(ChaVector3* dstpos, ChaVector3* dstrot)
{
	if (!dstpos || !dstrot) {
		_ASSERT(0);
		return 1;
	}
	if (!s_modelworldmatdlgwnd) {
		_ASSERT(0);
		return 1;
	}
	if (!s_model) {
		return 1;
	}

	HWND hDlgWnd = s_modelworldmatdlgwnd;

	ChaVector3 tmppos = s_model->GetModelPosition();
	ChaVector3 tmprot = s_model->GetModelRotation();
	WCHAR strval[256] = { 0L };
	float value = 0.0f;

	if (s_model) {
		tmppos = s_model->GetModelPosition();
		tmprot = s_model->GetModelRotation();
		const float maxvalue = 100000.0f;
		const float minvalue = -maxvalue;
		const float maxvalue2 = 10000.0f;
		const float minvalue2 = -maxvalue;

		GetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONX, strval, 256);
		value = (float)_wtof(strval);
		if ((value >= minvalue) && (value <= maxvalue)) {
			tmppos.x = value;
		}
		GetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONY, strval, 256);
		value = (float)_wtof(strval);
		if ((value >= minvalue) && (value <= maxvalue)) {
			tmppos.y = value;
		}
		GetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONZ, strval, 256);
		value = (float)_wtof(strval);
		if ((value >= minvalue) && (value <= maxvalue)) {
			tmppos.z = value;
		}

		GetDlgItemTextW(hDlgWnd, IDC_EDIT_ROTATIONX, strval, 256);
		value = (float)_wtof(strval);
		if ((value >= minvalue) && (value <= maxvalue)) {
			tmprot.x = value;
		}
		GetDlgItemTextW(hDlgWnd, IDC_EDIT_ROTATIONY, strval, 256);
		value = (float)_wtof(strval);
		if ((value >= minvalue) && (value <= maxvalue)) {
			tmprot.y = value;
		}
		GetDlgItemTextW(hDlgWnd, IDC_EDIT_ROTATIONZ, strval, 256);
		value = (float)_wtof(strval);
		if ((value >= minvalue) && (value <= maxvalue)) {
			tmprot.z = value;
		}


		*dstpos = tmppos;
		*dstrot = tmprot;
	}

	return 0;
}


LRESULT CALLBACK ModelWorldMatDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR strval[256] = { 0L };
	float value = 0.0f;
	ChaVector3 tmppos;
	tmppos.SetParams(0.0f, 0.0f, 0.0f);
	ChaVector3 tmprot;
	tmprot.SetParams(0.0f, 0.0f, 0.0f);

	switch (msg) {
	case WM_INITDIALOG:
	{
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model) {
			SetModel2ModelWorldMatDlg(s_model);
		}

		//RECT dlgrect;
		//GetWindowRect(hDlgWnd, &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		s_modelworldmatdlgwnd = hDlgWnd;

		return FALSE;
	}
	break;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			ShowWindow(hDlgWnd, SW_HIDE);
			s_dispmodelworldmat = false;
			break;
		case IDCANCEL:
			ShowWindow(hDlgWnd, SW_HIDE);
			s_dispmodelworldmat = false;
			break;

		case IDC_CHECK_PICKANDSET:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_PICKANDSET);
			if (ischecked == BST_CHECKED) {
				s_pickmodelworldmat = true;
			}
			else {
				s_pickmodelworldmat = false;
			}
		}
		break;

		case IDC_CHECK_REMOVEPOS:
		{
			UINT ischecked = 0;
			ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_REMOVEPOS);
			if (ischecked == BST_CHECKED) {
				s_removegrassflag = true;
			}
			else {
				s_removegrassflag = false;
			}
		}
		break;

		//case IDC_CHECK_PUTGRASS:
		//{
		//	UINT ischecked = 0;
		//	ischecked = IsDlgButtonChecked(hDlgWnd, IDC_CHECK_PUTGRASS);
		//	if (ischecked == BST_CHECKED) {
		//		s_putgrassflag = true;
		//	}
		//	else {
		//		s_putgrassflag = false;
		//	}
		//}
		//break;

		case IDC_TOCAMERAPOS:
		{
			swprintf_s(strval, 256, L"%.3f", g_camEye.x);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONX, strval);
			swprintf_s(strval, 256, L"%.3f", g_camEye.y);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONY, strval);
			swprintf_s(strval, 256, L"%.3f", g_camEye.z);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONZ, strval);

			SetModelWorldMat();
		}
			break;
		case IDC_TOCAMERATARGET:
		{
			swprintf_s(strval, 256, L"%.3f", g_camtargetpos.x);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONX, strval);
			swprintf_s(strval, 256, L"%.3f", g_camtargetpos.y);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONY, strval);
			swprintf_s(strval, 256, L"%.3f", g_camtargetpos.z);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_POSITIONZ, strval);

			SetModelWorldMat();
		}
			break;

		case IDC_APPLYMODELWORLDMAT:
		{
			SetModelWorldMat();
		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_CLOSE:
		ShowWindow(hDlgWnd, SW_HIDE);
		s_dispmodelworldmat = false;
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}

LRESULT CALLBACK JumpGravityDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR strval[256] = { 0L };

	switch (msg) {
	case WM_INITDIALOG:
	{
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		swprintf_s(strval, 256, L"Gravity for Jump Interpolation : %.2f", (double)g_jumpgravity * 0.01);
		SetDlgItemTextW(hDlgWnd, IDC_STATIC_JUMPGRAVITY, strval);

		int sliderpos = g_jumpgravity;
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_JUMPGRAVITY), TBM_SETRANGEMIN, (WPARAM)TRUE, (LPARAM)10);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_JUMPGRAVITY), TBM_SETRANGEMAX, (WPARAM)TRUE, (LPARAM)300);
		SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_JUMPGRAVITY), TBM_SETPOS, (WPARAM)TRUE, (LPARAM)sliderpos);

		s_jumpgravitydlgwnd = hDlgWnd;

		return FALSE;
	}
	break;

	case WM_HSCROLL:
		if (GetDlgItem(hDlgWnd, IDC_SLIDER_JUMPGRAVITY) == (HWND)lp) {
			int cursliderpos = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_SLIDER_JUMPGRAVITY), TBM_GETPOS, 0, 0);
			g_jumpgravity = cursliderpos;

			swprintf_s(strval, 256, L"Gravity for Jump Interpolation : %.2f", (double)g_jumpgravity * 0.01);
			SetDlgItemTextW(hDlgWnd, IDC_STATIC_JUMPGRAVITY, strval);
		}
	break;

	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			ShowWindow(hDlgWnd, SW_HIDE);
			break;
		case IDCANCEL:
			ShowWindow(hDlgWnd, SW_HIDE);
			break;

		case IDC_RECALCJUMPINTERPOLATION://再計算ボタン
			s_jumpinterpolateFlag = true;
			break;

		default:
			return FALSE;
		}
		break;
	case WM_CLOSE:
		ShowWindow(hDlgWnd, SW_HIDE);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}

LRESULT CALLBACK MaterialRateDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	WCHAR strval[256] = { 0L };
	float value = 1.0f;
	ChaVector4 tmpmaterialrate;
	tmpmaterialrate.SetParams(1.0f, 1.0f, 1.0f, 1.0f);

	switch (msg) {
	case WM_INITDIALOG:
	{
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		if (s_model) {
			ChaVector4 materialdisprate = s_model->GetMaterialDispRate();

			swprintf_s(strval, 256, L"%.3f", materialdisprate.x);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_DIFFUSERATE, strval);
			swprintf_s(strval, 256, L"%.3f", materialdisprate.y);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_SPECULARRATE, strval);
			swprintf_s(strval, 256, L"%.3f", materialdisprate.z);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_EMISSIVERATE, strval);
			swprintf_s(strval, 256, L"%.3f", materialdisprate.w);
			SetDlgItemTextW(hDlgWnd, IDC_EDIT_AMBIENTRATE, strval);
		}

		//RECT dlgrect;
		//GetWindowRect(hDlgWnd, &dlgrect);
		//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		s_materialratedlgwnd = hDlgWnd;

		return FALSE;
	}
	break;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			ShowWindow(hDlgWnd, SW_HIDE);
			break;
		case IDCANCEL:
			ShowWindow(hDlgWnd, SW_HIDE);
			break;
		case IDC_APPLYMATERIALRATE:
		{
			if (s_model) {
				tmpmaterialrate = s_model->GetMaterialDispRate();

				const float maxvalue = 10000.0f;

				GetDlgItemTextW(hDlgWnd, IDC_EDIT_DIFFUSERATE, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= 0.0f) && (value <= maxvalue)) {
					tmpmaterialrate.x = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_SPECULARRATE, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= 0.0f) && (value <= maxvalue)) {
					tmpmaterialrate.y = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_EMISSIVERATE, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= 0.0f) && (value <= maxvalue)) {
					tmpmaterialrate.z = value;
				}
				GetDlgItemTextW(hDlgWnd, IDC_EDIT_AMBIENTRATE, strval, 256);
				value = (float)_wtof(strval);
				if ((value >= 0.0f) && (value <= maxvalue)) {
					tmpmaterialrate.w = value;
				}

				s_model->SetMaterialDispRate(tmpmaterialrate);

			}

		}
		break;
		default:
			return FALSE;
		}
		break;
	case WM_CLOSE:
		ShowWindow(hDlgWnd, SW_HIDE);
		break;
	default:
		DefWindowProc(hDlgWnd, msg, wp, lp);
		return FALSE;
	}
	return TRUE;

}

int DispRotAxisDlg()
{
	if (s_rotaxisdlg) {
		//already opened
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	if (s_model->GetOldAxisFlagAtLoading() == 1) {
		::DSMessageBox(s_3dwnd, L"Work Only After Setting Of Axis.\nRetry After Saving FBX file.", L"error", MB_OK);
		return 0;
	}


	//s_rotaxisdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ROTAXISDLG), s_3dwnd, (DLGPROC)RotAxisDlgProc);
	s_rotaxisdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ROTAXISDLG), g_mainhwnd, (DLGPROC)RotAxisDlgProc);
	if (!s_rotaxisdlg) {
		_ASSERT(0);
		return 1;
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetParent(s_rotaxisdlg, g_mainhwnd);
	SetWindowPos(
		s_rotaxisdlg,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);


	ShowWindow(s_rotaxisdlg, SW_SHOW);
	UpdateWindow(s_rotaxisdlg);

	return 0;
}

int InitRotAxis()
{
	if (!s_rotaxisdlg) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (curbone) {
		RecalcBoneAxisX(curbone);
	}

	return 0;
}

int RotAxis(HWND hDlgWnd)
{
	if (!s_rotaxisdlg) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	CBone* curbone = s_model->GetBoneByID(s_curboneno);
	if (!curbone) {
		return 0;
	}

	UINT checkflagX;
	checkflagX = IsDlgButtonChecked(hDlgWnd, IDC_RADIO1);
	if (checkflagX == BST_CHECKED) {
		s_rotaxiskind = AXIS_X;
	}
	else {
		UINT checkflagY;
		checkflagY = IsDlgButtonChecked(hDlgWnd, IDC_RADIO2);
		if (checkflagY == BST_CHECKED) {
			s_rotaxiskind = AXIS_Y;
		}
		else {
			UINT checkflagZ;
			checkflagZ = IsDlgButtonChecked(hDlgWnd, IDC_RADIO3);
			if (checkflagZ == BST_CHECKED) {
				s_rotaxiskind = AXIS_Z;
			}
		}
	}

	WCHAR strdeg[256] = { 0L };
	GetWindowText(GetDlgItem(hDlgWnd, IDC_EDITDEG), strdeg, 256);
	strdeg[256 - 1] = 0L;
	size_t len = wcslen(strdeg);
	//_ASSERT(0);
	if ((len > 0) && (len < 256)) {
		s_rotaxisdeg = (float)_wtof(strdeg);
		//_ASSERT(0);
		if ((s_rotaxisdeg >= -360.0f) && (s_rotaxisdeg <= 360.0f)) {
			float rotrad = s_rotaxisdeg * (float)DEG2PAI;
			ChaVector3 axis0;
			CQuaternion rotq;
			if (s_rotaxiskind == AXIS_X) {
				axis0.SetParams(1.0f, 0.0f, 0.0f);
				rotq.SetAxisAndRot(axis0, rotrad);
			}
			else if (s_rotaxiskind == AXIS_Y) {
				axis0.SetParams(0.0f, 1.0f, 0.0f);
				rotq.SetAxisAndRot(axis0, rotrad);
			}
			else if (s_rotaxiskind == AXIS_Z) {
				axis0.SetParams(0.0f, 0.0f, 1.0f);
				rotq.SetAxisAndRot(axis0, rotrad);
			}
			else {
				_ASSERT(0);
				return 1;
			}

			ChaMatrix nodemat = curbone->GetNodeMat();
			CQuaternion noderot;
			noderot.RotationMatrix(nodemat);
			CQuaternion invnoderot;
			noderot.inv(&invnoderot);

			ChaMatrix newnodemat;
			newnodemat = nodemat * invnoderot.MakeRotMatX() * rotq.MakeRotMatX() * noderot.MakeRotMatX();

			ChaVector3 bonepos = curbone->GetJointFPos();
			newnodemat.SetTranslation(bonepos);

			curbone->SetNodeMat(newnodemat);

			if (s_model->ExistCurrentMotion()) {
				s_model->CalcBoneEul(g_limitdegflag, s_model->GetCurrentMotID());
			}
			//WCHAR strmes[256];
			//swprintf_s(strmes, 256, L"rotaxis %d, rotdeg %.3f", s_rotaxiskind, s_rotaxisdeg);
			//::DSMessageBox(hDlgWnd, strmes, L"Check!!!", MB_OK);
		}
	}

	return 0;
}

LRESULT CALLBACK RotAxisDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg) {
	case WM_INITDIALOG:
	{
		SetDlgPosDesktopCenter(hDlgWnd, HWND_TOPMOST);

		CheckRadioButton(hDlgWnd, IDC_RADIO1, IDC_RADIO3, IDC_RADIO1);
		s_rotaxiskind = AXIS_X;
		WCHAR strdeg[256];
		swprintf_s(strdeg, 256, L"0");
		SetWindowText(GetDlgItem(hDlgWnd, IDC_EDITDEG), strdeg);

		CBone* curbone = s_model->GetBoneByID(s_curboneno);
		if (curbone) {
			SetWindowText(GetDlgItem(hDlgWnd, IDC_BONENAME), curbone->GetWBoneName());
		}

		RECT dlgrect;
		::GetWindowRect(hDlgWnd, &dlgrect);
		SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);

		s_rotzisdlghwnd = hDlgWnd;

		return FALSE;
	}
	break;
	case WM_COMMAND:
		switch (LOWORD(wp)) {
		case IDOK:
			s_rotzisdlghwnd = 0;

			//EndDialog(hDlgWnd, IDOK);
			if (s_rotaxisdlg) {
				DestroyWindow(s_rotaxisdlg);
				s_rotaxisdlg = 0;
			}
			break;
		case IDCANCEL:
			s_rotzisdlghwnd = 0;

			//EndDialog(hDlgWnd, IDCANCEL);
			if (s_rotaxisdlg) {
				DestroyWindow(s_rotaxisdlg);
				s_rotaxisdlg = 0;
			}
			break;
		case IDC_INITROT:
			InitRotAxis();
			break;
		case IDC_ROTATE:
			RotAxis(hDlgWnd);
			break;
		default:
			return FALSE;
		}
		break;
	case WM_CLOSE:
		s_rotzisdlghwnd = 0;

		if (s_rotaxisdlg) {
			DestroyWindow(s_rotaxisdlg);
			s_rotaxisdlg = 0;
		}
		break;
	default:
		return FALSE;
	}
	return TRUE;

}


int ChangeCurrentBone(int prepairundoflag)
{
	static CModel* s_befmodel = 0;
	static CBone* s_befbone = 0;

	if (!s_model) {
		return 0;
	}
	if (s_model->GetLoadedFlag() == false) {//2021/08/23
		return 0;
	}
	if (s_nowloading == true) {
		return 0;
	}


	//if (g_retargetbatchflag == 0) {
	if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {

		if (s_model) {
			//CDXUTComboBox* pComboBox;
			//pComboBox = g_SampleUI.GetComboBox(IDC_COMBO_BONE);
			//CBone* pBone;
			//pBone = s_model->GetBoneByID(s_curboneno);
			//if (pBone) {
			//	pComboBox->SetSelectedByData(ULongToPtr(s_curboneno));
			//}

			CBone* curbone = s_model->GetBoneByID(s_curboneno);
			//if (curbone) {
			//	CDXUTComboBox* pComboBox3 = g_SampleUI.GetComboBox(IDC_COMBO_BONEAXIS);
			//	if (pComboBox3) {
			//		//ANGLELIMIT anglelimit = curbone->GetAngleLimit();
			//		//pComboBox3->SetSelectedByData(ULongToPtr(anglelimit.boneaxiskind));
			//		//g_boneaxis = anglelimit.boneaxiskind;
			//		g_boneaxis = (int)PtrToUlong(pComboBox3->GetSelectedData());
			//	}
			//}


			s_rigidparamsdlg.SetModel(s_model, s_curboneno, s_reindexmap, s_rgdindexmap);
			s_limiteuldlg.SetModel(s_model, s_curboneno);
			s_impulsedlg.SetModel(s_model, s_curboneno, s_rgdindexmap);
			s_dampanimdlg.SetModel(s_model, s_curboneno, s_rgdindexmap);

			//if (s_befbone != curbone) {
			//	refreshEulerGraph();
			//}


			//選択ボーンに変更が有った場合
			if ((s_befbone != curbone) || (s_befmodel != s_model)) {
				//if (s_owpTimeline) {
					//refreshTimeline(*s_owpTimeline);

				refreshEulerGraph();
				//s_tum.UpdateEditedEuler(refreshEulerGraph);//非ブロッキング


				//}

				if (prepairundoflag) {
					PrepairUndo();
				}
			}

			s_model->SetSelectedBoneNo(s_curboneno);
			s_saveboneno = s_curboneno;//2024/04/24 //curbone->GetBoneNo();
			s_befbone = curbone;
			s_befmodel = s_model;
		}
		else {
			s_saveboneno = -1;//2024/04/24
			s_befbone = 0;
			s_befmodel = s_model;
		}
	}

	return 0;
}

int ChangeWallScrapingIKFlag(bool srcflag)
{
	g_wallscrapingikflag = srcflag;
	s_spscraping.state = srcflag;
	s_WallScrapingCheckBoxFlag = true;//!!!!! 副作用として　SaveUndoMotionが働く

	return 0;
}

int ChangeLimitDegFlag(bool srcflag, bool setcheckflag, bool updateeulflag)
{
	//処理中にチェックボックスの状態を変えることが出来ないように　砂時計カーソルにする
	HCURSOR oldcursor = NULL;
	oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));


	g_limitdegflag = srcflag;
	//if (setcheckflag && s_LimitDegCheckBox) {
	//	s_LimitDegCheckBox->SetChecked(g_limitdegflag);//!!!!! 副作用として　SaveUndoMotionが働く
	//}

	s_splimiteul.state = srcflag;
	if (setcheckflag) {
		s_LimitDegCheckBoxFlag = true;//!!!!! 副作用として　SaveUndoMotionが働く
	}

	if (updateeulflag) {

		if (s_model && (g_limitdegflag == true)) {
			ClearLimitedWM(s_model);
			CopyWorldToLimitedWorld(s_model);
			ApplyNewLimitsToWM(s_model);
		}

		//if (g_limitdegflag == true) {
		//	vector<MODELELEM>::iterator itrmodel;
		//	for (itrmodel = s_modelindex.begin(); itrmodel != s_modelindex.end(); itrmodel++) {
		//		CModel* pmodel = itrmodel->modelptr;
		//		if (pmodel) {
		//			ClearLimitedWM(pmodel);
		//			ApplyNewLimitsToWM(pmodel);
		//		}
		//	}
		//}


		//2023/11/06 IK直後のグラフと　LimitEulオンオフ後のグラフが同一になるように
		if (s_model->ExistCurrentMotion()) {
			s_model->CalcBoneEul(g_limitdegflag, s_model->GetCurrentMotID());
		}


		//refreshEulerGraph();
		UpdateEditedEuler();
	}

	//if (s_model && s_model->GetCurMotInfo()) {
	//	int curmotid = s_model->GetCurMotInfo()->motid;
	//	s_model->CalcBoneEul(curmotid);
	//	refreshEulerGraph();
	//}
	//else {
	//	_ASSERT(0);
	//	return 1;
	//}

	if (oldcursor != NULL) {
		//カーソルを元に戻す
		SetCursor(oldcursor);
	}

	return 0;
}

int ChangeCameraMode(int forcemode)
{
	s_savecameraanimmode = g_cameraanimmode;

	if (g_edittarget == EDITTARGET_CAMERA) {
		//カメラグラフモードオンの場合には　カメラエディットオン＋カメラ再生オン
		//よってカメラ再生オン
		g_cameraanimmode = 1;
		s_spcameramode.state = true;
	}
	else {
		if (forcemode == 0) {

			//強制オフでは無い場合

			if (s_spcameramode.state == false) {
				//現在のスイッチがオフの場合
				if (s_cameramodel) {
					//カメラモデルが存在する場合　オンにする
					g_cameraanimmode = 1;
					s_spcameramode.state = true;
				}
				else {
					//カメラモデルが存在しない場合
					//何もしない　オンにしない
				}
			}
			else {
				//現在のスイッチがオンかつオプションもオンの場合　オフにする
				g_cameraanimmode = 0;
				s_spcameramode.state = false;
			}
		}
		else if (forcemode == 1) {
			//強制　オフ
			g_cameraanimmode = 0;
			s_spcameramode.state = false;
		}
		else if (forcemode == 2) {
			//強制　オン
			g_cameraanimmode = 1;
			s_spcameramode.state = true;
		}
		else {
			_ASSERT(0);
		}

		PrepairUndo();//2024/06/06
	}
	
	return 0;
}

int ChangeCameraInherit()
{
	s_saveCameraInheritMode = g_cameraInheritMode;

	switch (s_spcamerainherit.mode) {
	case CAMERA_INHERIT_ALL:
		if (s_cameramodel) {
			//カメラモデルが存在する場合　次モード
			g_cameraInheritMode = CAMERA_INHERIT_CANCEL_NULL1;
			s_spcamerainherit.mode = 1;
		}
		else {
			//カメラモデルが存在しない場合
			//何もしない
		}
		break;
	case CAMERA_INHERIT_CANCEL_NULL1:
		if (s_cameramodel) {
			//カメラモデルが存在する場合　次モード
			g_cameraInheritMode = CAMERA_INHERIT_CANCEL_NULL2;
			s_spcamerainherit.mode = 2;
		}
		else {
			//カメラモデルが存在しない場合
			//何もしない
		}
		break;
	case CAMERA_INHERIT_CANCEL_NULL2:
		if (s_cameramodel) {
			//最初のモードへ
			g_cameraInheritMode = CAMERA_INHERIT_ALL;
			s_spcamerainherit.mode = 0;
		}
		else {
			//カメラモデルが存在しない場合
			//何もしない
		}
		break;
	default:
		break;
	}

	return 0;
}


bool FocusEditWnd()
{
	HWND focuswnd = GetFocus();
	if (focuswnd == NULL) {
		return false;
	}
	else {
		WCHAR strclassname[MAX_PATH] = { 0 };
		int result = GetClassName(focuswnd, strclassname, MAX_PATH);
		if (result != 0) {
			if ((wcscmp(strclassname, L"EDIT") == 0) || (wcscmp(strclassname, L"Edit") == 0)) {
				return true;//!!!!!!!!!!!!!!!
			}
			else {
				return false;
			}
		}
		else {
			return false;
		}
	}
}


int ChangeToolSpriteMode()
{
	s_toolspritemode++;
	if (s_toolspritemode >= 3) {
		s_toolspritemode = 0;
	}

	return 0;
}

int OnFrameKeyboard()
{
	MoveMemory(g_savekeybuf, g_keybuf, sizeof(BYTE) * 256);

	if (GetKeyboardState((PBYTE)g_keybuf) == FALSE) {
		//失敗した場合にはゴミが入らないように初期化
		//MoveMemory(g_savekeybuf, g_keybuf, sizeof(BYTE) * 256);
		ZeroMemory(g_keybuf, sizeof(BYTE) * 256);
	}

	//################################################################################
	//2023/08/24 Editコントロールに入力中は　キーボードショートカット機能は実行しない
	//################################################################################
	if (!FocusEditWnd()) {
		//プレートメニュー：スペースキーを押すたびにkind変更. Cキーを押し続けながらスペースキーを押すたびにplate変更.
		//2023/08/22 以下のメニュー変更にスペースキーを使うので　DXUTの　スペースキーのホットキー機能をコメントアウト
		if ((g_keybuf[VK_SPACE] & 0x80) && ((g_savekeybuf[VK_SPACE] & 0x80) == 0)) {
			if (g_keybuf['C'] & 0x80) {
				if (s_plateFlag == false) {
					s_plateFlag = true;
				}
			}
			else if (g_keybuf['V'] & 0x80) {
				ChangeToolSpriteMode();
			}
			else {
				if (s_frogFlag == false) {
					s_frogFlag = true;
				}
			}
		}


		//マニピュレータ：SHIFTを押している間は非表示
		if (g_keybuf[VK_SHIFT] & 0x80) {
			s_dispselect = false;
		}
		else {
			s_dispselect = true;
		}


		//Hを押しながら　左右矢印で　左右ハンド(手)を選択
		if (g_keybuf['H'] & 0x80) {//HandのH
			if ((g_keybuf[VK_LEFT] & 0x80) && ((g_savekeybuf[VK_LEFT] & 0x80) == 0)) {
				if (s_selecthand == 0) {
					s_selecthand = 2;//select RightHandJoint //モデル正面向かって左=右
				}
			}
			else if ((g_keybuf[VK_RIGHT] & 0x80) && ((g_savekeybuf[VK_RIGHT] & 0x80) == 0)) {
				if (s_selecthand == 0) {
					s_selecthand = 1;//select LeftHandJoint //モデル正面向かって右=左
				}
			}
		}


		//Fを押しながら　左右矢印で　左右フット(足)を選択
		if (g_keybuf['F'] & 0x80) {//FootのF
			if ((g_keybuf[VK_LEFT] & 0x80) && ((g_savekeybuf[VK_LEFT] & 0x80) == 0)) {
				if (s_selectfoot == 0) {
					s_selectfoot = 2;//select RightFootJoint //モデル正面向かって左=右
				}
			}
			else if ((g_keybuf[VK_RIGHT] & 0x80) && ((g_savekeybuf[VK_RIGHT] & 0x80) == 0)) {
				if (s_selectfoot == 0) {
					s_selectfoot = 1;//select LeftFootJoint //モデル正面向かって右=左
				}
			}
		}



		//if ((g_keybuf[VK_F9] & 0x80) && ((g_savekeybuf[VK_F9] & 0x80) == 0)) {
		//	StartBt(s_model, TRUE, 0, 1);
		//}
		//if ((g_keybuf[VK_F10] & 0x80) && ((g_savekeybuf[VK_F10] & 0x80) == 0)) {
		//	StartBt(s_model, TRUE, 1, 1);
		//}
		//if ((g_keybuf[' '] & 0x80) && ((g_savekeybuf[' '] & 0x80) == 0)) {
		//	if (s_bpWorld && s_model) {
		//		StartBt(s_model, TRUE, 2, 1);
		//	}
		//}
		if (g_keybuf[VK_CONTROL] & 0x80) {
			g_controlkey = true;
		}
		else {
			g_controlkey = false;
		}
		if (g_keybuf[VK_SHIFT] & 0x80) {
			g_shiftkey = true;
		}
		else {
			g_shiftkey = false;
		}

		if (g_keybuf['S'] & 0x80) {
			s_skey = true;
		}
		else {
			s_skey = false;
		}


		if ((g_keybuf[VK_NUMPAD1] & 0x80) || (g_keybuf['1'] & 0x80)) {
			g_pickorder = 1;
		}
		else if ((g_keybuf[VK_NUMPAD2] & 0x80) || (g_keybuf['2'] & 0x80)) {
			g_pickorder = 2;
		}
		else if ((g_keybuf[VK_NUMPAD3] & 0x80) || (g_keybuf['3'] & 0x80)) {
			g_pickorder = 3;
		}
		else if ((g_keybuf[VK_NUMPAD4] & 0x80) || (g_keybuf['4'] & 0x80)) {
			g_pickorder = 4;
		}
		else if ((g_keybuf[VK_NUMPAD5] & 0x80) || (g_keybuf['5'] & 0x80)) {
			g_pickorder = 5;
		}
		else if ((g_keybuf[VK_NUMPAD6] & 0x80) || (g_keybuf['6'] & 0x80)) {
			g_pickorder = 6;
		}
		else if ((g_keybuf[VK_NUMPAD7] & 0x80) || (g_keybuf['7'] & 0x80)) {
			g_pickorder = 7;
		}
		else if ((g_keybuf[VK_NUMPAD8] & 0x80) || (g_keybuf['8'] & 0x80)) {
			g_pickorder = 8;
		}
		else if ((g_keybuf[VK_NUMPAD9] & 0x80) || (g_keybuf['9'] & 0x80)) {
			g_pickorder = 9;
		}
		else if ((g_keybuf[VK_NUMPAD0] & 0x80) || (g_keybuf['0'] & 0x80)) {
			g_pickorder = 10;
		}
		else {
			g_pickorder = 1;
		}


		//end of BoneTwist on MouseWheel 
		if ((s_tkeyflag != 0) && (s_editmotionflag >= 0) && ((g_keybuf['T'] & 0x80) == 0)) {
			s_tkeyflag = 0;
			PrepairUndo();//ツイスト保存
		}

		/*
		if (g_controlkey == false){
			if (g_keybuf[VK_ADD] & 0x80){
				g_btcalccnt += 1.0;
				Sleep(200);
			}
			else if (g_keybuf[VK_SUBTRACT] & 0x80){
				if (g_btcalccnt >= 2.0){
					g_btcalccnt -= 1.0;
					Sleep(200);
				}
			}
		}
		else{
			if (g_keybuf[VK_ADD] & 0x80){
				if (g_erp <= 0.9){
					g_erp += 0.1;
					Sleep(200);
				}
			}
			else if (g_keybuf[VK_SUBTRACT] & 0x80){
				if (g_erp >= 0.1){
					g_erp -= 0.1;
					Sleep(200);
				}
			}
		}
		*/



		//####################################################################################################################
		//Undo,RedoのRedoのコマンドキーがCtrl + Shift + Zなので,　MButton用のキーとしてCtrl + Shiftは使えない。コメントアウト　2022/01/11
		//####################################################################################################################
		//if (g_ctrlshiftkeyformb == false) {
		//	if ((g_keybuf[VK_CONTROL] & 0x80) && (g_keybuf[VK_SHIFT] & 0x80)) {
		//		if (((g_savekeybuf[VK_CONTROL] & 0x80) == 0) || ((g_savekeybuf[VK_SHIFT] & 0x80) == 0)) {
		//			g_ctrlshiftkeyformb = true;
		//			//reset g_ctrlshiftkeyformb at the place of calling OnTimelineMButtonDown
		//		}
		//	}
		//}


		//##################
		//OnTimeLineWheel()
		//##################
		if (g_keybuf['A'] & 0x80) {
			s_akeycnt++;
		}
		else {
			s_akeycnt = 0;
		}
		if (g_keybuf['D'] & 0x80) {
			s_dkeycnt++;
		}
		else {
			s_dkeycnt = 0;
		}

		//if (g_keybuf['1'] & 0x80) {//num
		//	s_1keycnt++;
		//}
		//else {
		//	s_1keycnt = 0;
		//}



		/////// all model bone
		if (s_model && g_controlkey && (g_keybuf['A'] & 0x80) && !(g_savekeybuf['A'] & 0x80)) {
			s_allmodelbone = !s_allmodelbone;
		}

		//if (g_controlkey && (s_1keycnt == 1)) {
		//	s_dispsampleui = !s_dispsampleui;
		//}

	}

	return 0;
}

int OnFrameUtCheckBox()
{
	static int save_wallscrapingikflag = g_wallscrapingikflag;
	static bool save_limitdegflag = g_limitdegflag;
	static int save_brushmirrorUflag = g_brushmirrorUflag;
	static int save_brushmirrorVflag = g_brushmirrorVflag;
	static int save_ifmirrorVDiv2flag = g_ifmirrorVDiv2flag;
	static int save_brushrepeats = g_brushrepeats;
	static double save_applyrate = g_applyrate;
	static int save_brushmethod = g_motionbrush_method;//2024/02/02

	////g_applyendflag = (int)s_ApplyEndCheckBox->GetChecked();
	////g_slerpoffflag = (int)s_SlerpOffCheckBox->GetChecked();
	////if (s_AbsIKCheckBox) {
	////	g_absikflag = (int)s_AbsIKCheckBox->GetChecked();
	////}

	////if (s_TPoseCheckBox) {
	////	g_tpose = (bool)s_TPoseCheckBox->GetChecked();
	////}
	//if (s_PreciseCheckBox) {
	//	g_preciseOnPreviewToo = (bool)s_PreciseCheckBox->GetChecked();
	//}
	//if (s_X180CheckBox) {
	//	g_x180flag = (bool)s_X180CheckBox->GetChecked();
	//}
	////if (s_VSyncCheckBox) {
	////	g_VSync = (bool)s_VSyncCheckBox->GetChecked();
	////}
	//if (s_TraRotCheckBox) {
	//	g_rotatetanim = (bool)s_TraRotCheckBox->GetChecked();
	//}
	////if (s_EdgeSmpCheckBox) {
	////	g_edgesmp = (bool)s_EdgeSmpCheckBox->GetChecked();
	////}
	//if (s_HighRpmCheckBox) {
	//	g_HighRpmMode = (int)s_HighRpmCheckBox->GetChecked();
	//}
	//if (s_BoneMarkCheckBox) {
	//	g_bonemarkflag = (int)s_BoneMarkCheckBox->GetChecked();
	//}
	//if (s_LightingCheckBox) {
	//	g_lightflag = (int)s_LightingCheckBox->GetChecked();
	//}
	//if (s_RigidMarkCheckBox) {
	//	g_rigidmarkflag = (int)s_RigidMarkCheckBox->GetChecked();
	//}
	////if (s_PseudoLocalCheckBox) {
	////	g_pseudolocalflag = (int)s_PseudoLocalCheckBox->GetChecked();
	////}



	//if (s_WallScrapingIKCheckBox && s_WallScrapingCheckBoxFlag) {
	if (s_WallScrapingCheckBoxFlag) {
		//g_wallscrapingikflag = (int)s_WallScrapingIKCheckBox->GetChecked();
		if (s_model && (save_wallscrapingikflag != g_wallscrapingikflag)) {
			PrepairUndo();
		}
		save_wallscrapingikflag = g_wallscrapingikflag;
		s_WallScrapingCheckBoxFlag = false;
	}


	//if (s_LimitDegCheckBox && s_LimitDegCheckBoxFlag) {
	if (s_LimitDegCheckBoxFlag) {
		//g_limitdegflag = s_LimitDegCheckBox->GetChecked();
		////if (s_model && s_model->GetCurMotInfo() && (s_curboneno >= 0) && (g_limitdegflag != s_beflimitdegflag)) {
		if (s_model && s_model->ExistCurrentMotion() && (g_limitdegflag != s_limiteuldlg.GetBefLimitDegFlag())) {
			////s_model->CalcBoneEul(s_model->GetCurMotInfo()->motid);
			////refreshEulerGraph();
			//////s_tum.UpdateEditedEuler(refreshEulerGraph);//非ブロッキング

			//ChangeLimitDegFlag(g_limitdegflag, false, true);
			PrepairUndo();
		}
		s_limiteuldlg.SetBefLimitDegFlag(g_limitdegflag);
		s_LimitDegCheckBoxFlag = false;
	}


	if (s_BrushMirrorUCheckBoxFlag) {
		//g_brushmirrorUflag = (int)s_BrushMirrorUCheckBox->GetChecked();
		if (s_model && (save_brushmirrorUflag != g_brushmirrorUflag)) {
			PrepairUndo();
		}
		save_brushmirrorUflag = g_brushmirrorUflag;
		s_BrushMirrorUCheckBoxFlag = false;
	}
	if (s_BrushMirrorVCheckBoxFlag) {
		//g_brushmirrorVflag = (int)s_BrushMirrorVCheckBox->GetChecked();
		if (s_model && (save_brushmirrorVflag != g_brushmirrorVflag)) {
			PrepairUndo();
		}
		save_brushmirrorVflag = g_brushmirrorVflag;
		s_BrushMirrorVCheckBoxFlag = false;
	}
	if (s_IfMirrorVDiv2CheckBoxFlag) {
		//g_ifmirrorVDiv2flag = (int)s_IfMirrorVDiv2CheckBox->GetChecked();
		if (s_model && (save_ifmirrorVDiv2flag != g_ifmirrorVDiv2flag)) {
			PrepairUndo();
		}
		save_ifmirrorVDiv2flag = g_ifmirrorVDiv2flag;
		s_IfMirrorVDiv2CheckBoxFlag = false;
	}



	if (s_utBrushRepeatsFlag) {//値が変わって　かつ　マウスアップのとき
		//WCHAR sz[100] = { 0L };
		//g_brushrepeats = (int)(g_SampleUI.GetSlider(IDC_SL_BRUSHREPEATS)->GetValue());
		//swprintf_s(sz, 100, L"Brush Repeats : %d", g_brushrepeats);
		//g_SampleUI.GetStatic(IDC_STATIC_BRUSHREPEATS)->SetText(sz);
		if (s_model && (save_brushrepeats != g_brushrepeats)) {
			PrepairUndo();
		}
		save_brushrepeats = g_brushrepeats;

		s_utBrushRepeatsFlag = false;//OnGUIEventのBrushRepaetsスライダー
	}

	if (s_utApplyRateFlag) {//値が変わって　かつ　マウスアップのとき
		//WCHAR sz[100] = { 0L };
		//g_applyrate = g_SampleUI.GetSlider(IDC_SL_APPLYRATE)->GetValue();
		//CEditRange::SetApplyRate((double)g_applyrate);
		//swprintf_s(sz, 100, L"TopPos : %d%% : %d", g_applyrate, (int)(s_editrange.GetApplyFrame()));
		//g_SampleUI.GetStatic(IDC_STATIC_APPLYRATE)->SetText(sz);
		if (s_model && (save_applyrate != g_applyrate)) {
			PrepairUndo();
		}
		save_applyrate = g_applyrate;

		s_utApplyRateFlag = false;//OnGUIEventのApplyRateスライダー
	}


	if (s_utBrushMethodFlag) {//2024/02/02
		//値が変わって　かつ　マウスアップのとき
		if (s_model && (save_brushmethod != g_motionbrush_method)) {
			PrepairUndo();
		}
		save_brushmethod = g_motionbrush_method;

		s_utBrushMethodFlag = false;
	}


	return 0;
}

int OnFrameLightsForEdit()
{

	//毎フレームコントロールを更新すると　手で入力できなくなる
	//if (s_lightsforeditdlg) {
	//	Lights2Dlg(s_lightsforeditdlg);
	//}

	return 0;
}


int OnFrameAngleLimit(bool updateonlycheckeul)
{
	if (s_limiteuldlg.GetVisible()) {
		if (s_model && (s_limiteuldlg.GetAngleLimitUnderHScroll() == 0)) {//HScroll中に値を取得して設定するとスライダーが動かないから
			//s_model->UpdateMatrix(&s_model->GetWorldMat(), &s_matVP);//commentout


			s_limiteuldlg.Bone2AngleLimit(s_curboneno);
			s_limiteuldlg.AngleLimit2Dlg(updateonlycheckeul);


			if (updateonlycheckeul == false) {
				if (g_previewFlag == 0) {//underchecking
					s_limiteuldlg.AngleLimit2Bone(eLIM2BONE_LIM2BONE_ONE);
				}
			}

			s_limiteuldlg.CallRewrite();

		}
	}

	return 0;
}

int OnFrameProcessTime(double difftime, double* pnextframe, int* pendflag, int* ploopstartflag)
{
	if (!pnextframe || !pendflag || !ploopstartflag) {
		_ASSERT(0);
		return 1;
	}

	if (!s_model) {
		return 0;
	}
	if (!s_model->ExistCurrentMotion()) {
		return 0;
	}
	
	//プレビューしていなくてもセット必要
	s_model->SetRenderSlotFrame(s_model->GetCurrentFrame());//2024/03/13 変更前に保存　RenderBoneMarkで使用

	if (g_previewFlag != 0) {
		if (s_savepreviewFlag == 0) {
			//preview start frame
			s_previewrange = s_editrange;
			double rangestart;
			if (s_previewrange.IsSameStartAndEnd()) {
				rangestart = 1.0;
			}
			else {
				rangestart = s_previewrange.GetStartFrame();
			}
			s_model->SetMotionFrame(rangestart);
			*pnextframe = 0.0;
		}
		s_model->AdvanceTime(0, s_previewrange, g_previewFlag, difftime, pnextframe, pendflag, ploopstartflag, -1);
		if (*pendflag == 1) {
			g_previewFlag = 0;
		}
		s_model->SetMotionFrame(*pnextframe);
	}

	return 0;
}

int OnFrameProcessCameraTime(double difftime, double* pnextframe, int* pendflag, int* ploopstartflag)
{
	if (!pnextframe || !pendflag || !ploopstartflag) {
		_ASSERT(0);
		return 1;
	}
	if (!s_model) {
		return 0;
	}

	if (!s_cameramodel) {//2024/01/31
		return 0;
	}
	//int cameramotid = s_model->GetCameraMotionId();
	int cameramotid = s_cameramodel->GetCameraMotionId();//2024/01/31
	if (cameramotid <= 0) {
		return 0;
	}

	if (g_previewFlag != 0) {
		if (s_savepreviewFlag == 0) {
			//preview start frame
			s_previewrange = s_editrange;
			double rangestart;
			if (s_previewrange.IsSameStartAndEnd()) {
				rangestart = 1.0;
			}
			else {
				rangestart = s_previewrange.GetStartFrame();
			}
			//s_model->SetMotionFrame(cameramotid, rangestart);
			s_cameramodel->SetCameraMotionFrame(cameramotid, rangestart);
			*pnextframe = 0.0;
		}
		//s_model->AdvanceTime(0, s_previewrange, g_previewFlag, difftime, pnextframe, pendflag, ploopstartflag, cameramotid);//!!! cameramotid !!!
		s_cameramodel->AdvanceTime(0, s_previewrange, g_previewFlag, difftime, pnextframe, pendflag, ploopstartflag, cameramotid);//!!! cameramotid !!!
		s_cameramodel->SetCameraMotionFrame(cameramotid, *pnextframe);
	}
	else {
		if (s_owpLTimeline) {
			*pnextframe = s_owpLTimeline->getCurrentTime();
		}
		else {
			*pnextframe = 1.0;
		}
	}
	//if (*pendflag == 1) {
	//	g_previewFlag = 0;
	//}

	
	//s_model->SetMotionSpeed(cameramotid, g_dspeed);
	//s_model->SetMotionFrame(cameramotid, *pnextframe);
	s_cameramodel->SetMotionSpeed(cameramotid, g_dspeed);
	s_cameramodel->SetMotionFrame(cameramotid, *pnextframe);

	return 0;
}



int OnFramePreviewCamera(double srcnextframe)
{
	double nextcameraframe = 0.0;

	if (!s_chascene) {
		return 0;
	}

	//if ((g_edittarget == EDITTARGET_CAMERA) && (s_model->GetUnderIKRot())) {
	//	//カメラアニメ編集中はスキップ
	//	return 0;
	//}

	//eNull用の時間は　カメラの時間と同じとする　(とりあえず)
	s_chascene->SetENullTime(-1, srcnextframe);


	if (g_cameraanimmode != 0) {//2023/05/29 2023/06/04
	 
		//########################
		//カメラアニメモード　オン
		//########################

		if (s_cameramodel) {
			if (g_previewFlag ||
				((g_previewFlag == 0) && (s_savepreviewFlag != 0))) {
				nextcameraframe = srcnextframe;
			}
			else {
				if (s_owpLTimeline) {
					nextcameraframe = s_owpLTimeline->getCurrentTime();
				}
				else {
					nextcameraframe = 0.0;
				}
			}

			//double roundingframe = RoundingTime(nextcameraframe);
			//s_cameramodel->GetCameraAnimParams(roundingframe, g_camdist, &g_camEye, &g_camtargetpos, &g_cameraupdir, 0, g_cameraInheritMode);//g_camdist
			////#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
			//s_cameraframe = roundingframe;


			//2024/01/31 NotRoundingTime
			s_cameramodel->GetCameraAnimParams(nextcameraframe, g_camdist,
				&g_camEye, &g_camtargetpos, &g_cameraupdir, 0, g_cameraInheritMode);//g_camdist
			s_cameraframe = nextcameraframe;

		}
		else {
			//######################################
			//カメラモデルが無い場合
			//GUIによるカメラ操作可能に
			//######################################
			//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
		}
	}
	else {

		//########################
		//カメラアニメモード　オフ
		//########################

		//######################################
		//GUIによるカメラ操作可能に
		//######################################
		//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
	}
	ChaVector3 cameradiff = g_camtargetpos - g_camEye;
	g_camdist = (float)ChaVector3LengthDbl(&cameradiff);


	//###################################
	//ライトの向きは　カメラの向きに依存
	//###################################
	SetLightDirection();


	return 0;
}

int OnFramePreviewStop()
{
	if (!s_chascene) {
		return 0;
	}

	double currenttime;
	if (s_owpTimeline) {
		currenttime = s_owpLTimeline->getCurrentTime();
	}
	else {
		currenttime = 0.0;
	}
	
	int loopstartflag = 1;
	s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matView, &s_matProj, currenttime, loopstartflag);

	//s_tum.UpdateMatrix(s_modelindex, &s_matVP);//ブロッキング

	return 0;
}

int OnFramePreviewNormal(double nextframe, double difftime, int endflag, int loopstartflag)
{
	if (!s_chascene) {
		return 0;
	}


	//if (g_previewFlag != 0) {
	//	if (s_savepreviewFlag == 0) {
	//		//preview start frame
	//		s_previewrange = s_editrange;
	//		double rangestart;
	//		if (s_previewrange.IsSameStartAndEnd()) {
	//			rangestart = 1.0;
	//		}
	//		else {
	//			rangestart = s_previewrange.GetStartFrame();
	//		}
	//		s_model->SetMotionFrame(rangestart);
	//		*pdifftime = 0.0;
	//	}
	//}

	//int endflag = 0;
	//int loopstartflag = 0;
	//s_model->AdvanceTime(s_onefps, s_previewrange, g_previewFlag, *pdifftime, pnextframe, &endflag, &loopstartflag, -1);
	//if (endflag == 1) {
	//	g_previewFlag = 0;
	//}

	s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matView, &s_matProj, nextframe, loopstartflag);

#ifndef SKIP_EULERGRAPH__
	if (s_owpTimeline) {
		s_owpLTimeline->setCurrentTime(nextframe, false);
	}
	if (s_owpEulerGraph) {
		s_owpEulerGraph->setCurrentTime(nextframe, false, true);
	}
#endif

	//2023/08/02　SetMotionFrameと同じループ内に移動
	//for (itrmodel = s_modelindex.begin(); itrmodel != s_modelindex.end(); itrmodel++) {
	//	CModel* curmodel = itrmodel->modelptr;
	//	if (curmodel) {
	//		ChaMatrix tmpwm = curmodel->GetWorldMat();
	//		curmodel->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matVP);
	//	}
	//}



	//s_tum.UpdateMatrix(s_modelindex, &s_matVP);//ブロッキング


	//if (s_anglelimitdlg) {
	//	UpdateEditedEuler();
	//	//s_tum.UpdateEditedEuler(UpdateEditedEuler);//非ブロッキング
	//}


	//playerButtonのonefpsボタン
	//if (s_onefps == 1) {
	//	Sleep(1000);//1fps
	//}
	//else if (s_onefps == 2) {
	//	Sleep(500);//2fps
	//}


	return 0;
}



int OnFramePreviewBt(double nextframe, double difftime, int endflag, int loopstartflag)
{
	if (!s_model || !s_chascene) {
		return 0;
	}



	//安定のために　シミュ開始時の姿勢で　キネマティックしている回数
	int INITTERM;
	INITTERM = max(10, (int)(s_avrgfps * 0.1));

	bool recstopflag = false;
	BOOL firstmodelflag = TRUE;

	int modelnum = s_chascene->GetModelNum();
	int modelcount;
	for (modelcount = 0; modelcount < modelnum; modelcount++) {
		CModel* curmodel = s_chascene->GetModel(modelcount);
		if (curmodel && (curmodel->GetNoBoneFlag() == false)) {//2023/11/03 NoBoneのときはスキップ

			if (curmodel->GetBtCnt() <= INITTERM) {
				curmodel->SetKinematicFlag();
				//!!curmodel->SetBtEquilibriumPoint();
			}
			else {
				curmodel->SetBtKinFlagReq(curmodel->GetTopBt(), 0);
				//curmodel->SetBtEquilibriumPoint();
			}

			if ((curmodel == s_model) && (s_model->GetBtCnt() == 0)) {
				s_rectime = 0.0;
				s_reccnt = 0;
				s_model->PhysIKRec(g_limitdegflag, s_rectime);
			}

			if ((g_btsimurecflag == true) && ((loopstartflag == 1) || (endflag == 1))) {
				recstopflag = true;//!!!!!!!!!!!!!!!!!!!!!!!
				break;
			}


			if (firstmodelflag) {
#ifndef SKIP_EULERGRAPH__
				if (s_owpTimeline) {
					s_owpLTimeline->setCurrentTime(nextframe, false);
				}
				if (s_owpEulerGraph) {
					s_owpEulerGraph->setCurrentTime(nextframe, false, true);
				}
#endif
				firstmodelflag = false;
			}
			//if (endflag == 1) {
				//g_previewFlag = 0;
			//}

			curmodel->SetMotionFrame(nextframe);

		}
	}


	//2023/11/03 モデル単位マルチスレッド＆ダブルバッファ
	s_chascene->UpdateBtFunc(g_limitdegflag, nextframe, 
		&s_matView, &s_matProj, loopstartflag, s_model, recstopflag, s_bpWorld, s_reccnt, StopBtRec);


	//60 x 60 frames limit : 60 sec limit
	if ((s_model->GetBtCnt() > 0) && (s_reccnt < MAXPHYSIKRECCNT)) {
		s_reccnt += 1.0;
	}


	return 0;
}

int StopBtRec()
{
	StopBt();
	s_model->ApplyPhysIkRec(g_limitdegflag);
	refreshEulerGraph();
	PrepairUndo();//物理REC用保存
	g_btsimurecflag = false;

	return 0;
}



//int OnFramePreviewBtAftFunc(double nextframe, CModel* curmodel)
//{
//	if (curmodel && (curmodel->GetBtCnt() != 0)) {
//		if (curmodel && curmodel->GetCurMotInfo()) {
//			ChaMatrix tmpwm = curmodel->GetWorldMat();
//			curmodel->SetBtMotion(g_limitdegflag, curmodel->GetBoneByID(s_curboneno), 0, nextframe, &tmpwm, &s_matVP);
//
//			//60 x 30 frames limit : 30 sec limit
//			if ((curmodel == s_model) && (s_model->GetBtCnt() > 0) && (s_reccnt < MAXPHYSIKRECCNT)) {
//				s_rectime = (double)((int)s_reccnt);
//				s_model->PhysIKRec(s_rectime);
//				s_reccnt++;
//			}
//		}
//	}
//
//	return 0;
//}



//void UpdateBtSimu(double nextframe, CModel* curmodel)
//{
//	if (!curmodel){
//		return;
//	}
//	int firstflag = 0;
//	if (s_savepreviewFlag != g_previewFlag){
//		firstflag = 1;
//	}
//	if (curmodel && curmodel->GetCurMotInfo()){
//		ChaMatrix tmpwm = curmodel->GetWorldMat();
//		curmodel->Motion2Bt(firstflag, nextframe, &tmpwm, &s_matVP, s_curboneno);
//	}
//	//s_bpWorld->setTimeStep(1.0f / 120.0f);// seconds
//	s_bpWorld->clientMoveAndDisplay();
//	if (curmodel && curmodel->GetCurMotInfo()){
//		ChaMatrix tmpwm = curmodel->GetWorldMat();
//		curmodel->SetBtMotion(curmodel->GetBoneByID(s_curboneno), 0, nextframe, &tmpwm, &s_matVP);
//	}
//}

//int OnFramePreviewRagdoll(double* pnextframe, double* pdifftime)
//{
//	static int s_underikflag = 0;
//	static int s_befunderikflag = 0;
//
//	int endflag = 0;
//
//	if (!s_model){
//		return 0;
//	}
//	CModel* curmodel = s_model;
//
//	//BOOL isstartframe = FALSE;
//	//double rangestart = 1.0;
//	//s_previewrange = s_editrange;
//	//if (s_previewrange.IsSameStartAndEnd()) {
//	//	rangestart = 1.0;
//	//}
//	//else {
//	//	rangestart = s_previewrange.GetStartFrame();
//	//}
//
//	//if (g_previewFlag != 0) {
//	//	if (s_savepreviewFlag == 0) {
//	//		//preview start frame
//	//		*pdifftime = 0.0;
//	//		*pnextframe = rangestart;
//	//		isstartframe = TRUE;
//	//	}
//	//}
//
//
//	//*pnextframe = s_previewrange.GetApplyFrame();
//	int tmpleng;
//	double tmpstart, tmpend;
//	s_previewrange.GetRange(&tmpleng, &tmpstart, &tmpend);
//	*pnextframe = s_previewrange.GetApplyFrame();
//	//*pnextframe = g_motionbrush_applyframe;
//
//	if (curmodel && curmodel->GetCurMotInfo()){
//		//if (s_onragdollik != 0){
//		//	if (s_underikflag == 0){
//		//		curmodel->BulletSimulationStop();
//		//		s_underikflag = 1;
//		//	}
//		//}
//
//
//		if (curmodel->GetBtCnt() <= g_prepcntonphysik) {
//			curmodel->SetKinematicFlag();
//			curmodel->SetMotionFrame(*pnextframe);
//
//			//UpdateBtSimu(*pnextframe, curmodel);
//			if (curmodel && curmodel->GetCurMotInfo()) {
//				int firstflag = 1;
//				ChaMatrix tmpwm = curmodel->GetWorldMat();
//				curmodel->Motion2Bt(firstflag, *pnextframe, &tmpwm, &s_matVP, s_curboneno);
//			}
//			curmodel->SetBtEquilibriumPoint();//必要
//
//			if (curmodel->GetBtCnt() == 0) {
//				s_rectime = 0.0;
//				s_reccnt = 0;
//				s_model->PhysIKRec(s_rectime);
//				SetKinematicToHand(curmodel, true);//指が変にならないように
//			}
//		}
//		else {
//			curmodel->SetRagdollKinFlag(s_curboneno, s_physicskind);
//			curmodel->SetBtEquilibriumPoint();//
//		}
//
//
//
//
//		//curmodel->SetRagdollKinFlag(s_curboneno, s_physicskind);
//
//	}
//
//	//physics mvの場合、クリックしていないときには直下のif文内を呼ばない。
//	//physics rotの場合、クリックしていなくても直下のif文内を呼んだほうが剛体がゆらゆらしない。
//	if((s_curboneno >= 0) && ((s_onragdollik != 0) || (s_physicskind == 0))){
//		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
//		POINT ptCursor;
//		GetCursorPos(&ptCursor);
//		::ScreenToClient(s_3dwnd, &ptCursor);
//		s_pickinfo.mousepos = ptCursor;
//
//		ChaVector3 tmpsc;
//		curmodel->TransformBone(s_pickinfo.winx, s_pickinfo.winy, s_curboneno, &s_pickinfo.objworld, &tmpsc, &s_pickinfo.objscreen);
//
//		if (s_oprigflag == 0) {//Rig操作ではないとき
//			ChaVector3 targetpos(0.0f, 0.0f, 0.0f);
//			CallF(CalcTargetPos(&targetpos), return 1);
//
//			s_model->SetDofRotAxis(s_pickinfo.buttonflag);//!!!!!!!!!!!!!!!!!!!!!!!
//
//
//			if (s_physicskind == 0) {
//				if (s_onragdollik == 1) {
//					int ikmaxlevel = 0;
//					curmodel->PhysicsRot(&s_editrange, s_pickinfo.pickobjno, targetpos, ikmaxlevel);
//				}
//				else if ((s_onragdollik == 2) || (s_onragdollik == 3)) {
//					float deltax = (float)((s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y)) * 0.1f;
//					if (g_controlkey == true) {
//						deltax *= 0.250f;
//					}
//					//s_editmotionflag = s_model->PhysicsRotAxisDelta(&s_editrange, s_pickinfo.buttonflag, s_pickinfo.pickobjno, deltax, g_iklevel, s_ikcnt, s_ikselectmat);
//					s_editmotionflag = s_model->PhysicsRotAxisDelta(&s_editrange, s_pickinfo.buttonflag, s_curboneno, deltax, g_iklevel, s_ikcnt, s_ikselectmat);
//					s_ikcnt++;
//				}
//
//				//if (s_curboneno <= 0){
//				//	::MessageBoxA(NULL, "OnFramePreviewRagdoll : curboneno error", "check", MB_OK);
//				//}
//
//			}
//			else {
//				//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//				//少しずつ動かさないと壊れやすい
//				//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//				int ikmaxlevel = 0;
//				ChaVector3 diffvec = (targetpos - s_pickinfo.objworld) * 0.2;//PhysicsMV関数内でさらにg_physicsmvrateが掛けられる。
//				curmodel->PhysicsMV(&s_editrange, s_pickinfo.pickobjno, diffvec);
//			}
//		}
//
//
//		CBone* curbone = s_model->GetBoneByID(s_curboneno);
//		if (curbone) {
//			CBone* parentbone = curbone->GetParent();
//			if (parentbone) {
//				s_editmotionflag = parentbone->GetBoneNo();
//			}
//			else {
//				s_editmotionflag = s_curboneno;
//			}
//			s_ikcnt++;
//		}
//
//
//	}
//
//
//	//curmodel->SetMotionFrame(s_editrange.GetStartFrame());
//	//*pnextframe = s_editrange.GetStartFrame();//!!!!!!!!!!!!!!!
//	{
//		int tmpleng2;
//		double tmpstart2, tmpend2;
//		s_previewrange.GetRange(&tmpleng2, &tmpstart2, &tmpend2);
//		*pnextframe = s_previewrange.GetApplyFrame();
//		curmodel->SetMotionFrame(*pnextframe);
//	}
//
//#ifndef SKIP_EULERGRAPH__
//	s_owpLTimeline->setCurrentTime(*pnextframe, false);
//	s_owpEulerGraph->setCurrentTime(*pnextframe, false, true);
//#endif
//
//
//	s_bpWorld->clientMoveAndDisplay();
//
//	if (curmodel && curmodel->GetCurMotInfo()){
//		ChaMatrix tmpwm = curmodel->GetWorldMat();
//		curmodel->SetBtMotion(curmodel->GetBoneByID(s_curboneno), 1, *pnextframe, &tmpwm, &s_matVP);
//		curmodel->UpdateMatrix(&tmpwm, &s_matVP, true);
//		curmodel->PlusPlusBtCnt();
//
//		//ドラッグ中だけ記録
//		if ((s_curboneno >= 0) && ((s_onragdollik != 0) || (s_physicskind == 0))) {
//			//60 x 30 frames limit : 30 sec limit
//			if ((curmodel->GetBtCnt() > g_prepcntonphysik) && (s_reccnt < MAXPHYSIKRECCNT)) {
//				s_rectime = (double)((int)s_reccnt);
//				s_model->PhysIKRec(s_rectime);
//				s_reccnt++;
//			}
//		}
//	}
//
//	s_bpWorld->clientMoveAndDisplay();//tmpkinematic部分のbullet情報変更がSetBtMotion内で生じるので、もう一回シミュをまわす。
//
//
//	s_befunderikflag = s_underikflag;
//
//	//if (s_anglelimitdlg) {
//	//	UpdateEditedEuler();
//	//	//s_tum.UpdateEditedEuler(UpdateEditedEuler);//非ブロッキング
//	//}
//
//
//	return 0;
//}

int OnFrameCloseFlag()
{
	// 終了フラグを確認

	if (s_closeFlag) {
		s_closeFlag = false;
		s_dispmw = false;
		if (s_timelineWnd) {
			s_timelineWnd->setVisible(0);
		}

	}
	if (s_LcloseFlag) {
		s_LcloseFlag = false;
		s_Ldispmw = false;
		if (s_LtimelineWnd) {
			s_LtimelineWnd->setVisible(0);
		}

	}
	if (s_closetoolFlag) {
		s_closetoolFlag = false;
		s_disptool = false;
		if (s_toolWnd) {
			s_toolWnd->setVisible(0);
		}
	}
	if (s_closeobjFlag) {
		s_closeobjFlag = false;
		s_dispobj = false;
		if (s_layerWnd) {
			s_layerWnd->setVisible(0);
		}
	}
	if (s_closemodelFlag) {
		s_closemodelFlag = false;
		s_dispmodel = false;
		if (s_modelpanel.panel) {
			s_modelpanel.panel->setVisible(0);
		}
	}
	if (s_closecameraFlag) {
		s_closecameraFlag = false;
		s_dispcamera = false;
		if (s_camerapanel.panel) {
			s_camerapanel.panel->setVisible(0);
		}
	}
	if (s_closemotionFlag) {
		s_closemotionFlag = false;
		s_dispmotion = false;
		if (s_motionpanel.panel) {
			s_motionpanel.panel->setVisible(0);
		}
	}
	if (s_retargetdlg.GetRetargetCloseFlag()) {
		s_retargetdlg.SetRetargetCloseFlag(false);
		s_dispconvbone = false;
		s_retargetdlg.SetVisible(false);
	}
	if (s_dampanimdlg.GetDampAnimCloseFlag()) {
		s_dampanimdlg.SetDampAnimCloseFlag(false);
		s_dampanimdlg.SetVisible(false);
		if (s_bpWorld) {
			s_bpWorld->setGlobalERP(btScalar(g_erp));
		}
		if (s_model) {
			CallF(s_model->CreateBtObject(g_limitdegflag, 0), return 1);
		}
	}
	if (s_displimitscloseFlag) {
		s_displimitscloseFlag = false;
		ShowGUIDlgDispParams(false);
	}
	if (s_shaderparamsdlg.GetShaderCloseFlag()) {
		s_shaderparamsdlg.SetShaderCloseFlag(false);
		ShowShaderTypeParamsDlg(false);
	}
	if (s_skyparamsdlg.GetSkyCloseFlag()) {
		s_skyparamsdlg.SetSkyCloseFlag(false);
		ShowSkyWnd(false);
	}
	if (s_ScloseFlag) {
		s_ScloseFlag = false;
		if (s_sidemenuWnd) {
			s_sidemenuWnd->setVisible(0);
		}
	}
	if (s_impulsedlg.GetImpulseCloseFlag()) {
		s_impulsedlg.SetImpulseCloseFlag(false);
		s_impulsedlg.SetVisible(false);
		if (s_bpWorld) {
			s_bpWorld->setGlobalERP(btScalar(g_erp));
		}
		if (s_model) {
			CallF(s_model->CreateBtObject(g_limitdegflag, 0), return 1);
		}
	}
	if (s_gplanedlg.GetGPlaneCloseFlag()) {
		s_gplanedlg.SetGPlaneCloseFlag(false);
		s_gplanedlg.SetVisible(false);
	}

	return 0;
}

int GetCurrentBoneFromTimeline(int* dstboneno)
{
	if (s_model && s_owpTimeline) {
		int curlineno = s_owpTimeline->getCurrentLine();// 選択行
		if (curlineno >= 0) {
			*dstboneno = s_lineno2boneno[curlineno];//*(&s_curboneno)
			SetLTimelineMark(s_curboneno);
			if ((s_undoFlag == false) && (s_redoFlag == false) && (s_cursorUnderUndo == false)) {
				ChangeCurrentBone(true);
			}
			else {
				ChangeCurrentBone(false);
			}
		}
		else {
			*dstboneno = -1;
		}
	}
	return 0;
}


int TimelineCursorToMotion()
{
	if (s_chascene && s_owpTimeline && s_model && s_model->ExistCurrentMotion()) {

		GetCurrentBoneFromTimeline(&s_curboneno);

		// カーソル位置を姿勢に反映。
		if (g_previewFlag == 0) {//underchecking
			double curframe = s_owpTimeline->getCurrentTime();// 選択時刻

			s_chascene->SetMotionFrame(-1, curframe);
		}
	}
	return 0;
}


int OnFrameTimeLineWnd()
{
	// カーソル移動フラグを確認 //////////////////////////////////////////////////


	if (g_previewFlag != 0) {//underchecking

		if (g_preciseOnPreviewToo) {
			//2022/10/27 再生中でも選択ジョイント変更処理はする
			GetCurrentBoneFromTimeline(&s_curboneno);
		}

		//カレントフレームの１フレームを選択状態にしてしまうのでfalseにする
		s_cursorFlag = false;
		s_LcursorFlag = false;
		s_keyShiftFlag = false;
		s_LupFlag = false;
		s_cursorUnderUndo = false;

		return 0;//!!!!!!!!!!!!!!!!!!!!!
	}

	if (s_zeroFrameFlag) {
		if (s_model) {
			if (s_owpTimeline && s_owpLTimeline && s_owpEulerGraph) {
				s_buttonselectstart = 0.0;
				s_buttonselectend = 0.0;
				s_buttonselecttothelast = 0;
				g_playingstart = 0.0;
				g_playingend = 0.0;
				OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);
				SetShowPosTime();
				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}
				PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
				g_underselectingframe = 0;
			}
		}
		s_zeroFrameFlag = false;
	}

	if (s_LchangeTargetFlag) {
		s_LchangeTargetFlag =false;

		g_edittarget++;
		if (g_edittarget >= EDITTARGET_MAX) {
			g_edittarget = EDITTARGET_BONE;
		}


		if (g_edittarget == EDITTARGET_CAMERA) {
			//カメラグラフモードオンの場合には　カメラエディットオン＋カメラ再生オン
			//よってカメラ再生オン
			g_cameraanimmode = 1;
			s_spcameramode.state = true;

			PrepairUndo();//編集前のPrepairUndo
		}

		s_LrefreshEditTarget = 1;
	}

	if (s_LrefreshEditTarget != 0) {
		//#############################################################################
		//2024/06/06
		//選択範囲を初期化後に選択範囲を復元しようとしても表示がずれてうまくいかない
		//s_LrefreshEditTarget == 1のif文で初期化処理を行い
		//ループを１周回して必要な処理をしてからs_LrefreshEditTarget == 2のif文で復元処理を行う
		//#############################################################################

		int tmpLrefreshEditTarget = s_LrefreshEditTarget;

		if (tmpLrefreshEditTarget >= 3) {
			s_LrefreshEditTarget = 0;

		}
		else if (tmpLrefreshEditTarget == 1) {
			s_LrefreshEditTarget = 2;

			if (g_edittarget == EDITTARGET_MORPH) {
				CloseAllRightPainWindow(true);
				s_guiswplateno = 6;
				GUISetVisible(s_guiswplateno);
			}
			//else if (g_edittarget == EDITTARGET_BONE) {//bone-->camera-->morph-->"bone"
			else {
				//undo時　bone-->morph-->"camera"でもmorphウインドウが閉じるように
				//2024/07/09　起動直後のプロジェクト読み込み後は　ショートカット一覧(メニュー１段目)が表示されるように
				if (s_spguisw[SPGUISW_BLENDSHAPE].state) {//2024/07/09
					s_guiswflag = false;
				}
				GUIMenuSetVisible(s_platemenukind, s_platemenuno);
			}
			if (s_model) {
				s_curboneno = s_model->GetSelectedBoneNo();//2024/06/06
			}
			SetLTimelineMark(s_curboneno);
			if (s_owpTimeline) {
				refreshTimeline(*s_owpTimeline);
			}


			s_savebuttonselectstart = s_buttonselectstart;
			s_savebuttonselectend = s_buttonselectend;
			s_savebuttonselecttothelast = s_buttonselecttothelast;
			s_saveplayingstart = g_playingstart;
			s_saveplayingend = g_playingend;
			s_savemotionbrush_startframe = g_motionbrush_startframe;
			s_savemotionbrush_endframe = g_motionbrush_endframe;
			s_savemotionbrush_applyframe = g_motionbrush_applyframe;


			s_buttonselectstart = 1.0;
			s_buttonselectend = 1.0;
			s_buttonselecttothelast = 0;
			g_playingstart = 1.0;
			g_playingend = 1.0;
			OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);
			SetShowPosTime();
			//refreshTimeline(*s_owpTimeline);
			if (s_owpLTimeline) {
				s_owpLTimeline->callRewrite();
			}
			if (s_owpEulerGraph) {
				s_owpEulerGraph->callRewrite();
			}
			refreshEulerGraph();
			//refreshTimeline(*s_owpTimeline);

			//#############################################################################
			//この直後に選択範囲を復元しようとしても表示がずれてうまくいかない
			//ループを１周回して必要な処理をしてからtmpLrefreshEditTarget == 2のif文で復元処理を行う
			//#############################################################################

		}
		else if (tmpLrefreshEditTarget == 2) {
			s_LrefreshEditTarget = 3;

			MOTINFO curmi = GetEditTargetMotInfo();
			//if ((curmi.motid > 0) && (s_savebuttonselectend < curmi.frameleng)) {
			if (curmi.motid > 0) {
				//##########################################################
				//処理前の選択範囲を引き継ぐ　ただしモーション長にクランプする
				//##########################################################
				s_buttonselectstart = s_savebuttonselectstart;
				s_buttonselectend = s_savebuttonselectend;
				s_buttonselecttothelast = s_savebuttonselecttothelast;
				g_playingstart = s_saveplayingstart;
				g_playingend = s_saveplayingend;
				g_motionbrush_startframe = s_savemotionbrush_startframe;
				g_motionbrush_endframe = s_savemotionbrush_endframe;
				g_motionbrush_applyframe = s_savemotionbrush_applyframe;

				//OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);
				ClampTimelineSelection();//2024/06/23

				SetShowPosTime();
				//refreshTimeline(*s_owpTimeline);
				if (s_owpLTimeline) {
					s_owpLTimeline->callRewrite();
				}
				if (s_owpEulerGraph) {
					s_owpEulerGraph->callRewrite();
				}
				refreshEulerGraph();
				//refreshTimeline(*s_owpTimeline);
			}

			//2024/07/02 UndoからPrepairUndo_BlendShape()が呼ばれる問題への対策
			//s_LrefreshEditTargetフラグを立てるとBlendShapeWndの表示関数が呼ばれて
			//s_blendshapeUnderSelectFromUndo(PrepairUndoの抑止の役割もしている)がリセットされた後で　s_blendshapeUnderSelectがセットされ　PrepairUndo_BlendShape()が実行されてしまう
			//つまりRollBack処理時にPrepairUndo_BlendShape()が呼ばれてしまう
			//これを避けるために
			//s_LrefeshEditTargetの処理が終わった時点まで　s_blendshapeUnderSelectFromUndoをリセットしない
			//s_LrefeshEditTargetが終わった時点で　s_blendshapeUnderSelectFromUndoをリセットしてs_blendshapeUnderSelectFromRefreshを立てる
			//そしてs_blendshapeUnderSelectFromRefreshをみて　PrepairUndo_BlendShape()無しのBlendShapeのSelChangeを行う
			if (s_blendshapedlg.GetBlendShapeUnderSelectFromUndo()) {
				s_blendshapedlg.SetBlendShapeUnderSelectFromUndo(false);
				s_blendshapedlg.SetBlendShapeUnderSelectFromRefresh(true);
			}
		}
	}

	if (s_LchangeTarget2Camera) {
		s_LchangeTarget2Camera = false;

		//編集前のPrepairUndoをする
		PrepairUndo();
	}

	if (s_firstkeyFlag) {
		if (s_model) {
			s_buttonselectstart = 1.0;
			s_buttonselectend = 1.0;
			s_buttonselecttothelast = 0;
			g_playingstart = 1.0;
			g_playingend = 1.0;
			OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);
			SetShowPosTime();
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}
			PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
			g_underselectingframe = 0;
		}
		s_firstkeyFlag = false;
	}

	if (s_lastkeyFlag) {
		if (s_model && s_model->ExistCurrentMotion()) {
			double lastframe;
			MOTINFO curmi = GetEditTargetMotInfo();
			if (curmi.motid > 0) {
				lastframe = curmi.frameleng - 1.0;

				s_buttonselectstart = lastframe;
				s_buttonselectend = lastframe;
				s_buttonselecttothelast = 0;
				g_playingstart = lastframe;
				g_playingend = lastframe;
				OnTimeLineButtonSelectFromSelectStartEnd(s_buttonselecttothelast);
				SetShowPosTime();
				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}
				PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
				g_underselectingframe = 0;
			}
		}
		s_lastkeyFlag = false;
	}

	if (g_selecttolastFlag) {
		if (s_model && s_owpLTimeline) {
			s_buttonselectstart = s_owpLTimeline->getCurrentTime();
			//if (s_model && s_model->ExistCurrentMotion()) {
			if (s_model) {//2024/06/17 カメラモーションだけの場合もある
				MOTINFO curmi = GetEditTargetMotInfo();
				if (curmi.motid > 0) {
					s_buttonselectend = s_model->GetCurMotInfo().frameleng - 1.0;
				}
				else {
					s_buttonselectend = s_buttonselectstart;
				}
			}
			else {
				s_buttonselectend = s_buttonselectstart;
			}
			//g_applyrate = g_SampleUI.GetSlider(IDC_SL_APPLYRATE)->GetValue();
			//CEditRange::SetApplyRate(g_applyrate);
			OnTimeLineButtonSelectFromSelectStartEnd(0);
			OnTimeLineSelectFromSelectedKey();
			SetShowPosTime();
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}
			PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定

			g_underselectingframe = 0;
		}
		g_selecttolastFlag = false;
	}




	if (s_LstartFlag) {
		s_buttonselectstart = s_editrange.GetStartFrame();
		s_buttonselectend = s_editrange.GetEndFrame();
		if (s_owpTimeline) {
			s_owpTimeline->setCurrentTime(s_buttonselectstart, false);
		}
		if (s_owpLTimeline) {
			s_owpLTimeline->setCurrentTime(s_buttonselectstart, false);
		}
		if (s_chascene) {
			int loopstartflag = 1;
			s_chascene->UpdateMatrixModels(g_limitdegflag, &s_matView, &s_matProj, s_buttonselectstart, loopstartflag);
		}

		s_limiteuldlg.Bone2AngleLimit(s_curboneno);

		s_LstartFlag = false;
	}


	if (s_cursorFlag) {
		TimelineCursorToMotion();
		s_cursorFlag = false;
		s_cursorUnderUndo = false;
	}

	if (s_LTimelineApplyFrameFlag) {
		s_LTimelineApplyFrameFlag = false;

		if (s_owpLTimeline && s_owpEulerGraph && s_owpTimeline) {
			double currenttime = s_owpLTimeline->getCurrentTime();
			s_owpTimeline->setCurrentTime(currenttime, false);
			s_owpEulerGraph->setCurrentTime(currenttime, false);//eulergraphとshowpostimeも同期

			g_motionbrush_applyframe = currenttime;
			if (g_motionbrush_startframe != g_motionbrush_endframe) {
				g_applyrate = (g_motionbrush_applyframe - g_motionbrush_startframe) * 100.0 / (g_motionbrush_endframe - g_motionbrush_startframe);;
			}
			else {
				g_applyrate = 50.0;
			}

			if (s_editmotionflag < 0) {//IK中でないとき
				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}
			}
		}
	}

	if (s_topslidersBrushRepeatsFlag) {
		s_topslidersBrushRepeatsFlag = false;

		if (s_editmotionflag < 0) {//IK中でないとき
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}
		}
	}
	if (s_topslidersBrushMirrorUFlag) {
		s_topslidersBrushMirrorUFlag = false;

		if (s_editmotionflag < 0) {//IK中でないとき
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}
			//PrepairUndo();//保存はOnFrameUtCheckBoxにて
		}

		//##################
		//For PrepairUndo()
		//##################
		s_BrushMirrorUCheckBoxFlag = true;//UTDialogの
	}
	if (s_topslidersBrushMirrorVFlag) {
		s_topslidersBrushMirrorVFlag = false;

		if (s_editmotionflag < 0) {//IK中でないとき
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}
			//PrepairUndo();//保存はOnFrameUtCheckBoxにて
		}

		//##################
		//For PrepairUndo()
		//##################
		s_BrushMirrorVCheckBoxFlag = true;//UTDialogの
	}


	//selectFlagは　タイムライン選択範囲が１フレームでも変わるとtrueになる
	if (s_selectFlag) {//selectFlagとLupFlagは本来は別物　しかしLupのときだけ処理するものがある
		if (s_owpLTimeline) {
			s_selectKeyInfoList.clear();
			s_selectKeyInfoList = s_owpLTimeline->getSelectedKey();
			s_editrange.SetRange(s_selectKeyInfoList, s_owpLTimeline->getCurrentTime());
			//CEditRange::SetApplyRate(g_applyrate);
			s_buttonselectstart = s_editrange.GetStartFrame();
			s_buttonselectend = s_editrange.GetEndFrame();


			if (s_mbuttoncnt != 0) {//2023/01/09 mbutton + wheelで選択を継続するため s_mbuttoncnt == 0のときには初期化しない
				g_underselectingframe = 0;
			}


			//_ASSERT(0);

			if (s_LupFlag) {//selectFlagとLupFlagは本来は別物　しかしLupのときだけ処理するものがある
				if (s_editmotionflag < 0) {
					int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
					if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
						_ASSERT(0);
						::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
						PostQuitMessage(result);
					}
				}

				OnTimeLineButtonSelectFromSelectStartEnd(0);

				//2022/09/13
				if (s_owpLTimeline) {
					//s_editmotionflag = s_curboneno;
					s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
					//CEditRange::SetApplyRate(g_applyrate);

					if (s_undoredoFromPlayerButton == false) {
						PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
					}
					else {
						//playerbuttonからのundoredo時には　SaveUndoMotionしない
						s_undoredoFromPlayerButton = false;
					}

				}
			}
		}
		s_selectFlag = false;
	}

	if (s_LupFlag) {
		if (s_owpLTimeline) {
			if (g_previewFlag == 0) {
				//###################################################
				//prevrange nextrangeは　undo redo処理に変わりました
				//選択範囲だけの　履歴機能は　コメントアウト
				//###################################################
				//if (s_prevrangeFlag || s_nextrangeFlag) {
				//	RollBackEditRange(s_prevrangeFlag, s_nextrangeFlag);
				//	s_buttonselectstart = s_editrange.GetStartFrame();
				//	s_buttonselectend = s_editrange.GetEndFrame();

				//	g_underselectingframe = 0;

				//	if (s_editmotionflag < 0) {
				//		int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				//		if (result) {
				//			_ASSERT(0);
				//		}
				//	}

				//	OnTimeLineButtonSelectFromSelectStartEnd(0);

				//	//2022/09/13
				//	if (s_owpLTimeline) {
				//		//s_editmotionflag = s_curboneno;
				//		s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
				//		CEditRange::SetApplyRate((double)g_applyrate);
				//		PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
				//	}

				//}
			}
			else {
				//再生ボタンが押されたとき
				//_ASSERT(0);
				s_buttonselectstart = s_editrange.GetStartFrame();
				s_buttonselectend = s_editrange.GetEndFrame();
				g_underselectingframe = 0;
				//_ASSERT(0);

				int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
				if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
					_ASSERT(0);
					::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
					PostQuitMessage(result);
				}

				OnTimeLineButtonSelectFromSelectStartEnd(0);

			}
		}

		s_LstartFlag = false;
		g_selecttolastFlag = false;
		s_prevrangeFlag = false;
		s_nextrangeFlag = false;


		s_LupFlag = false;
	}


	if (s_LcursorFlag) {
		OnTimeLineCursor();

		if (s_chascene && s_owpLTimeline && s_model && s_model->ExistCurrentMotion()) {
			if (g_previewFlag == 0) {//underchecking
				double curframe = s_owpLTimeline->getCurrentTime();// 選択時刻
				s_chascene->SetMotionFrame(-1, curframe);
			}
		}


		//2024/06/15
		//モーフスライダーの位置を更新
		//毎フレーム呼ぶと重いので　フレーム変更時に呼ぶ
		if (g_edittarget == EDITTARGET_MORPH) {
			s_blendshapedlg.ParamsToDlg();
		}


		//bool updateonlycheckeul = true;
		//OnFrameAngleLimit(updateonlycheckeul);//2022/12/30 commentout OnFrameUserMove()にて毎フレームupdateonlycheckeul = trueで呼び出す 

		s_LcursorFlag = false;
	}


	if (s_LstopFlag) {
		//停止ボタンが押されたとき
		//_ASSERT(0);
		//s_buttonselectstart = s_editrange.GetStartFrame();
		//s_buttonselectend = s_editrange.GetEndFrame();

		SetButtonStartEndFromPlaying();

		g_underselectingframe = 0;
		//_ASSERT(0);

		//int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
		//if (result) {
		//	_ASSERT(0);
		//}

		OnTimeLineButtonSelectFromSelectStartEnd(0);
		//_ASSERT(0);

		if (s_owpLTimeline && s_owpEulerGraph) {
			//プレビュー後に　CallRewrite --> InvalidateRect --> draw()を呼ぶため
			double currenttime = s_owpLTimeline->getCurrentTime();
			s_owpLTimeline->setCurrentTime(currenttime, false, true);
			s_owpEulerGraph->setCurrentTime(currenttime, false, true);
		}

		s_LstopFlag = false;
	}




	// キー移動フラグを確認 ///////////////////////////////////////////////////////////
	//if (s_keyShiftFlag){
	s_keyShiftFlag = false;
	//}

	return 0;
}

int OnFrameMouseButton()
{
	if (s_timelinembuttonFlag || g_ctrlshiftkeyformb) {
		s_timelinembuttonFlag = false;
		OnTimeLineMButtonDown(g_ctrlshiftkeyformb);
		g_ctrlshiftkeyformb = false;
	}
	if (s_timelinewheelFlag || (g_underselectingframe && ((g_keybuf['A'] & 0x80) || (g_keybuf['D'] & 0x80)))) {
		//if (s_timelinewheelFlag || (g_underselectingframe == 1) || (g_underselectingframe == 2)) {//wheeldeltaの値は取得後も消えない仕様のためこの条件だと止まらなくなる
		s_timelinewheelFlag = false;//OnTimeLineWheelの後ろにするとホイールしない？？？
		OnTimeLineWheel();
	}

	if (s_timelineshowposFlag) {
		s_timelineshowposFlag = false;//以下の処理の後にするとホイールしない？？？

		if (s_owpLTimeline) {
			s_owpLTimeline->WheelShowPosTime();
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->WheelShowPosTime();
			refreshEulerGraph();
			//s_tum.UpdateEditedEuler(refreshEulerGraph);//非ブロッキング
		}

	}


	if (s_timelineRUpFlag) {//s_timelineWnd
		s_timelineRUpFlag = false;

		GetCurrentBoneFromTimeline(&s_curboneno);
		if (s_curboneno > 0) {
			BoneRClick(s_curboneno);
		}
	}

	return 0;
}

int OnFrameToolWnd()
{

	//2024/06/18
	if (s_SpriteButtonDown) {
		//2024/06/18
		//スプライトボタンを押した状態を表示してから処理を行うために
		//s_SpriteButtonDownがtrueの場合は何もしないで1周回して　次の周回で処理を行う
		s_SpriteButtonDown = false;
		return 0;
	}


	OnFrameBlendShape();


	//2024/06/18 undo, redoはOnFrameUndo()で処理
	//if (s_undoFlag || s_redoFlag) {
	//	s_pickinfo.buttonflag = 0;
	//	s_ikcnt = 0;
	//	s_onragdollik = 0;
	//
	//	OnSpriteUndo();
	//}



	if (s_topslidersEditRateFlag) {
		if (s_topSlidersWnd && s_owpEditRateSlider) {
			float val = (float)s_owpEditRateSlider->getValue();
			g_physicsmvrate = val;
			s_topSlidersWnd->callRewrite();//再描画

			//if (s_guidlg[GUIDLG_DISP_AND_LIMITS] && 
			//	GetDlgItem(s_guidlg[GUIDLG_DISP_AND_LIMITS], IDC_SLIDER_EDITRATE) && 
			//	GetDlgItem(s_guidlg[GUIDLG_DISP_AND_LIMITS], IDC_STATIC_EDITRATE)) {
			//	SendMessage(GetDlgItem(s_guidlg[GUIDLG_DISP_AND_LIMITS], IDC_SLIDER_EDITRATE), 
			//		TBM_SETPOS, (WPARAM)TRUE, (LPARAM)(int)((double)g_physicsmvrate * 10.0));
			//
			//	//text
			//	WCHAR strdlg[256] = { 0L };
			//	swprintf_s(strdlg, 256, L"EditRate %.1f", g_physicsmvrate);
			//	SetDlgItemText(s_guidlg[GUIDLG_DISP_AND_LIMITS], IDC_STATIC_EDITRATE, strdlg);
			//}
		}
	}
	if (s_topslidersSpeedFlag) {
		if (s_topSlidersWnd && s_owpSpeedSlider) {
			//double val = s_owpSpeedSlider->getValue();
			//g_dspeed = val;
			//if (s_guidlg[GUIDLG_DISP_AND_LIMITS]) {
			//	HWND speedwnd = GetDlgItem(s_guidlg[GUIDLG_DISP_AND_LIMITS], IDC_SLIDER_SPEED);
			//	if (speedwnd && IsWindow(speedwnd)) {
			//		SendMessage(speedwnd, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)(int)(g_dspeed * 100.0));
			//	}
			//
			//	//text
			//	WCHAR strdlg[256] = { 0L };
			//	swprintf_s(strdlg, 256, L"Speed %.2f", g_dspeed);
			//	SetDlgItemText(s_guidlg[GUIDLG_DISP_AND_LIMITS], IDC_STATIC_SPEED, strdlg);
			//}
			OnSetMotSpeed();
			s_topSlidersWnd->callRewrite();//再描画
		}
		s_topslidersSpeedFlag = false;
	}

	//if (s_topslidersTopPosFlag) {
	//	if (s_topSlidersWnd && s_owpTopPosSlider) {
	//		double val = s_owpTopPosSlider->getValue();
	//		g_applyrate = val;
	//		
	//		if (s_editmotionflag < 0) {//IK中でないとき
	//			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
	//			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
	//				_ASSERT(0);
	//				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
	//				PostQuitMessage(result);
	//			}
	//			//PrepairUndo();//保存はOnFrameUtCheckBoxにて
	//		}			
	//		s_topSlidersWnd->callRewrite();//再描画
	//	}
	//
	//	s_topslidersTopPosFlag = false;
	//}


	if (s_camdistsliderflag) {
		s_camdistsliderflag = false;

		s_camdistsliderval = (float)fmin(s_camdistsliderval, s_maxcamdist);
		s_camdistsliderval = (float)fmax(s_camdistsliderval, 0.0);

		ChangeCameraDist(s_camdistsliderval, s_moveeyepos, true);
	}

	if (s_toonparamchange) {
		s_toonparamchange = false;
		if (s_model) {
			if (s_toonmqomaterial) {
				s_toonmqomaterial->RemakeDiffuseTexture();
			}
			else {
				int materialnum = s_model->GetMQOMaterialSize();
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->RemakeDiffuseTexture();
					}
				}
			}
		}
	}

	if (s_skytoonparamchange) {
		s_skytoonparamchange = false;
		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			int materialindex2;
			for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
				CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
				if (setmqomat) {
					setmqomat->RemakeDiffuseTexture();
				}
			}
		}
	}


	if (s_frogFlag) {
		ChangeToNextPlateMenuKind(s_platemenukind, s_platemenuno);
		s_frogFlag = false;
	}
	if (s_plateFlag) {
		ChangeToNextPlateMenuPlate(s_platemenukind, s_platemenuno);
		s_plateFlag = false;
	}

	if (s_camtargetOnceflag) {	
		if (s_model && (s_curboneno >= 0)) {

			int curmotid = s_model->GetCurrentMotID();
			bool cameraanimflag = s_model->IsCameraMotion(curmotid);
			if (cameraanimflag) {
				//jointの位置はjointのモーションに依存するから
				::MessageBox(s_3dwnd, L"カメラモーション以外を選択してから再試行してください.", L"CurrentMotion is Camera warning",
					MB_OK | MB_ICONINFORMATION);
			}
			else {
				AutoCameraTarget();

				//2024/08/02
				//Lock2Joint操作時には　カメラアニメオンまたはカメラグラフモードの場合に　カメラアニメを編集
				if (s_cameramodel && (s_spcameramode.state || (g_edittarget == EDITTARGET_CAMERA))) {
					if (s_camtargetflag) {
						//always s_editrange全範囲に対してウェイト1.0でLock2Joint処理.ジョイントのモーションにも対応
						s_editcameraflag = s_cameramodel->CameraAnimLock2Joint(&s_editrange, s_model, s_curboneno);
					}
					else {
						//once applyframeに対してLock2Joint、applyframe以外はbrushウェイト分だけLock2Joint.applyframe時のジョイント位置を使用
						s_editcameraflag = s_cameramodel->CameraAnimDiffRotMatView(&s_editrange, s_befLockMatView, s_matView);
					}

					s_cameramodel->GetCameraAnimParams(s_cameraframe,
						g_camdist,
						&g_camEye, &g_camtargetpos, &g_cameraupdir,
						0, g_cameraInheritMode);//g_camdist

					ChaVector3 diffvec = g_camtargetpos - g_camEye;
					float newcamdist = (float)ChaVector3LengthDbl(&diffvec);
					ChangeCameraDist(newcamdist, false, false);
				}

				UpdateEditedEuler();
				PrepairUndo();
			}

			s_camtargetOnceflag = 0;//AutoCameraTarget()呼び出しよりも後で初期化

		}
	}


	//DispGroupWnd チェックボックスを右クリック　類似をチェックするためのコンテクストメニューを出す
	if (s_dispgroupdlg.GetDispGroupCheckSimilarFlag()) {
		CheckSimilarMenu();
		s_dispgroupdlg.SetDispGroupCheckSimilarFlag(false);
	}



	if (s_selecthand == 1) {
		if (s_model) {
			CBone* selbone = 0;
			selbone = s_model->FindBoneByPattern("L_Hand");
			if (!selbone) {
				selbone = s_model->FindBoneByPattern("LeftHand");
			}
			if (selbone) {
				s_curboneno = selbone->GetBoneNo();

				if (s_owpTimeline) {
					s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
				}

				ChangeCurrentBone(true);
			}
		}
		s_selecthand = 0;
	}
	if (s_selecthand == 2) {
		if (s_model) {
			CBone* selbone = 0;
			selbone = s_model->FindBoneByPattern("R_Hand");
			if (!selbone) {
				selbone = s_model->FindBoneByPattern("RightHand");
			}
			if (selbone) {
				s_curboneno = selbone->GetBoneNo();

				if (s_owpTimeline) {
					s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
				}

				ChangeCurrentBone(true);
			}
		}
		s_selecthand = 0;
	}
	if (s_selectfoot == 1) {
		if (s_model) {
			CBone* selbone = 0;
			selbone = s_model->FindBoneByPattern("L_Foot");
			if (!selbone) {
				selbone = s_model->FindBoneByPattern("LeftFoot");
			}
			if (selbone) {
				s_curboneno = selbone->GetBoneNo();

				if (s_owpTimeline) {
					s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
				}

				ChangeCurrentBone(true);
			}
		}
		s_selectfoot = 0;
	}
	if (s_selectfoot == 2) {
		if (s_model) {
			CBone* selbone = 0;
			selbone = s_model->FindBoneByPattern("R_Foot");
			if (!selbone) {
				selbone = s_model->FindBoneByPattern("RightFoot");
			}
			if (selbone) {
				s_curboneno = selbone->GetBoneNo();

				if (s_owpTimeline) {
					s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
				}

				ChangeCurrentBone(true);
			}
		}
		s_selectfoot = 0;
	}




	//操作対象ボーンはs_selbonedlg::GetCpVec()にて取得。

	if (s_selboneFlag) {
		int result = -1;

		if (s_model && s_owpTimeline && s_owpLTimeline) {
			CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg(false);
			if (curcpdlg) {
				curcpdlg->SetModel(s_model);
				s_underframecopydlg = true;
				result = (int)curcpdlg->DoModal();
				s_underframecopydlg = false;
			}
		}

		s_selboneFlag = false;
		if ((result == IDOK) && (s_selboneAndPasteFlag == true) && (s_pasteFlag == false)) {
			s_pasteFlag = true;
		}
		s_selboneAndPasteFlag = false;
	}

	//if (s_180DegFlag) {
	//	//if (s_model && (s_curboneno >= 0)) {
	//	//	CBone* curbone = 0;
	//	//	CBone* adjustbone = 0;
	//	//	if (s_curboneno >= 0) {
	//	//		curbone = s_model->GetBoneByID(s_curboneno);
	//	//	}
	//	//	else {
	//	//		curbone = 0;
	//	//	}
	//	//	if (curbone) {
	//	//		if (curbone->GetParent()) {
	//	//			adjustbone = curbone->GetParent();
	//	//		}
	//	//		else {
	//	//			adjustbone = curbone;
	//	//		}
	//	//	}

	//	//	if (adjustbone) {
	//	//		s_model->Adjust180DegReq(adjustbone);
	//	//		refreshEulerGraph();
	//	//		PrepairUndo();//2022/10/27
	//	//	}
	//	//}
	//	s_180DegFlag = false;
	//}

	if (s_scaleAllInitFlag) {
		if (s_model && s_model->ExistCurrentMotion()) {

			PrepairUndo();//全フレーム変更の前に全フレーム保存

			//長いフレームの処理は数秒時間がかかることがあるので砂時計カーソルにする
			HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

			double motleng = s_model->GetCurrentMaxFrame();
			double frame;
			for (frame = 0.0; frame < motleng; frame += 1.0) {
				if (s_model->GetTopBone()) {
					s_model->SetMotionFrame(frame);
					bool broflag = false;
					InitMpByEulReq(INITMP_SCALE, s_model->GetTopBone(false), s_model->GetCurrentMotID(), frame, broflag);
				}
			}

			////2023/02/13
			////フィルターで滑らかに
			//int callnum = 1;
			//CallFilterFunc(callnum);
			MOTINFO curmi = s_model->GetCurMotInfo();
			bool copylw2w = true;
			FilterNoDlg(copylw2w, s_model, curmi.motid);

			//カーソルを元に戻す
			SetCursor(oldcursor);

			//PrepairUndo();//全フレーム変更後に全フレーム保存 //FilterNoDlg内部から呼ぶ
		}
		s_scaleAllInitFlag = false;
	}


	if (s_markFlag) {

		if (s_model && s_owpTimeline && s_owpLTimeline) {
			double curltime = s_owpLTimeline->getCurrentTime();
			KeyInfo ki = s_owpLTimeline->ExistKey(2, curltime);
			if (ki.lineIndex < 0) {
				s_owpLTimeline->newKey(s_strmark, curltime, 0);
			}
		}

		s_markFlag = false;
	}

	if (s_initmpFlag) {
		InitMpFromTool();
		//s_initmpFlag = false;//InitMpFromTool()はコンテクストメニューを出す　実際の処理の部分でフラグを参照する　フラグリセットは処理部で行う
	}
	if (s_initmpcameraFlag) {
		InitMpFromTool();
		//s_initmpcameraFlag = false;//InitMpFromTool()はコンテクストメニューを出す　実際の処理の部分でフラグを参照する　フラグリセットは処理部で行う
	}

	if (s_skipJointMark != 0) {

		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->ExistCurrentMotion()) {
			CBone* curbone = 0;
			if (s_curboneno >= 0) {
				curbone = s_model->GetBoneByID(s_curboneno);
			}
			else {
				curbone = 0;
			}

			SkipJointMarkReq(s_skipJointMark, curbone, false);
			s_model->SetBtObjectVec();//2024/06/16
		}

		s_skipJointMark = 0;
	}

	if (s_cameradollyFlag) {
		if (s_model) {
			ShowCameraDollyDlg();
		}
		s_cameradollyFlag = false;
	}
	if (s_materialrateFlag) {
		if (s_model) {
			ShowMaterialRateDlg();
		}
		s_materialrateFlag = false;
	}
	if (s_modelworldmatFlag) {
		if (s_model) {
			ShowModelWorldMatDlg();
		}
		s_modelworldmatFlag = false;
	}
	if (s_jumpgravityFlag) {
		ShowJumpGravityDlg();
		s_jumpgravityFlag = false;
	}

	OnFrameShaderTypeParamsDlg();

	OnFrameSkyParamsDlg();

	if (s_fogparamsFlag) {
		s_fogparamsFlag = false;
		s_platemenukind = SPPLATEMENUKIND_EFFECT;
		s_platemenuno = 2;
		s_guiswflag = false;//2段目メニューを右ペインに表示するときfalse
		GUIMenuSetVisible(s_platemenukind, 2);
	}
	if (s_dofparamsFlag) {
		s_dofparamsFlag = false;
		s_platemenukind = SPPLATEMENUKIND_EFFECT;
		s_platemenuno = 3;
		s_guiswflag = false;//2段目メニューを右ペインに表示するときfalse
		GUIMenuSetVisible(s_platemenukind, 3);
	}

	if (s_interpolateFlag) {
		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->ExistCurrentMotion()) {
			InterpolateFromTool();//コンテクストメニューを出してから処理
		}
		s_interpolateFlag = false;
	}
	if (s_interpolatecameraFlag) {
		if (s_cameramodel && s_owpTimeline && s_owpLTimeline) {
			MOTINFO curmi = GetCameraMotInfo();
			if (curmi.motid > 0) {
				//2024/06/24
				//カメラアニメの場合はメニューを選択する必要が無いので　コンテクストメニューをスキップして　直接処理関数を呼び出す
				s_interpolateState = 1;//all bone
				InterpolateMotionFunc(s_cameramodel, &curmi);
			}
		}
		s_interpolatecameraFlag = false;
	}

	if (s_jumpinterpolateFlag) {
		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->ExistCurrentMotion()) {
			s_jumpgravityFlag = true;//<-- gravity設定モードレスダイアログ表示トリガー
			JumpInterpolateFromTool();
		}
		s_jumpinterpolateFlag = false;
	}



	if ((s_opedelmodelcnt >= 0) && (s_underdelmodel == true)) {
		int modelcnt = s_opedelmodelcnt;
		bool ondelbutton = true;
		OnDelModel(modelcnt, ondelbutton);//s_modelpanel.modelindexはs_modelのindexなので違う

		s_opedelmodelcnt = -1;
		s_underdelmodel = false;
	}
	if ((s_opeselectmodelcnt >= 0) && s_modelpanel.panel) {
		s_modelpanel.modelindex = s_opeselectmodelcnt;
		//OnModelMenu(true, s_modelpanel.modelindex, 1);
		bool forceflag = true;
		bool callundo = true;
		OnChangeModel(s_modelpanel.modelindex, forceflag, callundo);
		s_modelpanel.panel->callRewrite();

		s_opeselectmodelcnt = -1;
	}

	if ((s_opedispmodelcnt >= 0) && s_underdispmodel && s_modelpanel.panel) {
		int modelcnt = s_opedispmodelcnt;
		OnDispModel(modelcnt);

		s_opedispmodelcnt = -1;
		s_underdispmodel = false;
	}


	if ((s_opedelmotioncnt >= 0) && (s_underdelmotion == true)) {
		int delmenuindex = s_opedelmotioncnt;
		bool ondelbutton = true;
		OnDelMotion(delmenuindex, ondelbutton);

		s_opedelmotioncnt = -1;
		s_underdelmotion = false;
	}
	if ((s_opeselectcameracnt >= 0) && s_camerapanel.panel) {
		int cameraindex = s_opeselectcameracnt;
		OnCameraMenu(true, cameraindex, 1);
		s_camerapanel.panel->callRewrite();

		s_opeselectcameracnt = -1;
	}
	if ((s_opeselectmotioncnt >= 0) && s_motionpanel.panel) {
		int motionindex = s_opeselectmotioncnt;
		OnAnimMenu(true, motionindex, 1);
		s_motionpanel.panel->callRewrite();

		s_opeselectmotioncnt = -1;
	}



	if (s_selCopyHisotryFlag) {

		//GUIMenuSetVisible(-1, -1);
		bool closefirstrow = true;
		CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる
		if (s_model) {
			//2024/07/25
			//OnModelMenu()とモーションコピー時にSetNames()を呼んでいるのでここでは呼ばない
			//ここで呼ばない方がウインドウ状態を閉じる前と同じ状態にすることができる
			//int result1 = GetCPTFileName(s_cptfilename);
			//_ASSERT(result1 == 0);
			//int result2 = s_copyhistorydlg2.SetNames(s_model, s_cptfilename);
			//_ASSERT(result2 == 0);

			s_copyhistorydlg2.SetVisible(true);
		}

		s_selCopyHisotryFlag = false;
	}

	if (s_copyLW2WFlag) {
		if (s_model && s_model->GetTopBone()) {

			int operatingjointno = s_model->GetTopBone(false)->GetBoneNo();

			PrepairUndo();//全フレーム変更するので　変更前にも保存

			bool allframeflag = true;
			bool setcursorflag = true;
			bool onpasteflag = false;
			CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);

			PrepairUndo();//変更後を保存

			refreshEulerGraph();
		}
		s_copyLW2WFlag = false;
	}

	if (s_copyFlag) {
		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->ExistCurrentMotion()) {
			MOTINFO curmi = s_model->GetCurMotInfo();
			if (curmi.motid > 0) {
				//CopyMotionFunc(s_model, &curmi);
				DispCpInfoDlg2(s_model, &curmi, 0);
			}
		}
		s_copyFlag = false;
		s_undersymcopyFlag = false;
	}
	if (s_copycameraFlag) {
		if (s_cameramodel && s_owpTimeline && s_owpLTimeline) {
			MOTINFO curmi = GetCameraMotInfo();
			if (curmi.motid > 0) {
				//CopyMotionFunc(s_cameramodel, &curmi);
				DispCpInfoDlg2(s_model, &curmi, 1);
			}
		}
		s_copycameraFlag = false;
		s_undersymcopyFlag = false;
	}

	if (s_symcopyFlag2) {

		//s_symcopyFlagでメニューを出し　１周回ってからのコンテクストメニュー実行後の　s_symcopyFlag2

		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->ExistCurrentMotion()) {
			MOTINFO curmi = s_model->GetCurMotInfo();
			if (curmi.motid > 0) {
				DispCpInfoDlg2(s_model, &curmi, 2);
			}
		}

		s_symcopyFlag2 = false;
		s_symcopyFlag = false;
		s_undersymcopyFlag = true;
	}

	if (s_symcopyFlag) {
		if (s_model && s_owpTimeline && s_owpLTimeline && s_model->ExistCurrentMotion()) {
			
			GetSymRootMode();//この関数が返った時点では　まだMsgProcでs_getsym_retmodeがセットされていない

			if (s_symcopyFlag2 == false) {

				//Flag2をセットして１周回す
				s_symcopyFlag2 = true;
			}
		}
		//s_symcopyFlag = false;
		//s_undersymcopyFlag = true;
	}


	if (s_RboneAndPasteFlag) {
		if (s_curboneno >= 0) {
			SetRJoint(s_curboneno);
			//s_RboneAndPasteFlag = false;//if(s_pasteFlag)ブロックの終わりで初期化する
			s_pasteFlag = true;
		}
	}


	if (s_pasteFlag) {

		HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));//長いフレームの保存は数秒時間がかかることがあるので砂時計カーソルにする

		if (s_model) {
			MOTINFO curmi = s_model->GetCurMotInfo();
			if (curmi.motid > 0) {
				PasteMotionFunc(s_model, &curmi);
			}
		}

		s_RboneAndPasteFlag = false;
		s_pasteFlag = false;

		if (oldcursor) {
			SetCursor(oldcursor);
		}
	}
	if (s_pastecameraFlag) {

		HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));//長いフレームの保存は数秒時間がかかることがあるので砂時計カーソルにする

		if (s_cameramodel) {
			MOTINFO curmi = GetCameraMotInfo();
			if (curmi.motid > 0) {
				PasteMotionFunc(s_cameramodel, &curmi);
			}
		}

		s_RboneAndPasteFlag = false;
		s_pastecameraFlag = false;

		if (oldcursor) {
			SetCursor(oldcursor);
		}
	}


	if (s_motpropFlag) {

		if (s_model && s_model->ExistCurrentMotion()) {
			int dlgret;
			dlgret = (int)DialogBoxW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_MOTPROPDLG),
				s_3dwnd, (DLGPROC)MotPropDlgProc);
			if ((dlgret == IDOK) && s_tmpmotname[0]) {

				//MOTINFO curmi = GetEditTargetMotInfo();

				//モーションプロパティ機能はモーションパネルで選択中のモーションに対して処理をする
				//カメラパネル内のモーションはモーションパネル内にも存在するので　カメラモーションの名前を変える場合にも　モーションパネルで選択して実行する
				MOTINFO curmi = s_model->GetCurMotInfo();
				if (curmi.motid > 0) {
					if (s_model) {//motpropはs_modelのカレントモーションに対して処理
						
						char newmotionname[256] = { 0L };
						WideCharToMultiByte(CP_ACP, 0, s_tmpmotname, -1, newmotionname, 256, NULL, NULL);
						newmotionname[255] = 0;
						int newnamelen = (int)strlen(newmotionname);
						if (newnamelen > 0) {
							s_model->SetMotionName(curmi.motid, newmotionname);
						}
						
						//s_model->m_curmotinfo->frameleng = s_tmpmotframeleng;
						//s_model->SetMotInfoLoopFlagByIndex(curmi.motid, s_tmpmotloop);//!!! index
						s_model->SetMotInfoLoopFlagByID(curmi.motid, s_tmpmotloop);//!!! motid
						double oldframeleng = curmi.frameleng;

						if (s_owpTimeline) {
							s_owpTimeline->setMaxTime(s_tmpmotframeleng);
						}
						s_model->ChangeMotFrameLeng(curmi.motid, s_tmpmotframeleng);//はみ出たmpも削除
						InitCurMotion(0, oldframeleng);

						//メニュー書き換え, timeline update
						OnAnimMenu(true, s_motmenuindexmap[s_model]);
					}
				}
			}
		}

		s_motpropFlag = false;
	}

	if (s_retargetdlg.GetRetargetRetargetGUIFlag()) {
		if (s_model && s_model->ExistCurrentMotion()) {

			HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

			s_limiteuldlg.SetSaveLimitDegFlag(g_limitdegflag);
			//ChangeLimitDegFlag(false, true, true);//2023/10/23　1.2.0.27_RC2にて コメントアウト
			s_saveretargetmodel = s_curmodelmenuindex;//終了時にOnModelMenuを呼ぶために保存

			RetargetMotion();

			////ChangeLimitDegFlag(s_savelimitdegflag, true, true);//2023/10/23　1.2.0.27_RC2にて コメントアウト
			//OnModelMenu(true, s_saveretargetmodel, 1);
			bool forceflag = true;
			bool callundo = true;
			OnChangeModel(s_saveretargetmodel, forceflag, callundo);


			if (oldcursor) {
				SetCursor(oldcursor);
			}
		}

		s_retargetdlg.SetRetargetRetargetGUIFlag(false);
	}


	if (s_filterFlag) {//ToolWindowの平滑化ボタン用
		FilterFromTool();
		s_filterFlag = false;
	}

	if (s_smoothFlag) {//s_spsmoothボタン用
		if (s_model && s_model->ExistCurrentMotion()) {
			MOTINFO curmi = s_model->GetCurMotInfo();
			if (curmi.motid > 0) {
				//PrepairUndo();

				//ギザギザを平滑化
				bool copylw2w = true;
				FilterNoDlg(copylw2w, s_model, curmi.motid);

				//PrepairUndo();//FilterNoDlg内部から呼ぶ
			}
		}
		s_smoothFlag = false;
	}
	if (s_smoothcameraFlag) {//s_spsmooth_cameraボタン用
		if (s_cameramodel) {
			MOTINFO curmi = GetCameraMotInfo();
			if (curmi.motid > 0) {
				int savefilterState = s_filterState;
				s_filterState = 1;//!!! all bone

				//PrepairUndo();

				//ギザギザを平滑化
				bool copylw2w = true;
				FilterNoDlg(copylw2w, s_cameramodel, curmi.motid);

				//PrepairUndo();//FilterNoDlg内部から呼ぶ
				s_filterState = savefilterState;
			}
		}
		s_smoothcameraFlag = false;
	}

	if (s_constexeFlag) {//s_spconstexeボタン用
		if (s_model && s_model->ExistCurrentMotion() && s_model->GetTopBone()) {

			HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
			OnTimeLineButtonSelectFromSelectStartEnd(0);
			OnTimeLineSelectFromSelectedKey();
			s_model->PosConstraintExecuteFromButton(g_limitdegflag, &s_editrange);

			//ギザギザを平滑化
			MOTINFO curmi = s_model->GetCurMotInfo();
			bool copylw2w = true;
			FilterNoDlg(copylw2w, s_model, curmi.motid);

			if (oldcursor) {
				SetCursor(oldcursor);
			}
		}
		s_constexeFlag = false;
	}
	if (s_constrefreshFlag) {//s_spconstexeボタン用
		if (s_model && s_model->ExistCurrentMotion()) {

			s_model->RefreshPosConstraint();

			//PrepairUndo();
		}
		s_constrefreshFlag = false;
	}


	if (s_btresetFlag == true) {
		if (s_model) {
			StartBt(s_model, TRUE, 2, 1);//flag = 2 --> resetflag = 1
		}

		s_btresetFlag = false;
	}

	if (s_newmotFlag == true) {
		AddMotion(0);
		s_newmotFlag = false;
	}

	if (s_delcurmotFlag == true) {
		s_underdelmotion = true;
		OnDelMotion(s_motmenuindexmap[s_model]);
		s_underdelmotion = false;
		s_delcurmotFlag = false;
	}

	if (s_delmodelFlag == true) {
		s_underdelmodel = true;
		OnDelModel(s_curmodelmenuindex);
		s_underdelmodel = false;
		s_delmodelFlag = false;
	}
	if (s_delallmodelFlag == true) {
		s_underdelmodel = true;
		OnDelAllModel();
		s_underdelmodel = false;
		s_delallmodelFlag = false;
	}


	if (s_deleteFlag) {
		s_deleteFlag = false;
		/***
		if( s_model && s_owpTimeline && s_model->m_curmotinfo){
		s_owpTimeline->deleteKey();
		//motionpointのdeleteはdelete Listenerでする。
		s_model->SaveUndoMotion(s_curboneno, s_curbaseno, &s_editrange, (double)g_applyrate);
		}
		***/
	}


	// 削除されたキー情報のスタックを確認 ////////////////////////////////////////////
	for (; s_deletedKeyInfoList.begin() != s_deletedKeyInfoList.end();
		s_deletedKeyInfoList.pop_front()) {
		/***
		CMotionPoint* mpptr = (CMotionPoint*)( s_deletedKeyInfoList.begin()->object );
		CBone* boneptr = s_model->m_bonelist[ s_lineno2boneno[ s_deletedKeyInfoList.begin()->lineIndex ] ];
		mpptr->LeaveFromChain( s_model->m_curmotinfo->motid, boneptr );
		//_ASSERT( 0 );
		delete mpptr;
		***/
	}

	return 0;
}

int SetRJoint(int srcboneno)
{
	s_pasteRJoint.clear();

	if (!s_model) {
		return 0;
	}

	CBone* startbone = s_model->GetBoneByID(srcboneno);
	if (startbone) {
		AddRJointReq(startbone);
	}
	return 0;

}
void AddRJointReq(CBone* srcbone)
{
	if (!s_model) {
		return;
	}

	if (srcbone) {
		s_pasteRJoint.push_back(srcbone);

		if (srcbone->GetChild(false)) {
			AddRJointReq(srcbone->GetChild(false));
		}
		if (srcbone->GetBrother(false)) {
			AddRJointReq(srcbone->GetBrother(false));
		}
	}

}

//int CreateCopyHistoryDlg()
//{
//	if (s_copyhistorydlg.GetCreatedFlag() == false) {
//		s_copyhistorydlg.Create(g_mainhwnd);
//	}
//	SetParent(s_copyhistorydlg.m_hWnd, g_mainhwnd);
//
//	int windowposx;
//	if (g_4kresolution) {
//		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
//	}
//	else {
//		windowposx = s_timelinewidth + s_mainwidth;
//	}
//
//
//	SetWindowPos(
//		s_copyhistorydlg.m_hWnd,
//		HWND_TOP,
//		windowposx,
//		s_sidemenuheight,
//		s_sidewidth,
//		s_sideheight,
//		SWP_SHOWWINDOW
//	);
//
//	s_copyhistorydlg.ShowWindow(SW_HIDE);
//
//	s_copyhistorydlg.ParamsToDlg(s_model);
//	GetCPTFileName(s_cptfilename);
//	s_copyhistorydlg.SetNames(s_model, s_cptfilename);
//
//	return 0;
//}
int CreateDollyHistoryDlg()
{
	//dollyhistorydlg2の作成は位置とサイズが決まってg_mainhwndがセットされた後で
	s_dollyhistorydlg2.SetUpdateFunc(UpdateCameraPosAndTarget, OnCameraAnimPaste);
	std::vector<DOLLYELEM2> vecdolly;
	vecdolly.clear();
	//s_dollyhistorydlg2.SetOnShow(true);//2024/02/27 ダイアログを出したときにカメラが動いてしまうのを防止
	s_dollyhistorydlg2.LoadDollyHistory(vecdolly);
	s_dollyhistorydlg2.SetNames(vecdolly);

	return 0;
}


void ResetPasteDoneFlagReq(CBone* srcbone)
{
	if (!s_model || !srcbone) {
		_ASSERT(0);
		return;
	}

	srcbone->SetPasteDoneFlag(false);

	if (srcbone->GetChild(false)) {
		ResetPasteDoneFlagReq(srcbone->GetChild(false));
	}
	if (srcbone->GetBrother(false)) {
		ResetPasteDoneFlagReq(srcbone->GetBrother(false));
	}
}

CMotionPoint CalcPasteMotionPoint(CBone* srcbone, double srcframe, double srcframe2, double interpolaterate)
{
	CMotionPoint retmp;
	retmp.InitParams();

	if (!s_model) {
		_ASSERT(0);
		return retmp;
	}

	CMotionPoint mp0;
	CMotionPoint mp1;
	mp0.InitParams();
	mp1.InitParams();
	bool getflag0 = false;
	bool getflag1 = false;
	vector<CPELEM2>::iterator itrcp;
	for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
		CBone* chkbone = itrcp->bone;
		if (chkbone && (chkbone == srcbone)) {
			CMotionPoint srcmp = itrcp->mp;
			if (!getflag0 && IsEqualRoundingTime(srcmp.GetFrame(), srcframe)) {
				mp0 = itrcp->mp;
				getflag0 = true;
			}
			if (!getflag1 && IsEqualRoundingTime(srcmp.GetFrame(), srcframe2)) {
				mp1 = itrcp->mp;
				getflag1 = true;
			}
			if (getflag0 && getflag1) {
				break;
			}
		}
	}

	if (!getflag0) {
		_ASSERT(0);
		return retmp;
	}

	if (!getflag1 || (interpolaterate == 0.0)) {
		retmp = mp0;
	}
	else {
		if (srcbone->IsSkeleton()) {
			ChaMatrix resultwm;
			ChaMatrix wm0;
			ChaMatrix wm1;
			resultwm.SetIdentity();
			wm0.SetIdentity();
			wm1.SetIdentity();

			wm0 = mp0.GetWorldMat();
			wm1 = mp1.GetWorldMat();
			resultwm = (wm0 * (1.0 - interpolaterate)) + (wm1 * interpolaterate);

			retmp = mp0;
			retmp.SetWorldMat(resultwm);
		}
		else {
			ChaMatrix resultwm;
			ChaMatrix wm0;
			ChaMatrix wm1;
			resultwm.SetIdentity();
			wm0.SetIdentity();
			wm1.SetIdentity();
			wm0 = mp0.GetWorldMat();
			wm1 = mp1.GetWorldMat();
			resultwm = (wm0 * (1.0 - interpolaterate)) + (wm1 * interpolaterate);

			ChaMatrix resultlcl;
			ChaMatrix lcl0;
			ChaMatrix lcl1;
			resultlcl.SetIdentity();
			lcl0.SetIdentity();
			lcl1.SetIdentity();
			lcl0 = mp0.GetLocalMat();
			lcl1 = mp1.GetLocalMat();
			resultlcl = (lcl0 * (1.0 - interpolaterate)) + (lcl1 * interpolaterate);

			retmp = mp0;
			retmp.SetWorldMat(resultwm);
			retmp.SetLocalMat(resultlcl);
			retmp.SetLimitedWM(resultwm);
		}
	}

	return retmp;
}

int InterpolateMotionFunc(CModel* srcmodel, MOTINFO* curmi)
{
	if (!srcmodel || !curmi) {
		_ASSERT(0);
		return 1;
	}
	if (curmi->motid <= 0) {
		_ASSERT(0);
		return 1;
	}

	bool cameraflag = srcmodel->IsCameraMotion(curmi->motid);

	CBone* interpolatebone = nullptr;
	bool limitdegflag;
	if (cameraflag) {
		interpolatebone = srcmodel->GetTopBone(false);
		limitdegflag = false;
	}
	else {
		CBone* opebone = nullptr;
		CBone* curbone = nullptr;
		if (srcmodel && (s_curboneno >= 0)) {
			curbone = srcmodel->GetBoneByID(s_curboneno);
		}
		else {
			curbone = 0;
		}
		//if (curbone && curbone->GetParent()) {
		//2023/02/08 opeboneにparentをセットするのは　IKRotのときだけ
		if (curbone && curbone->GetParent(false) && curbone->GetParent(false)->IsSkeleton() && (s_ikkind == 0)) {
			opebone = curbone->GetParent(false);
		}
		else {
			opebone = curbone;
		}

		if (s_ikkind == 0) {
			interpolatebone = opebone;
		}
		else {
			interpolatebone = curbone;
		}
		limitdegflag = g_limitdegflag;
	}

	if (curmi->motid > 0) {
		int operatingjointno = -1;
		operatingjointno = srcmodel->InterpolateBetweenSelection(limitdegflag,
			curmi->motid,
			s_buttonselectstart, s_buttonselectend, interpolatebone, s_interpolateState);

		bool cameraanimflag = srcmodel->IsCameraMotion(curmi->motid);
		if (!cameraanimflag && (g_limitdegflag == true) && (operatingjointno >= 0)) {
			bool allframeflag = false;
			bool setcursorflag = false;
			bool onpasteflag = false;
			CopyLimitedWorldToWorld(srcmodel, allframeflag, setcursorflag, operatingjointno, onpasteflag);
		}
		refreshEulerGraph();
		PrepairUndo();
	}
	s_interpolateState = 0;
	return 0;
}

int CopyMotionFunc(CModel* srcmodel, MOTINFO* curmi)
{
	if (srcmodel && s_owpTimeline && s_owpLTimeline && curmi && (curmi->motid > 0)) {

		//変更時は　s_symCopyFlagでの処理も合わせて変更
		int result1 = 0;
		int result2 = 0;
		if (!s_copymotvec.empty()) {
			//添付フォルダのファイルに記録
			WCHAR retcptfilename[MAX_PATH] = { 0L };
			result1 = WriteCPTFile(retcptfilename);
			if (result1 == 0) {
				result2 = WriteCPIFile(srcmodel, curmi, retcptfilename);//cp info
				if ((result2 != 0) && (retcptfilename[0] != 0)) {
					//ダイアログでコピーをCancelした場合含む
					//invalidな履歴はその場で削除
					BOOL bexist;
					bexist = PathFileExists(retcptfilename);
					if (bexist) {
						DeleteFileW(retcptfilename);
					}
				}
			}
		}
		if ((result1 == 0) && (result2 == 0)) {
			if (srcmodel) {
				PrepairUndo();
			}
			GetCPTFileName(s_cptfilename);
			s_copyhistorydlg2.SetNames(srcmodel, s_cptfilename);
		}
	}

	return 0;
}
int PasteMotionFunc(CModel* srcmodel, MOTINFO* curmi)
{
	if (!curmi) {
		_ASSERT(0);
		return 1;
	}
	if (curmi->motid <= 0) {
		_ASSERT(0);
		return 1;
	}

	//添付ファイルを読み取ってs_pastemotvecに格納する
	s_pastemotvec.clear();
	bool result;
	result = LoadCPTFile(srcmodel);

	if (result && srcmodel && s_owpTimeline && !s_pastemotvec.empty())
	{
		vector<CBone*> vecopebone;
		if (s_RboneAndPasteFlag == true) {
			vecopebone = s_pasteRJoint;
		}
		else {
			CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg(curmi->cameramotion);
			if (curcpdlg) {
				vecopebone = curcpdlg->m_cpvec;
			}
			else {
				vecopebone.clear();
			}
		}

		int cpnum = (int)vecopebone.size();
		int keynum = 0;
		double startframe, endframe, applyframe;

		double pastestartframe = 0.0;
		s_editrange.Clear();
		if (srcmodel) {
			if (s_owpTimeline && s_owpLTimeline) {
				s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
				//CEditRange::SetApplyRate(g_applyrate);
				s_editrange.GetRange(&keynum, &startframe, &endframe, &applyframe);
			}
		}

		//double curmaxframe = srcmodel->m_curmotinfo->frameleng;

		//コピーされたキーの先頭時刻を求める
		double copyStartTime = DBL_MAX;
		double copyEndTime = 0;
		vector<CPELEM2>::iterator itrcp;
		for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
			if (itrcp->mp.GetFrame() <= copyStartTime) {
				copyStartTime = itrcp->mp.GetFrame();
			}
			if (itrcp->mp.GetFrame() >= copyEndTime) {
				copyEndTime = itrcp->mp.GetFrame();
			}
		}


		if (keynum >= 0) {
			if (keynum == 0) {
				double motleng;
				motleng = curmi->frameleng - 1;
				double srcendframe = fmin(motleng, startframe + (copyEndTime - copyStartTime));
				srcendframe = fmax(srcendframe, 0.0);
				PasteMotionPointJustInTerm(srcmodel, curmi->motid, copyStartTime, copyEndTime, startframe, srcendframe);
			}
			else {
				PasteMotionPointJustInTerm(srcmodel, curmi->motid, copyStartTime, copyEndTime, startframe, endframe);
			}

			srcmodel->CalcBoneEul(g_limitdegflag, curmi->motid);//2023/11/05 既存モーションの上にペーストする際にギザギザしないように
		}


		//UpdateEditedEuler();
		refreshEulerGraph();

		if (srcmodel) {
			PrepairUndo();
		}
	}
	return 0;
}


int PasteMotionPoint(int curmotid, CBone* srcbone, CMotionPoint srcmp, double newframe)
{
	if (!s_model) {
		_ASSERT(0);
		return 1;
	}
	if (curmotid <= 0) {
		_ASSERT(0);
		return 1;
	}

	bool cameraflag;
	if (srcbone->GetParModel() && srcbone->GetParModel()->IsCameraMotion(curmotid)) {
		cameraflag = true;
	}
	else {
		cameraflag = false;
	}


	vector<CBone*> vecopebone;
	if (s_RboneAndPasteFlag == true) {
		vecopebone = s_pasteRJoint;
	}
	else {
		CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg(cameraflag);
		if (curcpdlg) {
			vecopebone = curcpdlg->m_cpvec;
		}
		else {
			vecopebone.clear();
		}
	}

	int cpnum = (int)vecopebone.size();

	int docopyflag = 0;
	int hasNotMvParFlag = 1;//ペーストするジョイントの内　親ジョイントがペースト対象ではない場合のフラグ
	ChaMatrix notmvparmat;
	ChaMatrixIdentity(&notmvparmat);
	if (cpnum != 0) {
		//selected bone at selbonedlg
		int cpno;
		for (cpno = 0; cpno < cpnum; cpno++) {
			CBone* chkbone = vecopebone[cpno];
			if (chkbone == srcbone) {
				docopyflag = 1;

				CBone* parentbone = srcbone->GetParent(false);
				if (parentbone && parentbone->IsSkeleton()) {
					int cpno2;
					for (cpno2 = 0; cpno2 < cpnum; cpno2++) {
						CBone* chkparentbone = vecopebone[cpno2];
						if (chkparentbone == parentbone) {
							hasNotMvParFlag = 0;
						}
					}
				}
				else {
					hasNotMvParFlag = 0;
				}

				break;
			}

			//2024/07/04 hasNotMVParFlagは初期値１。０で上書きするのは対象ボーンとしてvecopebone内に見つかったときだけ。よってコメントアウト。
			//else {
			//	hasNotMvParFlag = 0;
			//}
		}
	}
	else {
		docopyflag = 1;// all bone
		hasNotMvParFlag = 0;
	}

	if (srcbone && 
		((srcbone->IsSkeleton() && (docopyflag == 1)) || srcbone->IsCamera() || srcbone->IsNullAndChildIsCamera())
		) {
		//if (s_model->ExistCurrentMotion()) {
		//	int curmotid = s_model->GetCurMotInfo().motid;
			srcbone->PasteMotionPoint(g_limitdegflag, curmotid, RoundingTime(newframe), srcmp);
		//}
	}

	return 0;
}

int PasteNotMvParMotionPoint(CModel* srcmodel, CBone* srcbone, int curmotid,
	double copystarttime, double srcframe, double srcframe2, double interpolaterate, 
	double dststartframe, double newframe)
{
	//###########################
	//return operatingjointno
	//###########################

	int operatingjointno = 0;

	if (!srcmodel) {
		_ASSERT(0);
		return operatingjointno;
	}

	bool cameraflag;
	if (srcmodel->IsCameraMotion(curmotid)) {
		cameraflag = true;
	}
	else {
		cameraflag = false;
	}


	vector<CBone*> vecopebone;
	if (s_RboneAndPasteFlag == true) {
		vecopebone = s_pasteRJoint;
	}
	else {
		CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg(cameraflag);
		if (curcpdlg) {
			vecopebone = curcpdlg->m_cpvec;
		}
		else {
			vecopebone.clear();
		}
	}

	int cpnum = (int)vecopebone.size();


	int docopyflag = 0;
	int hasNotMvParFlag = 1;//ペーストするジョイントの内　親ジョイントがペースト対象ではない場合のフラグ
	ChaMatrix notmvparmat;
	ChaMatrixIdentity(&notmvparmat);

	if (cpnum != 0) {
		//selected bone at selbonedlg
		int cpno;
		for (cpno = 0; cpno < cpnum; cpno++) {
			CBone* chkbone = vecopebone[cpno];
			if (chkbone == srcbone) {
				docopyflag = 1;

				CBone* parentbone = srcbone->GetParent(false);
				if (parentbone && parentbone->IsSkeleton()) {
					int cpno2;
					for (cpno2 = 0; cpno2 < cpnum; cpno2++) {
						CBone* chkparentbone = vecopebone[cpno2];
						if (chkparentbone == parentbone) {
							hasNotMvParFlag = 0;
						}
					}
				}
				else {
					hasNotMvParFlag = 0;
				}

				break;
			}

			//2024/07/04 hasNotMVParFlagは初期値１。０で上書きするのは対象ボーンとしてvecopebone内に見つかったときだけ。よってコメントアウト。
			//この関数はペースト直後に　srcbone引数を変えて何回も呼び出される
			//コメントアウト前は　(srcbone == vecopebone[0])であるボーンがNotMvの処理対象であるような場合にしか機能していなかった。
			//else {
			//	hasNotMvParFlag = 0;
			//}

		}
	}
	else {
		docopyflag = 1;// all bone
		hasNotMvParFlag = 0;
	}


	if (srcbone && (docopyflag == 1)) {
		CMotionPoint* newmp = 0;
		//if (srcmodel->ExistCurrentMotion()) {
			//int curmotid = srcmodel->GetCurMotInfo().motid;
			newmp = srcbone->GetMotionPoint(curmotid, newframe);
			if (newmp) {
				if (hasNotMvParFlag == 1) {
					CBone* parentbone = srcbone->GetParent(false);
					if (parentbone && parentbone->IsSkeleton()) {

						operatingjointno = parentbone->GetBoneNo();//!!!! For CopyLimitedWorldToWorld()

						ChaMatrix parentwm = parentbone->GetWorldMat(g_limitdegflag,
							curmotid, newframe, 0);
						ChaMatrix parentwm0 = parentbone->GetWorldMat(g_limitdegflag,
							curmotid, RoundingTime(dststartframe), 0);


						if (parentbone->IsHipsBone()) {

							//####################################################################################
							//NotMvがhipsの場合
							//ペースト後の最初のフレームのparentboneの位置が同じで　コピー側のtraanimで動くように
							//####################################################################################

							ChaMatrix srclocalparent0;
							srclocalparent0.SetIdentity();
							ChaMatrix srclocalparent;
							srclocalparent.SetIdentity();


							//2023/11/02 src側のsrcframeの姿勢は　滑らかさのために補間する
							CMotionPoint srcmp;
							srcmp = CalcPasteMotionPoint(parentbone, srcframe, srcframe2, interpolaterate);
							srclocalparent = srcmp.GetWorldMat();
							
							//src側のstartframeの姿勢は　rate=0.0でそのままの姿勢
							CMotionPoint srcstartmp;
							srcstartmp = CalcPasteMotionPoint(parentbone, copystarttime, copystarttime, 0.0);
							srclocalparent0 = srcstartmp.GetWorldMat();

							//vector<CPELEM2>::iterator itrcp;
							//for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
							//	CBone* findbone = itrcp->bone;
							//	if (findbone && findbone == parentbone) {
							//		CMotionPoint findmp = itrcp->mp;
							//		if (IsEqualRoundingTime(findmp.GetFrame(), srcframe)) {
							//			srclocalparent = findmp.GetWorldMat();//copy情報としてローカルが格納されているがhipsなので実質global
							//		}
							//		if (IsEqualRoundingTime(findmp.GetFrame(), copystarttime)) {
							//			srclocalparent0 = findmp.GetWorldMat();//copy情報としてローカルが格納されているがhipsなので実質global
							//		}
							//	}
							//}

							ChaMatrix smat0, rmat0, tmat0, tanimmat0;
							GetSRTandTraAnim(parentwm0, parentbone->GetNodeMat(), &smat0, &rmat0, &tmat0, &tanimmat0);
							ChaMatrix srcsmat0, srcrmat0, srctmat0, srctanimmat0;
							GetSRTandTraAnim(srclocalparent0, parentbone->GetNodeMat(), &srcsmat0, &srcrmat0, &srctmat0, &srctanimmat0);

							ChaMatrix newparentwm = srclocalparent * ChaMatrixInv(srctanimmat0) * tanimmat0;

							parentbone->UpdateCurrentWM(g_limitdegflag, curmotid, newframe, newparentwm);

						}
						else {
							//######################
							//NotMvがhips以外の場合
							//######################
							bool setbroflag = false;
							srcbone->UpdateParentWMReq(g_limitdegflag, setbroflag,
								curmotid, newframe, parentwm, parentwm);

						}
					}
				}
			}
		//}
	}

	return operatingjointno;//!!!!!!!!!!
}

int PasteMotionPointJustInTerm(CModel* srcmodel, int curmotid, 
	double copyStartTime, double copyEndTime, double startframe, double endframe)
{
	if (!srcmodel) {
		_ASSERT(0);
		return 1;
	}

	bool cameraflag;
	if (srcmodel->IsCameraMotion(curmotid)) {
		cameraflag = true;
	}
	else {
		cameraflag = false;
	}

	vector<CBone*> vecopebone;
	if (s_RboneAndPasteFlag == true) {
		vecopebone = s_pasteRJoint;
	}
	else {
		CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg(cameraflag);
		if (curcpdlg) {
			vecopebone = curcpdlg->m_cpvec;
		}
		else {
			vecopebone.clear();
		}
	}

	int cpnum = (int)vecopebone.size();

	double srcleng;
	double dstleng;
	srcleng = copyEndTime - copyStartTime + 1;
	dstleng = endframe - startframe + 1;
	double roundingstartframe, roundingendframe;
	roundingstartframe = RoundingTime(startframe);
	roundingendframe = RoundingTime(endframe);
	double dstframe;
	for (dstframe = roundingstartframe; dstframe <= roundingendframe; dstframe += 1.0) {

		ResetPasteDoneFlagReq(srcmodel->GetTopBone(false));//!!!!

		//####################################################################################
		//2023/11/02
		//コピーフレーム長が短く　ペーストフレーム長が長い場合にも　結果が滑らかになるように
		//srcjustframeの端数を考慮して　CalcPasteMotionPoint()で　姿勢を補間する
		//####################################################################################
		double dstrate;// = (dstframe - roundingstartframe) / dstleng;
		double srcjustframe;// = copyStartTime + dstrate * srcleng;
		double srcframe;
		//srcframe = RoundingTime(srcjustframe);

		if (dstframe == roundingstartframe) {
			//先頭フレームはそのまま先頭フレーム
			dstrate = 0.0;
			srcjustframe = copyStartTime;
			srcframe = RoundingTime(srcjustframe);
		}
		else if (dstframe == roundingendframe) {
			//最終フレームはそのまま最終フレーム
			dstrate = 1.0;
			srcjustframe = copyEndTime;
			srcframe = RoundingTime(srcjustframe);
		}
		else {
			dstrate = (dstframe - roundingstartframe) / dstleng;
			srcjustframe = copyStartTime + dstrate * srcleng;
			srcframe = RoundingTime(srcjustframe);
		}
		double srcframe2;
		//srcframe2 = fmin((srcframe + 1.0), RoundingTime(copyEndTime));//+1.0がナゾ　最初のフレームにペーストされない不具合
		srcframe2 = fmin(srcframe, RoundingTime(copyEndTime));//2024/06/09 +1.0を取り除く
		double interpolaterate = (srcjustframe - srcframe);


		vector<CPELEM2>::iterator itrcp;
		for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
			CBone* srcbone = itrcp->bone;
			if (srcbone && (srcbone->GetPasteDoneFlag() == false)) {
				CMotionPoint srcmp;
				srcmp = CalcPasteMotionPoint(srcbone, srcframe, srcframe2, interpolaterate);
				PasteMotionPoint(curmotid, srcbone, srcmp, dstframe);

				srcbone->SetPasteDoneFlag(true);//!!!!!
			}

			//if (srcbone) {
			//	CMotionPoint srcmp = itrcp->mp;
			//	if (IsEqualRoundingTime(srcmp.GetFrame(), srcframe)) {
			//		PasteMotionPoint(srcbone, srcmp, dstframe);
			//	}
			//}
		}
	}
	ResetPasteDoneFlagReq(srcmodel->GetTopBone(false));//!!!!念のためにここでもリセットしておく



	////移動しないボーンのための処理
	int operatingjointno = 0;
	for (dstframe = roundingstartframe; dstframe <= roundingendframe; dstframe += 1.0) {

		ResetPasteDoneFlagReq(srcmodel->GetTopBone(false));//!!!!

		//double dstrate = (dstframe - startframe) / dstleng;
		double dstrate = (dstframe - roundingstartframe) / dstleng;

		double srcjustframe = copyStartTime + dstrate * srcleng;
		double srcframe;
		srcframe = RoundingTime(srcjustframe);
		double srcframe2;
		srcframe2 = fmin((srcframe + 1.0), RoundingTime(copyEndTime));
		double interpolaterate = (srcjustframe - srcframe);

		vector<CPELEM2>::iterator itrcp;
		for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
			CBone* srcbone = itrcp->bone;
			if (srcbone && (srcbone->GetPasteDoneFlag() == false) &&
				(
					(!cameraflag && srcbone->IsSkeleton()) || 
					(cameraflag && (srcbone->IsCamera() || srcbone->IsNullAndChildIsCamera()))
				) 
			) {
				CMotionPoint srcmp = itrcp->mp;
				if (IsEqualRoundingTime(srcmp.GetFrame(), srcframe)) {
					int resultjointno = PasteNotMvParMotionPoint(srcmodel, srcbone, curmotid,
						RoundingTime(copyStartTime), srcframe, srcframe2, interpolaterate,
						RoundingTime(startframe), dstframe);

					if (resultjointno >= 0) {
						if (operatingjointno > resultjointno) {
							operatingjointno = resultjointno;//0以上で最小のboneno
						}
					}
					else {
						_ASSERT(0);
					}

					srcbone->SetPasteDoneFlag(true);//!!!!!
				}
			}
		}
	}


	//2023/02/05
	//limitedにペーストした場合には　ペーストしたものと同じものをunlimitedにもペースト
	//更に　limitedに　現在の制限角度を適用する
	//
	//ペースト範囲のオイラー角はPasteMotionPoint()-->SetWorldMat()-->CalcLocalEulXYZ()で計算済
	//
	bool opecamera = false;
	//MOTINFO curmi = srcmodel->GetCurMotInfo();
	//if ((curmi.motid > 0) && srcmodel->IsCameraMotion(curmi.motid)) {
	if (srcmodel->IsCameraMotion(curmotid)) {
		opecamera = true;
	}
	else {
		opecamera = false;
	}

	if ((g_limitdegflag == true) && !opecamera) {
		bool allframeflag = false;
		bool setcursorflag = false;
		bool onpasteflag = true;
		CopyLimitedWorldToWorld(srcmodel, allframeflag, setcursorflag, operatingjointno, onpasteflag);
		//MOTINFO* curmi = srcmodel->GetCurMotInfo();
		//if (curmi) {
		//	srcmodel->CalcBoneEul(g_limitdegflag, curmi->motid);//2023/10/20 CopyWorldToLimitedWorldの後　ApplyNewLimitsToWMよりも前
		//}
		ApplyNewLimitsToWM(srcmodel);
	}

	//vector<CPELEM>::iterator itrcp;
	//for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++){
	//	CBone* srcbone = itrcp->bone;
	//	if (srcbone){
	//		CMotionPoint srcmp = itrcp->mp;
	//		double newframe = (double)((int)(srcmp.GetFrame() - copyStartTime + startframe + 0.1));//!!!!!!!!!!!!!!!!!!
	//		if ((newframe >= startframe) && (newframe <= endframe)){
	//			PasteMotionPoint(srcbone, srcmp, newframe);
	//		}
	//	}
	//}

	////移動しないボーンのための処理
	//for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++){
	//	CBone* srcbone = itrcp->bone;
	//	if (srcbone){
	//		CMotionPoint srcmp = itrcp->mp;
	//		double newframe = (double)((int)(srcmp.GetFrame() - copyStartTime + startframe + 0.1));//!!!!!!!!!!!!!!!!!!
	//		if ((newframe >= startframe) && (newframe <= endframe)){
	//			PasteNotMvParMotionPoint(srcbone, srcmp, newframe);
	//		}
	//	}
	//}

	return 0;
}

//int PasteMotionPointAfterCopyEnd(double copyStartTime, double copyEndTime, double startframe, double endframe)
//{
//	vector<CPELEM2>::iterator itrcp;
//
//	double newframe;
//	for (newframe = (double)((int)(copyEndTime - copyStartTime + startframe + 0.1)); newframe <= endframe; newframe += 1.0) {
//		for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
//			CBone* srcbone = itrcp->bone;
//			if (srcbone) {
//				CMotionPoint srcmp = itrcp->mp;
//				if (itrcp->mp.GetFrame() == copyEndTime) {
//					PasteMotionPoint(srcbone, srcmp, newframe);
//				}
//			}
//		}
//	}
//
//	//移動しないボーンのための処理
//	for (newframe = (double)((int)(copyEndTime - copyStartTime + startframe + 0.1)); newframe <= endframe; newframe += 1.0) {
//		for (itrcp = s_pastemotvec.begin(); itrcp != s_pastemotvec.end(); itrcp++) {
//			CBone* srcbone = itrcp->bone;
//			if (srcbone) {
//				CMotionPoint srcmp = itrcp->mp;
//				if (itrcp->mp.GetFrame() == copyEndTime) {
//					PasteNotMvParMotionPoint(srcbone, srcmp, newframe);
//				}
//			}
//		}
//	}
//
//	return 0;
//}


void DispProgressCalcLimitedWM()
{
	LONG framenum = InterlockedAdd(&s_progressnum, 0);
	LONG curframe = InterlockedAdd(&s_progresscnt, 0);
	LONG modelnum = InterlockedAdd(&s_progressmodelnum, 0);
	LONG modelcnt = InterlockedAdd(&s_progressmodelcnt, 0);
	LONG befframenum = InterlockedAdd(&s_befprogressnum, 0);
	LONG befcurframe = InterlockedAdd(&s_befprogresscnt, 0);
	LONG befmodelnum = InterlockedAdd(&s_befprogressmodelnum, 0);
	LONG befmodelcnt = InterlockedAdd(&s_befprogressmodelcnt, 0);

	if ((framenum != 0) && (modelnum != 0) &&
		((framenum != befframenum) || (curframe != befcurframe) || (modelnum != befmodelnum) || (modelcnt != befmodelcnt))) {//ちらつかないように変更があったときだけ
		//if ((curframe % 25) == 0) {
		if (s_progresswnd) {
			HWND hProg2;
			hProg2 = GetDlgItem(s_progresswnd, IDC_PROGRESS1);
			if (hProg2) {
				//現在位置を設定 
				int curpercent = (int)((double)curframe / (double)framenum * 100.0);
				curpercent = min(100, curpercent);
				curpercent = max(0, curpercent);
				SendMessage(hProg2, PBM_SETPOS, (WPARAM)curpercent, 0);
			}
		}
		if (s_progresswnd) {
			WCHAR strnumcnt[1024] = { 0L };
			swprintf_s(strnumcnt, 1024, L"%d / %d chara (cnt / num)", modelcnt, modelnum);
			SetDlgItemTextW(s_progresswnd, IDC_STRBVH2FBXBATCH, strnumcnt);

			UpdateWindow(s_progresswnd);
		}
		//SleepEx(1, TRUE);
	//}
	}

	InterlockedExchange(&s_befprogressnum, framenum);
	InterlockedExchange(&s_befprogresscnt, curframe);
	InterlockedExchange(&s_befprogressmodelnum, modelnum);
	InterlockedExchange(&s_befprogressmodelcnt, modelcnt);
}

int OnFrameBatchThread()
{
	//bhv2fbx batch
	if (InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 1) {//under thread working
		LONG fbxnum = InterlockedAdd(&s_bvh2fbxnum, 0);
		LONG fbxcnt = InterlockedAdd(&s_bvh2fbxcnt, 0);
		LONG beffbxnum = InterlockedAdd(&s_befbvh2fbxnum, 0);
		LONG beffbxcnt = InterlockedAdd(&s_befbvh2fbxcnt, 0);
		if (s_bvh2fbxbatchwnd && (fbxnum > 0) &&
			((fbxnum != beffbxnum) || (fbxcnt != beffbxcnt))) {//ちらつかないように変更があったときだけ
			WCHAR strnumcnt[1024] = { 0L };
			swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", (fbxcnt + 1), fbxnum);
			SetDlgItemTextW(s_bvh2fbxbatchwnd, IDC_STRBVH2FBXBATCH, strnumcnt);

			if (s_bvh2fbxbatchwnd) {
				HWND hProg = GetDlgItem(s_bvh2fbxbatchwnd, IDC_PROGRESS1);
				if (hProg) {
					//現在位置を設定
					int percent = (int)((double)fbxcnt / (double)fbxnum * 100.0);
					SendMessage(hProg, PBM_SETPOS, percent, 0);
					//ステップの範囲を設定 
					//SendMessage(hProg, PBM_SETSTEP, 1, 0);
				}
				UpdateWindow(s_bvh2fbxbatchwnd);
			}
		}
		InterlockedExchange(&s_befbvh2fbxnum, fbxnum);
		InterlockedExchange(&s_befbvh2fbxcnt, fbxcnt);
	}
	else if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 2) || (InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 3)) {//2はダイアログでのキャンセル
		InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)0);
		if (s_bvh2fbxbatchwnd) {
			SendMessage(s_bvh2fbxbatchwnd, WM_CLOSE, 0, 0);
		}
		InterlockedExchange(&g_bvh2fbxbatchflag, (LONG)0);//WM_CLOSEで変わる可能性あり
		InterlockedExchange(&s_bvh2fbxcnt, 0);
		InterlockedExchange(&s_bvh2fbxnum, 0);
		InterlockedExchange(&s_befbvh2fbxnum, 0);
		InterlockedExchange(&s_befbvh2fbxcnt, 0);

		if (s_chascene && (s_chascene->GetModelNum() > 0)) {
			//OnModelMenu(false, s_chascene->GetModelNum() - 1, 1);
			bool forceflag = true;
			bool callundo = true;
			OnChangeModel(s_chascene->GetModelNum() - 1, forceflag, callundo);
		}
	}


	//retarget batch
	if (InterlockedAdd(&g_retargetbatchflag, 0) == 1) {//under thread working
		LONG retargetnum = InterlockedAdd(&s_retargetnum, 0);
		LONG retargetcnt = InterlockedAdd(&s_retargetcnt, 0);
		LONG befretargetnum = InterlockedAdd(&s_befretargetnum, 0);
		LONG befretargetcnt = InterlockedAdd(&s_befretargetcnt, 0);
		if (s_retargetbatchwnd && (retargetnum > 0) &&
			((retargetnum != befretargetnum) || (retargetcnt != befretargetcnt))) {//ちらつかないように変更があったときだけ
			WCHAR strnumcnt[1024] = { 0L };
			swprintf_s(strnumcnt, 1024, L"%d / %d (cnt / num)", retargetcnt, retargetnum);
			SetDlgItemTextW(s_retargetbatchwnd, IDC_STRBVH2FBXBATCH, strnumcnt);

			if (s_retargetbatchwnd) {
				HWND hProg = GetDlgItem(s_retargetbatchwnd, IDC_PROGRESS1);
				if (hProg) {
					//現在位置を設定
					int percent = (int)((double)retargetcnt / (double)retargetnum * 100.0);
					SendMessage(hProg, PBM_SETPOS, percent, 0);
					//ステップの範囲を設定 
					//SendMessage(hProg, PBM_SETSTEP, 1, 0);
				}
				UpdateWindow(s_retargetbatchwnd);
			}
		}
		InterlockedExchange(&s_befretargetnum, retargetnum);
		InterlockedExchange(&s_befretargetcnt, retargetcnt);
	}
	else if ((InterlockedAdd(&g_retargetbatchflag, 0) == 2) || (InterlockedAdd(&g_retargetbatchflag, 0) == 3)) {//2はダイアログでのキャンセル
		InterlockedExchange(&g_retargetbatchflag, (LONG)0);
		if (s_retargetbatchwnd) {
			SendMessage(s_retargetbatchwnd, WM_CLOSE, 0, 0);
		}
		InterlockedExchange(&g_retargetbatchflag, (LONG)0);//WM_CLOSEで変わる可能性あり
		InterlockedExchange(&s_retargetcnt, 0);
		InterlockedExchange(&s_retargetnum, 0);
		InterlockedExchange(&s_befretargetnum, 0);
		InterlockedExchange(&s_befretargetcnt, 0);


		//2023/02/15
		////ChangeLimitDegFlag(s_savelimitdegflag, true, true);//2023/10/23 1.2.0.27_RC2にて　コメントアウト
		//OnModelMenu(true, s_saveretargetmodel, 1);
		bool forceflag = true;
		bool callundo = true;
		OnChangeModel(s_saveretargetmodel, forceflag, callundo);
	}


	return 0;
}

int OnFrameStartPreview(double curtime, double* psavetime)
{

	//normal preview start
	if (s_calclimitedwmState == 2) {

		//2022/08/12 リアルタイム計算に変更

		//if (InterlockedAdd(&g_calclimitedwmflag, 0) == 1) {//under threadfunc working
		//	DispProgressCalcLimitedWM();
		//}
		//else if (InterlockedAdd(&g_calclimitedwmflag, 0) == 2) {//confirm threadfunc finished
		s_calclimitedwmState = 0;
		g_previewFlag = 1;//!!!!!!
		InterlockedExchange(&g_calclimitedwmflag, (LONG)0);
		//}
		*psavetime = curtime;
	}
	if (s_calclimitedwmState == 1) {
		s_calclimitedwmState = 2;
		//CalcLimitedWorldMat();//2022/08/12 リアルタイム計算に変更
	}

	//preview to backword
	if (s_calclimitedwmState == 22) {

		//2022/08/12 リアルタイム計算に変更

		//if (InterlockedAdd(&g_calclimitedwmflag, 0) == 1) {//under threadfunc working
		//	DispProgressCalcLimitedWM();
		//}
		//else if (InterlockedAdd(&g_calclimitedwmflag, 0) == 2) {//confirm threadfunc finished
		s_calclimitedwmState = 0;
		g_previewFlag = -1;//!!!!!
		InterlockedExchange(&g_calclimitedwmflag, (LONG)0);
		//}
		*psavetime = curtime;
	}
	if (s_calclimitedwmState == 11) {
		s_calclimitedwmState = 22;
		//CalcLimitedWorldMat();//2022/08/12 リアルタイム計算に変更
	}


	//bullet simulation start
	if (s_calclimitedwmState == 107) {
		s_calclimitedwmState = 0;
		StartBt(s_model, TRUE, 0, 1);
		*psavetime = curtime;
	}
	if ((s_calclimitedwmState >= 103) && (s_calclimitedwmState <= 106)) {
		s_calclimitedwmState++;
	}
	if (s_calclimitedwmState == 102) {

		//2022/08/12 リアルタイム計算に変更

		//if (InterlockedAdd(&g_calclimitedwmflag, 0) == 1) {//under threadfunc working
		//	DispProgressCalcLimitedWM();
		//}
		//else if (InterlockedAdd(&g_calclimitedwmflag, 0) == 2) {//confirm threadfunc finished
		s_calclimitedwmState = 103;
		InterlockedExchange(&g_calclimitedwmflag, (LONG)0);
		//}
	}
	if (s_calclimitedwmState == 101) {
		s_calclimitedwmState = 102;
		//CalcLimitedWorldMat();//2022/08/12 リアルタイム計算に変更
		*psavetime = curtime;
	}
	if (s_calclimitedwmState == 1001) {
		s_calclimitedwmState = 102;
		//CalcLimitedWorldMat();//2022/08/12 リアルタイム計算に変更
		g_btsimurecflag = true;//rec flag
		*psavetime = curtime;
	}

	return 0;
}



int OnSpriteUndo()
{
	static bool s_underoperation = false;//再入禁止用
	if (s_underoperation == true) {
		return 0;
	}
	s_underoperation = true;

	if (!s_chascene) {
		_ASSERT(0);
		s_underoperation = false;
		return 1;
	}


	HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));


	bool undodoneflag = false;

	BRUSHSTATE brushstate;
	brushstate.Init();
	UNDOCAMERA undocamera;
	undocamera.Init();
	UNDOMOTID undomotid;
	undomotid.Init();
	UNDOSELECT undoselect;
	undoselect.Init();
	CBlendShapeElem blendshapeelem;
	blendshapeelem.Init();

	int saveedittarget = g_edittarget;
	int newedittarget = g_edittarget;//ただの初期化　RollBackUndoMotionにて新しい状態へと上書きされる
	int savecameramotionid;
	if (s_cameramodel) {
		savecameramotionid = s_cameramodel->GetCameraMotionId();
	}
	else {
		savecameramotionid = 0;
	}

	int newselectedboneno;
	if (s_model) {
		newselectedboneno = s_model->GetSelectedBoneNo();//ただの初期化　RollBackUndoMotionにて新しい状態へと上書きされる
	}
	else {
		newselectedboneno = 0;//ただの初期化　RollBackUndoMotionにて新しい状態へと上書きされる
	}

	///////////// undo
	if (s_model && (s_undoFlag == true)) {
		//undo
		StopBt();
		//#########################################################################################
		//2024/06/24 s_model->RollBackUndoMotion()は BoneMotionとCameraAnimの両方をRollBackするように.
		//#########################################################################################
		s_model->RollBackUndoMotion(s_chascene, g_limitdegflag, g_mainhwnd,
			0, &newedittarget, &newselectedboneno, &s_curbaseno,
			&undoselect,
			&brushstate, &undocamera, &undomotid, &blendshapeelem);//!!!!!!!!!!!

		RollbackBrushState(brushstate);//ブラシパラメータ復元
		Params2TopSlidersWnd();
		undodoneflag = true;
	}
	else if (s_model && (s_redoFlag == true))
	{
		//redo
		StopBt();
		//#########################################################################################
		//2024/06/24 s_model->RollBackUndoMotion()は BoneMotionとCameraAnimの両方をRollBackするように.
		//#########################################################################################
		s_model->RollBackUndoMotion(s_chascene, g_limitdegflag, g_mainhwnd,
			1, &newedittarget, &newselectedboneno, &s_curbaseno,
			&undoselect,
			&brushstate, &undocamera, &undomotid, &blendshapeelem);//!!!!!!!!!!!

		RollbackBrushState(brushstate);//ブラシパラメータ復元
		Params2TopSlidersWnd();
		undodoneflag = true;
	}

	if (!undodoneflag) {
		s_underoperation = false;
		return 0;
	}


	//2024/07/02 BlendShape選択状態の復元の１段階目のトリガーを立てる　UndoからPrepairUndo_BlendShape()を呼び出すことを抑止する
	if (blendshapeelem.validflag && 
		blendshapeelem.model && (blendshapeelem.model == s_model) &&
		blendshapeelem.mqoobj && (blendshapeelem.channelindex >= 0)) {

		s_blendshapedlg.SetBlendShapeUndoOpeIndex(blendshapeelem.channelindex);
		s_blendshapedlg.SetBlendShapeUnderSelectFromUndo(true);//2024/07/02 SelChange BlendShape
	}


	if ((undoselect.undokind == UNDOKIND_SELECTMODEL_FROMTHIS) ||
		(undoselect.undokind == UNDOKIND_SELECTMODEL_TOTHIS)) {

		CModel* setmodel = nullptr;
		int setmotion = 0;
		//int undoR = 0;
		//int undoW = 0;
		if (undoselect.undokind == UNDOKIND_SELECTMODEL_FROMTHIS) {
			setmodel = undoselect.to_model;
			setmotion = undoselect.to_motion;
			//undoR = undoselect.to_undoR;
			//undoW = undoselect.to_undoW;
		}
		else if (undoselect.undokind == UNDOKIND_SELECTMODEL_TOTHIS) {
			setmodel = undoselect.from_model;
			setmotion = undoselect.from_motion;
			//undoR = undoselect.from_undoR;
			//undoW = undoselect.from_undoW;
		}


		int setmodelindex = s_chascene->FindModelIndex(setmodel);
		if (setmodelindex >= 0) {//2024/06/26 モデルが削除されていないことを確認
			bool forceflag = true;
			bool callundo = false;
			OnChangeModel(setmodel, forceflag, callundo);

			int selindex = s_chascene->MotID2SelIndex(setmodelindex, setmotion);
			if (selindex >= 0) {
				bool dorefreshtl = true;
				int saveundoflag = 0;
				OnAnimMenu(dorefreshtl, selindex, saveundoflag);
			}
		}
	}

	else {
		g_edittarget = newedittarget;

		if (s_model) {
			//s_copyKeyInfoList.clear();
			//s_deletedKeyInfoList.clear();
			//s_selectKeyInfoList.clear();


			if (saveedittarget != newedittarget) {

				//s_LrefreshEditTarget = 1;//即時実行する必要があるのでフラグセットではなく処理を直書き

				if (g_edittarget == EDITTARGET_MORPH) {
					CloseAllRightPainWindow(true);
					s_guiswplateno = 6;
					GUISetVisible(s_guiswplateno);
				}
				//else if (g_edittarget == EDITTARGET_BONE) {//bone-->camera-->morph-->"bone"
				else {
					//undo時　bone-->morph-->"camera"でもmorphウインドウが閉じるように
					s_guiswflag = false;
					GUIMenuSetVisible(s_platemenukind, s_platemenuno);
				}
				SetLTimelineMark(s_curboneno);
				//if (s_owpTimeline) {
				//	refreshTimeline(*s_owpTimeline);
				//}
				//refreshEulerGraph();
			}


			int selindex = s_chascene->MotID2SelIndex(s_chascene->FindModelIndex(s_model), undomotid.bonemotid);
			if (selindex >= 0) {
				bool dorefreshtl = true;
				int saveundoflag = 0;
				OnAnimMenu(dorefreshtl, selindex, saveundoflag);
			}

			//if (s_model->ExistCurrentMotion() && (s_model->GetCurMotInfo().motid != undomotid.bonemotid)) {
			//	int chkcnt = 0;
			//	int findflag = 0;
			//	int minum;
			//	int miindex;
			//	minum = s_model->GetMotInfoSize();
			//	for (miindex = 0; miindex < minum; miindex++) {
			//		MOTINFO curmi = s_model->GetMotInfoByIndex(miindex);
			//		if (curmi.motid == undomotid.bonemotid) {
			//			findflag = 1;
			//			break;
			//		}
			//		chkcnt++;
			//	}
			//
			//	if (findflag == 1) {
			//		int selindex;
			//		selindex = chkcnt;
			//		OnAnimMenu(true, selindex, 0);
			//	}
			//}
			//else {
			//	if (s_model) {
			//		//メニュー書き換え, timeline update
			//		OnAnimMenu(true, s_motmenuindexmap[s_model], 0);
			//	}
			//}

			if (undocamera.cameramodel && (undocamera.cameramodel == s_cameramodel)) {
				if (s_cameramodel->ExistCurrentMotion() && 
					(undomotid.cameramotid > 0) && 
					(s_cameramodel->GetCameraMotionId() != undomotid.cameramotid)) {

					if (s_camerapanel.radiobutton) {
						int cameramotindex = s_model->MotionID2CameraIndex(undomotid.cameramotid);
						if (cameramotindex >= 0) {
							s_cameramenuindexmap[s_model] = cameramotindex;
							s_camerapanel.radiobutton->setSelectIndex(cameramotindex, false);
						}
					}

					s_cameramodel->SetCameraMotionId(undomotid.cameramotid);
				}
			}
			else {
				//カメラモデルが無い場合に通る
				// 
				//カメラモデル(最後に読み込んだカメラアニメ付きモデル)が作業途中で変更された場合にここを通る可能性がある(その場合は未対応)
				int dbgflag1 = 1;
			}
		}
	}



	RollbackUndoCamera(undocamera);//カメラパラメータ復元
	Params2SideMenuWnd();

	s_curboneno = newselectedboneno;
	if (s_curboneno >= 0) {
		ChangeCurrentBone(false);

		int curlineno = s_boneno2lineno[s_curboneno];
		if (s_owpTimeline) {
			//s_owpTimeline->setCurrentLine(curlineno, true);
			s_owpTimeline->setCurrentLine(curlineno, false);//!!!!!!
		}
		SetTimelineMark();
		SetLTimelineMark(s_curboneno);
	}

	//OnGUIEventSpeed();

	if (s_model->ExistCurrentMotion()) {

		if (g_edittarget != EDITTARGET_CAMERA) {
			s_buttonselectstart = fmax(0.0, undomotid.startframe);
			s_buttonselectstart = fmin(s_model->GetCurrentMaxFrame(), s_buttonselectstart);

			s_buttonselectend = fmax(0.0, undomotid.endframe);
			s_buttonselectend = fmin(s_model->GetCurrentMaxFrame(), s_buttonselectend);
		}
		else if (s_cameramodel) {
			MOTINFO camerami = s_cameramodel->GetMotInfo(s_cameramodel->GetCameraMotionId());
			if (camerami.motid > 0) {
				s_buttonselectstart = fmax(0.0, undomotid.startframe);
				s_buttonselectstart = fmin(camerami.frameleng, s_buttonselectstart);

				s_buttonselectend = fmax(0.0, undomotid.endframe);
				s_buttonselectend = fmin(camerami.frameleng, s_buttonselectend);
			}
			else {
				s_buttonselectstart = fmax(0.0, undomotid.startframe);
				s_buttonselectstart = fmin(s_model->GetCurrentMaxFrame(), s_buttonselectstart);

				s_buttonselectend = fmax(0.0, undomotid.endframe);
				s_buttonselectend = fmin(s_model->GetCurrentMaxFrame(), s_buttonselectend);
			}
		}
		g_applyrate = undomotid.applyrate;
		//CEditRange::SetApplyRate(g_applyrate);

		OnTimeLineButtonSelectFromSelectStartEnd(0);
		SetShowPosTime();//CreateMotionBrushより前で呼ばないと　TopPosを変えた後のUndoRedoで　描画がずれることがある


		//if (s_topSlidersWnd && s_owpTopPosSlider) {
		//	s_owpTopPosSlider->setValue(g_applyrate, false);
		//	s_topSlidersWnd->callRewrite();
		//}


		int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
		if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
			_ASSERT(0);
			::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
			PostQuitMessage(result);
		}

		//SetShowPosTime();//CreateMotionBrushより前で呼ばないと　TopPosを変えた後のUndoRedoで　描画がずれることがある

		SavePlayingStartEnd();


		//##############################################
		//2023/02/05
		//制限角度値とCMotionPointを丸ごと復元するので
		//limitedの計算し直しの必要なし
		//##############################################
		//#########################################################################
		//2022/12/06
		//保存時とは制限角度が異なっている可能性があるので　制限角度のために再計算
		//#########################################################################
		//if (g_limitdegflag == true) {
		//	ClearLimitedWM(s_model);
		//	ApplyNewLimitsToWM(s_model);//2022/12/18
		//}


		//limitedへの変更を　worldに反映
		if ((g_limitdegflag == true) && (g_edittarget != EDITTARGET_CAMERA)) {
			bool allframeflag = false;
			bool setcursorflag = false;
			bool onpasteflag = false;
			int operatingjointno = 0;
			if (s_model && s_model->GetTopBone()) {
				operatingjointno = s_model->GetTopBone(false)->GetBoneNo();
			}
			CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);
		}


		if (g_edittarget != EDITTARGET_CAMERA) {
			//2023/11/03 hipsを３回転してアンドゥしたときに　編集範囲の境目で　オイラーグラフが連続するために必要
			s_model->CalcBoneEul(g_limitdegflag, s_model->GetCurrentMotID());
		}
		else if (s_cameramodel) {

			//2024/06/05その後
			//IsCamera()==trueのボーンに関してもアンドゥ処理をすることによりUpdateCameramatFromENull()は不要になった　コメントアウト
			//2024/06/05
			//カメラアニメのアンドゥーはIsNullAndChildIsCamera()==trueのボーンに対して行っている
			//アンドゥ結果をIsCamera()==trueのボーンに反映するためにUpdateCameraMatFromENull()を呼ぶ
			//s_cameramodel->UpdateCameraMatFromENull(s_cameramodel->GetCameraMotionId());

			s_cameramodel->CalcBoneEul(false, s_cameramodel->GetCameraMotionId());
		}

		refreshEulerGraph();

		//s_selectFlag = true;
		//s_LupFlag = true;
	}


	//select復元
	//s_pickinfo.buttonflag = PICK_CENTER;
	//s_curboneno = newselectedboneno;//2024/06/06 もう一度復元　必要
	s_pickinfo.pickobjno = s_curboneno;
	//ChangeCurrentBone(false);


	//2024/06/07 可能な場合は選択範囲を復元
	s_LrefreshEditTarget = 1;


	s_undoFlag = false;
	s_redoFlag = false;

	


	if (oldcursor != NULL) {
		SetCursor(oldcursor);
	}




	s_underoperation = false;
	return 0;

}
int OnFrameUndo(bool fromds, int fromdskind)
{
	static bool s_underoperation = false;//再入禁止用
	if (s_underoperation == true) {
		return 0;
	}
	s_underoperation = true;


	//2024/06/18
	if (s_SpriteButtonDownUndoRedo) {
		//2024/06/18
		//スプライトボタンを押した状態を表示してから処理を行うために
		//s_SpriteButtonDownUndoRedoがtrueの場合は何もしないで1周回して　次の周回で処理を行う
		s_SpriteButtonDownUndoRedo = false;
		s_underoperation = false;
		return 0;
	}




	//2022/11/07 playerbuttonのprevrange, nextrangeに　undo, redoとして対応


	if (s_undoFlag == true) {
		//playerbutton prevrange
		//undo
		s_undoFlag = true;
		OnSpriteUndo();
	}
	else if (s_redoFlag == true) {
		//playerbutton nextrange
		//redo
		s_redoFlag = true;
		OnSpriteUndo();
	}
	//keyboard event
	else if (fromds || (s_model && g_controlkey && (g_keybuf['Z'] & 0x80) && !(g_savekeybuf['Z'] & 0x80))) {

		if (((fromds && (fromdskind == 1)) || (g_keybuf[VK_SHIFT] & 0x80)) && (s_undoFlag == false) && (s_redoFlag == false)) {
			//redo
			s_redoFlag = true;
			s_spundo[1].ButtonDown();
			s_SpriteButtonDownUndoRedo = true;
			//OnSpriteUndo();
		}
		else if (((fromds && (fromdskind == 0)) || !fromds) && (s_undoFlag == false) && (s_redoFlag == false)) {
			//undo
			s_undoFlag = true;
			s_spundo[0].ButtonDown();
			s_SpriteButtonDownUndoRedo = true;
			//OnSpriteUndo();
		}
	}

	s_underoperation = false;

	return 0;
}

int OnFrameUpdateGround()
{

	if (s_ground) {
		ChaMatrix tmpwm = s_ground->GetWorldMat();
		s_ground->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
	}

	if (s_gplane && s_bpWorld && s_bpWorld->m_rigidbodyG) {
		ChaMatrix gpmat = s_inimat;
		gpmat.data[MATI_42] = s_bpWorld->m_gplaneh;
		s_gplane->UpdateMatrix(g_limitdegflag, &gpmat, &s_matView, &s_matProj, true, 0);
	}
	return 0;
}

int OnFrameInitBtWorld()
{
	if (!s_model || !s_btWorld) {
		return 0;
	}

	CModel* curmodel = s_model;


	//vector<MODELELEM>::iterator itrmodel;
	//for (itrmodel = s_modelindex.begin(); itrmodel != s_modelindex.end(); itrmodel++){
		//CModel* curmodel = itrmodel->modelptr;
		//if (curmodel && (curmodel->GetLoadedFlag() == true) && (curmodel->GetCreateBtFlag() == false)){
	curmodel->SetBtWorld(s_btWorld);
	//	CallF(curmodel->CreateBtObject(s_coldisp, 1), return 1);
	//}

	//curmodel->PlusPlusBtCnt();

//}
	return 0;
}

int InitPluginMenu()
{

	//g_SampleUI.AddComboBox(IDC_COMBO_MOTIONBRUSH_METHOD, 35, iY += addh, ctrlxlen + 25, ctrlh);
	//s_ui_motionbrush = g_SampleUI.GetControl(IDC_COMBO_MOTIONBRUSH_METHOD);
	//_ASSERT(s_ui_motionbrush);
	//s_dsutgui0.push_back(s_ui_motionbrush);
	//s_dsutguiid0.push_back(IDC_COMBO_MOTIONBRUSH_METHOD);
	//CDXUTComboBox* pComboBox5 = g_SampleUI.GetComboBox(IDC_COMBO_MOTIONBRUSH_METHOD);
	//pComboBox5->RemoveAllItems();
	//pComboBox5->AddItem(L"Linear", ULongToPtr(0));
	//pComboBox5->AddItem(L"Cos(x+PI)", ULongToPtr(1));
	//pComboBox5->AddItem(L"Cos(x^2+PI)", ULongToPtr(2));
	//pComboBox5->AddItem(L"Rect", ULongToPtr(3));
	//pComboBox5->SetSelectedByData(ULongToPtr(0));


	s_plugin = new CPluginElem[MAXPLUGIN];
	if (!s_plugin) {
		DbgOut(L"viewer : InitPluginMenu : plugin alloc error !!!\n");
		_ASSERT(0);
		return 1;
	}

	///////////
	WCHAR plugindir[MAX_PATH];
	wcscpy_s(plugindir, MAX_PATH, g_basedir);
	WCHAR* lasten = 0;
	WCHAR* last2en = 0;
	lasten = wcsrchr(plugindir, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return S_FALSE;
	}
	*lasten = 0L;
	last2en = wcsrchr(plugindir, TEXT('\\'));
	if (!last2en) {
		_ASSERT(0);
		return S_FALSE;
	}
	*last2en = 0L;
	wcscat_s(plugindir, MAX_PATH, L"\\BrushesFolder\\");

	WCHAR finddir[_MAX_PATH];
	ZeroMemory(finddir, sizeof(WCHAR) * _MAX_PATH);
	wcscpy_s(finddir, _MAX_PATH, plugindir);
	wcscat(finddir, L"*.dll");

	///////////
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;
	hFind = FindFirstFile(finddir, &FindFileData);
	int pluginno = 0;

	if (hFind != INVALID_HANDLE_VALUE) {
		WCHAR pluginpath[_MAX_PATH];
		wcscpy_s(pluginpath, _MAX_PATH, plugindir);
		wcscat(pluginpath, FindFileData.cFileName);
		DbgOut(L"InitPluginMenu : FindFirst : %s\r\n", FindFileData.cFileName);

		(s_plugin + pluginno)->SetFilePath(pluginpath);
		(s_plugin + pluginno)->LoadPlugin();
		pluginno++;

		BOOL bret = 1;
		while (bret != 0) {
			bret = FindNextFile(hFind, &FindFileData);
			if (bret != 0) {

				wcscpy_s(pluginpath, _MAX_PATH, plugindir);
				wcscat(pluginpath, FindFileData.cFileName);
				DbgOut(L"InitPluginMenu : FindNext : %s\r\n", FindFileData.cFileName);

				(s_plugin + pluginno)->SetFilePath(pluginpath);
				(s_plugin + pluginno)->LoadPlugin();

				pluginno++;
			}
		}

		FindClose(hFind);
	}


	//一番最初のブラシをカレントのブラシとしてセット
	if (g_motionbrush_method <= 0) {
		int pluginno;
		for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
			if ((s_plugin + pluginno)->validflag == 1) {
				g_motionbrush_method = (s_plugin + pluginno)->menuid;//!!!!!!!!!!
				break;
			}
		}
	}



	////g_SampleUI.AddComboBox(IDC_COMBO_MOTIONBRUSH_METHOD, 35, iY += addh, ctrlxlen + 25, ctrlh);
	////s_ui_motionbrush = g_SampleUI.GetControl(IDC_COMBO_MOTIONBRUSH_METHOD);
	////_ASSERT(s_ui_motionbrush);
	////s_dsutgui0.push_back(s_ui_motionbrush);
	////s_dsutguiid0.push_back(IDC_COMBO_MOTIONBRUSH_METHOD);
	//CDXUTComboBox* pComboBox5 = g_SampleUI.GetComboBox(IDC_COMBO_MOTIONBRUSH_METHOD);
	//pComboBox5->RemoveAllItems();


	////pComboBox5->AddItem(L"Linear", ULongToPtr(0));
	////pComboBox5->AddItem(L"Cos(x+PI)", ULongToPtr(1));
	////pComboBox5->AddItem(L"Cos(x^2+PI)", ULongToPtr(2));
	////pComboBox5->AddItem(L"Rect", ULongToPtr(3));
	////pComboBox5->SetSelectedByData(ULongToPtr(0));
	int setno = 0;
	int firstmenuno = -1;
	for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
		if ((s_plugin + pluginno)->validflag == 1) {
			int menuid = setno;
			if (firstmenuno == -1) {
				firstmenuno = menuid;
			}
			//pComboBox5->AddItem((s_plugin + pluginno)->pluginname, ULongToPtr(menuid));
			(s_plugin + pluginno)->menuid = menuid;
			setno++;
		}
	}
	//pComboBox5->SetSelectedByData(ULongToPtr(firstmenuno));

	return 0;
}


bool UnderDragOperation_L()//左ドラッグ中かどうか
{

	if (s_twistcameraFlag) {
		return false;
	}
	if (s_rbuttonSelectFlag) {
		return false;
	}


	if (s_oprigflag == 0) {
		if ((s_ikkind == 0) && (s_editmotionflag >= 0)) {
			if (s_pickinfo.buttonflag == PICK_CENTER) {
				return true;
			}
			else if ((s_pickinfo.buttonflag == PICK_X) ||
				(s_pickinfo.buttonflag == PICK_Y) ||
				(s_pickinfo.buttonflag == PICK_Z) ||
				(s_pickinfo.buttonflag == PICK_SPA_X) ||
				(s_pickinfo.buttonflag == PICK_SPA_Y) ||
				(s_pickinfo.buttonflag == PICK_SPA_Z)) {
				return true;
			}
		}
		else if ((s_ikkind == 1) && (s_editmotionflag >= 0)) {
			if (s_pickinfo.buttonflag == PICK_CENTER) {
				return true;
			}
			else if ((s_pickinfo.buttonflag == PICK_X) ||
				(s_pickinfo.buttonflag == PICK_Y) ||
				(s_pickinfo.buttonflag == PICK_Z) ||
				(s_pickinfo.buttonflag == PICK_SPA_X) ||
				(s_pickinfo.buttonflag == PICK_SPA_Y) ||
				(s_pickinfo.buttonflag == PICK_SPA_Z)) {
				return true;
			}
		}
		else if ((s_ikkind == 2) && (s_editmotionflag >= 0)) {
			if (s_pickinfo.buttonflag == PICK_CENTER) {
				return true;
			}
			else if ((s_pickinfo.buttonflag == PICK_X) ||
				(s_pickinfo.buttonflag == PICK_Y) ||
				(s_pickinfo.buttonflag == PICK_Z) ||
				(s_pickinfo.buttonflag == PICK_SPA_X) ||
				(s_pickinfo.buttonflag == PICK_SPA_Y) ||
				(s_pickinfo.buttonflag == PICK_SPA_Z)) {
				return true;
			}
		}

	}
	else {
		if (s_customrigbone && (s_customrigno >= 0) && (s_editmotionflag >= 0)) {
			return true;
		}
	}

	//camera
	if ((s_pickinfo.buttonflag == PICK_CAMROT) ||
		(s_pickinfo.buttonflag == PICK_CAMMOVE) ||
		(s_pickinfo.buttonflag == PICK_CAMDIST)) {
		return true;
	}

	return false;
}

bool UnderDragOperation_R()
{
	if (s_twistcameraFlag == true) {
		return true;
	}
	if (s_rbuttonSelectFlag == true) {
		return true;
	}


	return false;
}


int CreateTimelineWnd()
{

	s_rctreewnd.top = TOPSLIDERSWNDH;
	s_rctreewnd.left = 0;


	s_timelineWnd = new OrgWindow(
		0,
		L"TimeLine",				//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		//WindowPos(0, 0),		//位置
		//WindowSize(400, 600),	//サイズ
		WindowPos(0, TOPSLIDERSWNDH),		//位置
		WindowSize(s_timelinewidth, s_timelineheight),	//サイズ 
		//WindowSize(150,540),	//サイズ
		L"TimeLine",				//タイトル
		g_mainhwnd,					//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70);				//カラー
		0, 0, 0);				//カラー
	if (s_timelineWnd) {
		s_rctreewnd.right = s_timelinewidth;
		s_rctreewnd.bottom = s_timelineheight;

		s_timelineWnd->callRewrite();


		// ウィンドウの閉じるボタンのイベントリスナーに
		// 終了フラグcloseFlagをオンにするラムダ関数を登録する
		s_timelineWnd->setCloseListener([]() {
			if (s_model) {
				s_closeFlag = true;
			}
			});


		// ウィンドウのキーボードイベントリスナーに
		// コピー/カット/ペーストフラグcopyFlag/cutFlag/pasteFlagをオンにするラムダ関数を登録する
		// コピー等のキーボードを使用する処理はキーボードイベントリスナーを使用しなくても
		// メインループ内でマイフレームキー状態を監視することで作成可能である。
		s_timelineWnd->setKeyboardEventListener([](const KeyboardEvent& e) {
			if (s_model) {
				if (e.ctrlKey && !e.repeat && e.onDown) {
					//switch (e.keyCode) {
					//###############################################################################################################
					//2023/08/18 : Ctrl + C, Vのコピーペーストは　ダイアログのEditCtrlとのバッティング対策が出来るまでコメントアウト
					//###############################################################################################################
					//case 'C':
					//	s_copyFlag = true;
					//	break;
					//case 'B':
					//	s_symcopyFlag = true;
					//	break;
					//case 'X':
					//	s_cutFlag = true;
					//	break;
					//case 'V':
					//	s_pasteFlag = true;
					//	break;
					//case 'P':
					//	//g_previewFlag = 1;
					//	s_calclimitedwmState = 1;
					//	break;
					//case 'S':
					//	g_previewFlag = 0;
					//	break;
					//case 'D':
					//	s_deleteFlag = true;
					//	break;
					//default:
					//	break;
					//}
				}
			}
		});
	}
	else {
		_ASSERT(0);
		return 1;
	}


	return 0;
}

void SavePlayingStartEnd()
{
	g_playingstart = g_motionbrush_startframe;
	g_playingend = g_motionbrush_endframe;
}
void SetButtonStartEndFromPlaying()
{
	s_buttonselectstart = g_playingstart;
	s_buttonselectend = g_playingend;
}

int CreateLongTimelineWnd()
{

	//////////
	///////// Long Timeline

	s_rcltwnd.top = 0;
	s_rcltwnd.left = 0;

	s_LtimelineWnd = new OrgWindow(
		0,
		L"EditRangeTimeLine",				//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		//WindowPos( 250, 825 ),		//位置
		//WindowPos(200, 645),		//位置
		WindowPos(s_toolwidth, s_2ndposy),		//位置
		WindowSize(s_longtimelinewidth, s_longtimelineheight),	//サイズ
		L"EditRangeTimeLine",				//タイトル
		g_mainhwnd,					//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70);				//カラー
		0, 0, 0);				//カラー
	if (s_LtimelineWnd) {
		s_rcltwnd.bottom = s_longtimelineheight;
		s_rcltwnd.right = s_longtimelinewidth;


		s_LtimelineWnd->callRewrite();


		/////////
		s_owpPlayerButton = new OWP_PlayerButton(s_longtimelinewidth);
		if (s_owpPlayerButton) {
			//s_owpPlayerButton->setButtonSize(20);
			s_LtimelineWnd->addParts(*s_owpPlayerButton);//owp_timelineより前

			s_owpPlayerButton->setPhysicsPlayButtonListener([]() {
				if (s_model) {
					s_calclimitedwmState = 101;
				}
				});
			s_owpPlayerButton->setPhysicsRecButtonListener([]() {
				if (s_model) {
					if (g_motionbrush_numframe < 10) {
						WCHAR strmes[1024] = { 0L };
						swprintf_s(strmes, 1024, L"複数フレームを選択してから再試行してください。\nPlease select more than 10 frames and try again.");
						::DSMessageBox(NULL, strmes, L"error!!!", MB_OK);
					}
					else {
						s_calclimitedwmState = 1001;
					}
				}
				});

			s_owpPlayerButton->setFrontPlayButtonListener([]() {
				if (s_model) {
					s_calclimitedwmState = 1; s_LstartFlag = true; s_LcursorFlag = true;
					//s_LtimelineWnd->setDoneFlag(1);
				}
				});
			s_owpPlayerButton->setBackPlayButtonListener([]() {
				if (s_model) {
					s_calclimitedwmState = 11; s_LstartFlag = true; s_LcursorFlag = true;
					//s_LtimelineWnd->setDoneFlag(1);
				}
				});


			s_owpPlayerButton->setFrontStepButtonListener([]() {
				//##################################
				//means to step to the last frame
				//##################################
				if (s_model) {
					//s_LstartFlag = true; s_LcursorFlag = true; s_lastkeyFlag = true;
					//s_LtimelineWnd->setDoneFlag(1);

					s_LstopFlag = true;
					g_previewFlag = 0;
					s_LcursorFlag = true;
					s_lastkeyFlag = true;
				}
				});
			s_owpPlayerButton->setBackStepButtonListener([]() {
				//##################################
				//means to step to the first frame
				//##################################
				if (s_model) {
					//s_LstartFlag = true; s_LcursorFlag = true; s_firstkeyFlag = true;
					//s_LtimelineWnd->setDoneFlag(1);

					s_LstopFlag = true;
					g_previewFlag = 0;
					s_LcursorFlag = true;
					s_firstkeyFlag = true;
				}
				});


			//s_owpPlayerButton->setOneFpsButtonListener([]() {
			//	if (s_model) {

			//		int tmponefps;
			//		if (s_onefps == 0) {
			//			tmponefps = 1;
			//		}
			//		else if (s_onefps == 1) {
			//			tmponefps = 2;
			//		}
			//		else if (s_onefps == 2) {
			//			tmponefps = 0;
			//		}
			//		else {
			//			tmponefps = 0;
			//		}
			//		s_onefps = tmponefps;

			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setStopButtonListener([]() {
			//	if (s_model) {
			//		s_LstopFlag = true; s_LcursorFlag = true; g_previewFlag = 0;
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			s_owpPlayerButton->setResetButtonListener([]() {
				//##############################################
				// means to stop preview and step to first key 
				//##############################################
				if (s_model) {
					if (s_owpLTimeline) {
						s_LstopFlag = true;
						g_previewFlag = 0;
						s_LcursorFlag = true;
						//s_firstkeyFlag = true;
						////s_LtimelineWnd->setDoneFlag(1);
					}
				}
				});

			s_owpPlayerButton->setSelectToLastButtonListener([]() {
				if (s_model) {
					//g_underselecttolast = true;  s_LcursorFlag = true; g_selecttolastFlag = true;
					//g_underselecttolast = false;  s_LcursorFlag = true; g_selecttolastFlag = true;
					////s_LtimelineWnd->setDoneFlag(1);

					if (s_owpLTimeline) {
						s_LstopFlag = true;
						g_previewFlag = 0;
						s_LcursorFlag = true;
						g_selecttolastFlag = true;
						//s_LtimelineWnd->setDoneFlag(1);
					}
				}
				});

			s_owpPlayerButton->setChangeTargetButtonListener([]() {
				if (s_model) {
					s_LchangeTargetFlag = true;
				}
				});


			//s_owpPlayerButton->setBtResetButtonListener([]() {
			//	if (s_model) {
			//		s_btresetFlag = true;
			//		//StartBt(s_model, TRUE, 0, 1);
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setPrevRangeButtonListener([]() {
			//	if (s_model) {
			//		//g_undereditrange = true; s_prevrangeFlag = true;
			//		////s_LtimelineWnd->setDoneFlag(1);

			//		RollbackCurBoneNo();//2022/11/07
			//		s_undoFlag = true;//2022/11/02 選択範囲だけの履歴をやめて　アンドゥに

			//		//2022/11/27 playerbuttonからundoredoすると　s_LupFlagとs_selectFlagがtrueになり　PrepairUndoが呼ばれる
			//		//undoredo結果が　SaveUndoMotionされないように　s_undoredoFromPlayerButtonフラグを立てる
			//		s_undoredoFromPlayerButton = true;
			//	}
			//	});
			//s_owpPlayerButton->setNextRangeButtonListener([]() {
			//	if (s_model) {
			//		//g_undereditrange = true; s_nextrangeFlag = true;
			//		////s_LtimelineWnd->setDoneFlag(1);

			//		RollbackCurBoneNo();//2022/11/07
			//		s_redoFlag = true;//2022/11/02 選択範囲だけの履歴をやめて　リドゥに

			//		//2022/11/27 playerbuttonからundoredoすると　s_LupFlagとs_selectFlagがtrueになり　PrepairUndoが呼ばれる
			//		//undoredo結果が　SaveUndoMotionされないように　s_undoredoFromPlayerButtonフラグを立てる
			//		s_undoredoFromPlayerButton = true;
			//	}
			//	});
			//s_owpPlayerButton->setPlusDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->PlusDisp();
			//		s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		//s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setMinusDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->MinusDisp();
			//		s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		//s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setPlusOffsetDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->MinusOffset();//上に動かすにはオフセットを減らす
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setMinusOffsetDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->PlusOffset();//下に動かすにはオフセットを増やす
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});
			//s_owpPlayerButton->setResetDispButtonListener([]() {
			//	if (s_model && s_owpEulerGraph) {
			//		s_owpEulerGraph->ResetScaleAndOffset();
			//		//s_LtimelineWnd->setDoneFlag(1);
			//	}
			//	});


			//###################################
			//s_owpLTimelineの関連ラムダをコメントとしてコピペ
			//###################################
			//s_owpLTimeline->setCursorListener([]() { s_LcursorFlag = true; });
			//s_owpLTimeline->setSelectListener([]() { s_selectFlag = true; });
			//s_owpLTimeline->setMouseMDownListener([]() {
			//	s_timelinembuttonFlag = true;
			//	if (s_mbuttoncnt == 0) {
			//		s_mbuttoncnt = 1;
			//	}
			//	else {
			//		s_mbuttoncnt = 0;
			//	}
			//});
			//s_owpLTimeline->setMouseWheelListener([]() {
			//	s_timelinewheelFlag = true;
			//});
		}
		else {
			_ASSERT(0);
			return 1;
		}

		//####################################
		//s_LtimelineWndのラムダ　s_owpLTimelineではない。
		//####################################
		s_LtimelineWnd->setCloseListener([]() {
			if (s_model) {
				s_LcloseFlag = true;
			}
			});
		s_LtimelineWnd->setLDownListener([]() {
			if (s_model) {
				g_underselectingframe = 1;
			}
			});
		s_LtimelineWnd->setLUpListener([]() {
			if (s_model) {
				s_LupFlag = true;
			}
			});

		s_LtimelineWnd->setPos(WindowPos(s_toolwidth, s_2ndposy));
		s_LtimelineWnd->setSizeMin(OrgWinGUI::WindowSize(100, 100));
		s_LtimelineWnd->setSize(WindowSize(s_longtimelinewidth, s_longtimelineheight));
		//s_LtimelineWnd->refreshPosAndSize();//2022/09/20
		s_LtimelineWnd->callRewrite();
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;
}

int Params2SideMenuWnd()//2024/06/06
{
	if (s_sidemenu_sellock) {
		s_sidemenu_sellock->setValue(s_camtargetflag, false);
	}

	if (s_sidemenu_targetdisp) {
		s_sidemenu_targetdisp->setValue(s_camtargetdisp, false);
	}
	
	if (s_sidemenu_moveeyepos) {
		s_sidemenu_moveeyepos->setValue(s_moveeyepos, false);
	}

	if (s_sidemenu_camdistSlider) {
		s_sidemenu_camdistSlider->setValue((double)g_camdist, false);
	}

	return 0;
}

int Params2TopSlidersWnd()
{

	if (s_owpEditRateSlider) {
		s_owpEditRateSlider->setValue(g_physicsmvrate, false);
	}
	if (s_owpSpeedSlider) {
		s_owpSpeedSlider->setValue(g_dspeed, false);
	}
	if (s_owpBrushRepeatsSlider) {
		s_owpBrushRepeatsSlider->setValue((double)g_brushrepeats, false);
	}
	if (s_owpBrushMirrorU) {
		s_owpBrushMirrorU->setValue((g_brushmirrorUflag == 1), false);
	}
	if (s_owpBrushMirrorV) {
		s_owpBrushMirrorV->setValue((g_brushmirrorVflag == 1), false);
	}
	return 0;
}

int CreateTopSlidersWnd()
{

	WCHAR sliderinfo[2048] = { 0L };
	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;

		//ウインドウタイトルをスライダーの説明として使う　スペースキーで適当に位置を合わせる
		wcscpy_s(sliderinfo, 2048, L"Slider1 : EditRate,                                                                                               \
       Slier2 : Speed,                                                                                                    \
                                                                  Slider3 : BrushRepeats");

	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;

		//ウインドウタイトルをスライダーの説明として使う　スペースキーで適当に位置を合わせる
		wcscpy_s(sliderinfo, 2048, L"Slider1 : EditRate,                              \
   Slier2 : Speed,                                 \
                                   Slider3 : BrushRepeats");
	}

	s_topSlidersWnd = new OrgWindow(
		0,
		_T("TopSlidersWnd"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
								//WindowPos(100, 200),		//位置
		WindowPos(0, 0),
		//WindowSize(450,880),		//サイズ
		//WindowSize(450,680),		//サイズ
		//WindowSize(450, 760),		//サイズ
		WindowSize(windowposx, TOPSLIDERSWNDH),		//サイズ
		//_T("TopSlidersWnd"),	//タイトル
		sliderinfo,
		g_mainhwnd,	//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true, true);					//サイズ変更の可否


	int labelheight;
	if (g_4kresolution) {
		labelheight = 20;
	}
	else {
		labelheight = 18;
	}


	if (s_topSlidersWnd) {
		//s_sidemenuWnd->setCloseListener([]() { s_ScloseFlag = true; });

		s_topSlidersWnd->setBlackTheme();
		s_topSlidersSeparator1 = new OWP_Separator(s_topSlidersWnd, true, 0.5, true);
		if (!s_topSlidersSeparator1) {
			_ASSERT(0);
			return 1;
		}
		s_topSlidersSeparator2 = new OWP_Separator(s_topSlidersWnd, true, 0.5, true);
		if (!s_topSlidersSeparator2) {
			_ASSERT(0);
			return 1;
		}
		s_topSlidersSeparator3 = new OWP_Separator(s_topSlidersWnd, true, 0.30, true);
		if (!s_topSlidersSeparator3) {

			_ASSERT(0);
			return 1;
		}
		s_topSlidersSeparator4 = new OWP_Separator(s_topSlidersWnd, true, 0.5, true);
		if (!s_topSlidersSeparator4) {
			_ASSERT(0);
			return 1;
		}
		s_owpEditRateSlider = new OWP_Slider(g_physicsmvrate, 50.0, 0.0);
		if (!s_owpEditRateSlider) {
			_ASSERT(0);
			return 1;
		}
		s_owpSpeedSlider = new OWP_Slider(g_dspeed, 7.0, 0.0);
		if (!s_owpSpeedSlider) {
			_ASSERT(0);
			return 1;
		}
		//s_owpTopPosSlider = new OWP_Slider(g_applyrate, 100.0, 0.0);
		//if (!s_owpTopPosSlider) {
		//	_ASSERT(0);
		//	return 1;
		//}
		s_owpBrushRepeatsSlider = new OWP_Slider((double)g_brushrepeats, 100.0, 1.0, labelheight);
		if (!s_owpBrushRepeatsSlider) {
			_ASSERT(0);
			return 1;
		}
		s_owpBrushMirrorU = new OWP_CheckBoxA(L"Brush U", (g_brushmirrorUflag == 1), labelheight, false);
		if (!s_owpBrushMirrorU) {
			_ASSERT(0);
			return 1;
		}
		s_owpBrushMirrorV = new OWP_CheckBoxA(L"Brush V", (g_brushmirrorVflag == 1), labelheight, false);
		if (!s_owpBrushMirrorV) {
			_ASSERT(0);
			return 1;
		}



		s_topSlidersWnd->addParts(*s_topSlidersSeparator1);
		s_topSlidersSeparator1->addParts1(*s_topSlidersSeparator2);
		//s_topSlidersSeparator1->addParts2(*s_owpTopPosSlider);
		s_topSlidersSeparator1->addParts2(*s_topSlidersSeparator3);
		s_topSlidersSeparator2->addParts1(*s_owpEditRateSlider);
		s_topSlidersSeparator2->addParts2(*s_owpSpeedSlider);
		s_topSlidersSeparator3->addParts1(*s_topSlidersSeparator4);
		s_topSlidersSeparator3->addParts2(*s_owpBrushRepeatsSlider);
		s_topSlidersSeparator4->addParts1(*s_owpBrushMirrorU);
		s_topSlidersSeparator4->addParts2(*s_owpBrushMirrorV);

		//if (s_owpTopPosSlider) {
		//	s_owpTopPosSlider->setCursorListener([]() {
		//		if (s_topslidersTopPosFlag == false) {
		//			s_topslidersTopPosFlag = true;
		//		}
		//	});
		//	s_owpTopPosSlider->setLUpListener([]() {
		//		if (s_utApplyRateFlag == false) {
		//			//#################################################
		//			//ReleasedCaptureのときに　PrepairUndo用のフラグを立てる
		//			//#################################################
		//			s_utApplyRateFlag = true;//PrepairUndo();//保存はOnFrameUtCheckBoxにて
		//		}
		//	});
		//}

		if (s_owpBrushRepeatsSlider) {
			s_owpBrushRepeatsSlider->setCursorListener([]() {
				g_brushrepeats = (int)(s_owpBrushRepeatsSlider->getValue() + 0.0001);//整数
				if (!s_topslidersBrushRepeatsFlag) {
					s_topslidersBrushRepeatsFlag = true;
				}
			});
			s_owpBrushRepeatsSlider->setLUpListener([]() {
				g_brushrepeats = (int)(s_owpBrushRepeatsSlider->getValue() + 0.0001);
				s_owpBrushRepeatsSlider->setValue((double)g_brushrepeats, false);//整数
				if (s_utBrushRepeatsFlag == false) {
					//#################################################
					//ReleasedCaptureのときに　PrepairUndo用のフラグを立てる
					//#################################################
					s_utBrushRepeatsFlag = true;//PrepairUndo();//保存はOnFrameUtCheckBoxにて
				}
			});
		}
		if (s_owpBrushMirrorU) {
			s_owpBrushMirrorU->setButtonListener([]() {
				bool value = s_owpBrushMirrorU->getValue();
				if (value) {
					g_brushmirrorUflag = 1;
				}
				else {
					g_brushmirrorUflag = 0;
				}
				s_topslidersBrushMirrorUFlag = true;
			});
		}
		if (s_owpBrushMirrorV) {
			s_owpBrushMirrorV->setButtonListener([]() {
				bool value = s_owpBrushMirrorV->getValue();
				if (value) {
					g_brushmirrorVflag = 1;
				}
				else {
					g_brushmirrorVflag = 0;
				}
				s_topslidersBrushMirrorVFlag = true;
			});
		}
		if (s_owpEditRateSlider) {
			s_owpEditRateSlider->setCursorListener([]() {
				if (s_topslidersEditRateFlag == false) {
					s_topslidersEditRateFlag = true;
				}
				});
		}
		if (s_owpSpeedSlider) {
			s_owpSpeedSlider->setCursorListener([]() {
				if (s_topslidersSpeedFlag == false) {
					s_topslidersSpeedFlag = true;
				}
				});
		}



		//2024/04/24 正しい配置のために必要
		s_topSlidersSeparator3->autoResize();//separator4よりも前で
		s_topSlidersSeparator4->autoResize();
		s_topSlidersSeparator2->autoResize();
		s_topSlidersSeparator1->autoResize();


		//450, 32
		s_rctopsliderswnd.top = 0;
		s_rctopsliderswnd.left = 0;
		s_rctopsliderswnd.bottom = TOPSLIDERSWNDH;

		s_topSlidersWnd->setSize(WindowSize(windowposx, TOPSLIDERSWNDH));
		s_topSlidersWnd->setPos(WindowPos(0, 0));
		//１クリック目問題対応
		s_topSlidersWnd->refreshPosAndSize();//2022/09/20
		s_topSlidersWnd->autoResizeAllParts();

		//if (s_owpBrushRepeatsSlider) {
		//	WindowPos tmppos = s_owpBrushRepeatsSlider->getPos();
		//	s_owpBrushRepeatsSlider->setPos(WindowPos(tmppos.x, 16));
		//}
		//if (s_owpBrushMirrorU) {
		//	WindowPos tmppos = s_owpBrushMirrorU->getPos();
		//	s_owpBrushMirrorU->setPos(WindowPos(tmppos.x, 16));
		//}
		//if (s_owpBrushMirrorV) {
		//	WindowPos tmppos = s_owpBrushMirrorV->getPos();
		//	s_owpBrushMirrorV->setPos(WindowPos(tmppos.x, 16));
		//}
		//if (s_owpEditRateSlider) {
		//	WindowPos tmppos = s_owpEditRateSlider->getPos();
		//	s_owpEditRateSlider->setPos(WindowPos(tmppos.x, 16));
		//}
		//if (s_owpSpeedSlider) {
		//	WindowPos tmppos = s_owpSpeedSlider->getPos();
		//	s_owpSpeedSlider->setPos(WindowPos(tmppos.x, 16));
		//}


		s_topSlidersWnd->setVisible(true);
		s_topSlidersWnd->callRewrite();						//再描画

		s_rctopsliderswnd.right = windowposx;

	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;

}

int CreateSideMenuWnd()
{
	s_sidemenuWnd = new OrgWindow(
		0,
		//_T("SideMenuWindow"),		//ウィンドウクラス名
		_T("CameraTargetWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
								//WindowPos(100, 200),		//位置
		WindowPos(0, 0),
		//WindowSize(450,880),		//サイズ
		//WindowSize(450,680),		//サイズ
		//WindowSize(450, 760),		//サイズ
		WindowSize(s_sidemenuwidth, s_sidemenuheight),		//サイズ
		//_T("SideMenu"),	//タイトル
		_T("CameraTarget"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true, true);					//サイズ変更の可否

	if (s_sidemenuWnd) {


		s_sidemenusp1 = new OWP_Separator(s_sidemenuWnd, true, 0.5f, true);
		if (!s_sidemenusp1) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenusp2 = new OWP_Separator(s_sidemenuWnd, true, 0.5f, true);
		if (!s_sidemenusp2) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenusp3 = new OWP_Separator(s_sidemenuWnd, true, 0.5f, true);
		if (!s_sidemenusp3) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenu_sellock = new OWP_CheckBoxA(L"AlwaysLock", s_camtargetflag, 15, false);
		if (!s_sidemenu_sellock) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenu_sellockOnce = new OWP_Button(L"OnceLock", 15);
		if (!s_sidemenu_sellockOnce) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenu_targetdisp = new OWP_CheckBoxA(L"DispTarget", s_camtargetdisp, 15, false);
		if (!s_sidemenu_targetdisp) {
			_ASSERT(0);
			return 1;
		}
		s_sidemenu_moveeyepos = new OWP_CheckBoxA(L"MoveEyePos", s_moveeyepos, 15, false);
		if (!s_sidemenu_moveeyepos) {
			_ASSERT(0);
			return 1;
		}
		g_camdist = (float)fmin(g_camdist, s_maxcamdist);
		g_camdist = (float)fmax(g_camdist, 1.0);
		//s_sidemenu_camdistSlider = new OWP_Slider(g_camdist, 1000.0, 1.0);
		s_sidemenu_camdistSlider = new OWP_Slider(g_camdist, (double)s_maxcamdist, 1.0);//2024/06/03 maxを5000から20000に変更
		if (!s_sidemenu_camdistSlider) {
			_ASSERT(0);
			return 1;
		}
		//s_sidemenu_sellock->setSize(WindowSize((int)(s_sidemenuwidth * 0.25f), (int)s_sidemenuheight));
		//s_sidemenu_targetdisp->setSize(WindowSize((int)(s_sidemenuwidth * 0.25f), (int)s_sidemenuheight));
		//s_sidemenu_camdistSlider->setSize(WindowSize((int)(s_sidemenuwidth * 0.5f), (int)s_sidemenuheight));

		//s_sidemenuWnd->addParts(*s_sidemenusp1);
		//s_sidemenusp1->addParts1(*s_sidemenusp2);
		//s_sidemenusp1->addParts2(*s_sidemenu_camdistSlider);
		//s_sidemenusp2->addParts1(*s_sidemenu_sellock);
		//s_sidemenusp2->addParts2(*s_sidemenu_targetdisp);
		//s_sidemenusp2->addParts2(*s_sidemenu_moveeyepos);//２段目 targetdispの下

		s_sidemenuWnd->addParts(*s_sidemenusp1);
		s_sidemenusp1->addParts1(*s_sidemenusp2);
		s_sidemenusp1->addParts2(*s_sidemenusp3);
		s_sidemenusp2->addParts1(*s_sidemenu_sellockOnce);
		s_sidemenusp2->addParts2(*s_sidemenu_sellock);
		s_sidemenusp3->addParts1(*s_sidemenu_moveeyepos);
		s_sidemenusp3->addParts2(*s_sidemenu_targetdisp);
		s_sidemenuWnd->addParts(*s_sidemenu_camdistSlider);//２段目の全幅をスライダーに割り当て


		s_sidemenuWnd->setCloseListener([]() {
			if (s_model) {
				s_ScloseFlag = true;
			}
			});

		if (s_sidemenu_sellock) {
			s_sidemenu_sellock->setButtonListener([]() {
				bool value = s_sidemenu_sellock->getValue();
				if (value) {
					if (s_model) {
						int curmotid = s_model->GetCurrentMotID();
						bool cameraanimflag = s_model->IsCameraMotion(curmotid);
						if (cameraanimflag) {
							//jointの位置はjointのモーションに依存するから
							::MessageBox(s_3dwnd, L"カメラモーション以外を選択してから再試行してください.", L"CurrentMotion is Camera warning",
								MB_OK | MB_ICONINFORMATION);

							s_sidemenu_sellock->setValue(false, false);
						}
						else {
							s_befLockMatView = s_matView;//2024/06/06
							s_camtargetflag = true;

							//sellockオンの時はカメラが選択ジョイント中心回転、targetdispオンの時はカメラがマニピュレータ(カメラターゲット位置)中心回転
							//両方オンにすると分かりずらいので排他選択
							if (s_sidemenu_targetdisp) {
								s_sidemenu_targetdisp->setValue(false, false);
								s_camtargetdisp = false;
							}

							s_camtargetOnceflag = 1;//2024/06/04  2024/06/06オンの時だけ

						}
					}
				}
				else {
					s_camtargetflag = false;
				}
			});
		}
		if (s_sidemenu_sellockOnce) {
			s_sidemenu_sellockOnce->setButtonListener([]() {
				if (s_model) {
					int curmotid = s_model->GetCurrentMotID();
					bool cameraanimflag = s_model->IsCameraMotion(curmotid);
					if (cameraanimflag) {
						//jointの位置はjointのモーションに依存するから
						::MessageBox(s_3dwnd, L"カメラモーション以外を選択してから再試行してください.", L"CurrentMotion is Camera warning",
							MB_OK | MB_ICONINFORMATION);

						s_sidemenu_sellock->setValue(false, false);
					}
					else {
						//Once
						s_befLockMatView = s_matView;
						s_camtargetOnceflag = 1;

					}
				}
			});
		}
		if (s_sidemenu_targetdisp) {
			s_sidemenu_targetdisp->setButtonListener([]() {
				bool value = s_sidemenu_targetdisp->getValue();
				if (value) {
					s_camtargetdisp = true;

					//sellockオンの時はカメラが選択ジョイント中心回転、targetdispオンの時はカメラがマニピュレータ(カメラターゲット位置)中心回転
					//両方オンにすると分かりずらいので排他選択
					if (s_sidemenu_sellock) {
						s_sidemenu_sellock->setValue(false, false);
						s_camtargetflag = false;
					}
				}
				else {
					s_camtargetdisp = false;
				}
			});
		}
		if (s_sidemenu_moveeyepos) {
			s_sidemenu_moveeyepos->setButtonListener([]() {
				bool value = s_sidemenu_moveeyepos->getValue();
				if (value) {
					s_moveeyepos = true;
				}
				else {
					s_moveeyepos = false;
				}
			});
		}

		if (s_sidemenu_camdistSlider) {
			s_sidemenu_camdistSlider->setCursorListener([]() {
				s_camdistsliderval = (float)s_sidemenu_camdistSlider->getValue();
				s_camdistsliderflag = true;
			});
		}


		int windowposx;
		if (g_4kresolution) {
			//windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
			windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
		}
		else {
			//windowposx = s_timelinewidth + s_mainwidth;
			windowposx = s_timelinewidth + s_mainwidth;
		}

		s_sidemenuWnd->setPos(WindowPos(windowposx, 0));

		//450, 32
		s_rcsidemenuwnd.top = 0;
		s_rcsidemenuwnd.left = 0;
		s_rcsidemenuwnd.bottom = s_sidemenuheight;
		s_rcsidemenuwnd.right = s_sidemenuwidth;

		//１クリック目問題対応
		s_sidemenuWnd->refreshPosAndSize();//2022/09/20


		s_sidemenuWnd->callRewrite();						//再描画

	}
	else {
		_ASSERT(0);
		return 1;
	}

	

	return 0;
}

int CreatePlaceFolderWnd()
{
	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}


	s_placefolderWnd = new OrgWindow(
		0,
		_T("PlaceFolderWindow"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),
		WindowSize(s_sidewidth, s_sideheight),		//サイズ
		_T("PlaceFolderWindow"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		true,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true, true);					//サイズ変更の可否

	int labelheight;
	if (g_4kresolution) {
		labelheight = 18;
	}
	else {
		labelheight = 15;
	}


	if (s_placefolderWnd) {
		//s_placefolderlabel_1 = new OWP_Label(L"After Loading Model Data,");
		//if (!s_placefolderlabel_1) {
		//	_ASSERT(0);
		//	return 1;
		//}
		//s_placefolderlabel_2 = new OWP_Label(L"Click Frog Button for Change Plate Menu.");
		//if (!s_placefolderlabel_2) {
		//	_ASSERT(0);
		//	return 1;
		//}
		//s_placefolderlabel_3 = new OWP_Label(L" ");
		//if (!s_placefolderlabel_3) {
		//	_ASSERT(0);
		//	return 1;
		//}


		WCHAR shortcuttext[SHORTCUTTEXTNUM][90] = {
			L"ShortCutKey",
			L" ",
			L"　Menu",
			L"　　SpaceKey　：　Change kind of PlateMenu.",
			L"　　C + SpaceKey　：　Change Plate.",
			L"　　V + SpaceKey　：　Change ToolShortCutButtons.",
			L" ",
			L"　Joint Selection",
			L"　　H + LeftArrow or RightArrow　：　Select LeftHand or RightHand.",
			L"	　　　JointName whitch contain string L_Hand or LeftHand",

			L"	　　　JointName whitch contain string R_Hand or RightHand",
			L"　　F + LeftArrow or RightArrow　：　Select LeftFoot or RightFoot.",
			L"	　　　JointName whitch contain string L_Foot or LeftFoot",
			L"	　　　JointName whitch contain string R_Foot or RightFoot",
			L" ",
			L"　　LeftArrow or RightArrow　：　Select joint whitch is at same depth level.",
			L" ",
			L"　　UpperArrow or LowerArrow　：　Select parent joint or child joint.",
			L" ",
			L"　Brush Selection",

			L"　　RClick in the margin of 3DWnd　：　Select Brush.",
			L"　　RClick or RDrag in the Timeline of EulerGraph　：　Set TopPos of BrushShape.",
			L" ",
			L"　Edit Motion",
			L"　　T + MouseWheel　：　Twist motion.",
			L" ",
			L"　　Shift + Drag(X or Y or Z) on ScalingMode　：　Scale all axes.",
			L" ",
			L" ",
			L"　Timeline",
			
			L"　　Ctrl + MouseWheel　：　Move frame selection by 1 frame.",
			L" ",
			L"　Manipulator",
			L"　　S + Mouse_R_Drag　：　Change manipulator scale.",
			L" ",
			L"　OWP_Slider",
			L"　　Drag on CenterBar　：　Slide starting from clicked position.",
			L"    LButton DoubleClick :  Set value of clicked position.",
			L"    RButton DoubleClick :  Undo value limited to 1,000,000 times.",
			L"    Mouse Wheel : Slide per a pixel.",
			
			L" ",
			L"　DispGroupWindow",
			L"　　RButton on a Element　：　Context Menu for SimilarCheck.",
			L" ",
			L"　OWP_ScrollWindow",
			L"　　MouseWheel on ScrollBar　：　Scroll Window.",
			L" ",
			L"　Pick on ShaderPlateMenu, DispGroupPlateMenu",
			L"　　NumKey(1-9) : Pick an object from the camera close to theNumber.",
			L" "

		};

		int textno;
		for (textno = 0; textno < SHORTCUTTEXTNUM; textno++) {
			s_shortcuttext[textno] = new OWP_Label(shortcuttext[textno], labelheight);
			if (!s_shortcuttext[textno]) {
				_ASSERT(0);
				return 1;
			}
		
			//red color new line
			//if (textno == 25) {
			//if ((textno == 19) || (textno == 20)) {
			if (textno == 21) {
				COLORREF colred = RGB(168, 129, 129);
				s_shortcuttext[textno]->setTextColor(colred);
			}
		}



		//s_placefolderWnd->addParts(*s_placefolderlabel_1);
		//s_placefolderWnd->addParts(*s_placefolderlabel_2);
		//s_placefolderWnd->addParts(*s_placefolderlabel_3);
		for (textno = 0; textno < SHORTCUTTEXTNUM; textno++) {
			s_placefolderWnd->addParts(*s_shortcuttext[textno]);
		}


		s_placefolderWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
		s_placefolderWnd->setPos(WindowPos(windowposx, s_sidemenuheight));

		//１クリック目問題対応
		s_placefolderWnd->refreshPosAndSize();//2022/09/20


		s_placefolderWnd->callRewrite();						//再描画

		s_placefolderWnd->setVisible(false);
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;

}

int CheckSimilarMenu()//context menu
{
	if (!s_model) {
		return 0;
	}

	HWND parwnd;
	parwnd = s_3dwnd;


	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_CHECKSIMILARGROUP);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}


	WCHAR strmenu[256] = { 0L };
	int setmenuid;

	setmenuid = ID_RMENU_0 + 0 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"SimilarON (pattern include number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);
	
	setmenuid = ID_RMENU_0 + 1 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"SimilarOFF (pattern include number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);

	setmenuid = ID_RMENU_0 + 2 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"SimilarON (pattern exclude number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);

	setmenuid = ID_RMENU_0 + 3 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"SimilarOFF (pattern exclude number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);

	//2024/03/02 check 2nd word
	setmenuid = ID_RMENU_0 + 4 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"2nd SimilarON (pattern include number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);

	setmenuid = ID_RMENU_0 + 5 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"2nd SimilarOFF (pattern include number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);

	setmenuid = ID_RMENU_0 + 6 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"2nd SimilarON (pattern exclude number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);

	setmenuid = ID_RMENU_0 + 7 + MENUOFFSET_CHECKSIMILARGROUP;
	wcscpy_s(strmenu, 256, L"2nd SimilarOFF (pattern exclude number)");
	AppendMenu(submenu, MF_STRING, setmenuid, strmenu);


	POINT pt;
	GetCursorPos(&pt);
	//::ScreenToClient(parwnd, &pt);

	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	return 0;
}

int CreateToolWnd()
{
	/////////
	// ツールウィンドウを作成してボタン類を追加
	s_toolWnd = new OrgWindow(
		0,
		L"ToolWindow_",		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		//WindowPos(400, 580),		//位置
		//WindowPos(50, 645),		//位置
		WindowPos(0, s_2ndposy),		//位置
		WindowSize(s_toolwidth, s_toolheight),		//サイズ
		L"ToolWindow",	//タイトル
		//s_timelineWnd->getHWnd(),	//親ウィンドウハンドル
		g_mainhwnd,
		true,					//表示・非表示状態
		//70, 50, 70);// ,				//カラー
		0, 0, 0);				//カラー

	//	true);// ,					//閉じられるか否か
	//	false);					//サイズ変更の可否

	//s_toolWnd->callRewrite();

	int labelheight;
	if (g_4kresolution) {
		labelheight = 28;
	}
	else {
		labelheight = 15;
	}

	if (s_toolWnd) {
		s_toolSelBoneB = new OWP_Button(_T("コマンド対象ボーン target bone"), labelheight);
		if (!s_toolSelBoneB) {
			_ASSERT(0);
			return 1;
		}
		s_toolSelectCopyFileName = new OWP_Button(_T("コピー履歴選択 sel cp history"), labelheight);
		if (!s_toolSelectCopyFileName) {
			_ASSERT(0);
			return 1;
		}
		s_toolCopyB = new OWP_Button(_T("コピー copy"), labelheight);
		if (!s_toolCopyB) {
			_ASSERT(0);
			return 1;
		}
		s_toolSymCopyB = new OWP_Button(_T("対称コピー sym copy"), labelheight);
		if (!s_toolSymCopyB) {
			_ASSERT(0);
			return 1;
		}
		//s_toolCutB = new OWP_Button(_T("カット"));
		s_toolPasteB = new OWP_Button(_T("ペースト paste"), labelheight);
		if (!s_toolPasteB) {
			_ASSERT(0);
			return 1;
		}
		s_toolInitMPB = new OWP_Button(_T("姿勢初期化 init"), labelheight);
		if (!s_toolInitMPB) {
			_ASSERT(0);
			return 1;
		}
		//s_toolDeleteB = new OWP_Button(_T("削除"));
		//s_toolMarkB = new OWP_Button(_T("マーク作成"));
		s_toolMotPropB = new OWP_Button(_T("プロパティ property"), labelheight);
		if (!s_toolMotPropB) {
			_ASSERT(0);
			return 1;
		}
		s_toolFilterB = new OWP_Button(_T("平滑化 smoothing"), labelheight);
		if (!s_toolFilterB) {
			_ASSERT(0);
			return 1;
		}
		s_toolInterpolateB = new OWP_Button(_T("補間 interpolate"), labelheight);
		if (!s_toolInterpolateB) {
			_ASSERT(0);
			return 1;
		}
		s_toolZeroFrameB = new OWP_Button(_T("Edit 0 Frame"), labelheight);
		if (!s_toolZeroFrameB) {
			_ASSERT(0);
			return 1;
		}
		s_toolSkipRenderBoneMarkB = new OWP_Button(_T("jointマークスキップ(Deeper)"), labelheight);
		if (!s_toolSkipRenderBoneMarkB) {
			_ASSERT(0);
			return 1;
		}
		s_toolSkipRenderBoneMarkB2 = new OWP_Button(_T("jointマークスキップReset(Deeper)"), labelheight);
		if (!s_toolSkipRenderBoneMarkB2) {
			_ASSERT(0);
			return 1;
		}
		//s_tool180deg = new OWP_Button(_T("180度修正 180deg Adjust Euler"));
		s_toolScaleInitAllB = new OWP_Button(_T("ScaleAllInit(ギザギザしたら押す)"), labelheight);
		if (!s_toolScaleInitAllB) {
			_ASSERT(0);
			return 1;
		}
		s_toolCameraDollyB = new OWP_Button(_T("カメラ数値ドリー (CameraDolly)"), labelheight);
		if (!s_toolCameraDollyB) {
			_ASSERT(0);
			return 1;
		}
		s_toolMaterialRateB = new OWP_Button(_T("モデルマテリアル倍率MaterialRate"), labelheight);
		if (!s_toolMaterialRateB) {
			_ASSERT(0);
			return 1;
		}
		s_toolModelWorldMatB = new OWP_Button(_T("モデル位置向きModelWorldMat"), labelheight);
		if (!s_toolModelWorldMatB) {
			_ASSERT(0);
			return 1;
		}



		s_toolWnd->addParts(*s_toolSelBoneB);
		s_toolWnd->addParts(*s_toolSelectCopyFileName);
		s_toolWnd->addParts(*s_toolCopyB);
		s_toolWnd->addParts(*s_toolSymCopyB);
		s_toolWnd->addParts(*s_toolPasteB);
		s_toolWnd->addParts(*s_toolInitMPB);
		//s_toolWnd->addParts(*s_toolMarkB);
		s_toolWnd->addParts(*s_toolMotPropB);
		s_toolWnd->addParts(*s_toolFilterB);
		s_toolWnd->addParts(*s_toolInterpolateB);
		s_toolWnd->addParts(*s_toolZeroFrameB);
		s_toolWnd->addParts(*s_toolSkipRenderBoneMarkB);
		s_toolWnd->addParts(*s_toolSkipRenderBoneMarkB2);
		//s_toolWnd->addParts(*s_tool180deg);
		s_toolWnd->addParts(*s_toolScaleInitAllB);
		s_toolWnd->addParts(*s_toolCameraDollyB);
		s_toolWnd->addParts(*s_toolMaterialRateB);
		s_toolWnd->addParts(*s_toolModelWorldMatB);

		s_dstoolctrls.push_back(s_toolSelBoneB);
		s_dstoolctrls.push_back(s_toolCopyB);
		s_dstoolctrls.push_back(s_toolSymCopyB);
		s_dstoolctrls.push_back(s_toolPasteB);
		s_dstoolctrls.push_back(s_toolInitMPB);
		//s_dstoolctrls.push_back(s_toolMarkB);
		s_dstoolctrls.push_back(s_toolMotPropB);
		s_dstoolctrls.push_back(s_toolFilterB);
		s_dstoolctrls.push_back(s_toolInterpolateB);
		s_dstoolctrls.push_back(s_toolZeroFrameB);
		s_dstoolctrls.push_back(s_toolSkipRenderBoneMarkB);
		s_dstoolctrls.push_back(s_toolSkipRenderBoneMarkB2);
		//s_dstoolctrls.push_back(s_tool180deg);
		s_dstoolctrls.push_back(s_toolScaleInitAllB);
		s_dstoolctrls.push_back(s_toolCameraDollyB);
		s_dstoolctrls.push_back(s_toolMaterialRateB);
		s_dstoolctrls.push_back(s_toolModelWorldMatB);


		s_toolWnd->setCloseListener([]() {
			if (s_model) {
				if (s_closetoolFlag == false) {
					s_closetoolFlag = true;
				}
			}
			});
		//s_toolWnd->setHoverListener([]() { SetCapture(s_toolWnd->getHWnd()); });
		//s_toolWnd->setLeaveListener([]() { ReleaseCapture(); });
		s_toolSelectCopyFileName->setButtonListener([]() {
			if (s_model) {
				if (s_selCopyHisotryFlag == false) {
					s_selCopyHisotryFlag = true;
				}
			}
			});
		s_toolCopyB->setButtonListener([]() {
			if (s_model) {
				if (s_copyFlag == false) {
					s_copyFlag = true;
				}
			}
			});
		s_toolZeroFrameB->setButtonListener([]() {
			if (s_model) {
				if (s_owpLTimeline) {
					if (s_zeroFrameFlag == false) {
						s_LstopFlag = true;
						g_previewFlag = 0;
						s_LcursorFlag = true;
						s_zeroFrameFlag = true;
					}
				}
			}
			});

		s_toolSymCopyB->setButtonListener([]() {
			if (s_model) {
				if (s_symcopyFlag == false) {
					s_symcopyFlag = true;
				}
			}
			});
		s_toolPasteB->setButtonListener([]() {
			if (s_model) {
				if (s_pasteFlag == false) {
					s_pasteFlag = true;
				}
			}
			});
		s_toolMotPropB->setButtonListener([]() {
			if (s_model) {
				if (s_motpropFlag == false) {
					s_motpropFlag = true;
				}
			}
			});
		//s_toolMarkB->setButtonListener( [](){ s_markFlag = true; } );
		s_toolSelBoneB->setButtonListener([]() {
			if (s_model) {
				if (s_selboneFlag == false) {
					s_selboneFlag = true;
				}
			}
			});
		s_toolInitMPB->setButtonListener([]() {
			if (s_model) {
				if (s_initmpFlag == false) {
					s_initmpFlag = true;
				}
			}
			});
		s_toolFilterB->setButtonListener([]() {
			if (s_model) {
				if (s_filterFlag == false) {
					s_filterFlag = true;
				}
			}
			});
		s_toolInterpolateB->setButtonListener([]() {
			if (s_model && (s_interpolateFlag == false)) {
				s_interpolateFlag = true;
			}
			});
		s_toolSkipRenderBoneMarkB->setButtonListener([]() {
			if (s_model && (s_skipJointMark == 0)) {
				s_skipJointMark = 1;//deeper
			}
			});
		s_toolSkipRenderBoneMarkB2->setButtonListener([]() {
			if (s_model && (s_skipJointMark == 0)) {
				s_skipJointMark = 2;//deeper
			}
			});
		//s_tool180deg->setButtonListener([]() {
		//	if (s_model && (s_180DegFlag == false)) {
		//		s_180DegFlag = true;
		//	}
		//});
		s_toolScaleInitAllB->setButtonListener([]() {
			if (s_model && (s_scaleAllInitFlag == false)) {
				s_scaleAllInitFlag = true;
			}
			});
		s_toolCameraDollyB->setButtonListener([]() {
			if (s_model && (s_cameradollyFlag == false)) {
				s_cameradollyFlag = true;
			}
			});
		s_toolMaterialRateB->setButtonListener([]() {
			if (s_model && (s_materialrateFlag == false)) {
				s_materialrateFlag = true;
			}
			});
		s_toolModelWorldMatB->setButtonListener([]() {
			if (s_model && (s_modelworldmatFlag == false)) {
				s_modelworldmatFlag = true;
			}
			});


		s_rctoolwnd.top = 0;
		s_rctoolwnd.left = 0;
		s_toolWnd->setPos(WindowPos(0, s_2ndposy));
		s_rctoolwnd.bottom = s_toolheight;
		s_rctoolwnd.right = s_toolwidth;


		s_toolWnd->autoResizeAllParts();
		s_toolWnd->refreshPosAndSize();//これを呼ばないと1回目のクリック位置がずれることがある。

	}
	else {
		_ASSERT(0);
		return 1;
	}


	return 0;

}


int CreateLayerWnd()
{
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	if (s_layerWnd) {
		//_ASSERT(0);
		return 0;
	}

	WindowSize layersize;

	////
	// ウィンドウを作成
	if (g_4kresolution) {
		layersize = WindowSize(150 * 2, 200 * 2);
		s_layerWnd = new OrgWindow(
			1,
			_T("LayerTool"),		//ウィンドウクラス名
			GetModuleHandle(NULL),	//インスタンスハンドル
			//WindowPos(800, 500),		//位置
			//WindowPos(250, 645),		//位置
			//WindowPos(250, 660),		//位置
			WindowPos(2000, 660),		//位置
			layersize,		//サイズ
			_T("LayerTool"),	//タイトル
			//g_mainhwnd,					//親ウィンドウハンドル
			//s_3dwnd,
			NULL,//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 他所をクリックしても隠れないように
			true,					//表示・非表示状態
			//false,					//表示・非表示状態
			//70, 50, 70,				//カラー
			0, 0, 0,				//カラー
			true,					//閉じられるか否か
			true);					//サイズ変更の可否
	}
	else {
		layersize = WindowSize(150, 200);
		s_layerWnd = new OrgWindow(
			1,
			_T("LayerTool"),		//ウィンドウクラス名
			GetModuleHandle(NULL),	//インスタンスハンドル
			//WindowPos(800, 500),		//位置
			//WindowPos(250, 645),		//位置
			//WindowPos(250, 660),		//位置
			WindowPos(2000, 660),		//位置
			layersize,		//サイズ
			_T("LayerTool"),	//タイトル
			//g_mainhwnd,					//親ウィンドウハンドル
			//s_3dwnd,
			NULL,//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 他所をクリックしても隠れないように
			true,					//表示・非表示状態
			//false,					//表示・非表示状態
			//70, 50, 70,				//カラー
			0, 0, 0,				//カラー
			true,					//閉じられるか否か
			true);					//サイズ変更の可否
	}

	if (s_layerWnd) {
		s_layerWnd->setVisible(false);

		// レイヤーウィンドウパーツを作成
		s_owpLayerTable = new OWP_LayerTable(_T("レイヤーテーブル"));
		if (!s_owpLayerTable) {
			_ASSERT(0);
			return 1;
		}


		s_owpLayerTable->setSize(WindowSize(layersize.x - 30, layersize.y));
		s_layerWnd->addParts(*s_owpLayerTable);


		WCHAR label[256];
		wcscpy_s(label, 256, L"dummy name");
		s_owpLayerTable->newLine(label, 0);

		// ウィンドウにウィンドウパーツを登録
		//s_layerWnd->addParts(*s_owpLayerTable);


		s_layerWnd->setCloseListener([]() {
			if (s_model) {
				s_closeobjFlag = true;
			}
			});

		//レイヤーのカーソルリスナー
		s_owpLayerTable->setCursorListener([]() {
			//_tprintf_s( _T("CurrentLayer: Index=%3d Name=%s\n"),
			//			owpLayerTable->getCurrentLine(),
			//			owpLayerTable->getCurrentLineName().c_str() );
			});

		//レイヤーの移動リスナー
		s_owpLayerTable->setLineShiftListener([](int from, int to) {
			//_tprintf_s( _T("ShiftLayer: fromIndex=%3d toIndex=%3d\n"), from, to );
			});

		//レイヤーの可視状態変更リスナー
		s_owpLayerTable->setChangeVisibleListener([](int index) {
			if (s_model && s_owpLayerTable) {
				CMQOObject* curobj = (CMQOObject*)(s_owpLayerTable->getObj(index));
				if (curobj) {
					if (s_owpLayerTable->getVisible(index)) {
						curobj->SetDispFlag(1);
					}
					else {
						curobj->SetDispFlag(0);
					}
				}
			}
			});

		//レイヤーのロック状態変更リスナー
		s_owpLayerTable->setChangeLockListener([](int index) {
			//if( owpLayerTable->getLock(index) ){
			//	_tprintf_s( _T("ChangeLock: Index=%3d Lock='True'  Name=%s\n"),
			//				index,
			//				owpLayerTable->getName(index).c_str() );
			//}else{
			//	_tprintf_s( _T("ChangeLock: Index=%3d Lock='False' Name=%s\n"),
			//				index,
			//				owpLayerTable->getName(index).c_str() );
			//}
			});

		//レイヤーのプロパティコールリスナー
s_owpLayerTable->setCallPropertyListener([](int index) {
	//_tprintf_s( _T("CallProperty: Index=%3d Name=%s\n"),
	//			index,
	//			owpLayerTable->getName(index).c_str() );
	});

RECT wnd3drect;
if (g_mainhwnd) {
	GetWindowRect(g_mainhwnd, &wnd3drect);
	s_layerWnd->setPos(WindowPos(wnd3drect.left + 750, wnd3drect.top + 500));
}
else {
	s_layerWnd->setPos(WindowPos(600, 200));
}
s_layerWnd->setVisible(false);

	}
	else {
		_ASSERT(0);
		return 1;
	}


	return 0;

}

int OnRenderRefPos(myRenderer::RenderingEngine* re, CModel* curmodel)
{
	if (!re || !curmodel || !s_chascene) {
		return 0;
	}

	if (s_sprefpos.state) {
		if ((curmodel == s_model) && (curmodel->GetGrassFlag() == false)) {

			//int keynum;
			//double startframe, endframe, applyframe;
			double roundingstartframe, roundingendframe, roundingapplyframe;
			//s_editrange.GetRange(&keynum, &startframe, &endframe, &applyframe);
			//roundingstartframe = RoundingTime(startframe);
			//roundingendframe = RoundingTime(endframe);
			//roundingapplyframe = RoundingTime(applyframe);
			roundingstartframe = RoundingTime(g_motionbrush_startframe);
			roundingendframe = RoundingTime(g_motionbrush_endframe);
			roundingapplyframe = RoundingTime(g_motionbrush_applyframe);

			if (s_model->ExistCurrentMotion()) {
				int curmotid = s_model->GetCurrentMotID();
				double currentframe = s_model->GetCurrentFrame();
				CBone* curbone = s_model->GetBoneByID(s_curboneno);
				if (curbone) {

					std::vector<ChaVector3> vecbonepos;
					vecbonepos.clear();
					ChaVector3 curbonepos;

					ChaMatrix modelwm = s_model->GetWorldMat();

					double renderleng = roundingendframe - roundingstartframe;

					//2024/02/08 選択ジョイントの位置の軌跡を表示する際に補間無しのGetWorldMatで済ませたいのでRoundingTimeしてキーの位置限定にする
					int divnum;
					divnum = min((int)renderleng, (REFPOSMAXNUM - 2));//選択フレーム長より多くは分割しない
					double renderstep = fmax(1.0, (renderleng / (double)divnum));//renderstep = 0は無限ループになる

					bool addcurrentjointpos = false;
					int refposindex = 0;
					double renderframe, roundingrenderframe;
					for (refposindex = 0; refposindex <= divnum; refposindex++) {
						renderframe = roundingstartframe + renderstep * (double)refposindex;
						roundingrenderframe = RoundingTime(renderframe);

						if ((addcurrentjointpos == false) && (roundingrenderframe >= currentframe)) {
							double roundingcurrentframe = RoundingTime(currentframe);
							s_model->SetMotionFrame(roundingcurrentframe);
							ChaVector3 tmpfpos = curbone->GetJointFPos();
							ChaMatrix tmpcurwm = curbone->GetWorldMat(g_limitdegflag, curmotid, roundingcurrentframe, 0) * modelwm;
							ChaVector3TransformCoord(&curbonepos, &tmpfpos, &tmpcurwm);
							vecbonepos.push_back(curbonepos);
							addcurrentjointpos = true;
						}
						s_model->SetMotionFrame(roundingrenderframe);
						ChaVector3 tmpfpos = curbone->GetJointFPos();
						ChaMatrix tmpcurwm = curbone->GetWorldMat(g_limitdegflag, curmotid, roundingrenderframe, 0) * modelwm;
						ChaVector3TransformCoord(&curbonepos, &tmpfpos, &tmpcurwm);
						vecbonepos.push_back(curbonepos);


						//int lightflag = 0;//!!!!!!!透けるために必要!!!!!!!!!

						//refframeのポーズを表示
						int btflag1 = 0;

						s_model->SetMotionFrame(roundingrenderframe);
						//s_model->UpdateMatrix(g_limitdegflag, &modelwm, &s_matVP, true, s_chascene->GetUpdateSlot());
						s_chascene->UpdateMatrixOneModel(s_model, g_limitdegflag, &modelwm, &s_matView, &s_matProj,
							roundingrenderframe, refposindex);


						bool calcslotflag;
						calcslotflag = true;//2024/03/20
						//calcslotflag = false;
						s_model->SetShaderConst(btflag1, calcslotflag);
						s_model->SetRefPosFl4x4ToDispObj(refposindex);

						//カレントフレームから離れるほど　透明度を薄くする
						//const double refstartalpha = 0.80f;
						//double renderalpha0 = (renderleng - fabs(currentframe - renderframe)) / renderleng;
						////2024/02/08 int g_refalpha (0から100) : DispAndLimitsプレートメニューのRefPosAlphaスライダー
						//double renderalpha = refstartalpha * renderalpha0 * renderalpha0 * renderalpha0 * (double)g_refalpha * 0.01f;
						//ChaVector4 refdiffusemult.SetParams(1.0f, 1.0f, 1.0f, (float)renderalpha);
						const double refstartalpha = (double)g_refalpha * 0.01f;
						ChaVector4 refdiffusemult;
						refdiffusemult.SetParams(1.0f, 1.0f, 1.0f, (float)refstartalpha);

						int lightflag = 0;
						bool forcewithalpha = true;
						int btflag = 0;
						bool zcmpalways = true;
						bool zenable = true;
						//s_chascene->RenderOneModel(s_model, forcewithalpha, re,
						//	lightflag, refdiffusemult, btflag, zcmpalways, zenable, refposindex);
						s_chascene->AddToRefPos(s_model, forcewithalpha, re,
							lightflag, refdiffusemult, btflag, zcmpalways, zenable, refposindex);

					}

					{
						if ((refposindex >= 0) && (refposindex < REFPOSMAXNUM)) {
							////カレントフレームをレンダー
							int btflag1 = 0;

							s_model->SetMotionFrame(currentframe);
							//s_model->UpdateMatrix(g_limitdegflag, &modelwm, &s_matVP, true, s_chascene->GetUpdateSlot());
							s_chascene->UpdateMatrixOneModel(s_model, g_limitdegflag, &modelwm, &s_matView, &s_matProj,
								currentframe, refposindex);

							bool calcslotflag;
							calcslotflag = true;//2024/03/20
							//calcslotflag = false;
							s_model->SetShaderConst(btflag1, calcslotflag);//calcslotflag = true !!!!
							s_model->SetRefPosFl4x4ToDispObj(refposindex);

							ChaVector4 refdiffusemult;
							refdiffusemult.SetParams(1.0f, 1.0f, 1.0f, 1.0f);

							int lightflag = -1;
							bool forcewithalpha = true;
							int btflag = 0;
							//bool zcmpalways = false;
							bool zcmpalways = g_zalways;//2024/02/08 DispAndLimitsプレートメニューのチェックボックス
							bool zenable = true;
							//s_chascene->RenderOneModel(s_model, forcewithalpha, re,
							//	lightflag, refdiffusemult, btflag, zcmpalways, zenable, refposindex);

							s_chascene->AddToRefPos(s_model, forcewithalpha, re,
								lightflag, refdiffusemult, btflag, zcmpalways, zenable, refposindex);

							refposindex++;
						}
					}

					//s_chascene->RenderRefPos(re);//RenderModelsで一緒にレンダー


					{
						//render arrow : selected bone : befpos --> aftpos arrow
						CBone* childbone = curbone->GetChild(false);
						if (childbone && childbone->IsSkeleton() && curbone->GetRefPosMark()) {
							//ChaVector4 arrowdiffusemult.SetParams(1.0f, 0.5f, 0.5f, 0.85f);
							ChaVector4 arrowdiffusemult;
							arrowdiffusemult.SetParams(1.0f, 0.5f, 0.5f, 0.5f);

							curbone->GetRefPosMark()->RenderRefArrow(g_limitdegflag,
								re, s_chascene, s_matVP, curbone, arrowdiffusemult, 1, vecbonepos);
							//s_model->RenderBoneCircleOne(g_limitdegflag,
							//	pRenderContext, s_bcircle, s_curboneno);
						}
					}


				}
			}
		}
	}

	return 0;
}

int OnRenderModel(RenderContext* pRenderContext)
{
	if (!pRenderContext) {
		_ASSERT(0);
		return 1;
	}


	////if (g_bvh2fbxbatchflag || g_motioncachebatchflag || g_retargetbatchflag) {
	////if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	//	return 0;
	//}

	//if (s_nowloading == true) {
	//	return 0;
	//}

	//if (!s_model || !s_chascene) {
	//	return 0;
	//}


	//int lightflag = 1;
	//ChaVector4 diffusemult.SetParams(1.0f, 1.0f, 1.0f, 1.0f);
	//int btflag = 0;
	//if ((g_previewFlag != 4) && (g_previewFlag != 5)) {
	//	btflag = 0;
	//}
	//else {
	//	if (g_previewFlag == 4) {
	//		btflag = 1;
	//	}
	//	else {
	//		//previewFlag == 5
	//		if ((s_curboneno >= 0) && ((s_onragdollik != 0) || (s_physicskind == 0))) {
	//			btflag = 2;//2022/07/09
	//		}
	//	}
	//}

	//s_chascene->RenderModels(pRenderContext, lightflag, diffusemult, btflag);
	//if (s_sprefpos.state) {
	//	OnRenderLOD(pRenderContext, s_model);
	//}

	return 0;
}

int OnRenderOnlyOneObj(myRenderer::RenderingEngine* re, RenderContext* rc)
{
	if (!re || !rc) {
		_ASSERT(0);
		return 1;
	}


	//if (g_bvh2fbxbatchflag || g_motioncachebatchflag || g_retargetbatchflag) {
	//if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_motioncachebatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
	if ((InterlockedAdd(&g_bvh2fbxbatchflag, 0) != 0) || (InterlockedAdd(&g_retargetbatchflag, 0) != 0)) {
		return 0;
	}

	if (s_nowloading == true) {
		return 0;
	}

	if (!s_model) {
		return 0;
	}
	if (s_model->GetGrassFlag()) {
		return 0;
	}

	int rendercount;
	for (rendercount = 0; rendercount < 2; rendercount++) {
		bool withalpha;
		if (rendercount == 0) {
			withalpha = false;
		}
		else {
			withalpha = true;
		}

		CModel* curmodel = s_model;

		//if (curmodel && curmodel->GetLoadedFlag() && curmodel->GetModelDisp()){
		if (curmodel && curmodel->m_loadedflag && curmodel->m_modeldisp) {//curmodelが作成途中の場合を考えて、先頭から２つのpublicデータメンバーを参照する
			int lightflag = -1;
			ChaVector4 diffusemult;
			diffusemult.SetParams(1.0f, 1.0f, 1.0f, 1.0f);
			int btflag = 0;

			curmodel->RenderTest(withalpha, s_chascene, g_lightflag, diffusemult, 
				s_dispgroupdlg.GetDispGroupOnlyOneObjNo());
		}
	}

	return 0;
}

int OnRenderSky(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!re || !pRenderContext) {
		_ASSERT(0);
		return 1;
	}

	if (!s_chascene) {
		return 0;
	}

	if (s_sky) {
		MODELBOUND totalmb;
		totalmb.Init();
		totalmb = s_chascene->GetTotalModelBound();
		ChaVector3 vCenter;
		if (totalmb.IsValid()) {
			vCenter = totalmb.center;
			vCenter.x = g_camEye.x;
			vCenter.z = g_camEye.z;
		}
		else {
			vCenter.SetParams(g_camEye.x, 0.0f, g_camEye.z);
		}

		//float fObjectRadius = s_chascene->GetTotalModelBound().r;
		//if (fObjectRadius < 0.1f) {
		//	fObjectRadius = 10.0f;
		//}
		//fObjectRadius *= 1.25f;
		//fObjectRadius = (float)fmax(500000.0f, fObjectRadius);//model１体だけ読込の場合にも　カメラがSkyの中に入るように
		//float fObjectRadius = 490000.0f * 0.080f;//fbxの半径が10なので0.1倍より少し小さめ
		float fObjectRadius = 490000.0f * 0.080f;//fbxの半径が10なので0.1倍より少し小さめ

		ChaMatrix skymat;
		skymat.SetIdentity();
		skymat.SetScale(ChaVector3(fObjectRadius, fObjectRadius, fObjectRadius));
		skymat.SetTranslation(vCenter);


		//g_projfarでクリッピングされないようにsky用のprojを使う
		s_chascene->UpdateMatrixOneModel(s_sky, g_limitdegflag, &skymat, &s_matView, &s_matSkyProj, 0.0, 0);
		ChaVector4 diffusemult;
		diffusemult.SetParams(1.0f, 1.0f, 1.0f, 1.0f);
		bool forcewithalpha = false;//2024/03/25 skyは一番最初に描画するために不透明である必要
		//bool forcewithalpha = true;
		int btflag = 0;
		bool zcmpalways = false;
		//bool zcmpalways = true;
		bool zenable = false;//2024/03/25 上書き可能な背景として描画するのでZは書き込まない
		int lightflag = -1;
		s_chascene->RenderOneModel(s_sky, forcewithalpha, re, lightflag, diffusemult, btflag, zcmpalways, zenable);
	}

	return 0;
}



int OnRenderGround(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!re || !pRenderContext) {
		_ASSERT(0);
		return 1;
	}

	if (!s_chascene) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}

	if (s_ground && s_dispground) {
		//g_hmWorld->SetMatrix(s_matWorld.GetDataPtr());
		//g_pEffect->SetMatrix(g_hmWorld, &(s_matWorld.D3DX()));
		ChaMatrix initmat;
		initmat.SetIdentity();
		s_chascene->UpdateMatrixOneModel(s_ground, g_limitdegflag, &initmat, &s_matView, &s_matProj, 0.0, 0);
		ChaVector4 diffusemult;
		diffusemult.SetParams(1.0f, 1.0f, 1.0f, 1.0f);
		bool forcewithalpha = false;
		int btflag = 0;
		bool zcmpalways = false;
		bool zenable = true;
		s_chascene->RenderOneModel(s_ground, forcewithalpha, re, 0, diffusemult, btflag, zcmpalways, zenable);
	}
	//if (s_gplane && s_bpWorld && s_bpWorld->m_gplanedisp) {
	//	ChaMatrix gpmat = s_inimat;
	//	gpmat.data[MATI_42] = s_bpWorld->m_gplaneh;
	//	g_hmWorld->SetMatrix(gpmat.GetDataPtr());
	//	//g_pEffect->SetMatrix(g_hmWorld, &(gpmat.D3DX()));
	//
	//	ChaVector4 diffusemult.SetParams(1.0f, 1.0f, 1.0f, 1.0f);
	//	bool withalpha = false;
	//	s_gplane->OnRender(withalpha, pRenderContext, 0, diffusemult);
	//}

	return 0;
}

int OnRenderBoneMark(myRenderer::RenderingEngine* re, RenderContext* rc)
{
	if (!re || !rc) {
		_ASSERT(0);
		return 1;
	}
	if (g_changeUpdateThreadsNum) {
		//アップデート用スレッド数を変更中
		return 0;
	}
	if (!s_model) {
		return 0;
	}


	//GetBoneForMotionSize()が重い　全体の負荷の１％近く持っていくこともあるようだ　コメントアウト
	//if (!s_model->GetLoadedFlag() || (s_model->GetBoneForMotionSize() == 0) || 
	//	(s_model->GetBoneForMotionSize() >= RIGMULTINDEXMAX)) {
	//	//インスタンシング最大数を越えた場合にもリターン0
	//	return 0;
	//}

	if (!s_model->GetLoadedFlag()) {
		return 0;
	}




	if (s_model->GetGrassFlag()) {
		return 0;
	}

	if (g_bonemarkflag || g_rigidmarkflag) {

		//if (s_allmodelbone == false) {
			//if ((g_previewFlag != 1) && (g_previewFlag != -1) && (g_previewFlag != 4)){
			if (s_model && s_model->GetModelDisp()) {
				//if (s_ikkind >= 3){
				s_model->RenderBoneMark(g_limitdegflag, &s_bcircle,
					s_curboneno, s_chascene, s_matVP);

				//}
				//else{
				//	s_model->RenderBoneMark(s_pdev, s_bmark, s_bcircle, 0, s_curboneno);
				//}
			}
			//}
		//}
		//else {
			//int modelnum = s_chascene->GetModelNum();
			//int modelcount;
			//for (modelcount = 0; modelcount < modelnum; modelcount++) {
			//	CModel* curmodel = s_chascene->GetModel(modelcount);
			//	if (curmodel) {
			//		curmodel->RenderBoneMark(g_limitdegflag,
			//			pRenderContext, s_bmark, s_bcircle, 0, s_curboneno);
			//		s_model->RenderBoneMark(re, rc, g_limitdegflag,
			//			s_bmark, s_bcircle, s_curboneno);

			//	}
			//}
		//}
	}

	return 0;
}
int OnRenderSelect(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!re || !pRenderContext) {
		_ASSERT(0);
		return 1;
	}

	if (!s_model) {
		return 0;
	}
	if (s_model->GetGrassFlag()) {
		return 0;
	}

	if (s_camtargetdisp == false) {
		if ((g_previewFlag != 4) && (g_previewFlag != 5)) {
			if (s_select && (s_curboneno >= 0) && (g_previewFlag == 0) && (s_model && s_model->GetModelDisp()) && (g_bonemarkflag != 0)) {//underchecking
				//SetSelectCol();
				SetSelectState();
				RenderSelectMark(re, pRenderContext, 1);
			}
		}
		//else if ((g_previewFlag == 5) && (s_oprigflag == 1)){
		else if (g_previewFlag == 5) {
			if (s_select && (s_curboneno >= 0) && (s_model && s_model->GetModelDisp())) {
				//SetSelectCol();
				SetSelectState();
				RenderSelectMark(re, pRenderContext, 1);
			}
		}
	}
	else {
		if (g_previewFlag == 0) {
			SetSelectState();
			RenderSelectMark(re, pRenderContext, 1);
		}
	}


	//プレビュー中　物理中は　リグマークは表示しない
	if (g_previewFlag == 0) {
		if ((s_model && s_model->GetModelDisp()) && (s_oprigflag != 0)) {
			RenderRigMarkFunc(re, pRenderContext);
		}
	}

	return 0;
}

int OnRenderFontForTip(myRenderer::RenderingEngine* re, RenderContext* rc)
{
	if (!re || !rc || !s_chascene) {
		_ASSERT(0);
		return 1;
	}

	if ((s_dispPickfortip && g_pickmeshflag) || s_dispfontfortip) {//pick時にもスプライトのtipを表示することはある
	//if (s_dispfontfortip) {
	//if (s_strfortip[0] != 0L) {
		Vector4 fontcol;
		fontcol.Set(1.0f, 1.0f, 1.0f, 1.0f);
		Vector2 fontpivot;
		fontpivot.Set(0.0f, 0.0f);

		float fontscale = 0.5f;//フォントのスケール


		//表示文字列の　おおまかな長さを計算
		size_t szlen = wcslen(s_strfortip);
		int displen;
		if (szlen <= 511) {
			displen = (int)szlen * 14;
		}
		else {
			s_strfortip[511] = 0L;
			displen = 511 * 14;
		}


		Vector2 tmpfontpos = s_fontposfortip;
		tmpfontpos.y += 18;//ジョイント位置が隠れないように少し下に


		//スクリーンからはみ出さないように　フォントの位置をクランプする
		int winx = g_graphicsEngine->GetFrameBufferWidth();
		int winy = g_graphicsEngine->GetFrameBufferHeight();
		int tipposx = min((winx - (int)displen), (int)(tmpfontpos.x + 0.1f));
		int tipposy = min((winy - 18), (int)(tmpfontpos.y + 0.1f));


		//フォントの位置を　-0.5から0.5のスクリーン座標系に直す
		Vector2 disppos;
		float fontposx = ((float)tipposx - (float)winx / 2.0f);// *2.0f;
		float fontposy = -((float)tipposy - (float)winy / 2.0f);// *2.0f;
		disppos.Set(fontposx, fontposy);


		myRenderer::RENDERFONT renderfont;
		renderfont.Init();
		renderfont.pfont = &s_fontfortip;
		wcscpy_s(renderfont.strfont, 512, s_strfortip);
		renderfont.disppos = disppos;
		renderfont.color = fontcol;
		renderfont.rotation = 0.0f;
		renderfont.scale = fontscale;
		renderfont.pivot = fontpivot;
		s_chascene->AddFontToForwardRenderPass(renderfont);
	}

	//s_dispfontfortip = false;

	return 0;
}


int OnRenderSprite(myRenderer::RenderingEngine* re, RenderContext* pRenderContext)
{
	if (!re || !pRenderContext || !s_chascene) {
		_ASSERT(0);
		return 1;
	}



	{
		s_spupperbar.UpdatePushCount();
		s_spret2prev.UpdatePushCount();
		s_mousecenteron.UpdatePushCount();
		//s_sprefpos.UpdatePushCount();
		//s_splimiteul.UpdatePushCount();
		//s_spscraping.UpdatePushCount();
		s_spcplw2w.UpdatePushCount();
		int spucnt;
		for (spucnt = 0; spucnt < 2; spucnt++) {
			s_spundo[spucnt].UpdatePushCount();
		}
		s_spsmooth.UpdatePushCount();
		s_spconstexe.UpdatePushCount();
		s_spconstrefresh.UpdatePushCount();
		s_spret2prev2.UpdatePushCount();
		s_spcopy.UpdatePushCount();
		s_spsymcopy.UpdatePushCount();
		s_sppaste.UpdatePushCount();
		s_spcopyhistory.UpdatePushCount();
		s_spjumpinterpolate.UpdatePushCount();
		s_spinterpolate.UpdatePushCount();
		s_spinit.UpdatePushCount();
		s_spscaleinit.UpdatePushCount();
		s_spproperty.UpdatePushCount();
		s_spzeroframe.UpdatePushCount();
		s_spcameradolly.UpdatePushCount();
		s_spmodelposdir.UpdatePushCount();
		s_spmaterialrate.UpdatePushCount();

		s_spcopy_camera.UpdatePushCount();
		s_sppaste_camera.UpdatePushCount();
		s_spinterpolate_camera.UpdatePushCount();
		s_spinit_camera.UpdatePushCount();
		s_spsmooth_camera.UpdatePushCount();
	}


	{
		//2024/03/04
		myRenderer::RENDERSPRITE rendersprite;
		rendersprite.Init();
		rendersprite.psprite = s_spupperbar.GetSpriteForRender();
		s_chascene->AddSpriteToForwardRenderPass(rendersprite);
	}


	if (!s_model) {
		return 0;
	}

	if (s_model) {
		int dispfps = (int)(s_avrgfps + 0.5);
		//s_fpssprite.DrawScreen(pRenderContext, dispfps);

		myRenderer::RENDERSPRITE rendersprite;
		rendersprite.Init();
		rendersprite.pfpssprite = &s_fpssprite;
		rendersprite.userint1 = dispfps;
		s_chascene->AddSpriteToForwardRenderPass(rendersprite);
	}

	////Undoの読み込みポイントW と書き込みポイントR を表示
	if (s_model && (g_previewFlag == 0)) {
		//s_undosprite.DrawScreen(pRenderContext, s_model->GetCurrentUndoR(), s_model->GetCurrentUndoW());

		myRenderer::RENDERSPRITE rendersprite;
		rendersprite.Init();
		rendersprite.pundosprite = &s_undosprite;

		//2024/06/24
		//カメラアニメのアンドゥデータは　選択中のモデルに格納することにした　EDITTARGET_CAMERA時にも　選択中のモデルアンドゥ番号を表示する
		//if (g_edittarget != EDITTARGET_CAMERA) {
			rendersprite.userint1 = s_model->GetCurrentUndoR();
			rendersprite.userint2 = s_model->GetCurrentUndoW();
		//}
		//else if (s_cameramodel) {
		//	rendersprite.userint1 = s_cameramodel->GetCurrentUndoR();
		//	rendersprite.userint2 = s_cameramodel->GetCurrentUndoW();
		//}
		
		s_chascene->AddSpriteToForwardRenderPass(rendersprite);
	}


	//frog
	//s_spret2prev.sprite.DrawScreen(pRenderContext);
	myRenderer::RENDERSPRITE rendersprite;
	rendersprite.Init();
	rendersprite.psprite = s_spret2prev.GetSpriteForRender();
	s_chascene->AddSpriteToForwardRenderPass(rendersprite);


	//Mouse Middle Button Mark
	if (s_mbuttoncnt == 0) {
		//s_mousecenteron.sprite.DrawScreen(pRenderContext);
		myRenderer::RENDERSPRITE rendersprite;
		rendersprite.Init();
		rendersprite.psprite = s_mousecenteron.GetSpriteForRender();
		s_chascene->AddSpriteToForwardRenderPass(rendersprite);
	}

	//aimbar
	if (g_enableDS && (s_dsdeviceid >= 0)) {

		int platemenukind = s_platemenukind;
		int platenomax = 0;

		switch (platemenukind) {
		//case SPPLATEMENUKIND_GUI:
		//	platenomax = SPGUISWNUM;
		//	break;
		case SPPLATEMENUKIND_DISP:
			platenomax = SPDISPSWNUM;
			break;
		case SPPLATEMENUKIND_RIGID:
			platenomax = SPRIGIDSWNUM;
			break;
		case SPPLATEMENUKIND_RETARGET:
			platenomax = SPRETARGETSWNUM;
			break;
		case SPPLATEMENUKIND_EFFECT:
			platenomax = SPEFFECTSWNUM;
			break;
		default:
			platenomax = 0;
			break;
		}

		{
			myRenderer::RENDERSPRITE rendersprite;
			rendersprite.Init();
			rendersprite.psprite = s_spsel3d.GetSpriteForRender();
			s_chascene->AddSpriteToForwardRenderPass(rendersprite);
		}
		//{
		//	int spgcnt;
		//	int chkplatenomax;
		//	chkplatenomax = min(SPAIMBARNUM, platenomax);
		//	for (spgcnt = 0; spgcnt < chkplatenomax; spgcnt++) {
		//		if (s_spaimbar[spgcnt].state) {
		//			s_spaimbar[spgcnt].spriteON.DrawScreen(pRenderContext);
		//		}
		//		else {
		//			s_spaimbar[spgcnt].spriteOFF.DrawScreen(pRenderContext);
		//		}
		//	}
		//}
		//{
		//	if (s_topSlidersWnd) {
		//		s_topSlidersWnd->callRewrite();
		//	}


		//	//int spgcnt;
		//	//for (spgcnt = 0; spgcnt < SPMENU_MAX; spgcnt++) {
		//	//	//TopSlidersWndの背景色は、非選択時に茶色、選択時にオレンジ。オレンジはspriteONの色。よってスプライト表示のオンとオフを入れ替える。
		//	//	if (s_spmenuaimbar[spgcnt].state) {
		//	//		if (s_spmenuaimbar[spgcnt].spriteOFF) {//ONのときにOFF色
		//	//			s_spmenuaimbar[spgcnt].spriteOFF.DrawScreen(pRenderContext);
		//	//		}
		//	//		else {
		//	//			_ASSERT(0);
		//	//		}
		//	//	}
		//	//	else {
		//	//		if (s_spmenuaimbar[spgcnt].spriteON) {//OFFのときにON色
		//	//			s_spmenuaimbar[spgcnt].spriteON.DrawScreen(pRenderContext);
		//	//		}
		//	//		else {
		//	//			_ASSERT(0);
		//	//		}
		//	//	}
		//	//}
		//}

	}




	//if (s_platemenukind == SPPLATEMENUKIND_GUI) 
	if (g_previewFlag == 0) {
		if (s_guiswflag)
		{
			//menu 0 : Select 3DWindow GUI
			{

				//常時表示だが　２段目クリック時には１段目は全てOFFにする　１段目クリックに対してだけONを表示する

				//Plate Menu 0
				int spgcnt;
				for (spgcnt = 0; spgcnt < SPGUISWNUM; spgcnt++) {
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spguisw[spgcnt].GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
		}
		else {
			//Plate Menu 0
			int spgcnt;
			for (spgcnt = SPGUISW_DISP_AND_LIMITS; spgcnt < SPGUISWNUM; spgcnt++) {

				//常時表示だが　２段目クリック時には１段目はCameraAndIK以外OFFにする　１段目クリックに対してだけONを表示する

				//s_spguisw[spgcnt].spriteOFF.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = &(s_spguisw[spgcnt].spriteOFF);
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}


			//CameraAndIKに関しては s_guiswflag==falseの場合にも　ONのときはON
			{
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spguisw[SPGUISW_CAMERA_AND_IK].GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

		}
		//else 

		if (s_platemenukind == SPPLATEMENUKIND_DISP) {
			//menu 1 : Select SideMenu 

			//Plate Menu 1
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPDISPSWNUM; spgcnt++) {
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spdispsw[spgcnt].GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}
		}
		else if (s_platemenukind == SPPLATEMENUKIND_RIGID) {
			//menu 1 : Select SideMenu 

			//Plate Menu 1
			int spgcnt;
			for (spgcnt = 0; spgcnt < SPRIGIDSWNUM; spgcnt++) {
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_sprigidsw[spgcnt].GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}
		}
		else if (s_platemenukind == SPPLATEMENUKIND_RETARGET) {

			//Plate Menu 2
			int sprcnt;
			for (sprcnt = 0; sprcnt < SPRETARGETSWNUM; sprcnt++) {
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spretargetsw[sprcnt].GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}
		}
		else if (s_platemenukind == SPPLATEMENUKIND_EFFECT) {

			int sprcnt;
			for (sprcnt = 0; sprcnt < SPEFFECTSWNUM; sprcnt++) {
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_speffectsw[sprcnt].GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}
		}
	}

	//Sprites of Camera And IK Plate Menu Group
	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {

		if (g_previewFlag == 0) {

			//Axis
			int spacnt;
			for (spacnt = 0; spacnt < SPAXISNUM; spacnt++) {
				//s_spaxis[spacnt].sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				//rendersprite.psprite = &(s_spaxis[spacnt].sprite);
				rendersprite.psprite = s_spaxis[spacnt].GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			//IK Mode
			int spgcnt;
			for (spgcnt = 0; spgcnt < 3; spgcnt++) {
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spikmodesw[spgcnt].GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			//lodsw
			{
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_sprefpos.GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			//limiteulsw
			{
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_splimiteul.GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			//scrapingsw
			{
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spscraping.GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//L2W button
				//s_spcplw2w.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spcplw2w.GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}


			//Undo Redo
			int spucnt;
			for (spucnt = 0; spucnt < 2; spucnt++) {
				//s_spundo[spucnt].sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spundo[spucnt].GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			//Rig switch
			if ((s_oprigflag >= 0) && (s_oprigflag < SPRIGMAX)) {
				//s_sprig[s_oprigflag].sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_sprig[s_oprigflag].GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//Smooth
				//s_spsmooth.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spsmooth.GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//ConstExe
				//s_spconstexe.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spconstexe.GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//ConstRefresh
				//s_spconstrefresh.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spconstrefresh.GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}

			{
				//s_spret2prev2.sprite.DrawScreen(pRenderContext);
				myRenderer::RENDERSPRITE rendersprite;
				rendersprite.Init();
				rendersprite.psprite = s_spret2prev2.GetSpriteForRender();
				s_chascene->AddSpriteToForwardRenderPass(rendersprite);
			}


			//tool shortcut button : １段目
			{
				{
					//CameraCopy
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spcopy_camera.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//CameraPaste
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_sppaste_camera.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//CameraInit
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spinit_camera.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//CameraInterpolate
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spinterpolate_camera.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//CameraSmooth
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spsmooth_camera.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
			}


			if (s_toolspritemode == 0) {
				{
					//Copy
					//s_spcopy.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spcopy.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}

				{
					//SymCopy
					//s_spsymcopy.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spsymcopy.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}

				{
					//Paste
					//s_sppaste.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_sppaste.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}

				{
					//CopyHistory
					//s_spcopyhistory.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spcopyhistory.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
			else if (s_toolspritemode == 1) {
				{
					//Interpolate
					//s_spinterpolate.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spjumpinterpolate.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}

				{
					//Interpolate
					//s_spinterpolate.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spinterpolate.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}

				{
					//Init
					//s_spinit.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spinit.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//ScaleInit
					//s_spscaleinit.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spscaleinit.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//Property
					//s_spproperty.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spproperty.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
			else if (s_toolspritemode == 2) {
				{
					//Edit0Frame
					//s_spzeroframe.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spzeroframe.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
				{
					//CameraDolly
					//s_spcameradolly.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spcameradolly.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);

				}
				{
					//ModelPosDir
					//s_spmodelposdir.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spmodelposdir.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);

				}
				{
					//MaterialRate
					//s_spmaterialrate.sprite.DrawScreen(pRenderContext);
					myRenderer::RENDERSPRITE rendersprite;
					rendersprite.Init();
					rendersprite.psprite = s_spmaterialrate.GetSpriteForRender();
					s_chascene->AddSpriteToForwardRenderPass(rendersprite);
				}
			}
			else {
				_ASSERT(0);
			}

		}

		//カメラ操作スプライトは　プレビュー中も表示
		int spccnt;
		for (spccnt = 0; spccnt < SPR_CAM_MAX; spccnt++) {
			//s_spcam[spccnt].sprite.DrawScreen(pRenderContext);
			myRenderer::RENDERSPRITE rendersprite;
			rendersprite.Init();
			rendersprite.psprite = s_spcam[spccnt].GetSpriteForRender();
			s_chascene->AddSpriteToForwardRenderPass(rendersprite);
		}
		//cameramode
		{
			myRenderer::RENDERSPRITE rendersprite;
			rendersprite.Init();
			rendersprite.psprite = s_spcameramode.GetSpriteForRender();
			s_chascene->AddSpriteToForwardRenderPass(rendersprite);
		}
		//camerainherit
		if (g_cameraanimmode != 0) {
			myRenderer::RENDERSPRITE rendersprite;
			rendersprite.Init();
			rendersprite.psprite = s_spcamerainherit.GetSpriteForRender();
			s_chascene->AddSpriteToForwardRenderPass(rendersprite);
		}
	}



	//UFO
	if (g_dsmousewait == 1) {
		//s_spmousehere.sprite.DrawScreen(pRenderContext);
		myRenderer::RENDERSPRITE rendersprite;
		rendersprite.Init();
		rendersprite.psprite = s_spmousehere.GetSpriteForRender();
		s_chascene->AddSpriteToForwardRenderPass(rendersprite);
	}


	return 0;
}

int SetLightDirection()
{
	if ((g_lightSlot < 0) || (g_lightSlot >= LIGHTSLOTNUM)) {
		_ASSERT(0);
		return 1;
	}


	ChaVector3 dirz;
	dirz.SetParams(0.0f, 0.0f, 1.0f);
	ChaVector3 lightdir0, nlightdir0;
	lightdir0 = g_camEye - g_camtargetpos;//2022/10/31
	ChaVector3Normalize(&nlightdir0, &lightdir0);
	//g_LightControl[0].SetLightDirection(nlightdir0.D3DX());

	bool rot180flag = false;
	float chkdot180 = ChaVector3Dot(&dirz, &nlightdir0);
	if (chkdot180 <= -0.9999f) {
		rot180flag = true;
	}
	else {
		rot180flag = false;
	}

	CQuaternion camrotq;
	camrotq.RotationArc(dirz, nlightdir0);

	ZeroMemory(g_lightNo, sizeof(int) * LIGHTNUMMAX);

	int lightindex;
	int activenum = 0;
	for (lightindex = 0; lightindex < LIGHTNUMMAX; lightindex++) {
		ChaVector3 nrotdir;

		if (g_lightDirWithView[g_lightSlot][lightindex] == true) {
			ChaVector3 nlightdir;
			ChaVector3Normalize(&nlightdir, &(g_lightDir[g_lightSlot][lightindex]));

			ChaVector3 rotdir;
			if (rot180flag == false) {
				camrotq.Rotate(&rotdir, nlightdir);
			}
			else {
				rotdir.SetParams(-nlightdir.x, nlightdir.y, -nlightdir.z);
			}
			ChaVector3Normalize(&nrotdir, &rotdir);
		}
		else {
			ChaVector3Normalize(&nrotdir, &(g_lightDir[g_lightSlot][lightindex]));
		}
		ChaVector3 scaleddiffuse;
		scaleddiffuse = g_lightDiffuse[g_lightSlot][lightindex] * g_lightScale[g_lightSlot][lightindex] * g_fLightScale;

		if (g_lightEnable[g_lightSlot][lightindex] == true) {
			g_lightdirforshader[activenum] = -ChaVector4(nrotdir, 0.0f);//-lightdir
			g_lightdiffuseforshader[activenum].SetParams(scaleddiffuse.x, scaleddiffuse.y, scaleddiffuse.z, 1.0f);
			g_lightNo[activenum] = lightindex;//2023/12/17必要分詰めて格納するので　ShaderのLightScale参照用のライト番号が必要
			activenum++;
		}
		g_lightdirforall[lightindex] = -ChaVector4(nrotdir, 0.0f);//-lightdir

		//2023/12/17 最近のシェーダは　pixelshaderについてもuniform変数が使用出来てループ回数に使うことが可能
		//定数にuniform宣言を追加するだけで出来た
		// 
		//else {
		//	//シェーダ定数のintでfor分を回すことは出来ない　シェーダ引数のuniform intでなら可だがfxファイルのtechniqueを記述する必要有
		//	//shaderではif分でスキップするよりは配列分計算した方が速いので　計算結果が０になるようなデータを入れる
		//	g_lightdirforshader[lightindex].SetParams(0.0f, 0.0f, 1.0f, 0.0f);
		//	g_lightdiffuseforshader[lightindex].SetParams(0.0f, 0.0f, 0.0f, 1.0f);
		//}
	}

	g_nNumActiveLights = activenum;

	return 0;
}


int OnRenderUtDialog(RenderContext* pRenderContext, float fElapsedTime)
{
	if (!pRenderContext) {
		_ASSERT(0);
		return 1;
	}

	//if (g_previewFlag != 3) {
	//	//g_HUD.OnRender( fElapsedTime );
	//	g_SampleUI.OnRender(fElapsedTime);
	//}

	return 0;
}

void SkipJointMarkReq(int srcstate, CBone* srcbone, bool setbrotherflag)
{
	if (srcbone) {

		if (srcbone->IsSkeleton()) {
			if (srcstate == 1) {
				srcbone->SetSkipRenderBoneMark(true);
			}
			else if (srcstate == 2) {
				srcbone->SetSkipRenderBoneMark(false);
			}
		}


		if (setbrotherflag) {
			if (srcbone->GetBrother(false)) {
				SkipJointMarkReq(srcstate, srcbone->GetBrother(false), setbrotherflag);
			}
		}
		if (srcbone->GetChild(false)) {
			SkipJointMarkReq(srcstate, srcbone->GetChild(false), true);
		}
	}


}

int FilterFromTool()
{
	if (!s_chascene) {
		return 0;
	}
	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_owpTimeline || !s_owpLTimeline) {
		return 0;
	}
	if (!s_model->ExistCurrentMotion()) {
		return 0;
	}


	HWND parwnd;
	//parwnd = s_3dwnd;
	parwnd = s_3dwnd;

	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_FILTERFROMTOOL);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();
	POINT pt;
	GetCursorPos(&pt);


	CRMenuMain* rsubmenu[3];
	ZeroMemory(rsubmenu, sizeof(CRMenuMain*) * 3);

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}
	//s_customrigmenuindex.clear();

	int subnum = 3;
	int setmenuid;

	WCHAR strinitmpsub[3][32] = { L"AllBones", L"SelectedOne", L"Deeper" };
	int subno;
	for (subno = 0; subno < 3; subno++) {
		setmenuid = ID_RMENU_0 + MENUOFFSET_FILTERFROMTOOL + subno;
		AppendMenu(submenu, MF_STRING, setmenuid, strinitmpsub[subno]);
	}

	/////////////
	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int initmode = -1;
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);

	for (subno = 0; subno < 3; subno++) {
		CRMenuMain* delsubmenu = rsubmenu[subno];
		if (delsubmenu) {
			delete delsubmenu;
		}
	}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	return 0;
}

int JumpInterpolateFromTool()
{
	if (!s_chascene) {
		return 0;
	}
	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_owpTimeline || !s_owpLTimeline) {
		return 0;
	}
	if (!s_model->ExistCurrentMotion()) {
		return 0;
	}

	double roundingstart, roundingend;
	roundingstart = RoundingTime(g_motionbrush_startframe);
	roundingend = RoundingTime(g_motionbrush_endframe);
	double frameleng;
	frameleng = roundingend - roundingstart;

	if (frameleng < 4.0) {
		::MessageBox(s_3dwnd, L"フレーム範囲長５フレーム以上で動作します.選択し直してリトライしてください.", L"動作条件に満たないフレーム長です",
			MB_OK | MB_ICONINFORMATION);
		return 0;
	}

	CBone* hipsbone = 0;
	s_model->GetHipsBoneReq(s_model->GetTopBone(false), &hipsbone);
	if (hipsbone) {
		ChaVector3 hipsjointpos;
		hipsjointpos = hipsbone->GetJointFPos();
		int curmotid = s_model->GetCurrentMotID();
		//##############################
		//hipsなのでローカルと同じように計算
		//##############################
		ChaMatrix startmat, endmat;
		startmat = hipsbone->GetWorldMat(g_limitdegflag, curmotid, roundingstart, 0);
		endmat = hipsbone->GetWorldMat(g_limitdegflag, curmotid, roundingend, 0);
		ChaMatrix startS, startR, startT, startTAnim;
		ChaMatrix endS, endR, endT, endTAnim;
		GetSRTandTraAnim(startmat, hipsbone->GetNodeMat(), &startS, &startR, &startT, &startTAnim);
		GetSRTandTraAnim(endmat, hipsbone->GetNodeMat(), &endS, &endR, &endT, &endTAnim);

		//#########################
		//TAnimだけに着目して計算する
		//#########################

		//double gravity = -9.8 / 15.0;//後でgravity設定用のモードレスダイアログを出す予定
		double gravity = (double)g_jumpgravity * -0.01;

		//上部でframeleng < 4の場合を除外している
		double vecx, vecz;
		vecx = (double)(endTAnim.data[MATI_41] - startTAnim.data[MATI_41]) / frameleng;
		vecz = (double)(endTAnim.data[MATI_43] - startTAnim.data[MATI_43]) / frameleng;
		double vecy0;
		vecy0 = (endTAnim.data[MATI_42] - startTAnim.data[MATI_42]) / frameleng - 0.5 * gravity * frameleng;

		double calcframe;
		for (calcframe = (roundingstart + 1.0); calcframe <= (roundingend - 1.0); calcframe++)
		{
			ChaMatrix mat1;
			mat1 = hipsbone->GetWorldMat(g_limitdegflag, curmotid, calcframe, 0);
			ChaMatrix S1, R1, T1, TAnim1;
			GetSRTandTraAnim(mat1, hipsbone->GetNodeMat(), &S1, &R1, &T1, &TAnim1);

			double difft = calcframe - roundingstart;
			ChaVector3 newtanim;
			newtanim.SetParams(0.0f, 0.0f, 0.0f);
			newtanim.x = (float)((double)startTAnim.data[MATI_41] + vecx * difft);
			newtanim.z = (float)((double)startTAnim.data[MATI_43] + vecz * difft);
			newtanim.y = (float)((double)startTAnim.data[MATI_42] + vecy0 * difft + 0.5 * gravity * difft * difft);
			ChaMatrix newTAnimMat;
			newTAnimMat.SetIdentity();
			newTAnimMat.SetTranslation(newtanim);

			ChaMatrix befrotmat, aftrotmat;
			befrotmat.SetIdentity();
			aftrotmat.SetIdentity();
			befrotmat.SetTranslation(-hipsbone->GetJointFPos());
			aftrotmat.SetTranslation(hipsbone->GetJointFPos());

			ChaMatrix newhipsmat;
			newhipsmat = befrotmat * S1 * R1 * aftrotmat * newTAnimMat;

			//hipsbone->SetWorldMat(g_limitdegflag, mi->motid, calcframe, newhipsmat, 0);
			hipsbone->UpdateCurrentWM(g_limitdegflag, curmotid, calcframe, newhipsmat);
		}

		refreshEulerGraph();
		PrepairUndo();
	}

	return 0;
}


int InterpolateFromTool()
{
	if (!s_chascene) {
		return 0;
	}
	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_owpTimeline || !s_owpLTimeline) {
		return 0;
	}
	if (s_interpolateFlag && !s_model->ExistCurrentMotion()) {
		return 0;
	}


	HWND parwnd;
	//parwnd = s_3dwnd;
	parwnd = s_3dwnd;

	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_INTERPOLATEFROMTOOL);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();
	POINT pt;
	GetCursorPos(&pt);


	CRMenuMain* rsubmenu[3];
	ZeroMemory(rsubmenu, sizeof(CRMenuMain*) * 3);

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}
	//s_customrigmenuindex.clear();

	int subnum = 3;
	int setmenuid;

	WCHAR strinitmpsub[3][32] = { L"AllBones", L"SelectedOne", L"Deeper" };
	int subno;
	for (subno = 0; subno < 3; subno++) {
		setmenuid = ID_RMENU_0 + MENUOFFSET_INTERPOLATEFROMTOOL + subno;
		AppendMenu(submenu, MF_STRING, setmenuid, strinitmpsub[subno]);
	}

	/////////////
	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int initmode = -1;
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);

	for (subno = 0; subno < 3; subno++) {
		CRMenuMain* delsubmenu = rsubmenu[subno];
		if (delsubmenu) {
			delete delsubmenu;
		}
	}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	return 0;
}


int InitMpFromTool()
{
	if (!s_chascene) {
		return 0;
	}
	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_owpTimeline || !s_owpLTimeline) {
		return 0;
	}
	if (s_initmpFlag && !s_model->ExistCurrentMotion()) {
		return 0;
	}


	HWND parwnd;
	//parwnd = s_3dwnd;
	parwnd = s_3dwnd;

	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 1;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_INITMPFROMTOOL);
	if (ret) {
		return 1;
	}

	HMENU submenu = rmenu->GetSubMenu();
	POINT pt;
	GetCursorPos(&pt);


	CRMenuMain* rsubmenu[4];
	ZeroMemory(rsubmenu, sizeof(CRMenuMain*) * 4);

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}
	//s_customrigmenuindex.clear();

	int subnum = 4;
	int subsubnum = 4;
	int setmenuid;

	WCHAR strinitmpsub[4][32] = { L"AllBones", L"SelectedOne", L"Deeper", L"DeeperEndJoint"};
	WCHAR strinitmpsubsub[4][32] = { L"InitRotAndPosAndScale", L"InitRot", L"InitPos", L"InitScale" };

	int subno;
	for (subno = 0; subno < 4; subno++) {
		setmenuid = ID_RMENU_0 + subno * 4 + MENUOFFSET_INITMPFROMTOOL;

		rsubmenu[subno] = new CRMenuMain(IDR_RMENU);
		if (!rsubmenu[subno]) {
			return 1;
		}

		bool subgrayed;
		if (s_initmpcameraFlag && (subno >= 1)) {
			//2024/06/24
			//カメラアニメのInitMpの場合には　処理対象としてAllBoneしか選択肢が無いので　他の選択肢はグレーアウトする
			subgrayed = true;
		}
		else {
			subgrayed = false;
		}

		ret = rsubmenu[subno]->CreatePopupMenu(parwnd, submenu, strinitmpsub[subno], subgrayed);
		if (ret) {
			return 1;
		}
		HMENU subsubmenu = rsubmenu[subno]->GetSubMenu();
		int subsubmenunum;
		subsubmenunum = GetMenuItemCount(subsubmenu);
		int subsubmenuno;
		for (subsubmenuno = 0; subsubmenuno < subsubmenunum; subsubmenuno++)
		{
			RemoveMenu(subsubmenu, 0, MF_BYPOSITION);
		}

		int subsubno;
		for (subsubno = 0; subsubno < 4; subsubno++) {
			bool subsubgrayed;
			if (s_initmpcameraFlag && (subsubno >= 1)) {
				subsubgrayed = true;
			}
			else {
				subsubgrayed = false;
			}

			int subsubid = setmenuid + subsubno;
			if (!subsubgrayed) {
				AppendMenu(subsubmenu, MF_STRING, subsubid, strinitmpsubsub[subsubno]);
			}
			else {
				//2024/06/24
				//現在、カメラアニメのInitMpは　SRT全初期化のみ対応なので　未対応機能の呼び出しはグレーアウト
				AppendMenu(subsubmenu, MF_STRING | MF_GRAYED, subsubid, strinitmpsubsub[subsubno]);
			}
		}
	}



	/////////////
	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int initmode = -1;
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);

	for (subno = 0; subno < 4; subno++) {
		CRMenuMain* delsubmenu = rsubmenu[subno];
		if (delsubmenu) {
			delete delsubmenu;
		}
	}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	return 0;
}

int InitMpByEul(int initmode, CBone* curbone, int srcmotid, double srcframe)
{
	double roundingframe = RoundingTime(srcframe);

	if (curbone && (curbone->IsSkeleton())) {
		//if (curbone->GetChild()){//2022/11/23 CommentOut なぜこのif文があったのか？ 不具合によりエンドジョイントにモーションポイントが無かったから？
		if (initmode == INITMP_ROTTRA) {
			ChaVector3 cureul;
			cureul.SetParams(0.0f, 0.0f, 0.0f);
			ChaVector3 traanim;
			traanim.SetParams(0.0f, 0.0f, 0.0f);
			//int inittraflag1 = 1;
			int setchildflag1 = 1;
			//int initscaleflag1 = 1;//!!!!!!!
			//curbone->SetWorldMatFromEul(inittraflag1, setchildflag1, cureul, srcmotid, roundingframe, initscaleflag1);
			ChaMatrix befwm = curbone->GetWorldMat(g_limitdegflag, srcmotid, roundingframe, 0);
			curbone->SetWorldMatFromEulAndTra(g_limitdegflag,
				setchildflag1, befwm, cureul, traanim, srcmotid, roundingframe);//scale計算無し
		}
		else if (initmode == INITMP_ROT) {
			ChaVector3 cureul;
			cureul.SetParams(0.0f, 0.0f, 0.0f);
			int inittraflag0 = 0;
			int setchildflag1 = 1;
			ChaMatrix befwm = curbone->GetWorldMat(g_limitdegflag, srcmotid, roundingframe, 0);
			curbone->SetWorldMatFromEul(g_limitdegflag,
				inittraflag0, setchildflag1, befwm, cureul, srcmotid, roundingframe);
		}
		else if (initmode == INITMP_TRA) {
			ChaVector3 cureul;
			cureul.SetParams(0.0f, 0.0f, 0.0f);
			int paraxsiflag1 = 1;
			//int isfirstbone = 0;
			cureul = curbone->CalcLocalEulXYZ(g_limitdegflag,
				paraxsiflag1, srcmotid, roundingframe, BEFEUL_BEFFRAME);

			int inittraflag1 = 1;
			int setchildflag1 = 1;
			ChaMatrix befwm = curbone->GetWorldMat(g_limitdegflag, srcmotid, roundingframe, 0);
			curbone->SetWorldMatFromEul(g_limitdegflag,
				inittraflag1, setchildflag1, befwm, cureul, srcmotid, roundingframe);
		}
		else if (initmode == INITMP_SCALE) {
			ChaVector3 cureul;
			cureul.SetParams(0.0f, 0.0f, 0.0f);
			int paraxsiflag1 = 1;
			//int isfirstbone = 0;
			cureul = curbone->CalcLocalEulXYZ(g_limitdegflag,
				paraxsiflag1, srcmotid, roundingframe, BEFEUL_BEFFRAME);

			ChaVector3 traanim = curbone->CalcLocalTraAnim(g_limitdegflag, srcmotid, roundingframe);

			//int inittraflag1 = 0;
			int setchildflag1 = 1;
			//int initscaleflag1 = 1;//!!!!!!!
			ChaMatrix befwm = curbone->GetWorldMat(g_limitdegflag, srcmotid, roundingframe, 0);
			curbone->SetWorldMatFromEulAndTra(g_limitdegflag,
				setchildflag1, befwm, cureul, traanim, srcmotid, roundingframe);//scale計算無し
		}
		//}
	}
	else if (curbone->IsNullAndChildIsCamera()) {//2024/06/23
		ChaCalcFunc chacalcfunc;
		chacalcfunc.InitMPReq(curbone->GetParModel(), g_limitdegflag, curbone, srcmotid, roundingframe);
	}
	return 0;
}

void InitMpByEulReq(int initmode, CBone* curbone, int srcmotid, double srcframe, bool broflag)
{
	if (!curbone) {
		return;
	}

	if (curbone->IsSkeleton() || curbone->IsNullAndChildIsCamera()) {//2024/06/23 eNullCamera
		InitMpByEul(initmode, curbone, srcmotid, srcframe);
	}

	if (curbone->GetChild(false)) {
		bool broflag2 = true;
		InitMpByEulReq(initmode, curbone->GetChild(false), srcmotid, srcframe, broflag2);
	}
	if (curbone->GetBrother(false) && (broflag == true)) {
		InitMpByEulReq(initmode, curbone->GetBrother(false), srcmotid, srcframe, broflag);
	}
}

void InitMpByEulEndJointReq(int initmode, CBone* curbone, int srcmotid, double srcframe, bool broflag)
{
	if (!curbone) {
		return;
	}

	//#################################
	//2023/10/22 DeeperEndJoint
	//子供階層の内　endjointだけをInit
	//#################################

	if (curbone->IsSkeleton() && !curbone->GetChild(false)) {
		InitMpByEul(initmode, curbone, srcmotid, srcframe);
	}

	if (curbone->GetChild(false)) {
		bool broflag2 = true;
		InitMpByEulEndJointReq(initmode, curbone->GetChild(false), srcmotid, srcframe, broflag2);
	}
	if (curbone->GetBrother(false) && (broflag == true)) {
		InitMpByEulEndJointReq(initmode, curbone->GetBrother(false), srcmotid, srcframe, broflag);
	}
}


/// CustomRigDlg
int DispCustomRigDlg(int rigno)
{
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}
	if (s_model->GetOldAxisFlagAtLoading() == 1) {
		::DSMessageBox(s_3dwnd, L"Work Only After Setting Of Axis.\nRetry After Saving Of FBX file.", L"error!!!", MB_OK);
		return 0;
	}

	//古いダイアログを閉じる
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}

	Bone2CustomRig(rigno);

	if (!s_customrigdlg) {
		//s_customrigdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_CUSTOMRIGDLG), s_3dwnd, (DLGPROC)CustomRigDlgProc);
		s_customrigdlg = CreateDialogW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_CUSTOMRIGDLG), g_mainhwnd, (DLGPROC)CustomRigDlgProc);
		if (!s_customrigdlg) {
			_ASSERT(0);
			return 1;
		}
	}
	else {
		CustomRig2Dlg(s_customrigdlg);
	}

	SetParent(s_customrigdlg, g_mainhwnd);

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	SetWindowPos(
		s_customrigdlg,
		HWND_TOP,
		windowposx,
		s_sidemenuheight,
		s_sidewidth,
		s_sideheight,
		SWP_SHOWWINDOW
	);


	ShowWindow(s_customrigdlg, SW_SHOW);
	UpdateWindow(s_customrigdlg);

	s_oprigflag = 1;

	return 0;
}

int InvalidateCustomRig(int rigno)
{
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}
	if (s_model->GetOldAxisFlagAtLoading() == 1) {
		::DSMessageBox(s_3dwnd, L"Work Only After Setting Of Axis.\nRetry After Saving Of FBX file.", L"error!!!", MB_OK);
		return 0;
	}

	s_customrigbone = s_model->GetBoneByID(s_curboneno);
	if (s_customrigbone) {
		if ((rigno >= 0) && (rigno < MAXRIGNUM)) {
			s_customrigbone->InvalidateCustomRig(rigno);
		}
	}

	//古いダイアログを閉じる
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}

	s_customrigbone = 0;
	s_oprigflag = 0;


	SetTimelineHasRigFlag();


	return 0;
}


int Bone2CustomRig(int rigno)
{
	if (!s_model) {
		return 0;
	}
	if (s_curboneno < 0) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	s_customrigbone = s_model->GetBoneByID(s_curboneno);
	if (s_customrigbone) {
		if ((rigno >= 0) && (rigno < MAXRIGNUM)) {
			s_customrig = s_customrigbone->GetCustomRig(rigno);
		}
		else {
			s_customrig = s_customrigbone->GetFreeCustomRig();
		}
		if (s_customrig.rigboneno <= 0) {
			_ASSERT(0);
		}
		s_customrigno = s_customrig.rigno;
	}
	else {
		_ASSERT(0);
		InitCustomRig(&s_customrig, 0, 0);
	}

	return 0;
}

int CustomRig2Bone()
{
	if (!s_model) {
		return 0;
	}
	if (!s_customrigbone) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}


	if (s_customrigbone) {
		int isvalid = IsValidCustomRig(s_model, s_customrig, s_customrigbone);
		if (isvalid == 0) {
			::DSMessageBox(s_3dwnd, L"Invalid Parameter", L"error!!!", MB_OK);
			return 0;
		}
		s_customrigbone->SetCustomRig(s_customrig);
	}
	else {
		_ASSERT(0);
	}

	return 0;
}

int GetCustomRigRateVal(HWND hDlgWnd, int resid, float* dstptr)
{
	WCHAR strval[256] = { 0L };
	GetDlgItemText(hDlgWnd, resid, strval, 256);
	float tmpval;
	tmpval = (float)_wtof(strval);
	if ((tmpval < -100.0f) || (tmpval > 100.0f)) {
		::DSMessageBox(hDlgWnd, L"Limit Range From -100.0 to 100.", L"Out Of Limit Error", MB_OK);
		*dstptr = 0.0f;
		return 1;
	}

	*dstptr = tmpval;
	return 0;
}

int CustomRig2Dlg(HWND hDlgWnd)
{
	if (s_customrigbone) {
		SetDlgItemText(hDlgWnd, IDC_RIGNAME, (LPCWSTR)s_customrig.rigname);
		SetDlgItemText(hDlgWnd, IDC_RIGBONENAME, (LPCWSTR)s_customrigbone->GetWBoneName());

		int elemnum = s_customrig.elemnum;
		SendMessage(GetDlgItem(hDlgWnd, IDC_CHILNUM), CB_RESETCONTENT, 0, 0);


		//dispaxis
		WCHAR strcomboda[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_RESETCONTENT, 0, 0);
		wcscpy_s(strcomboda, 256, L"X");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_ADDSTRING, 0, (LPARAM)strcomboda);
		wcscpy_s(strcomboda, 256, L"Y");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_ADDSTRING, 0, (LPARAM)strcomboda);
		wcscpy_s(strcomboda, 256, L"Z");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_ADDSTRING, 0, (LPARAM)strcomboda);
		if ((s_customrig.dispaxis >= 0) && (s_customrig.dispaxis <= 2)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_SETCURSEL, s_customrig.dispaxis, 0);
		}
		else {
			s_customrig.dispaxis = 0;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_SETCURSEL, s_customrig.dispaxis, 0);
		}

		//disporder
		WCHAR strcombodo[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_RESETCONTENT, 0, 0);
		int orderno;
		for (orderno = 0; orderno <= RIGPOSINDEXMAX; orderno++) {
			swprintf_s(strcombodo, 256, L"%d", orderno);
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_ADDSTRING, 0, (LPARAM)strcombodo);

		}
		if ((s_customrig.disporder >= 0) && (s_customrig.disporder <= RIGPOSINDEXMAX)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_SETCURSEL, s_customrig.disporder, 0);
		}
		else {
			s_customrig.disporder = 0;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_SETCURSEL, s_customrig.disporder, 0);
		}

		//posinverse
		if (s_customrig.posinverse) {
			CheckDlgButton(hDlgWnd, IDC_CHKINV, BST_CHECKED);
		}
		else {
			CheckDlgButton(hDlgWnd, IDC_CHKINV, BST_UNCHECKED);
		}


		//shapemult
		WCHAR strcombomult[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_RESETCONTENT, 0, 0);
		int shapemultno;
		for (shapemultno = 0; shapemultno <= RIGMULTINDEXMAX; shapemultno++) {
			swprintf_s(strcombomult, 256, L"%d", shapemultno);
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_ADDSTRING, 0, (LPARAM)strcombomult);

		}
		if ((s_customrig.shapemult >= 0) && (s_customrig.shapemult <= RIGMULTINDEXMAX)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_SETCURSEL, s_customrig.shapemult, 0);
		}
		else {
			s_customrig.shapemult = 0;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_SETCURSEL, s_customrig.shapemult, 0);
		}

		//shapekind
		WCHAR strcomboshape[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_RESETCONTENT, 0, 0);
		wcscpy_s(strcomboshape, 256, L"球");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_ADDSTRING, 0, (LPARAM)strcomboshape);
		wcscpy_s(strcomboshape, 256, L"円X");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_ADDSTRING, 0, (LPARAM)strcomboshape);
		wcscpy_s(strcomboshape, 256, L"円Y");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_ADDSTRING, 0, (LPARAM)strcomboshape);
		wcscpy_s(strcomboshape, 256, L"円Z");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_ADDSTRING, 0, (LPARAM)strcomboshape);
		if ((s_customrig.shapekind >= 0) && (s_customrig.shapekind < RIGSHAPE_MAX)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_SETCURSEL, s_customrig.shapekind, 0);
		}
		else {
			s_customrig.shapekind = 0;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_SETCURSEL, s_customrig.shapekind, 0);
		}

		//rigcolor
		WCHAR strcomborigcolor[256] = { 0L };
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_RESETCONTENT, 0, 0);
		wcscpy_s(strcomborigcolor, 256, L"赤");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_ADDSTRING, 0, (LPARAM)strcomborigcolor);
		wcscpy_s(strcomborigcolor, 256, L"緑");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_ADDSTRING, 0, (LPARAM)strcomborigcolor);
		wcscpy_s(strcomborigcolor, 256, L"青");
		SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_ADDSTRING, 0, (LPARAM)strcomborigcolor);
		if ((s_customrig.rigcolor >= 0) && (s_customrig.rigcolor < RIGCOLOR_MAX)) {
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_SETCURSEL, s_customrig.rigcolor, 0);
		}
		else {
			s_customrig.rigcolor = RIGCOLOR_RED;
			SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_SETCURSEL, s_customrig.rigcolor, 0);
		}


		WCHAR strcombo[256];
		WCHAR strval[256];

		int elemno;
		for (elemno = 0; elemno < MAXRIGELEMNUM; elemno++) {
			swprintf_s(strcombo, 256, L"%d", elemno + 1);//from 1 to MAXRIGELEMNUM
			SendMessage(GetDlgItem(hDlgWnd, IDC_CHILNUM), CB_ADDSTRING, 0, (LPARAM)strcombo);
		}
		if (elemnum < 1) {
			_ASSERT(0);
			elemnum = 1;
			s_customrig.rigelem[0].boneno = s_customrigbone->GetBoneNo();
		}
		SendMessage(GetDlgItem(hDlgWnd, IDC_CHILNUM), CB_SETCURSEL, elemnum - 1, 0);


		int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };
		int axisuid[5] = { IDC_AXIS_U1, IDC_AXIS_U2, IDC_AXIS_U3, IDC_AXIS_U4, IDC_AXIS_U5 };
		int axisvid[5] = { IDC_AXIS_V1, IDC_AXIS_V2, IDC_AXIS_V3, IDC_AXIS_V4, IDC_AXIS_V5 };
		int rateuid[5] = { IDC_RATE_U1, IDC_RATE_U2, IDC_RATE_U3, IDC_RATE_U4, IDC_RATE_U5 };
		int ratevid[5] = { IDC_RATE_V1, IDC_RATE_V2, IDC_RATE_V3, IDC_RATE_V4, IDC_RATE_V5 };
		int enableuid[5] = { IDC_ENABLEU1, IDC_ENABLEU2, IDC_ENABLEU3, IDC_ENABLEU4, IDC_ENABLEU5 };
		int enablevid[5] = { IDC_ENABLEV1, IDC_ENABLEV2, IDC_ENABLEV3, IDC_ENABLEV4, IDC_ENABLEV5 };
		int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };


		for (elemno = 0; elemno < MAXRIGELEMNUM; elemno++) {
			RIGELEM currigelem = s_customrig.rigelem[elemno];
			CBone* curbone = 0;
			if (elemno < elemnum) {
				curbone = s_model->GetBoneByID(currigelem.boneno);
				if (curbone) {
					SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)curbone->GetWBoneName());
				}
				else {
					_ASSERT(0);
					SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)L"None");
					//return 1;
				}
			}
			else {
				SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)L"None");
			}

			SetRigRigCombo(hDlgWnd, elemno);


			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_RESETCONTENT, 0, 0);
			wcscpy_s(strcombo, 256, L"CurrentX");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"CurrentY");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"CurrentZ");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentX");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentY");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentZ");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalX");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalY");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalZ");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeX");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeY");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeZ");
			SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);

			if ((currigelem.transuv[0].axiskind >= 0) && (currigelem.transuv[0].axiskind < RIGAXIS_MAX)) {
				SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_SETCURSEL, currigelem.transuv[0].axiskind, 0);
			}
			swprintf_s(strval, 256, L"%f", currigelem.transuv[0].applyrate);
			SetDlgItemText(hDlgWnd, rateuid[elemno], (LPCWSTR)strval);


			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_RESETCONTENT, 0, 0);
			wcscpy_s(strcombo, 256, L"CurrentX");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"CurrentY");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"CurrentZ");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentX");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentY");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"ParentZ");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalX");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalY");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"GlobalZ");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeX");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeY");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
			wcscpy_s(strcombo, 256, L"NodeZ");
			SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);

			if ((currigelem.transuv[0].axiskind >= 0) && (currigelem.transuv[0].axiskind < RIGAXIS_MAX)) {
				SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_SETCURSEL, currigelem.transuv[1].axiskind, 0);
			}
			swprintf_s(strval, 256, L"%f", currigelem.transuv[1].applyrate);
			SetDlgItemText(hDlgWnd, ratevid[elemno], (LPCWSTR)strval);

			//int enableuid[5] = { IDC_ENABLEU1, IDC_ENABLEU2, IDC_ENABLEU3, IDC_ENABLEU4, IDC_ENABLEU5 };
			//int enablevid[5] = { IDC_ENABLEV1, IDC_ENABLEV2, IDC_ENABLEV3, IDC_ENABLEV4, IDC_ENABLEV5 };
			if (currigelem.transuv[0].enable == 1) {
				CheckDlgButton(hDlgWnd, enableuid[elemno], BST_CHECKED);
			}
			else {
				CheckDlgButton(hDlgWnd, enableuid[elemno], BST_UNCHECKED);
			}

			if (currigelem.transuv[1].enable == 1) {
				CheckDlgButton(hDlgWnd, enablevid[elemno], BST_CHECKED);
			}
			else {
				CheckDlgButton(hDlgWnd, enablevid[elemno], BST_UNCHECKED);
			}

		}
		EnableRigAxisUV(hDlgWnd);
	}
	else {
		_ASSERT(0);
	}

	return 0;
}

int CheckRigRigCombo(HWND hDlgWnd, int elemno)
{
	//_ASSERT(0);
	//初期化
	int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };
	int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };
	s_customrig.rigelem[elemno].rigrigboneno = -1;
	s_customrig.rigelem[elemno].rigrigno = -1;
	CBone* levelbone = s_model->GetBoneByID(s_customrig.rigelem[elemno].boneno);
	if (levelbone) {
		SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)levelbone->GetWBoneName());
	}
	else {
		SetDlgItemText(hDlgWnd, gpboxid[elemno], L"None");
	}


	//チェック　アンド　セット
	int combono;
	combono = (int)SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_GETCURSEL, 0, 0);
	s_customrig.rigelem[elemno].rigrigboneno = -1;
	s_customrig.rigelem[elemno].rigrigno = -1;
	if ((combono != 0) && (combono != CB_ERR)) {
		WCHAR combolabel[256];
		ZeroMemory(combolabel, sizeof(WCHAR) * 256);
		SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_GETLBTEXT, combono, (LPARAM)combolabel);
		//{
		//	WCHAR strdbg[256];
		//	swprintf_s(strdbg, 256, L"elemno %d, combolabel %s", elemno, combolabel);
		//	::DSMessageBox(hDlgWnd, strdbg, L"combolabel", MB_OK);
		//}
		combolabel[256 - 1] = 0L;
		size_t labellen = wcslen(combolabel);
		if ((labellen > 0) && (labellen < 256)) {
			//format    [rigrigno]rigrigbonename[|]rigname
			if (combolabel[0] == L'[') {
				WCHAR* prigrignoend = wcsstr(combolabel, L"]");
				if (prigrignoend) {
					WCHAR strrigrigno[256];
					ZeroMemory(strrigrigno, sizeof(WCHAR) * 256);
					wcsncpy_s(strrigrigno, 256, combolabel + 1, (size_t)(prigrignoend - (combolabel + 1)));
					int rigrigno = _wtoi(strrigrigno);
					//{
					//	WCHAR strdbg[256];
					//	swprintf_s(strdbg, 256, L"rigrigno %d", rigrigno);
					//	::DSMessageBox(hDlgWnd, strdbg, L"rigrigno", MB_OK);
					//}
					if ((rigrigno >= 0) && (rigrigno < MAXRIGNUM)) {
						s_customrig.rigelem[elemno].rigrigno = rigrigno;

						WCHAR* pbonenameend = wcsstr(combolabel, L"[|]");
						if (pbonenameend) {
							WCHAR rigrigbonename[256];
							ZeroMemory(rigrigbonename, sizeof(WCHAR) * 256);
							wcsncpy_s(rigrigbonename, 256, prigrignoend + 1, (size_t)(pbonenameend - (prigrignoend + 1)));
							//{
							//	WCHAR strdbg[256];
							//	swprintf_s(strdbg, 256, L"rigrigbonename %s", rigrigbonename);
							//	::DSMessageBox(hDlgWnd, strdbg, L"rigrigbonename", MB_OK);
							//}
							CBone* rigrigbone = s_model->GetBoneByWName(rigrigbonename);
							if (rigrigbone) {
								s_customrig.rigelem[elemno].rigrigboneno = rigrigbone->GetBoneNo();

								//{
								//	WCHAR strdbg[256];
								//	swprintf_s(strdbg, 256, L"rigrigboneno %d", s_customrig.rigelem[elemno].rigrigboneno);
								//	::DSMessageBox(hDlgWnd, strdbg, L"rigrigboneno", MB_OK);
								//}
																//int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };
								SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)rigrigbone->GetWBoneName());
							}
						}
					}
				}
			}
		}
	}

	EnableRigAxisUV(hDlgWnd);

	return 0;

}



LRESULT CALLBACK CustomRigDlgProc(HWND hDlgWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };

	switch (msg) {
	case WM_INITDIALOG:
	{
		CustomRig2Dlg(hDlgWnd);
		s_customrighwnd = hDlgWnd;
		return FALSE;
	}
	break;
	case WM_COMMAND:
		if (HIWORD(wp) == CBN_SELCHANGE) {
			switch (LOWORD(wp)) {
			case IDC_COMBO1:
				CheckRigRigCombo(hDlgWnd, 0);
				break;
			case IDC_COMBO2:
				CheckRigRigCombo(hDlgWnd, 1);
				break;
			case IDC_COMBO3:
				CheckRigRigCombo(hDlgWnd, 2);
				break;
			case IDC_COMBO4:
				CheckRigRigCombo(hDlgWnd, 3);
				break;
			case IDC_COMBO5:
				CheckRigRigCombo(hDlgWnd, 4);
				break;
			case IDC_CHILNUM:
			{
				int combono = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_CHILNUM), CB_GETCURSEL, 0, 0);
				if ((combono >= 0) && (combono < MAXRIGELEMNUM)) {
					SetCustomRigDlgLevel(hDlgWnd, combono + 1);
				}
			}
			break;
			default:
				break;
			}
		}
		else {
			switch (LOWORD(wp)) {
			case IDOK:
			{
				s_customrighwnd = 0;

				WCHAR strrigname[256] = { 0L };
				GetDlgItemText(hDlgWnd, IDC_RIGNAME, strrigname, 256);
				wcscpy_s(s_customrig.rigname, 256, strrigname);

				int combonoda = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPAXIS), CB_GETCURSEL, 0, 0);
				if ((combonoda >= 0) && (combonoda <= 2)) {
					s_customrig.dispaxis = combonoda;
				}
				else {
					s_customrig.dispaxis = 0;
				}

				int combonodo = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_DISPORDER), CB_GETCURSEL, 0, 0);
				if ((combonodo >= 0) && (combonodo <= RIGPOSINDEXMAX)) {
					s_customrig.disporder = combonodo;
				}
				else {
					s_customrig.disporder = 0;
				}

				if (IsDlgButtonChecked(hDlgWnd, IDC_CHKINV) == BST_CHECKED) {
					s_customrig.posinverse = true;
				}
				else {
					s_customrig.posinverse = false;
				}

				int combonomult = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGMULT), CB_GETCURSEL, 0, 0);
				if ((combonomult >= 0) && (combonomult <= RIGMULTINDEXMAX)) {
					s_customrig.shapemult = combonomult;
				}
				else {
					s_customrig.shapemult = 0;
				}

				int combonoshape = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGSHAPE), CB_GETCURSEL, 0, 0);
				if ((combonoshape >= 0) && (combonoshape < RIGSHAPE_MAX)) {
					s_customrig.shapekind = combonoshape;
				}
				else {
					s_customrig.shapekind = 0;
				}

				int combonocolor = (int)SendMessage(GetDlgItem(hDlgWnd, IDC_COMBO_RIGCOLOR), CB_GETCURSEL, 0, 0);
				if ((combonocolor >= 0) && (combonocolor < RIGCOLOR_MAX)) {
					s_customrig.rigcolor = combonocolor;
				}
				else {
					s_customrig.rigcolor = RIGCOLOR_RED;
				}


				int axisuid[5] = { IDC_AXIS_U1, IDC_AXIS_U2, IDC_AXIS_U3, IDC_AXIS_U4, IDC_AXIS_U5 };
				int axisvid[5] = { IDC_AXIS_V1, IDC_AXIS_V2, IDC_AXIS_V3, IDC_AXIS_V4, IDC_AXIS_V5 };
				int rateuid[5] = { IDC_RATE_U1, IDC_RATE_U2, IDC_RATE_U3, IDC_RATE_U4, IDC_RATE_U5 };
				int ratevid[5] = { IDC_RATE_V1, IDC_RATE_V2, IDC_RATE_V3, IDC_RATE_V4, IDC_RATE_V5 };
				int enableuid[5] = { IDC_ENABLEU1, IDC_ENABLEU2, IDC_ENABLEU3, IDC_ENABLEU4, IDC_ENABLEU5 };
				int enablevid[5] = { IDC_ENABLEV1, IDC_ENABLEV2, IDC_ENABLEV3, IDC_ENABLEV4, IDC_ENABLEV5 };

				int elemno;
				for (elemno = 0; elemno < s_customrig.elemnum; elemno++) {

					CheckRigRigCombo(hDlgWnd, elemno);


					int combono = (int)SendMessage(GetDlgItem(hDlgWnd, axisuid[elemno]), CB_GETCURSEL, 0, 0);
					if ((combono >= 0) && (combono < RIGAXIS_MAX)) {
						s_customrig.rigelem[elemno].transuv[0].axiskind = combono;
					}
					combono = (int)SendMessage(GetDlgItem(hDlgWnd, axisvid[elemno]), CB_GETCURSEL, 0, 0);
					if ((combono >= 0) && (combono < RIGAXIS_MAX)) {
						s_customrig.rigelem[elemno].transuv[1].axiskind = combono;
					}

					int ret;
					float tmprate;
					ret = GetCustomRigRateVal(hDlgWnd, rateuid[elemno], &tmprate);
					if (ret) {
						::DSMessageBox(hDlgWnd, L"Invalid VerticalScale. Limit From -100.0 to 100.0.", L"error!!!", MB_OK);
						return 0;
					}
					s_customrig.rigelem[elemno].transuv[0].applyrate = tmprate;

					ret = GetCustomRigRateVal(hDlgWnd, ratevid[elemno], &tmprate);
					if (ret) {
						::DSMessageBox(hDlgWnd, L"Invalid HolizontalScale. Limit From -100.0 to 100.0.", L"error!!!", MB_OK);
						return 0;
					}
					s_customrig.rigelem[elemno].transuv[1].applyrate = tmprate;


					if (IsDlgButtonChecked(hDlgWnd, enableuid[elemno]) == BST_CHECKED) {
						s_customrig.rigelem[elemno].transuv[0].enable = 1;
					}
					else {
						s_customrig.rigelem[elemno].transuv[0].enable = 0;
					}

					if (IsDlgButtonChecked(hDlgWnd, enablevid[elemno]) == BST_CHECKED) {
						s_customrig.rigelem[elemno].transuv[1].enable = 1;
					}
					else {
						s_customrig.rigelem[elemno].transuv[1].enable = 0;
					}

				}


				int isvalid = IsValidCustomRig(s_model, s_customrig, s_customrigbone);
				if (isvalid == 0) {
					::DSMessageBox(hDlgWnd, L"Invalid Parameter", L"error!!!", MB_OK);
					return 0;
				}

				CustomRig2Bone();

				SetTimelineHasRigFlag();

				//EndDialog(hDlgWnd, IDOK);
			}
			break;
			case IDCANCEL:
				s_customrighwnd = 0;
				//EndDialog(hDlgWnd, IDCANCEL);
				SetTimelineHasRigFlag();

				break;
			default:
				return FALSE;
			}
		}
		break;
	case WM_CLOSE:
		if (s_customrigdlg) {
			DestroyWindow(s_customrigdlg);
			s_customrigdlg = 0;
		}

		GUIMenuSetVisible(s_platemenukind, s_platemenuno);

		break;
	default:
		return FALSE;
	}
	return TRUE;

}

int BrushesContextMenu()
{
	if (!s_model) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}

	HWND parwnd;
	parwnd = s_3dwnd;

	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 0;
	}
	int ret;
	ret = rmenu->Create(parwnd, MENUOFFSET_BRUSHESCONTEXTMENU);
	if (ret) {
		return 0;
	}

	HMENU submenu = rmenu->GetSubMenu();

	CRMenuMain* rsubmenu[MAXPLUGIN];
	ZeroMemory(rsubmenu, sizeof(CRMenuMain*) * MAXPLUGIN);


	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}


	int currentpluginno = 0;
	int pluginno;
	int addindex = 0;
	for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
		if ((s_plugin + pluginno)->validflag == 1) {
			WCHAR strmenu[256];
			swprintf_s(strmenu, 256, (s_plugin + pluginno)->pluginname);

			AppendMenu(submenu, MF_STRING,
				(MENUOFFSET_BRUSHESCONTEXTMENU + pluginno),
				strmenu);
		}
	}


	POINT pt;
	GetCursorPos(&pt);
	//::ScreenToClient(parwnd, &pt);

	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	int currigno = -1;
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);


	for (pluginno = 0; pluginno < MAXPLUGIN; pluginno++) {
		CRMenuMain* curmenu = rsubmenu[pluginno];
		if (curmenu) {
			curmenu->Destroy();
			delete curmenu;
		}
	}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	return 0;
}


int BoneRClick(int srcboneno)
{
	int pickflag = 0;//return value


	if (!s_model) {
		return pickflag;
	}
	if (!s_model->GetTopBone()) {
		return pickflag;
	}



	if (srcboneno < 0) {
		s_ikcnt = 0;
		//SetCapture(s_3dwnd);
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.clickpos = ptCursor;
		s_pickinfo.mousepos = ptCursor;
		s_pickinfo.mousebefpos = ptCursor;
		s_pickinfo.diffmouse.SetParams(0.0f, 0.0f);
		s_pickinfo.firstdiff.SetParams(0.0f, 0.0f);

		//s_pickinfo.winx = (int)DXUTGetWindowWidth();
		//s_pickinfo.winy = (int)DXUTGetWindowHeight();
		s_pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
		s_pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
		s_pickinfo.pickrange = PICKRANGE;

		s_pickinfo.pickobjno = -1;

		s_curboneno = -1;//2023/08/28 ジョイント以外を右クリックした場合には　メニューを出さない

		if (s_oprigflag == 0) {
			CallF(PickBone(&s_pickinfo), return pickflag);
			if (s_pickinfo.pickobjno >= 0) {
				s_curboneno = s_pickinfo.pickobjno;
				pickflag = 1;
			}
		}
		else {
			int pickrigboneno = PickRigBone(&s_pickinfo);
			if (pickrigboneno >= 0) {
				s_curboneno = s_pickinfo.pickobjno;
				pickflag = 1;
			}
		}
	}

	if (s_curboneno > 0) {
		if (s_owpTimeline) {
			s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
		}

		ChangeCurrentBone(true);

		if (s_curboneno >= 0) {
			CBone* curbone = s_model->GetBoneByID(s_curboneno);
			if (curbone) {
				HWND parwnd;
				//parwnd = s_3dwnd;
				parwnd = s_3dwnd;

				CRMenuMain* rmenu;
				rmenu = new CRMenuMain(IDR_RMENU);
				if (!rmenu) {
					return pickflag;
				}
				int ret;
				ret = rmenu->Create(parwnd, MENUOFFSET_BONERCLICK);
				if (ret) {
					return pickflag;
				}

				HMENU submenu = rmenu->GetSubMenu();

				CRMenuMain* rsubmenu[MAXRIGNUM];
				ZeroMemory(rsubmenu, sizeof(CRMenuMain*) * MAXRIGNUM);


				int menunum;
				menunum = GetMenuItemCount(submenu);
				int menuno;
				for (menuno = 0; menuno < menunum; menuno++)
				{
					RemoveMenu(submenu, 0, MF_BYPOSITION);
				}
				s_customrigmenuindex.clear();


				AppendMenu(submenu, MF_STRING,
					(ID_RMENU_COPY + MENUOFFSET_BONERCLICK),
					L"Copy Motion");
				AppendMenu(submenu, MF_STRING,
					(ID_RMENU_PASTE + MENUOFFSET_BONERCLICK),
					L"Paste Deeper");


				if (curbone->GetIKTargetFlag() == false){
					AppendMenu(submenu, MF_STRING, 
						(ID_RMENU_IKTARGET + MENUOFFSET_BONERCLICK), 
						L"Pos Constraint ON");
				}
				else{
					AppendMenu(submenu, MF_STRING, 
						(ID_RMENU_IKTARGET + MENUOFFSET_BONERCLICK), 
						L"Pos Constraint OFF");
				}

				if (curbone->GetIKStopFlag() == false) {
					AppendMenu(submenu, MF_STRING, 
						(ID_RMENU_IKSTOP + MENUOFFSET_BONERCLICK), 
						L"IK Stop ON");
				}
				else {
					AppendMenu(submenu, MF_STRING, 
						(ID_RMENU_IKSTOP + MENUOFFSET_BONERCLICK), 
						L"IK Stop OFF");
				}

				AppendMenu(submenu, MF_STRING, ID_RMENU_0 + MENUOFFSET_BONERCLICK, L"CreateNewRig");
				int setmenuno = 1;
				int rigno;
				for (rigno = 0; rigno < MAXRIGNUM; rigno++) {
					CUSTOMRIG currig = curbone->GetCustomRig(rigno);
					if (currig.useflag == 2) {
						int setmenuid = ID_RMENU_0 + setmenuno + MENUOFFSET_BONERCLICK;

						//AppendMenu(submenu, MF_STRING, setmenuid, currig.rigname);
						s_customrigmenuindex[setmenuno] = rigno;

						rsubmenu[rigno] = new CRMenuMain(IDR_RMENU);
						if (!rsubmenu[rigno]) {
							return pickflag;
						}
						ret = rsubmenu[rigno]->CreatePopupMenu(parwnd, submenu, currig.rigname);
						if (ret) {
							return pickflag;
						}
						HMENU subsubmenu = rsubmenu[rigno]->GetSubMenu();
						int subsubmenunum;
						subsubmenunum = GetMenuItemCount(subsubmenu);
						int subsubmenuno;
						for (subsubmenuno = 0; subsubmenuno < subsubmenunum; subsubmenuno++)
						{
							RemoveMenu(subsubmenu, 0, MF_BYPOSITION);
						}

						int subsubid1 = setmenuid + MAXRIGNUM;
						int subsubid2 = setmenuid + MAXRIGNUM * 2;
						int subsubid3 = setmenuid + MAXRIGNUM * 3;
						AppendMenu(subsubmenu, MF_STRING, subsubid1, L"SettingOfRig");
						AppendMenu(subsubmenu, MF_STRING, subsubid2, L"Execute Rig");
						AppendMenu(subsubmenu, MF_STRING, subsubid3, L"Invalidate Rig");

						setmenuno++;
					}
				}


				POINT pt;
				GetCursorPos(&pt);
				//::ScreenToClient(parwnd, &pt);

				s_cursubmenu = rmenu->GetSubMenu();

				InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
				int currigno = -1;
				int menuid;
				menuid = rmenu->TrackPopupMenu(pt);


				for (rigno = 0; rigno < MAXRIGNUM; rigno++) {
					CRMenuMain* curmenu = rsubmenu[rigno];
					if (curmenu) {
						curmenu->Destroy();
						delete curmenu;
					}
				}

				rmenu->Destroy();
				delete rmenu;
				InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
			}
		}
	}

	return pickflag;
}

int EnableRigAxisUV(HWND hDlgWnd)
{
	int axisuid[5] = { IDC_AXIS_U1, IDC_AXIS_U2, IDC_AXIS_U3, IDC_AXIS_U4, IDC_AXIS_U5 };
	int axisvid[5] = { IDC_AXIS_V1, IDC_AXIS_V2, IDC_AXIS_V3, IDC_AXIS_V4, IDC_AXIS_V5 };
	int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };

	int elemno;
	for (elemno = 0; elemno < s_customrig.elemnum; elemno++) {
		RIGELEM currigelem = s_customrig.rigelem[elemno];
		if (currigelem.rigrigboneno >= 0) {
			EnableWindow(GetDlgItem(hDlgWnd, axisuid[elemno]), false);
			EnableWindow(GetDlgItem(hDlgWnd, axisvid[elemno]), false);
		}
		else {
			EnableWindow(GetDlgItem(hDlgWnd, axisuid[elemno]), true);
			EnableWindow(GetDlgItem(hDlgWnd, axisvid[elemno]), true);
		}
	}

	return 0;
}

int SetRigRigCombo(HWND hDlgWnd, int elemno)
{
	int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };
	int rigrigcomboid[5] = { IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_COMBO4, IDC_COMBO5 };

	WCHAR strcombo[256];

	SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)L"NotSet");
	SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_RESETCONTENT, 0, 0);
	wcscpy_s(strcombo, 256, L"RegularBone");
	SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
	SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_SETCURSEL, 0, 0);


	if (elemno < s_customrig.elemnum) {
		RIGELEM currigelem = s_customrig.rigelem[elemno];
		int selrigrigcombono = 0;
		SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_RESETCONTENT, 0, 0);
		wcscpy_s(strcombo, 256, L"RegularBone");
		SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
		int setcombono = 1;

		CBone* rigrigbone = s_model->GetBoneByID(currigelem.rigrigboneno);
		CBone* currigrigbone;
		map<int, CBone*>::iterator itrcurrigrigbone;
		for (itrcurrigrigbone = s_model->GetBoneListBegin(); itrcurrigrigbone != s_model->GetBoneListEnd(); itrcurrigrigbone++) {
			currigrigbone = itrcurrigrigbone->second;
			if (currigrigbone && (currigrigbone->IsSkeleton())) {
				WCHAR rigrigbonename[256];
				ZeroMemory(rigrigbonename, sizeof(WCHAR) * 256);
				wcscpy_s(rigrigbonename, 256, currigrigbone->GetWBoneName());
				int rigrigno;
				for (rigrigno = 0; rigrigno < MAXRIGNUM; rigrigno++) {
					CUSTOMRIG rigrig = currigrigbone->GetCustomRig(rigrigno);
					if (rigrig.useflag == 2) {
						int isvalid = IsValidCustomRig(s_model, rigrig, currigrigbone);
						if (isvalid == 1) {
							swprintf_s(strcombo, 256, L"[%d]%s[|]%s", rigrigno, rigrigbonename, rigrig.rigname);
							SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_ADDSTRING, 0, (LPARAM)strcombo);
							if (rigrigbone && (currigrigbone == rigrigbone) && (rigrigno == currigelem.rigrigno)) {
								selrigrigcombono = setcombono;
								SetDlgItemText(hDlgWnd, gpboxid[elemno], (LPCWSTR)rigrigbone->GetWBoneName());
							}
							setcombono++;
						}
					}
				}
			}
		}
		SendMessage(GetDlgItem(hDlgWnd, rigrigcomboid[elemno]), CB_SETCURSEL, selrigrigcombono, 0);
	}

	return 0;
}

int SetCustomRigDlgLevel(HWND hDlgWnd, int levelnum)
{
	if (!s_model) {
		return 0;
	}
	if (!s_customrigbone) {
		return 0;
	}
	if (!s_model->GetTopBone()) {
		return 0;
	}
	if (!s_customrigdlg) {
		return 0;
	}

	if ((levelnum >= 1) && (levelnum <= MAXRIGELEMNUM)) {
		int gpboxid[5] = { IDC_CHILD1, IDC_CHILD2, IDC_CHILD3, IDC_CHILD4, IDC_CHILD5 };

		int parno = 1;
		CBone* parentbone = s_customrigbone->GetParent(false);
		while (parentbone && parentbone->IsSkeleton() && (parno < MAXRIGELEMNUM) && (parno < levelnum)) {
			SetDlgItemText(s_customrigdlg, gpboxid[parno], (LPCWSTR)parentbone->GetWBoneName());
			s_customrig.rigelem[parno].boneno = parentbone->GetBoneNo();
			parentbone = parentbone->GetParent(false);
			parno++;
		}

		//int newlevelnum = parno;
		//s_customrig.elemnum = levelnum;
		//SendMessage(GetDlgItem(s_customrigdlg, IDC_CHILNUM), CB_SETCURSEL, newlevelnum - 1, 0);
		s_customrig.elemnum = levelnum;

		int elemno;
		for (elemno = 0; elemno < MAXRIGELEMNUM; elemno++) {
			SetRigRigCombo(hDlgWnd, elemno);
		}
	}

	EnableRigAxisUV(hDlgWnd);


	return 0;
}

int ToggleRig()
{
	//if (s_customrigbone){
	if (s_oprigflag == 0) {
		s_oprigflag = 1;

		//if (s_BoneMarkCheckBox) {
		//	s_savebonemarkflag = (int)s_BoneMarkCheckBox->GetChecked();
		//	s_BoneMarkCheckBox->SetChecked(false);
		//}
		//if (s_RigidMarkCheckBox) {
		//	s_saverigidmarkflag = (int)s_RigidMarkCheckBox->GetChecked();
		//	s_RigidMarkCheckBox->SetChecked(false);
		//}

		////s_curboneno = s_customrigbone->GetBoneNo();
		////s_pickinfo.buttonflag = PICK_CENTER;
	}
	else {
		s_oprigflag = 0;
		s_pickinfo.buttonflag = 0;

		//if (s_BoneMarkCheckBox) {
		//	s_BoneMarkCheckBox->SetChecked(s_savebonemarkflag == 1);
		//}
		//if (s_RigidMarkCheckBox) {
		//	s_RigidMarkCheckBox->SetChecked(s_saverigidmarkflag == 1);
		//}


		////if (s_customrigdlg){
		////	DestroyWindow(s_customrigdlg);
		////	s_customrigdlg = 0;
		////}

		////GUIMenuSetVisible(s_platemenukind, s_platemenuno);

	}
	//}
	//else{
	//	s_oprigflag = 0;
	//	if (s_customrigdlg){
	//		DestroyWindow(s_customrigdlg);
	//		s_customrigdlg = 0;
	//	}
	//	s_pickinfo.buttonflag = 0;

	//	//GUIMenuSetVisible(s_platemenukind, s_platemenuno);
	//}
	return 0;
}

int GetSymRootMode()
{
	/*
	enum
	{
		//for bit mask operation
		SYMROOTBONE_SAMEORG = 0,
		SYMROOTBONE_SYMDIR = 1,
		SYMROOTBONE_SYMPOS = 2
	};
	*/

	if (!s_chascene) {
		return 0;
	}
	int modelnum = s_chascene->GetModelNum();
	if (modelnum <= 0) {
		return 0;
	}

	CRMenuMain* rmenu;
	rmenu = new CRMenuMain(IDR_RMENU);
	if (!rmenu) {
		return 0;
	}
	int ret;
	ret = rmenu->Create(s_3dwnd, MENUOFFSET_GETSYMROOTMODE);
	//ret = rmenu->Create(g_mainhwnd);
	if (ret) {
		return 0;
	}

	HMENU submenu = rmenu->GetSubMenu();

	int menunum;
	menunum = GetMenuItemCount(submenu);
	int menuno;
	for (menuno = 0; menuno < menunum; menuno++)
	{
		RemoveMenu(submenu, 0, MF_BYPOSITION);
	}

	//scaleを変えるとtraanimも変わるのでscaleメニューを分けないでおく。
	int setmenuid;
	setmenuid = ID_RMENU_0 + MENUOFFSET_GETSYMROOTMODE;
	AppendMenu(submenu, MF_STRING, setmenuid, L"RootBone:SameToSource");
	setmenuid = ID_RMENU_0 + 1 + MENUOFFSET_GETSYMROOTMODE;
	AppendMenu(submenu, MF_STRING, setmenuid, L"RootBone:SymDirAndSymPosAndSymScale");
	setmenuid = ID_RMENU_0 + 2 + MENUOFFSET_GETSYMROOTMODE;
	AppendMenu(submenu, MF_STRING, setmenuid, L"RootBone:SymDirAndSymSale");
	setmenuid = ID_RMENU_0 + 3 + MENUOFFSET_GETSYMROOTMODE;
	AppendMenu(submenu, MF_STRING, setmenuid, L"RootBone:SymPos");


	//2024/01/20
	//実際に有効な使用方法としては　RootBone:SymDirAndSymPosAndSymScaleだけとも言えるので　他のメニューはグレーアウト
	//部分的にペーストしたい場合には　上段カエルショートカットボタンの中のペーストボタンを右クリックして　対象を絞って対称ペーストする
	MENUITEMINFO mii;
	ZeroMemory(&mii, sizeof(MENUITEMINFO));
	mii.cbSize = sizeof(MENUITEMINFO);
	mii.fMask = MIIM_STATE;
	mii.fState = MFS_GRAYED;
	SetMenuItemInfo(submenu, ID_RMENU_0 + MENUOFFSET_GETSYMROOTMODE, FALSE, &mii);
	SetMenuItemInfo(submenu, ID_RMENU_0 + 2 + MENUOFFSET_GETSYMROOTMODE, FALSE, &mii);
	SetMenuItemInfo(submenu, ID_RMENU_0 + 3 + MENUOFFSET_GETSYMROOTMODE, FALSE, &mii);


	POINT pt;
	GetCursorPos(&pt);

	s_cursubmenu = rmenu->GetSubMenu();

	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);
	s_getsym_retmode = 0;
	int menuid;
	menuid = rmenu->TrackPopupMenu(pt);
	//if ((menuid >= ID_RMENU_0) && (menuid <= (ID_RMENU_0 + 3))){
	//	switch(menuid){
	//	case (ID_RMENU_0) :
	//		retmode = SYMROOTBONE_SAMEORG;
	//		break;
	//	case (ID_RMENU_0 + 1) :
	//		retmode = SYMROOTBONE_SYMDIR | SYMROOTBONE_SYMPOS;
	//		break;
	//	case (ID_RMENU_0 + 2) :
	//		retmode = SYMROOTBONE_SYMDIR;
	//		break;
	//	case (ID_RMENU_0 + 3) :
	//		retmode = SYMROOTBONE_SYMPOS;
	//		break;
	//	default:
	//		retmode = SYMROOTBONE_SYMDIR | SYMROOTBONE_SYMPOS;
	//		break;
	//	}
	//}

	rmenu->Destroy();
	delete rmenu;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	//return s_getsym_retmode;//この時点では s_getsym_retmodeは0のまま
	return 0;
}

void AutoCameraTarget()
{
	//s_camtargetflag = (int)s_CamTargetCheckBox->GetChecked();
	if (s_model && (s_curboneno >= 0) && (s_camtargetflag || s_camtargetOnceflag)) {
		CBone* curbone = s_model->GetBoneByID(s_curboneno);
		_ASSERT(curbone);
		if (curbone) {
			g_befcamtargetpos = g_camtargetpos;
			g_camtargetpos = curbone->GetChildWorld();

			//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));//!!!!!!!!!!!
			////#replacing comment out#g_Camera->SetViewParamsWithUpVec(neweye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));//!!!!!!!!!!!

			//!!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
			//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
			ChaVector3 diffv;
			diffv = g_camEye - g_camtargetpos;
			float newcamdist = (float)ChaVector3LengthDbl(&diffv);
			ChangeCameraDist(newcamdist, false, false);//2024/03/08

			////#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
			////#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

		}
		else {
			s_curboneno = -1;
		}
	}
	else {
		//ChaVector3 diffv;
		//diffv = g_camEye - g_camtargetpos;
		//float newcamdist = (float)ChaVector3LengthDbl(&diffv);
		//ChangeCameraDist(newcamdist, false, false);
	}

	SetCamera3DFromEyePos();
}


/////// for directx9

//--------------------------------------------------------------------------------------
// Rejects any D3D9 devices that aren't acceptable to the app by returning false
//--------------------------------------------------------------------------------------
//bool CALLBACK IsD3D9DeviceAcceptable(D3DCAPS9* pCaps, D3DFORMAT AdapterFormat,
//	D3DFORMAT BackBufferFormat, bool bWindowed, void* pUserContext)
//{
//	//// No fallback defined by this app, so reject any device that doesn't support at least ps2.0
//	//if (pCaps->PixelShaderVersion < D3DPS_VERSION(2, 0))
//	//	return false;
//
//	//// Skip backbuffer formats that don't support alpha blending
//	//IDirect3D9* pD3D = DXUTGetD3D9Object();
//	//if (FAILED(pD3D->CheckDeviceFormat(pCaps->AdapterOrdinal, pCaps->DeviceType,
//	//	AdapterFormat, D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING,
//	//	D3DRTYPE_TEXTURE, BackBufferFormat)))
//	//	return false;
//
//	//return true;
//	return false;
//}


//////////////////////////////////////////
int OnTimeLineSelectFromSelectedKey()
{
	if (g_previewFlag != 0) {
		return 0;
	}

	s_editrange.Clear();
	if (s_model && s_model->ExistCurrentMotion()) {
		if (s_owpTimeline && s_owpLTimeline && s_owpEulerGraph) {
			s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
			//CEditRange::SetApplyRate(g_applyrate);

			int keynum;
			double startframe, endframe, applyframe;
			s_editrange.GetRange(&keynum, &startframe, &endframe, &applyframe);

			if (g_underselectingframe != 0) {
				//if (s_buttonselecttothelast == 0) {//tothelastのときも同じ処理
				if (s_buttonselectstart <= s_buttonselectend) {
					s_owpLTimeline->setCurrentTime(endframe, true);
					s_owpEulerGraph->setCurrentTime(endframe, false);
				}
				else {
					s_owpLTimeline->setCurrentTime(startframe, true);
					s_owpEulerGraph->setCurrentTime(startframe, false);
				}
				//}
				//else {
				//	//to the last selectionの際にはカレントをアプライフレームへ
				//	s_owpLTimeline->setCurrentTime(applyframe, true);
				//	s_owpEulerGraph->setCurrentTime(applyframe, false);
				//}
			}
			else {
				s_owpLTimeline->setCurrentTime(applyframe, true);
				s_owpEulerGraph->setCurrentTime(applyframe, false);
				AddEditRangeHistory();
			}

			//UpdateTopPosText();
		}
	}



	return 0;
}

int OnTimeLineButtonSelectFromSelectStartEnd(int tothelastflag)
{
	s_buttonselecttothelast = tothelastflag;

	if (s_owpLTimeline && (g_underselectingframe == 0) && s_timelinewheelFlag) {
		s_owpLTimeline->selectClear(false);
		if (s_owpTimeline) {
			s_owpTimeline->selectClear(false);
		}
		return 0;
	}

	//if ((s_copyKeyInfoList.size() > 0) || tothelastflag) {//2021/11/09 選択済の場合にはそのまま　これがないと１フレーム長選択でOnButtonSelectがループする
	if (s_owpLTimeline) {
		s_owpLTimeline->selectClear(false);//フレームに色付選択していない場合には呼ばれないので再帰ループしない
		if (s_owpTimeline) {
			s_owpTimeline->selectClear(false);
		}
		//if ((s_buttonselectstart != s_buttonselectend) || tothelastflag) {//tothelastの際には　範囲を指定していなくても実行
		//if ((s_buttonselectstart <= s_buttonselectend) || tothelastflag) {//2021/11/09
		double tmpmaxselectionframe;
		tmpmaxselectionframe = s_owpLTimeline->OnButtonSelect(s_buttonselectstart, s_buttonselectend, s_buttonselecttothelast);
		s_buttonselectend = tmpmaxselectionframe;//tothelast対応
	//}
	}

	OnTimeLineSelectFromSelectedKey();
	//}

	return 0;
}

int OnTimeLineCursorFunc()
{
	if (s_owpLTimeline && s_model && s_model->ExistCurrentMotion()) {
		double curframe;
		curframe = s_owpLTimeline->getCurrentTime();// 選択時刻
		if (s_owpTimeline) {
			s_owpTimeline->setCurrentTime(curframe, false);
			//s_owpLTimeline->setCurrentTime(curframe, false);
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->setCurrentTime(curframe, false);
		}
	}

	return 0;
}

int OnTimeLineCursor()
{
	//s_tum.UpdateTimeline(OnTimeLineCursorFunc, mbuttonflag, newframe);//非ブロック

	if ((s_delmodelFlag == false) && (s_delallmodelFlag == false) && (s_delcurmotFlag == false) &&
		(s_opedelmodelcnt < 0) && (s_opedelmotioncnt < 0) && (s_opeselectmodelcnt < 0) && (s_opeselectmotioncnt < 0) && (s_opeselectcameracnt < 0) &&
		(s_underdelmotion == false) && (s_underdelmodel == false) 
		)// &&
		//s_model && (s_model->GetLoadedFlag() == true) && 
		//(g_underRetargetFlag == false))
	{
		OnTimeLineCursorFunc();
		//UpdateEditedEuler();
		//s_tum.UpdateTimeline(OnTimeLineCursorFunc, mbuttonflag, newframe);//非ブロック
		//if (s_updatetimeline) {
		//	s_updatetimeline->UpdateTimeline(OnTimeLineCursorFunc, mbuttonflag, newframe);
		//	while (s_updatetimeline->IsFinished() == false) {
		//		timeBeginPeriod(1);
		//		SleepEx(0, TRUE);
		//		//SleepEx(1, TRUE);
		//		timeEndPeriod(1);
		//	}
		//}
	}
	else {
		double curframe = 1.0;
		if (s_owpTimeline) {
			s_owpTimeline->setCurrentTime(curframe, false);
		}
		if (s_owpLTimeline) {
			s_owpLTimeline->setCurrentTime(curframe, false);
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->setCurrentTime(curframe, false);
		}
	}




	//if (g_previewFlag != 0){
	//	return 0;
	//}

	//if (s_owpLTimeline && s_model && s_model->GetCurMotInfo()) {
	//	double curframe;
	//	if (mbuttonflag != 2) {
	//		curframe = s_owpLTimeline->getCurrentTime();// 選択時刻
	//		s_owpTimeline->setCurrentTime(curframe, false);
	//		//s_owpLTimeline->setCurrentTime(curframe, false);
	//		s_owpEulerGraph->setCurrentTime(curframe, false);
	//	}
	//	else {
	//		curframe = newframe;
	//		s_owpTimeline->setCurrentTime(curframe, false);
	//		s_owpLTimeline->setCurrentTime(curframe, false);
	//		s_owpEulerGraph->setCurrentTime(curframe, false);
	//	}
	//}

	return 0;
}

int OnTimeLineMButtonDown(bool ctrlshiftflag)
{
	//if (g_underselectingframe == 0){
	if (s_mbuttoncnt == 1) {
		if (ctrlshiftflag == false) {
			g_underselectingframe = 1;
		}
		else {
			g_underselectingframe = 2;
		}
		if (g_previewFlag == 0) {
			if (s_owpLTimeline) {
				s_buttonselectstart = s_owpLTimeline->getCurrentTime();
				s_buttonselectend = s_buttonselectstart;
				s_mbuttonstart = s_buttonselectstart;//2021/11/10
				OnTimeLineCursor();
			}
		}
	}
	else {
		g_underselectingframe = 0;
		OnTimeLineButtonSelectFromSelectStartEnd(0);

		if (s_editmotionflag < 0) {
			int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
			if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
				_ASSERT(0);
				::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
				PostQuitMessage(result);
			}

			//2022/09/13
			if (s_owpLTimeline) {
				s_editmotionflag = s_curboneno;
				s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
				//CEditRange::SetApplyRate(g_applyrate);
				PrepairUndo();//LTimelineの選択後かつ編集前の保存を想定
			}
		}

	}

	s_mbuttoncnt = (int)(!(s_mbuttoncnt == 1));
	//if (s_mbuttoncnt == 0) {
	//	s_mbuttoncnt = 1;
	//}
	//else {
	//	s_mbuttoncnt = 0;
	//}


	DbgOut(L"OnTimeLineMButtonDown : underselectingframe %d, start %lf, end %lf\r\n", g_underselectingframe, s_buttonselectstart, s_buttonselectend);

	return 0;
}


int OnTimeLineWheel()
{

	DbgOut(L"OnTimeLineWheel Called\r\n");

	if (s_owpLTimeline) {
		if ((g_underselectingframe == 1) || (g_underselectingframe == 2)) {
			int delta = 0;
			double delta2 = 0;

			int adkeyflag = 0;

			//A D key
			if (g_keybuf['A'] & 0x80) {
				adkeyflag = 1;
				if ((s_akeycnt % 5) == 0) {
					if (g_controlkey == false) {
						delta2 = -5;
					}
					else {
						delta2 = -1;
					}
				}
				else {
					delta2 = 0;
				}
			}
			else if (g_keybuf['D'] & 0x80) {
				adkeyflag = 1;
				if ((s_dkeycnt % 5) == 0) {
					if (g_controlkey == false) {
						delta2 = 5;
					}
					else {
						delta2 = 1;
					}
				}
				else {
					delta2 = 0;
				}
			}

			if (adkeyflag == 0) {//timelineのwheeldeltaはホイールを回していない間は更新されずに値が残るため、ホイールだけを扱うこと(キー処理中ではないこと)を明示的に確認する。
								 //マウス操作 MButton and Wheel, A D key
				delta = (int)(s_owpLTimeline->getMouseWheelDelta());
				if (g_controlkey == false) {
					delta2 = (double)delta / 20.0;
				}
				else {
					//delta2 = (double)delta / 100.0;//ctrlを押していたら[slowly]
					if (delta > 0) {
						delta2 = 1;
					}
					else if (delta < 0) {
						delta2 = -1;
					}
					else {
						delta2 = 0;
					}
				}
			}

			//timeline
			if (delta2 != 0.0) {
				if (s_buttonselectstart == s_mbuttonstart) {
					s_buttonselectend += delta2;
				}
				else {
					s_buttonselectstart += delta2;
				}
				if (s_buttonselectstart > s_buttonselectend) {
					double tmp;
					tmp = s_buttonselectstart;
					s_buttonselectstart = s_buttonselectend;
					s_buttonselectend = tmp;
				}

				DbgOut(L"OnTimeLineWheel 0 : start %lf, end %lf, delta %lf\r\n", s_buttonselectstart, s_buttonselectend, delta2);

				OnTimeLineButtonSelectFromSelectStartEnd(0);

				if (s_editmotionflag < 0) {
					int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
					if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
						_ASSERT(0);
						::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
						PostQuitMessage(result);
					}
				}

			}
		}
		else {
			DbgOut(L"OnTimeLineWheel 1 : start %lf, end %lf\r\n", s_buttonselectstart, s_buttonselectend);

			int delta = 0;
			double delta2 = 0;
			delta = (int)(s_owpLTimeline->getMouseWheelDelta());
			if (g_controlkey == false) {
				delta2 = (double)delta / 20.0;
			}
			else {
				//delta2 = (double)delta / 100.0;//ctrlを押していたら[slowly]
				if (delta > 0) {
					delta2 = 1;
				}
				else if (delta < 0) {
					delta2 = -1;
				}
				else {
					delta2 = 0;
				}
			}
			if (delta2 != 0.0) {
				double curframe = s_owpLTimeline->getCurrentTime();
				double newframe = curframe + delta2;
				s_buttonselectstart = newframe;
				s_buttonselectend = newframe;
				//s_editrange.Clear();
				//s_owpLTimeline->selectClear();
				//OnTimeLineCursor(2, newframe);

				OnTimeLineButtonSelectFromSelectStartEnd(0);

				if (s_editmotionflag < 0) {
					int result = CreateMotionBrush(s_buttonselectstart, s_buttonselectend, false);
					if ((result != 0) && (result != 2)) {//result==2はマウス操作でフレームが範囲外に出たときなど通常使用で起きる
						_ASSERT(0);
						::MessageBox(g_mainhwnd, L"致命的なエラーが生じたので終了します。", L"CreateMotionBrush ERROR !!!", MB_OK);
						PostQuitMessage(result);
					}
				}

			}

		}

		//UpdateTopPosText();
	}

	return 0;
}




LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	WORD menuid;
	menuid = LOWORD(wParam);

	LRESULT lret = 0;
	bool closefirstrow = true;

	switch (uMsg)
	{
		//case WM_TIMER:
		//	OnTimerFunc(wParam);
		//	break;

		//case WM_LBUTTONDOWN:
		//case WM_RBUTTONDOWN:
		//	SetCapture(g_mainhwnd);
		//	break;
		//case WM_LBUTTONUP:
		//case WM_RBUTTONUP:
		//	ReleaseCapture();
		//	break;
		//case WM_MOUSEMOVE:
		//	OnMouseMoveFunc();
		//	break;


	case WM_DESTROY:
		//ここでOnDestroyDevice()を呼ぶと　何回もOnDestroyDevice()が呼ばれる
		//WM_QUITでメッセージループを抜けて　ループを出たところでOnDestroyDevice()を呼ぶ
		PostQuitMessage(0);
		return 0;
		//DXUTShutdown(0);//2023/09/23 ここで解放処理を呼んでも　DirectX11の遅延解放のため？VisualStudioのログにデバイスのAlive情報は出る
		break;
	case WM_CREATE:
		break;

	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:
		SetCapture(g_mainhwnd);
		break;
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
		ReleaseCapture();
		break;

	case WM_COMMAND:
	{



		if (menuid == (ID_RMENU_0 + MENUOFFSET_RETARGETDLG)) {
			int opekind = (int)lParam;
			switch (opekind) {
			case RETARGETDLG_OPE_SELECTBVH:
				SetConvBoneBvh();
				break;
			case RETARGETDLG_OPE_SELECTBONE:
				SetConvBone(s_retargetdlg.GetRetargetSelectBoneIndex());
				break;
			//case RETARGETDLG_OPE_RETARGETGUI:
			//	break;
			case RETARGETDLG_OPE_SAVEFILE:
				SaveRetargetFile();
				break;
			case RETARGETDLG_OPE_LOADFILE:
				LoadRetargetFile(0);
				break;
			default:
				break;
			}
		}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_LIGHTSDLG)) {
			SetLightDirection();
		}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_BLENDSHAPEDLG)) {
			int blendshapeindex = (int)lParam;
			CBlendShapeElem curblendshape = s_blendshapedlg.GetBlendShapeElem(blendshapeindex);
			if (curblendshape.validflag && curblendshape.mqoobj &&
				!s_undoFlag && !s_redoFlag &&
				!s_blendshapedlg.GetBlendShapeUnderSelectFromUndo() && 
				!s_blendshapedlg.GetBlendShapeUnderSelectFromRefresh()) {

				s_blendshapedlg.SetBlendShapeOpeIndex(blendshapeindex);
				s_blendshapedlg.SetBlendShapeUnderSelect(true);//2024/06/30
			}
		}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_PROJLODDLG)) {
			SetCamera3DFromEyePos();
		}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_BULLETDLG)) {
			if (s_chascene) {
				s_chascene->ChangeAngleSpringScale();
			}
		}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_DISPLIMITSDLG)) {
			ChangeUpdateMatrixThreads();
		}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_RIGIDPARAMSDLG)) {
			int opekind = (int)lParam;
			if (opekind == RIGIDPARAMSDLG_OPE_CLOSE) {
				s_rigidparamsdlg.SetVisible(false);
				if (s_bpWorld) {
					s_bpWorld->setGlobalERP(btScalar(g_erp));
				}
				if (s_model) {
					CallF(s_model->CreateBtObject(g_limitdegflag, 0), return 1);
				}
			}
			else if (opekind == RIGIDPARAMSDLG_OPE_COLIDLG) {
				if (s_model) {
					CRigidElem* curre = s_model->GetRigidElem(s_curboneno);
					if (curre) {
						CColiIDDlg dlg(curre);
						s_pcolidlg = &dlg;
						s_undercolidlg = true;

						dlg.DoModal();
						if (dlg.m_setgroup == 1) {
							if (s_model) {
								s_model->SetColiIDtoGroup(curre);
							}
						}

						s_undercolidlg = false;
						s_pcolidlg = 0;
					}
				}
			}
			else if (opekind == RIGIDPARAMSDLG_OPE_GCOLIDLG) {
				if (s_model) {
					if (s_bpWorld) {
						//CGColiIDDlg dlg(m_bpWorld->m_coliids, m_bpWorld->m_myselfflag);
						CGColiIDDlg dlg(s_bpWorld->m_coliids);
						s_pgcolidlg = &dlg;
						s_undergcolidlg = true;

						int dlgret = (int)dlg.DoModal();
						if (dlgret == IDOK) {
							s_bpWorld->m_coliids = dlg.m_coliids;
							//s_bpWorld->m_myselfflag = dlg.m_myself;
							s_bpWorld->RemakeG();
						}

						s_undergcolidlg = false;
						s_pgcolidlg = 0;
					}
				}
			}

		}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_CPINFODLG)) {
			s_undercpinfodlg2 = false;

			int dlgresult = (int)lParam;
			if (dlgresult == 0) {
				if (s_model && s_owpTimeline && s_owpLTimeline && s_model->ExistCurrentMotion()) {
					if (s_cpmotinfo.motid > 0) {
						CopyMotionFunc(s_model, &s_cpmotinfo);
					}
				}
			}
		}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_DOLLYHISTORYDLG)) {
			if (s_dollyhistorydlg2.GetCreatedFlag()) {
				s_dollyhistorydlg2.OnSaveDolly();
			}
		}
		else if (menuid == (ID_RMENU_0 + MENUOFFSET_COPYHISTORYDLG)) {
			if (s_copyhistorydlg2.GetCreatedFlag()) {
				s_copyhistorydlg2.OnSearch();
			}
		}
		else if ((menuid >= 59900) && (menuid <= (59900 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 59900;
			OnAnimMenu(true, selindex);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 61000) && (menuid <= (61000 + MAXMODELNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 61000;
			//OnModelMenu(true, selindex, 1);
			bool forceflag = true;
			bool callundo = true;
			OnChangeModel(selindex, forceflag, callundo);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 62000) && (menuid <= (62000 + MAXRENUM))) {
			ActivatePanel(0);
			int selindex = menuid - 62000;
			OnREMenu(selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 63000) && (menuid <= (63000 + MAXRENUM))) {
			ActivatePanel(0);
			int selindex = menuid - 63000;
			OnRgdMenu(selindex, 1);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 64000) && (menuid <= (64000 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 64000;
			OnRgdMorphMenu(selindex);
			ActivatePanel(1);
			//return 0;
		}
		else if ((menuid >= 64500) && (menuid <= (64500 + MAXMOTIONNUM))) {
			ActivatePanel(0);
			int selindex = menuid - 64500;
			OnImpMenu(selindex);
			ActivatePanel(1);
			//return 0;
		}
		else {
			switch (menuid) {
			case ID_40047:
				// "編集・変換"
				// "ボーン軸をXに再計算"
				ActivatePanel(0);
				//RecalcBoneAxisX(0);
				RecalcAxisX_All();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_CAMERADOLLY:
				ActivatePanel(0);
				ShowCameraDollyDlg();
				ActivatePanel(1);
				break;
			case 29800:
				ActivatePanel(0);
				//RegistKey();
				AboutMotionBrush();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_EXPORTBNT:
				ActivatePanel(0);
				ExportBntFile();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_OPEN40001:
				ActivatePanel(0);
				OpenFile();
				ActivatePanel(1);
				//return 0;
				break;
			case ID_FILE_BVH2FBX:
				if (s_registflag == 1) {
					ActivatePanel(0);
					BVH2FBX();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_FILE_BVH2FBXBATCH:
				if (s_registflag == 1) {
					CloseAllAndDispPlaceFolder();//バッチ処理中にOnModelMenu()で頻繁にCreate*DlgするとDlgが閉じられなくなることがあるので対応
					ActivatePanel(0);
					BVH2FBXBatch();
					ActivatePanel(1);
				}
				//return 0;
				break;
				//case ID_FILE_MOTIONCACHE:
				//	if (s_registflag == 1) {
				//		ActivatePanel(0);
				//		MotionCacheBatch();
				//		ActivatePanel(1);
				//	}
				//	//return 0;
				//	break;
			case ID_FILE_RETARGETBATCH:
				if (s_registflag == 1) {
					CloseAllAndDispPlaceFolder();//バッチ処理中にOnModelMenu()で頻繁にCreate*DlgするとDlgが閉じられなくなることがあるので対応
					ActivatePanel(0);
					RetargetBatch();
					ActivatePanel(1);
				}
				//return 0;
				break;

			case ID_SAVE_FBX40039:
				if (s_registflag == 1) {
					ActivatePanel(0);
					ExportFBXFile();
					ActivatePanel(1);
				}
				break;
			case ID_SAVEPROJ_40035:
				if (s_registflag == 1) {
					CloseAllAndDispPlaceFolder();
					ActivatePanel(0);
					SaveProject();
					ActivatePanel(1);
				}
				break;
			case ID_RESAVE_40028:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveREFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_IMPSAVE_40030:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveImpFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_SAVEGCOLI_40033:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveGcoFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_SAVE_MOTIONNAMELIST:
				if (s_registflag == 1) {
					ActivatePanel(0);
					SaveMotionNameListFile();
					ActivatePanel(1);
				}
				//return 0;
				break;
			case ID_DISPMW40002:
				DispMotionWindow();
				//return 0;
				break;
			case 4007:
				DispToolWindow();
				//return 0;
				break;
			case 40012:
			{
				bool savedispflag = s_dispobj;
				s_dispobj = !savedispflag;
				DispObjPanel();
				//return 0;
			}
			break;
			case ID_40048:
				//DispConvBoneWindow();
				s_platemenukind = SPPLATEMENUKIND_RETARGET;
				GUIMenuSetVisible(s_platemenukind, 1);
				//return 0;
				break;
			case ID_40049:
				//GUIMenuSetVisible(-1, -1);
				closefirstrow = true;
				CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる
				ShowLimitEulerWnd(true);
				//return 0;
				break;
			case ID_40050:
				//GUIMenuSetVisible(-1, -1);
				closefirstrow = true;
				CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる
				DispRotAxisDlg();
				//return 0;
				break;
			case ID_DISPMODELPANEL:
			{
				bool savedispflag = s_dispmodel;
				s_dispmodel = !savedispflag;
				DispModelPanel();
				//return 0;
			}
			break;
			case ID_MOTIONPANEL:
			{
				bool savedispflag = s_dispmotion;
				s_dispmotion = !savedispflag;
				DispMotionPanel();
				//return 0;
			}
			break;
			case ID_CAMERAPANEL:
			{
				bool savedispflag = s_dispcamera;
				s_dispcamera = !savedispflag;
				DispCameraPanel();
				//return 0;
			}
			break;
			case ID_SETTINGS:
			{
				s_skyparamsFlag = true;
			}
			break;
			case ID_FOG:
			{
				s_fogparamsFlag = true;
			}
			break;
			case ID_DOF:
			{
				s_dofparamsFlag = true;
			}
			break;

			case ID_DISPGROUND:
				s_dispground = !s_dispground;
				//return 0;
				break;
			case ID_NEWMOT:
				s_newmotFlag = true;
				//AddMotion(0);
				//InitCurMotion(0, 0);
				//return 0;
				break;
			case ID_DELCURMOT:
				if (s_model) {
					s_delcurmotFlag = true;
					//OnDelMotion(s_motmenuindexmap[s_model]);
				}
				//return 0;
				break;
			case ID_DELMODEL:
				s_delmodelFlag = true;
				//OnDelModel(s_curmodelmenuindex);
				//return 0;
				break;
			case ID_DELALLMODEL:
				s_delallmodelFlag = true;
				//OnDelAllModel();
				//return 0;
				break;
			default:
				break;
			}
		}
	}
	break;

	case WM_MOUSEWHEEL:
	{
		if ((g_keybuf['T'] & 0x80) != 0) {
			if (ChkEnableIK() && s_model && (s_curboneno > 0)) {
				s_tkeyflag = 1;

				int delta;
				delta = GET_WHEEL_DELTA_WPARAM(wParam);
				s_ikselectmat = s_selm;
				//s_editmotionflag = s_model->TwistBoneAxisDelta(&s_editrange, s_curboneno, (float)delta, g_iklevel, s_ikcnt, s_ikselectmat);
				s_editmotionflag = s_model->IKRotateAxisDelta(g_limitdegflag,
					&s_editrange, PICK_X, s_curboneno, (float)delta, g_iklevel, s_ikcnt, s_ikselectmat);

				//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
				//UpdateEditedEuler();
			}
		}
	}
	break;

	default:
		//if (uMsg != WM_SETCURSOR) {
		lret = DefWindowProc(hwnd, uMsg, wParam, lParam);
		//}
		break;
	}

	return lret;
}


BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lp) {
	WCHAR strWindowText[1024];
	GetWindowTextW(hwnd, strWindowText, 1024);
	if (wcsstr(strWindowText, L"AdditiveIKC4") != 0) {
		if (lp) {
			*((HWND*)lp) = hwnd;
		}
		return FALSE;
	}
	else {
		return TRUE;
	}
}


HWND CreateMainWindow()
{
	if (g_mainhwnd && IsWindow(g_mainhwnd)) {
		DestroyWindow(g_mainhwnd);
		g_mainhwnd = 0;
	}
	g_mainhwnd = 0;


	//AdditiveIKC4.exeが起動していればそのウインドウを親にする
	HWND parenthwnd = 0;
	if (s_launchbyc4 != 0) {
		EnumWindows(EnumWindowsProc, (LPARAM)&parenthwnd);
	}


	HWND window;
	WNDCLASSEX wcx;
	ZeroMemory(&wcx, sizeof(WNDCLASSEX));
	int returnCode = 0;

	HICON appicon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_ICON1));
	HBRUSH blkbrush = CreateSolidBrush(RGB(0, 0, 0));//自分で削除しない　DestroyWindow時に解放される

	wcx.cbSize = sizeof(WNDCLASSEX);
	wcx.style = CS_HREDRAW | CS_VREDRAW;
	wcx.lpfnWndProc = MainWindowProc;
	wcx.cbClsExtra = 0;
	wcx.cbWndExtra = 0;
	wcx.hInstance = (HINSTANCE)GetModuleHandle(NULL);
	//wcx.hIcon = NULL;
	wcx.hIcon = appicon;
	wcx.hCursor = NULL;
	wcx.hbrBackground = blkbrush;// (HBRUSH)COLOR_BACKGROUND + 1;
	wcx.lpszMenuName = NULL;
	wcx.lpszClassName = WINDOWS_CLASS_NAME;
	wcx.hIconSm = NULL;

	if (!RegisterClassEx(&wcx))
	{
		OutputDebugString(TEXT("Error: ウィンドウクラスの登録ができません。\n"));
		return NULL;
	}

	//HICON appicon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_ICON1));

	s_mainmenu = LoadMenuW((HINSTANCE)GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_MENU1));
	if (s_mainmenu == NULL) {
		_ASSERT(0);
		return NULL;
	}

	//animmenu
	HMENU motmenu;
	motmenu = GetSubMenu(s_mainmenu, 2);
	s_animmenu = GetSubMenu(motmenu, 3);
	_ASSERT(s_animmenu);

	HMENU mdlmenu = GetSubMenu(s_mainmenu, 3);
	s_modelmenu = GetSubMenu(mdlmenu, 3);
	_ASSERT(s_modelmenu);

	//編集メニュー　4

	s_remenu = GetSubMenu(s_mainmenu, 5);
	_ASSERT(s_remenu);

	s_rgdmenu = GetSubMenu(s_mainmenu, 6);
	_ASSERT(s_rgdmenu);

	s_morphmenu = GetSubMenu(s_mainmenu, 7);
	_ASSERT(s_morphmenu);

	s_impmenu = GetSubMenu(s_mainmenu, 8);
	_ASSERT(s_impmenu);




	WCHAR strwindowname[MAX_PATH] = { 0L };
	swprintf_s(strwindowname, MAX_PATH, L"AdditiveIK Ver1.0.0.30 : No.%d : ", s_appcnt);//本体のバージョン

	s_rcmainwnd.top = 0;
	s_rcmainwnd.left = 0;



	window = CreateWindowEx(
		WS_EX_LEFT, WINDOWS_CLASS_NAME, strwindowname,
		WS_OVERLAPPEDWINDOW | WS_VISIBLE,
		//CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
		0, 0, s_totalwndwidth, s_totalwndheight,
		parenthwnd, s_mainmenu, (HINSTANCE)GetModuleHandle(NULL), NULL
	);

	s_rcmainwnd.right = s_totalwndwidth;
	s_rcmainwnd.bottom = s_totalwndheight;

	if (!window)
	{
		OutputDebugString(TEXT("Error: ウィンドウが作成できません。\n"));
		return NULL;
	}




	g_mainhwnd = window;

	if ((s_launchbyc4 != 0) && parenthwnd) {
		SetParent(g_mainhwnd, parenthwnd);
		//::MessageBox(g_mainhwnd, L"setparent", L"check!!!", MB_OK);
	}


	HWND desktopwnd;
	desktopwnd = ::GetDesktopWindow();
	if (desktopwnd) {
		RECT desktoprect;
		::GetClientRect(desktopwnd, &desktoprect);
		//if ((s_appcnt == 0) && (desktoprect.right >= 3840) && (desktoprect.bottom >= 2160)) {
		if (s_appcnt == 0) {
			//if (g_4kresolution) {
			//	SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE);
			//}
			//else {
			//	if (s_launchbyc4 == 0) {
			//		SetWindowPos(g_mainhwnd, HWND_TOP, 1100, 1000, 0, 0, SWP_NOSIZE);
			//	}
			//	else {
			//		SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE);
			//	}
			//}
			if (s_launchbyc4 == 0) {

				//desktopの中心にメインウインドウの中心が来るように移動

				int desktopcenterx, desktopcentery;
				desktopcenterx = (desktoprect.left + desktoprect.right) / 2;
				desktopcentery = (desktoprect.top + desktoprect.bottom) / 2;

				int currentcenterx, currentcentery;
				currentcenterx = s_totalwndwidth / 2;
				currentcentery = s_totalwndheight / 2;

				int diffx, diffy;
				diffx = desktopcenterx - currentcenterx;
				diffy = desktopcentery - currentcentery;

				SetWindowPos(g_mainhwnd, HWND_TOP, diffx, diffy, 0, 0, SWP_NOSIZE);

			}
			else {
				SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE);
			}

		}
		else if (s_appcnt == 1) {
			SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE);
		}
		else if (s_appcnt == 2) {
			SetWindowPos(g_mainhwnd, HWND_TOP, s_totalwndwidth, 0, 0, 0, SWP_NOSIZE);
		}
		else if (s_appcnt == 3) {
			SetWindowPos(g_mainhwnd, HWND_TOP, 0, s_totalwndheight, 0, 0, SWP_NOSIZE);
		}
		else if (s_appcnt == 4) {
			SetWindowPos(g_mainhwnd, HWND_TOP, s_totalwndwidth, s_totalwndheight, 0, 0, SWP_NOSIZE);
		}
	}

	return window;

}

HWND Create3DWnd(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
{
	//HRESULT hr;

	if (s_3dwnd && IsWindow(s_3dwnd)) {
		DestroyWindow(s_3dwnd);
		s_3dwnd = 0;
	}
	s_3dwnd = 0;

	RECT rc;
	ZeroMemory(&rc, sizeof(RECT));
	if (g_4kresolution) {
		rc = InitGame(hInstance, hPrevInstance, lpCmdLine, nShowCmd, TEXT("AdditiveIK"),
			g_mainhwnd,
			s_timelinewidth + s_modelwindowwidth, TOPSLIDERSWNDH,
			s_mainwidth, s_mainheight);
	}
	else {
		rc = InitGame(hInstance, hPrevInstance, lpCmdLine, nShowCmd, TEXT("AdditiveIK"),
			g_mainhwnd,
			s_timelinewidth, TOPSLIDERSWNDH,
			s_mainwidth, s_mainheight);
	}

	//s_mainwidth = rc.right - rc.left;
	//s_mainheight = rc.bottom - rc.top;

	s_3dwnd = g_hWnd;//g_hWndはsystem.cpp, system.hで定義

	//if (g_4kresolution) {
	//	hr = DXUTCreateWindow(L"AdditiveIK", 0, 0, 0, 450 * 2, 0);
	//}
	//else {
	//	hr = DXUTCreateWindow(L"AdditiveIK", 0, 0, 0, 450, 0);
	//}



	//if (g_4kresolution) {
	//	//hr = DXUTCreateWindow(L"AdditiveIK", 0, 0, 0, s_toolwidth + s_modelwindowwidth, 0);
	//	hr = DXUTCreateWindow(L"AdditiveIK", g_mainhwnd, (HINSTANCE)GetModuleHandle(NULL),
	//		0, 0,
	//		(s_timelinewidth + s_modelwindowwidth), TOPSLIDERSWNDH,
	//		s_mainwidth, s_mainheight);
	//}
	//else {
	//	//hr = DXUTCreateWindow(L"AdditiveIK", 0, 0, 0, s_timelinewidth, 0);
	//	hr = DXUTCreateWindow(L"AdditiveIK", g_mainhwnd, (HINSTANCE)GetModuleHandle(NULL),
	//		0, 0, 
	//		s_timelinewidth, TOPSLIDERSWNDH,
	//		s_mainwidth, s_mainheight);
	//}

	//if (FAILED(hr)) {
	//	_ASSERT(0);
	//	return 0;
	//}

	//s_3dwnd = DXUTGetHWND();
	//_ASSERT(s_3dwnd);
	////RECT clientrect;
	////GetClientRect(s_3dwnd, &clientrect);
	////s_bufwidth = clientrect.right;
	////s_bufheight = clientrect.bottom;


	//LONG winstyle = ::GetWindowLong(s_3dwnd, GWL_STYLE);
	//winstyle &= ~WS_CAPTION;
	//winstyle |= WS_CHILD;//2023/02/14
	//::SetWindowLong(s_3dwnd, GWL_STYLE, winstyle);
	//SetParent(s_3dwnd, g_mainhwnd);


	//int cycaption = GetSystemMetrics(SM_CYCAPTION);
	//int cymenu = GetSystemMetrics(SM_CYMENU);
	//int cyborder = GetSystemMetrics(SM_CYBORDER);
	//int bufwidth = s_mainwidth;
	//int bufheight = s_mainheight - cycaption - cymenu - cyborder;


	////hr = DXUTCreateDevice(true);//mac + VM Fusionの場合はこっち
	////hr = DXUTCreateDevice(true, bufwidth, bufheight);
	////hr = DXUTCreateDevice(D3D_FEATURE_LEVEL_11_0, true, s_mainwidth, s_mainheight);
	//hr = DXUTCreateDevice(D3D_FEATURE_LEVEL_11_1, true, s_mainwidth, s_mainheight);
	////hr = DXUTCreateDevice(D3D_FEATURE_LEVEL_11_1, true);
	//if (FAILED(hr)) {
	//	_ASSERT(0);
	//	return 0;
	//}
	
	
	//s_3dwnd = DXUTGetHWND();
	//_ASSERT(s_3dwnd);
	RECT clientrect2;
	GetClientRect(s_3dwnd, &clientrect2);
	//s_bufwidth = clientrect2.right;
	//s_bufheight = clientrect2.bottom;


	////RECT clientrect;
	////GetClientRect(s_3dwnd, &clientrect);
	////s_mainwidth = clientrect.right;
	////s_mainheight = clientrect.bottom;
	////ShowWindow( s_3dwnd, SW_SHOW );
	////SetWindowPos( s_3dwnd, HWND_TOP, 450, 0, s_mainwidth, s_mainheight, SWP_NOSIZE ); 

	RECT winrect;
	::GetWindowRect(s_3dwnd, &winrect);
	//::MoveWindow(s_3dwnd, 400, 0, winrect.right - winrect.left, winrect.bottom - winrect.top, TRUE);
	//::MoveWindow(s_3dwnd, 400, 0, s_mainwidth, s_mainheight, TRUE);
	if (g_4kresolution) {
		::MoveWindow(s_3dwnd, s_timelinewidth + s_modelwindowwidth, TOPSLIDERSWNDH, s_mainwidth, s_mainheight, TRUE);
		//::SetWindowPos(s_3dwnd, HWND_NOTOPMOST, 
		//	s_toolwidth + s_modelwindowwidth, TOPSLIDERSWNDH, s_mainwidth, s_mainheight, SWP_NOSIZE);
	}
	else {
		::MoveWindow(s_3dwnd, s_timelinewidth, TOPSLIDERSWNDH, s_mainwidth, s_mainheight, TRUE);
		//::SetWindowPos(s_3dwnd, HWND_NOTOPMOST, 
		//	s_timelinewidth, TOPSLIDERSWNDH, s_mainwidth, s_mainheight, SWP_NOSIZE);
	}

	s_rc3dwnd.top = TOPSLIDERSWNDH;
	s_rc3dwnd.bottom = (s_mainheight + TOPSLIDERSWNDH);
	//s_rc3dwnd.left = 0;
	//s_rc3dwnd.right = s_mainwidth;
	s_rc3dwnd.left = s_timelinewidth + s_modelwindowwidth;
	s_rc3dwnd.right = s_rc3dwnd.left + s_mainwidth;


	////#############################################################################
	////次のコメントアウトブロックはDXUTのウインドウにメニューを付けるときに使用する。
	////#############################################################################
	////最大化してから元に戻すことにより
	////バックバッファの大きさ問題（メニューやキャプションがあるときのずれ）が解消される。
	////::ShowWindow(s_3dwnd, SW_MAXIMIZE);
	////::ShowWindow(s_3dwnd, SW_SHOWNORMAL);


	return s_3dwnd;
}

CInfoWindow* CreateInfoWnd()
{
	if (g_infownd) {
		delete g_infownd;
		g_infownd = 0;
	}

	int cxframe = GetSystemMetrics(SM_CXFRAME);
	int cyframe = GetSystemMetrics(SM_CYFRAME);

	//s_rcinfownd.top = s_mainheight + 3 * cyframe + TOPSLIDERSWNDH;
	//s_rcinfownd.bottom = (s_infowinheight + 2 * cyframe);
	//s_rcinfownd.right = s_infowinwidth;
	//s_rcinfownd.left = 400;
	s_rcinfownd.top = s_mainheight + TOPSLIDERSWNDH;
	s_rcinfownd.bottom = s_rcinfownd.top + s_infowinheight + 2 * cyframe;
	s_rcinfownd.right = s_infowinwidth;
	s_rcinfownd.left = 400;



	CInfoWindow* newinfownd = new CInfoWindow();
	if (newinfownd) {

		int ret;
		//if (g_4kresolution) {
		//	ret = newinfownd->CreateInfoWindow(g_mainhwnd,
		//		400 * 2, s_mainheight + 3 * cyframe + TOPSLIDERSWNDH,
		//		s_infowinwidth, s_infowinheight + 2 * cyframe);

		//	s_rcinfownd.left = 400 * 2;
		//}
		//else {
		//	ret = newinfownd->CreateInfoWindow(g_mainhwnd,
		//		400, s_mainheight + 3 * cyframe + TOPSLIDERSWNDH,
		//		s_infowinwidth, s_infowinheight + 2 * cyframe);

		//	s_rcinfownd.left = 400;
		//}

		if (g_4kresolution) {
			ret = newinfownd->CreateInfoWindow(g_mainhwnd,
				//s_timelinewidth + s_modelwindowwidth, s_mainheight + 3 * cyframe + TOPSLIDERSWNDH,
				s_timelinewidth + s_modelwindowwidth, s_mainheight + TOPSLIDERSWNDH,
				s_infowinwidth, s_infowinheight + 2 * cyframe);

			s_rcinfownd.left = s_timelinewidth;
		}
		else {
			ret = newinfownd->CreateInfoWindow(g_mainhwnd,
				//s_timelinewidth, s_mainheight + 3 * cyframe + TOPSLIDERSWNDH,
				s_timelinewidth, s_mainheight + TOPSLIDERSWNDH,
				s_infowinwidth, s_infowinheight + 2 * cyframe);

			s_rcinfownd.left = s_timelinewidth;
		}


		if (ret == 0) {
			g_infownd = newinfownd;

			//OutputToInfoWnd(INFOCOLOR_INFO, L"InfoWindow initialized 1");
			OutputToInfoWnd(INFOCOLOR_INFO, L"Upper to lower, older to newer. Limit to 6,000 lines.");
			OutputToInfoWnd(INFOCOLOR_INFO, L"Scroll is enable by mouse wheel.");
			OutputToInfoWnd(INFOCOLOR_INFO, L"If the most newest line is shown at lowest position, AutoScroll works.Save to info_(date).txt on exit.");
			OutputToInfoWnd(INFOCOLOR_INFO, L"上：古,下：新。6,000行。ホイールでスクロール。一番新しいものを表示している時AutoScroll。終了時にinfo_日時.txtにセーブ。");
		}

	}



	return newinfownd;
}


int RecalcBoneAxisX(CBone* srcbone)
{
	if (s_model && (s_model->GetOldAxisFlagAtLoading() == 1)) {
		::DSMessageBox(s_3dwnd, L"Retry After Saving And Loading.", L"error!!!", MB_OK);
		return 0;
	}

	s_model->RecalcBoneAxisX(srcbone);

	return 0;
}

void RecalcAxisX_All()
{
	if (s_model) {
		if (s_model && (s_model->GetOldAxisFlagAtLoading() == 1)) {
			::DSMessageBox(s_3dwnd, L"Retry After Saving And Loding.", L"error!!!", MB_OK);
			return;
		}

		if (s_owpLTimeline) {
			s_owpLTimeline->setCurrentTime(0.0, true);
		}
		if (s_owpEulerGraph) {
			s_owpEulerGraph->setCurrentTime(0.0, false);
		}
		s_model->SetMotionFrame(0.0);
		ChaMatrix tmpwm = s_model->GetWorldMat();
		s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);

		//ここでAxisMatXの初期化
		s_model->CreateBtObject(g_limitdegflag, 1);
		s_model->CalcBtAxismat(2);//2
		s_model->SetInitAxisMatX(1);
	}
}


int OnMouseMoveFunc()
{
	//OutputToInfoWnd(INFOCOLOR_INFO, L"AdditiveIK.cpp : MouseMoveFunc 0");

	static bool s_doingflag = false;
	if (s_doingflag == true) {
		return 0;
	}
	s_doingflag = true;

	//OutputToInfoWnd(INFOCOLOR_INFO, L"AdditiveIK.cpp : MouseMoveFunc 1");

	if (g_graphicsEngine) {
		s_pickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
		s_pickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
		s_pickinfo.pickrange = PICKRANGE;
	}


	//2024/01/19
	if (g_fpsforce30) {
		double difftime = s_fTime - s_mousemoveBefTime;//s_fElapsedTimeは表示に関する時間なのでここでは使わない
		if (difftime < (1.0 / 33.0)) {
			s_doingflag = false;
			return 0;//!!!!!!!!!!!!!! 強制30fpsフラグが経っている場合には 30fps以上の計算(IK計算)はしない
		}
		s_mousemoveBefTime = s_fTime;
	}



	if (s_rbuttonSelectFlag) {
		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		float deltax = (float)((s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y)) * 0.5f;
		if (deltax > 0.0f) {
			if (g_controlkey == true) {
				s_selectuserscale += 1;
			}
			else {
				s_selectuserscale += 5;
			}
			s_selectuserscale = min(300, s_selectuserscale);
			s_selectuserscale = max(30, s_selectuserscale);
		}
		else if (deltax < 0.0f) {
			if (g_controlkey == true) {
				s_selectuserscale -= 1;
			}
			else {
				s_selectuserscale -= 5;
			}
			s_selectuserscale = min(300, s_selectuserscale);
			s_selectuserscale = max(30, s_selectuserscale);
		}
		else {

		}
	}
	else if ((s_pickinfo.pickobjno >= 0) && (s_pickinfo.buttonflag == PICK_CENTER)) {
		if (s_model) {
			if (g_previewFlag == 0) {

				s_pickinfo.mousebefpos = s_pickinfo.mousepos;
				POINT ptCursor;
				GetCursorPos(&ptCursor);
				::ScreenToClient(s_3dwnd, &ptCursor);
				s_pickinfo.mousepos = ptCursor;

				ChaVector3 tmpsc;
				s_model->TransformBone(s_pickinfo.winx, s_pickinfo.winy, s_curboneno, &s_pickinfo.objworld, &tmpsc, &s_pickinfo.objscreen);

				if (g_edittarget == EDITTARGET_MORPH) {
					//::MessageBox(s_3dwnd, L"EdittingMorph mode now. \nClick red frog and change graph mode!", 
					//	L"Current mode is not for editing BoneMotion.", MB_OK);
					OutputToInfoWnd(INFOCOLOR_WARNING, L"### EdittingMorph mode now. ###");
					OutputToInfoWnd(INFOCOLOR_WARNING, L"### Click red frog and change graph mode! ###");
				}
				else if (g_edittarget == EDITTARGET_BONE) {
					if (s_model && ChkEnableIK()) {
						if (s_oprigflag == 0) {
							ChaVector3 targetpos(0.0f, 0.0f, 0.0f);
							//CallF(CalcTargetPos(&targetpos), return 1);
							CalcTargetPos(&targetpos);
							if (s_ikkind == 0) {
								s_editmotionflag = s_model->IKRotateUnderIK(g_limitdegflag,
									&s_editrange, s_pickinfo.pickobjno, targetpos, g_iklevel);

								//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
								//UpdateEditedEuler();
							}
							else if (s_ikkind == 1) {
								//ChaVector3 diffvec = targetpos - s_pickinfo.objworld;

								ChaVector3 modelobjworld;
								ChaMatrix invmodelwm = ChaMatrixInv(s_model->GetWorldMat());
								ChaVector3TransformCoord(&modelobjworld, &s_pickinfo.objworld, &invmodelwm);
								ChaVector3 diffvec = targetpos - modelobjworld;
								AddBoneTra2(diffvec);
								s_editmotionflag = s_curboneno;
							}
							else if (s_ikkind == 2) {
								//ChaVector3 diffvec = targetpos - s_pickinfo.objworld;

								ChaVector3 modelobjworld;
								ChaMatrix invmodelwm = ChaMatrixInv(s_model->GetWorldMat());
								ChaVector3TransformCoord(&modelobjworld, &s_pickinfo.objworld, &invmodelwm);
								ChaVector3 diffvec = targetpos - modelobjworld;
								AddBoneScale2(diffvec);
								s_editmotionflag = s_curboneno;
							}

						}
						else {
							if (s_customrigbone) {
								float deltau = (float)(s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) * 0.5f;
								float deltav = (float)(s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y) * 0.5f;
								if (g_controlkey == true) {
									deltau *= 0.250f;
									deltav *= 0.250f;
								}

								s_ikcustomrig = s_customrigbone->GetCustomRig(s_customrigno);
								s_model->RigControlUnderRig(g_limitdegflag,
									0, &s_editrange, s_pickinfo.pickobjno,
									0, deltau,
									s_ikcustomrig, s_pickinfo.buttonflag);
								ChaMatrix tmpwm = s_model->GetWorldMat();
								s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
								s_model->RigControlUnderRig(g_limitdegflag,
									0, &s_editrange, s_pickinfo.pickobjno,
									1, deltav,
									s_ikcustomrig, s_pickinfo.buttonflag);
								s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
								s_editmotionflag = s_curboneno;
								//s_editmotionflag = 0;//これを０にすると　oprigflag == 1の状態でアンドゥした時に　アンドゥ用の保存が走って　保存が増えて状態が戻らない
							}
						}
						s_ikcnt++;
					}
				}
			}
			else if (g_previewFlag == 5) {
				if (s_model) {
					//if (s_onragdollik == 0){
					//	StartBt(1, 1);
					//}
					s_onragdollik = 1;
				}
			}
		}
	}
	else if ((s_pickinfo.pickobjno >= 0) && 
		((s_pickinfo.buttonflag == PICK_X) || (s_pickinfo.buttonflag == PICK_Y) || (s_pickinfo.buttonflag == PICK_Z))
		) {
		if (s_model) {
			if (g_previewFlag == 0) {
				s_pickinfo.mousebefpos = s_pickinfo.mousepos;
				POINT ptCursor;
				GetCursorPos(&ptCursor);
				::ScreenToClient(s_3dwnd, &ptCursor);
				s_pickinfo.mousepos = ptCursor;

				ChaVector3 tmpsc;
				s_model->TransformBone(s_pickinfo.winx, s_pickinfo.winy, s_curboneno, &s_pickinfo.objworld, &tmpsc, &s_pickinfo.objscreen);

				if (g_previewFlag == 0) {
					float deltax = (float)((s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y)) * 0.5f;
					if (g_controlkey == true) {
						deltax *= 0.250f;
					}

					if (g_edittarget == EDITTARGET_MORPH) {
						//::MessageBox(s_3dwnd, L"EdittingMorph mode now. \nClick red frog and change graph mode!",
						//	L"Current mode is not for editing BoneMotion.", MB_OK);
						OutputToInfoWnd(INFOCOLOR_WARNING, L"### EdittingMorph mode now. ###");
						OutputToInfoWnd(INFOCOLOR_WARNING, L"### Click red frog and change graph mode! ###");
					}
					else if (g_edittarget == EDITTARGET_BONE) {
						if (ChkEnableIK()) {
							if (s_ikkind == 0) {
								s_editmotionflag = s_model->IKRotateAxisDeltaUnderIK(
									g_limitdegflag,
									&s_editrange, s_pickinfo.buttonflag, s_pickinfo.pickobjno,
									deltax, g_iklevel, s_ikcnt, s_ikselectmat);

								//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
								//UpdateEditedEuler();
							}
							else if (s_ikkind == 1) {
								AddBoneTra(s_pickinfo.buttonflag - PICK_X, deltax * 0.1f);
								s_editmotionflag = s_curboneno;
							}
							else if (s_ikkind == 2) {
								if (g_shiftkey == false) {
									AddBoneScale(s_pickinfo.buttonflag - PICK_X, deltax);
									s_editmotionflag = s_curboneno;
								}
								else {
									//2024/01/30 
									//shiftキーを押しながらX,Y,ZどれかのスプライトドラッグでPICK_CENTER
									AddBoneScale(-1, deltax);
									s_editmotionflag = s_curboneno;
								}
							}
						}
					}
					else if (g_edittarget == EDITTARGET_CAMERA) {
						switch (s_ikkind) {
						case 0:
							s_cameraeditkind = CAMERAANIMEDIT_ROT;
							break;
						case 1:
							s_cameraeditkind = CAMERAANIMEDIT_MV;
							break;
						case 2:
							s_cameraeditkind = CAMERAANIMEDIT_DIST;
							break;
						default:
							_ASSERT(0);
							s_cameraeditkind = CAMERAANIMEDIT_ROT;
							break;
						}
						OnCameraAnimMouseMove(s_cameraeditkind, s_pickinfo.buttonflag, deltax);
					}
					s_befdeltax = deltax;

					s_ikcnt++;
				}
			}
			else if (g_previewFlag == 5) {
				if (s_model) {
					s_onragdollik = 2;
				}
			}
		}
	}
	else if ((s_pickinfo.pickobjno >= 0) && 
		((s_pickinfo.buttonflag == PICK_SPA_X) || (s_pickinfo.buttonflag == PICK_SPA_Y) || (s_pickinfo.buttonflag == PICK_SPA_Z))
		) {

		//OutputToInfoWnd(INFOCOLOR_INFO, L"AdditiveIK.cpp : MouseMoveFunc 2");

		if (s_model) {
			if (g_previewFlag == 0) {

				//s_pickinfo.buttonflag = s_pickinfo.buttonflag - PICK_SPA_X + PICK_X;
				int buttonflagForIkFunc = s_pickinfo.buttonflag - PICK_SPA_X + PICK_X;


				s_pickinfo.mousebefpos = s_pickinfo.mousepos;
				POINT ptCursor;
				GetCursorPos(&ptCursor);
				::ScreenToClient(s_3dwnd, &ptCursor);
				s_pickinfo.mousepos = ptCursor;

				ChaVector3 tmpsc;
				s_model->TransformBone(s_pickinfo.winx, s_pickinfo.winy, s_curboneno, &s_pickinfo.objworld, &tmpsc, &s_pickinfo.objscreen);

				//OutputToInfoWnd(INFOCOLOR_INFO, L"AdditiveIK.cpp : MouseMoveFunc 3");


				if (g_previewFlag == 0) {
					float deltax = (float)((s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y)) * 0.5f;
					if (g_controlkey == true) {
						deltax *= 0.250f;
					}

					//OutputToInfoWnd(INFOCOLOR_INFO, L"AdditiveIK.cpp : MouseMoveFunc 4");

					if (g_edittarget == EDITTARGET_MORPH) {
						//::MessageBox(s_3dwnd, L"EdittingMorph mode now. \nClick red frog and change graph mode!",
						//	L"Current mode is not for editing BoneMotion.", MB_OK);
						OutputToInfoWnd(INFOCOLOR_WARNING, L"### EdittingMorph mode now. ###");
						OutputToInfoWnd(INFOCOLOR_WARNING, L"### Click red frog and change graph mode! ###");
					}
					else if (g_edittarget == EDITTARGET_BONE) {
						if (ChkEnableIK()) {
							if (s_ikkind == 0) {
								s_editmotionflag = s_model->IKRotateAxisDeltaUnderIK(
									g_limitdegflag,
									&s_editrange, buttonflagForIkFunc, s_pickinfo.pickobjno,
									deltax, g_iklevel, s_ikcnt, s_ikselectmat);

								//ClearLimitedWM(s_model);//これが無いとIK時にグラフにおかしな値が入り　おかしな値がある時間に合わせると直る
								//UpdateEditedEuler();
							}
							else if (s_ikkind == 1) {
								AddBoneTra(buttonflagForIkFunc - PICK_X, deltax * 0.1f);
								s_editmotionflag = s_curboneno;
							}
							else if (s_ikkind == 2) {
								if (g_shiftkey) {
									AddBoneScale(buttonflagForIkFunc - PICK_X, deltax);
									s_editmotionflag = s_curboneno;
								}
								else {
									//2024/01/30 
									//shiftキーを押しながらX,Y,ZどれかのスプライトドラッグでPICK_CENTER
									AddBoneScale(-1, deltax);
									s_editmotionflag = s_curboneno;
								}

							}
						}
					}
					else if (g_edittarget == EDITTARGET_CAMERA) {
						switch (s_ikkind) {
						case 0:
							s_cameraeditkind = CAMERAANIMEDIT_ROT;
							break;
						case 1:
							s_cameraeditkind = CAMERAANIMEDIT_MV;
							break;
						case 2:
							s_cameraeditkind = CAMERAANIMEDIT_DIST;
							break;
						default:
							_ASSERT(0);
							s_cameraeditkind = CAMERAANIMEDIT_ROT;
							break;
						}
						OnCameraAnimMouseMove(s_cameraeditkind, buttonflagForIkFunc, deltax);
					}

					s_befdeltax = deltax;
					s_ikcnt++;
				}
			}
			else if (g_previewFlag == 5) {
				if (s_model) {
					s_onragdollik = 3;
				}
			}
		}
	}
	else if (s_pickinfo.buttonflag == PICK_CAMMOVE) {

		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		ChaVector3 cammv;
		cammv.x = ((float)s_pickinfo.mousepos.x - (float)s_pickinfo.mousebefpos.x) / (float)s_pickinfo.winx * -s_cammvstep;
		cammv.y = ((float)s_pickinfo.mousepos.y - (float)s_pickinfo.mousebefpos.y) / (float)s_pickinfo.winy * s_cammvstep;
		cammv.z = 0.0f;
		if (g_controlkey == true) {
			cammv *= 0.250f;
		}
		cammv *= g_physicsmvrate;//2024/01/30 DispAndLimitsPlateMenu : EditRateSlider

		if (g_edittarget != EDITTARGET_CAMERA) {
			if (s_spcameramode.state) {
				OutputToInfoWnd(INFOCOLOR_WARNING, L"### PlayingCameraAnim mode now. ###");
				OutputToInfoWnd(INFOCOLOR_WARNING, L"### Click red frog and change to CameraEditMode or Off CameraAnimSwitch! ###");
			}
			else {
				ChaMatrix invmatView;
				invmatView = ChaMatrixInv(s_matView);
				ChaVector3 camdirx, camdiry;
				camdirx.SetParams(invmatView.data[MATI_11], invmatView.data[MATI_12], invmatView.data[MATI_13]);
				camdiry.SetParams(invmatView.data[MATI_21], invmatView.data[MATI_22], invmatView.data[MATI_23]);
				ChaVector3Normalize(&camdirx, &camdirx);
				ChaVector3Normalize(&camdiry, &camdiry);
				ChaVector3 movevec = camdirx * cammv.x + camdiry * cammv.y;

				g_befcamEye = g_camEye;
				g_befcamtargetpos = g_camtargetpos;

				g_camEye = g_camEye + movevec;
				g_camtargetpos = g_camtargetpos + movevec;

				ChaVector3 diffv;
				diffv = g_camtargetpos - g_camEye;
				g_camdist = (float)ChaVector3LengthDbl(&diffv);
			}
		}
		else {
			OnCameraAnimMouseMove(CAMERAANIMEDIT_MV, PICK_X, cammv.x);
			OnCameraAnimMouseMove(CAMERAANIMEDIT_MV, PICK_Y, cammv.y);
		}

		SetCamera3DFromEyePos();

	}
	else if (s_twistcameraFlag) {
		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		float deltax;
		deltax = -((float)s_pickinfo.mousepos.x - (float)s_pickinfo.mousebefpos.x) / (float)s_pickinfo.winx * 250.0f * (float)DEG2PAI;
		if (g_controlkey == true) {
			deltax *= 0.250f;
		}

		if (g_edittarget != EDITTARGET_CAMERA) {
			if (s_spcameramode.state) {
				OutputToInfoWnd(INFOCOLOR_WARNING, L"### PlayingCameraAnim mode now. ###");
				OutputToInfoWnd(INFOCOLOR_WARNING, L"### Click red frog and change to CameraEditMode or Off CameraAnimSwitch! ###");
			}
			else {
				ChaVector3 twistaxis;
				CQuaternion twistq;
				twistaxis = g_camtargetpos - g_camEye;
				ChaVector3Normalize(&twistaxis, &twistaxis);
				twistq.SetAxisAndRot(twistaxis, deltax);
				ChaVector3 newupvec;
				twistq.Rotate(&newupvec, g_cameraupdir);
				ChaVector3Normalize(&newupvec, &newupvec);
				g_cameraupdir = newupvec;

				g_befcamEye = g_camEye;
				ChaVector3 diffv;
				diffv = g_camEye - g_camtargetpos;
				g_camdist = (float)ChaVector3LengthDbl(&diffv);

				SetCamera3DFromEyePos();
			}
		}
		else {
			//##################################
			//g_edittarget == EDITTARGET_CAMERA
			//##################################
			OnCameraAnimMouseMove(CAMERAANIMEDIT_TWIST, PICK_Z, deltax);
		}
	}
	else if (s_pickinfo.buttonflag == PICK_CAMROT) {

		//not use quaternion yet in this part, so ジンバルロック未回避.

		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		float roty, rotxz;
		rotxz = -((float)s_pickinfo.mousepos.x - (float)s_pickinfo.mousebefpos.x) / (float)s_pickinfo.winx * 250.0f;
		roty = ((float)s_pickinfo.mousepos.y - (float)s_pickinfo.mousebefpos.y) / (float)s_pickinfo.winy * 250.0f;
		if (g_controlkey == true) {
			rotxz *= 0.250f;
			roty *= 0.250f;
		}

		if (g_edittarget != EDITTARGET_CAMERA) {
			if (s_spcameramode.state) {
				OutputToInfoWnd(INFOCOLOR_WARNING, L"### PlayingCameraAnim mode now. ###");
				OutputToInfoWnd(INFOCOLOR_WARNING, L"### Click red frog and change to CameraEditMode or Off CameraAnimSwitch! ###");
			}
			else {
				ChaMatrix matview;
				ChaVector3 weye, wat;
				weye = g_camEye;
				wat = g_camtargetpos;

				ChaVector3 viewvec, upvec, rotaxisy, rotaxisxz;
				viewvec = wat - weye;
				ChaVector3Normalize(&viewvec, &viewvec);
				upvec.SetParams(0.000001f, 1.0f, 0.0f);

				float chkdot;
				chkdot = ChaVector3Dot(&viewvec, &upvec);
				if (fabs(chkdot) < 0.99965f) {
					ChaVector3Cross(&rotaxisxz, (const ChaVector3*)&upvec, (const ChaVector3*)&viewvec);
					ChaVector3Normalize(&rotaxisxz, &rotaxisxz);

					ChaVector3Cross(&rotaxisy, (const ChaVector3*)&viewvec, (const ChaVector3*)&rotaxisxz);
					ChaVector3Normalize(&rotaxisy, &rotaxisy);

					if (s_model && (s_curboneno >= 0) && s_camtargetflag) {
						CBone* curbone = s_model->GetBoneByID(s_curboneno);
						_ASSERT(curbone);
						if (curbone) {
							g_befcamtargetpos = g_camtargetpos;
							g_camtargetpos = curbone->GetChildWorld();
						}
						else {
							s_curboneno = -1;
						}
					}

					ChaMatrix befrotmat, rotmaty, rotmatxz, aftrotmat;
					befrotmat.SetIdentity();//2023/02/12
					aftrotmat.SetIdentity();//2023/02/12
					rotmaty.SetIdentity();//2023/02/12
					rotmatxz.SetIdentity();//2023/02/12
					ChaMatrixTranslation(&befrotmat, -g_camtargetpos.x, -g_camtargetpos.y, -g_camtargetpos.z);
					ChaMatrixTranslation(&aftrotmat, g_camtargetpos.x, g_camtargetpos.y, g_camtargetpos.z);
					ChaMatrixRotationAxis(&rotmaty, &rotaxisy, rotxz * (float)DEG2PAI);
					ChaMatrixRotationAxis(&rotmatxz, &rotaxisxz, roty * (float)DEG2PAI);

					ChaMatrix mat;
					mat = befrotmat * rotmatxz * rotmaty * aftrotmat;
					ChaVector3 neweye;
					ChaVector3TransformCoord(&neweye, &weye, &mat);

					g_befcamEye = g_camEye;
					g_camEye = neweye;
					//!!!!!ChaMatrixLookAtRH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);
					//ChaMatrixLookAtLH(&s_matView, &g_camEye, &g_camtargetpos, &s_camUpVec);

					ChaVector3 diffv;
					diffv = neweye - g_camtargetpos;
					g_camdist = (float)ChaVector3LengthDbl(&diffv);

				}
				else {
					g_camEye = g_befcamEye;
					g_camtargetpos = g_befcamtargetpos;
				}

				SetCamera3DFromEyePos();
			}
		}
		else {
			if (s_model && (s_curboneno >= 0) && s_camtargetflag) {
				CBone* curbone = s_model->GetBoneByID(s_curboneno);
				_ASSERT(curbone);
				if (curbone) {
					g_befcamtargetpos = g_camtargetpos;
					g_camtargetpos = curbone->GetChildWorld();
				}
				else {
					s_curboneno = -1;
				}
			}
			OnCameraAnimMouseMove(CAMERAANIMEDIT_ROT, PICK_Y, rotxz);
			OnCameraAnimMouseMove(CAMERAANIMEDIT_ROT, PICK_X, -roty);
		}
	}
	else if (s_pickinfo.buttonflag == PICK_CAMDIST) {
		s_pickinfo.mousebefpos = s_pickinfo.mousepos;
		POINT ptCursor;
		GetCursorPos(&ptCursor);
		::ScreenToClient(s_3dwnd, &ptCursor);
		s_pickinfo.mousepos = ptCursor;

		float deltadist = (float)((s_pickinfo.mousepos.x - s_pickinfo.mousebefpos.x) + (s_pickinfo.mousepos.y - s_pickinfo.mousebefpos.y)) * 0.5f;
		//float mdelta = (float)GET_WHEEL_DELTA_WPARAM(wParam);
		//float deltadist = mdelta * g_camdist * 0.0010f;
		if (g_controlkey == true) {
			deltadist *= 0.250f;
		}
		deltadist *= g_physicsmvrate;//2024/01/30 DispAndLimitsPlateMenu : EditRateSlider

		if (g_edittarget != EDITTARGET_CAMERA) {
			if (s_spcameramode.state) {
				OutputToInfoWnd(INFOCOLOR_WARNING, L"### PlayingCameraAnim mode now. ###");
				OutputToInfoWnd(INFOCOLOR_WARNING, L"### Click red frog and change to CameraEditMode or Off CameraAnimSwitch! ###");
			}
			else {
				float newcamdist = g_camdist + deltadist;
				ChangeCameraDist(newcamdist, true, false);
			}
		}
		else {
			//int ikkind_translation = 1;
			//OnCameraAnimMouseMove(ikkind_translation, PICK_Z, deltadist);
			
			//2024/07/30
			//camaradist操作は　カメラが回転していく場合には　回転に応じてカメラ位置を動かす必要がある
			//よってZ方向の移動ではうまくいかないことが多かった
			//CameraDist操作専用の関数を呼び出す
			OnCameraAnimMouseMove(CAMERAANIMEDIT_DIST, PICK_Z, deltadist);//2024/07/30
		}

	}

	s_doingflag = false;

	return 0;
}

void GUIRetargetSetVisible(int srcplateno)
{
	if (srcplateno == 1) {
		ShowRetargetWnd(true);
		ShowLimitEulerWnd(false);
		ShowThresholdWnd(false);
	}
	else if (srcplateno == 2) {
		ShowRetargetWnd(false);
		ShowLimitEulerWnd(true);
		ShowThresholdWnd(false);
	}
	else if (srcplateno == 3) {
		ShowRetargetWnd(false);
		ShowLimitEulerWnd(false);
		ShowThresholdWnd(true);
	}
	else if (srcplateno == -2) {
		ShowRetargetWnd(false);
		ShowLimitEulerWnd(false);
		ShowThresholdWnd(false);
	}
	else {
		_ASSERT(0);
	}
}

void GUIEffectSetVisible(int srcplateno)
{
	if (srcplateno == 1) {
		ShowSkyWnd(true);
		ShowFogWnd(false);
		ShowDofWnd(false);
	}
	else if (srcplateno == 2) {
		ShowSkyWnd(false);
		ShowFogWnd(true);
		ShowDofWnd(false);
	}
	else if (srcplateno == 3) {
		ShowSkyWnd(false);
		ShowFogWnd(false);
		ShowDofWnd(true);
	}
	else if (srcplateno == -2) {
		ShowSkyWnd(false);
		ShowFogWnd(false);
		ShowDofWnd(false);
	}
	else {
		_ASSERT(0);
	}
}


void GUIDispSetVisible(int srcplateno)
{
	if (srcplateno == 1) {
		ShowLightsWnd(true);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(false);
	}
	else if (srcplateno == 2) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(true);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(false);
	}
	else if (srcplateno == 3) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(true);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(false);
	}
	else if (srcplateno == 4) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(true);
		ShowShadowParamsWnd(false);
	}
	else if (srcplateno == 5) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(true);
	}
	else if (srcplateno == -2) {
		ShowLightsWnd(false);
		ShowDispGroupWnd(false);
		ShowLaterTransparentWnd(false);
		ShowShaderTypeWnd(false);
		ShowShadowParamsWnd(false);
	}
	else {
		_ASSERT(0);
	}
}



void GUIRigidSetVisible(int srcplateno)
{
	if (srcplateno == 1) {
		ShowRigidWnd(true);
		ShowImpulseWnd(false);
		ShowGroundWnd(false);
		ShowDampAnimWnd(false);
	}
	else if (srcplateno == 2) {
		ShowRigidWnd(false);
		ShowImpulseWnd(true);
		ShowGroundWnd(false);
		ShowDampAnimWnd(false);
	}
	else if (srcplateno == 3) {
		ShowRigidWnd(false);
		ShowImpulseWnd(false);
		ShowGroundWnd(true);
		ShowDampAnimWnd(false);
	}
	else if (srcplateno == 4) {
		ShowRigidWnd(false);
		ShowImpulseWnd(false);
		ShowGroundWnd(false);
		ShowDampAnimWnd(true);
	}
	else if (srcplateno == -2) {
		ShowRigidWnd(false);
		ShowImpulseWnd(false);
		ShowGroundWnd(false);
		ShowDampAnimWnd(false);
	}
	else {
		_ASSERT(0);
	}
}



void GUISetVisible(int srcplateno)
{
	if (srcplateno == 1) {
		//srcplateno == 1 --> PlaceFolderWnd visible
	}
	else if (srcplateno == 2) {
		GUISetVisible_CameraAndIK();
	}
	else if (srcplateno == 3) {
		GUISetVisible_DispAndLimits();
	}
	//else if (srcplateno == 4) {
	//	GUISetVisible_BrushParams();
	//}
	else if (srcplateno == 4) {
		GUISetVisible_Bullet();
	}
	else if (srcplateno == 5) {
		GUISetVisible_LOD();
	}
	else if (srcplateno == 6) {
		GUISetVisible_BlendShape();
	}
	else {
		_ASSERT(0);
	}
}

void GUISetVisible_Sel3D()
{
	if (s_currentwndid == 1) {
		s_spsel3d.state = true;
	}
	else {
		s_spsel3d.state = false;
	}
}


// g_currentsubmenuid
void GUISetVisible_MenuAimBar()
{
	////static int s_curaimbarno
	//if ((g_currentsubmenuid >= 0) && (g_currentsubmenuid < SPMENU_MAX)) {
	//	int aimno;
	//	for (aimno = 0; aimno < SPMENU_MAX; aimno++) {
	//		s_spmenuaimbar[aimno].state = false;
	//	}

	//	s_spmenuaimbar[g_currentsubmenuid].state = true;

	//}
}

void GUISetVisible_AimBar()
{
	////static int s_curaimbarno
	//if ((s_curaimbarno >= 0) && (s_curaimbarno < SPAIMBARNUM)) {
	//	int aimno;
	//	for (aimno = 0; aimno < SPAIMBARNUM; aimno++) {
	//		s_spaimbar[aimno].state = false;
	//	}

	//	s_spaimbar[s_curaimbarno].state = true;

	//}
}

void GUISetVisible_CameraAndIK()
{

	//１段目のCameraAndIKだけは　SPGUISWの他のボタンと連動しないで　オンオフ

	bool newstate = !s_spguisw[SPGUISW_CAMERA_AND_IK].state;

	//選択プレートをオンにする
	s_spguisw[SPGUISW_CAMERA_AND_IK].state = newstate;

	//ShowGUIDlgDispParams(false);
	//ShowGUIDlgBrushes(false);
	//ShowGUIDlgBullet(false);
	//ShowGUIDlgLOD(false);

	//SPGUISWの他のものが全てOFFの場合　placefolderWndを表示
	if ((s_spguisw[SPGUISW_DISP_AND_LIMITS].state == false) &&
		//(s_spguisw[SPGUISW_BRUSHPARAMS].state == false) &&
		(s_spguisw[SPGUISW_BULLETPHYSICS].state == false) &&
		(s_spguisw[SPGUISW_PROJ_AND_LOD].state == false) && 
		(s_spguisw[SPGUISW_BLENDSHAPE].state == false)) {
		if (s_placefolderWnd) {
			s_placefolderWnd->setVisible(true);
		}
	}
}

void GUISetVisible_DispAndLimits()
{
	//CameraAndIK以外は　いったん全部オフにする
	int plateno;
	for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
		s_spguisw[plateno].state = false;
	}

	//選択プレートをオンにする
	s_spguisw[SPGUISW_DISP_AND_LIMITS].state = true;
	ShowGUIDlgDispParams(true);
	//ShowGUIDlgBrushes(false);
	ShowGUIDlgBullet(false);
	ShowGUIDlgLOD(false);
	ShowGUIDlgBlendShape(false);
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}
}
//void GUISetVisible_BrushParams()
//{
//	//CameraAndIK以外は　いったん全部オフにする
//	int plateno;
//	for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
//		s_spguisw[plateno].state = false;
//	}
//
//	//選択プレートをオンにする
//	s_spguisw[SPGUISW_BRUSHPARAMS].state = true;
//	ShowGUIDlgDispParams(false);
//	ShowGUIDlgBrushes(true);
//	ShowGUIDlgBullet(false);
//	ShowGUIDlgLOD(false);
//	if (s_placefolderWnd) {
//		s_placefolderWnd->setVisible(false);
//	}
//
//}
void GUISetVisible_Bullet()
{
	//CameraAndIK以外は　いったん全部オフにする
	int plateno;
	for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
		s_spguisw[plateno].state = false;
	}

	//選択プレートをオンにする
	s_spguisw[SPGUISW_BULLETPHYSICS].state = true;
	ShowGUIDlgDispParams(false);
	//ShowGUIDlgBrushes(false);
	ShowGUIDlgBullet(true);
	ShowGUIDlgLOD(false);
	ShowGUIDlgBlendShape(false);
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}

}
void GUISetVisible_LOD()
{
	//CameraAndIK以外は　いったん全部オフにする
	int plateno;
	for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
		s_spguisw[plateno].state = false;
	}

	//選択プレートをオンにする
	s_spguisw[SPGUISW_PROJ_AND_LOD].state = true;
	ShowGUIDlgDispParams(false);
	//ShowGUIDlgBrushes(false);
	ShowGUIDlgBullet(false);
	ShowGUIDlgLOD(true);
	ShowGUIDlgBlendShape(false);
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}
}
void GUISetVisible_BlendShape()
{
	//CameraAndIK以外は　いったん全部オフにする
	int plateno;
	for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
		s_spguisw[plateno].state = false;
	}

	//選択プレートをオンにする
	s_spguisw[SPGUISW_BLENDSHAPE].state = true;
	ShowGUIDlgDispParams(false);
	//ShowGUIDlgBrushes(false);
	ShowGUIDlgBullet(false);
	ShowGUIDlgLOD(false);
	ShowGUIDlgBlendShape(true);
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}
}

void ShowRetargetWnd(bool srcflag)
{
	if (s_model && (s_curboneno >= 0)) {
		if (s_bpWorld) {
			if (srcflag == true) {
				s_retargetdlg.SetModel(s_model);
				s_retargetdlg.SetVisible(true);
			}
			else {
				s_retargetdlg.SetVisible(false);
			}
		}
	}

	s_spretargetsw[SPRETARGETSW_RETARGET].state = srcflag;
	s_dispconvbone = srcflag;

}

void ShowLimitEulerWnd(bool srcflag)
{
	if (s_model && (s_curboneno >= 0) && s_bpWorld) {
		if (srcflag == true) {
			if (!s_model->GetTopBone()) {
				return;
			}
			if (s_model->GetOldAxisFlagAtLoading() == 1) {
				::DSMessageBox(s_3dwnd, L"Work Only After Setting Of Axis.\nRetry after Saving FBX file.", L"error!!!", MB_OK);
				return;
			}
			////s_dseullimitctrls.clear();
			//ChaMatrix tmpwm = s_model->GetWorldMat();
			//s_model->UpdateMatrix(g_limitdegflag, &tmpwm, &s_matView, &s_matProj, true, 0);
			//s_limiteuldlg.SetModel(s_model, s_curboneno);

			s_limiteuldlg.SetVisible(true);
		}
		else {
			s_limiteuldlg.SetVisible(false);
		}

		s_spretargetsw[SPRETARGETSW_LIMITEULER].state = srcflag;
	}
}

void ShowThresholdWnd(bool srcflag)
{
	s_thresholddlg.SetVisible(srcflag);

	s_spretargetsw[SPRETARGETSW_THRESHOLD].state = srcflag;
}


void ShowGUIDlgDispParams(bool srcflag)
{
	s_displimitsdlg.SetVisible(srcflag);

	s_spguisw[SPGUISW_DISP_AND_LIMITS].state = srcflag;
}

void ShowGUIDlgBullet(bool srcflag)
{

	s_bulletdlg.SetVisible(srcflag);

	s_spguisw[SPGUISW_BULLETPHYSICS].state = srcflag;
}
void ShowGUIDlgLOD(bool srcflag)
{
	s_projloddlg.SetVisible(srcflag);

	s_spguisw[SPGUISW_PROJ_AND_LOD].state = srcflag;
}
void ShowGUIDlgBlendShape(bool srcflag)
{
	if (srcflag == true) {

		g_edittarget = EDITTARGET_MORPH;//2024/06/09　グラフモード変更

		if (s_model) {
			s_blendshapedlg.SetModel(s_model);
			s_blendshapedlg.SetVisible(srcflag);
		}

		refreshEulerGraph();

		if (s_LrefreshEditTarget == 0) {
			s_LrefreshEditTarget = 1;//2024/06/09 グラフリフレッシュ
		}

		//2024/06/30 BlendShapeの操作中ターゲットのグラフを表示
		if (!s_undoFlag && !s_redoFlag &&
			!s_blendshapedlg.GetBlendShapeUnderSelectFromUndo() && 
			!s_blendshapedlg.GetBlendShapeUnderSelectFromRefresh()) {

			//s_blendshapeUnderSelect = true;
			
			//2024/07/02 RollBackUndoMotionの一連の動作でUndoが走ってしまわないようにFromUndoフラグを使用
			s_blendshapedlg.SetBlendShapeUnderSelectFromUndo(true);
		}
	}
	else {
		//2024/07/02
		//BlendShapeメニューオフの時に　EDITTARGET_BONEにするのをやめた
		//s_LrefreshEditTargetを処理すると１段目のメニューが全てオフになってしまうから
		//エディットターゲット(Bone or Camera or Morph)は必要に応じてユーザが手動で操作(タイムラインの赤いカエルをクリック)
		//
		////2024/06/09　グラフモード変更
		//bool changedflag = false;
		//if (g_edittarget == EDITTARGET_MORPH) {
		//	g_edittarget = EDITTARGET_BONE;
		//	changedflag = true;
		//}

		s_blendshapedlg.SetVisible(srcflag);

		refreshEulerGraph();

		//2024/07/02
		//BlendShapeメニューオフの時に　EDITTARGET_BONEにするのをやめた
		//s_LrefreshEditTargetを処理すると１段目のメニューが全てオフになってしまうから
		//エディットターゲット(Bone or Camera or Morph)は必要に応じてユーザが手動で操作(タイムラインの赤いカエルをクリック)
		//
		//if (changedflag && (s_LrefreshEditTarget == 0)) {
		//	s_LrefreshEditTarget = 1;//2024/06/09 グラフリフレッシュ
		//}
	}

	s_spguisw[SPGUISW_BLENDSHAPE].state = srcflag;
}



void ShowLightsWnd(bool srcflag)
{
	s_lightsdlg.SetVisible(srcflag);

	s_spdispsw[SPDISPSW_LIGHTS].state = srcflag;
}

void ShowLaterTransparentWnd(bool srcflag)
{
	s_latertransparentdlg.SetVisible(srcflag);

	s_spdispsw[SPDISPSW_LATERTRANSPARENT].state = srcflag;
}


void ShowDispGroupWnd(bool srcflag)
{
	s_dispgroupdlg.SetVisible(srcflag);

	s_spdispsw[SPDISPSW_DISPGROUP].state = srcflag;
}


void ShowRigidWnd(bool srcflag)
{
	if (s_model && (s_curboneno >= 0)) {
		//if (s_model) {
		if (s_bpWorld) {
			s_model->SetCurrentRigidElem(s_reindexmap[s_model]);
			CallF(s_model->CreateBtObject(g_limitdegflag, 1), return);

			s_rigidparamsdlg.SetModel(s_model, s_curboneno, s_reindexmap, s_rgdindexmap);
			s_rigidparamsdlg.SetVisible(srcflag);

			s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].state = srcflag;
		}
	}
}


void ShowShaderTypeWnd(bool srcflag)
{

	//paramsの方は閉じる
	ShowShaderTypeParamsDlg(false);

	s_shadertypedlg.SetVisible(srcflag);

	s_spdispsw[SPDISPSW_SHADERTYPE].state = srcflag;

	{
		////############################
		////### ERROR 
		////### materialnum range error
		////############################
		////_ASSERT(0);
		//CloseAllAndDispPlaceFolder();
		//return;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	}

}

void ShowShadowParamsWnd(bool srcflag)
{
	s_shadowdlg.SetVisible(srcflag);

	s_spdispsw[SPDISPSW_SHADOWPARAMS].state = srcflag;
}

void ShowImpulseWnd(bool srcflag)
{
	//if (s_model && (s_curboneno >= 0)) {
	if (srcflag && s_model) {
		if (s_bpWorld) {
			CallF(s_model->CreateBtObject(g_limitdegflag, 0), return);

			s_impulsedlg.SetVisible(true);
		}
		else {
			s_impulsedlg.SetVisible(false);
		}
	}
	else {
		s_impulsedlg.SetVisible(false);
	}

	s_sprigidsw[SPRIGIDSW_IMPULSE].state = srcflag;

}
void ShowGroundWnd(bool srcflag)
{
	//if (s_model && (s_curboneno >= 0)) {
	if (srcflag && s_gplane && s_model && s_bpWorld) {
		CallF(s_model->CreateBtObject(g_limitdegflag, 0), return);

		s_gplanedlg.SetModel(s_gplane, s_bpWorld);
		s_gplanedlg.SetVisible(true);
	}
	else {
		s_gplanedlg.SetVisible(false);
	}

	s_sprigidsw[SPRIGIDSW_GROUNDPLANE].state = srcflag;

}
void ShowDampAnimWnd(bool srcflag)
{
	//if (s_model && (s_curboneno >= 0)) {
	if (srcflag && s_model && s_bpWorld) {
		CallF(s_model->CreateBtObject(g_limitdegflag, 0), return);

		s_dampanimdlg.SetVisible(true);
	}
	else {
		s_dampanimdlg.SetVisible(false);
	}

	s_sprigidsw[SPRIGIDSW_DAMPANIM].state = srcflag;
}


void GUIMenuSetVisible(int srcmenukind, int srcplateno)
{

	if (s_guiswflag) {
		bool closefirstrow;
		if (s_guiswplateno == 2) {
			closefirstrow = false;
		}
		else {
			closefirstrow = true;
		}
		CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる

		//１段目メニュー
		if ((s_guiswplateno > 1) && (s_guiswplateno < (SPGUISWNUM + 2))) {
			GUISetVisible(s_guiswplateno);//((spgno == 0) && (spgno < SPGUISWNUM))でGUISetVisible(spgno + 2)でGUISetVisible(1)はPlaceFolderWindow用
			SelectNextWindow(MB3D_WND_3D);
		}
		else {
			if (s_placefolderWnd) {
				s_placefolderWnd->setVisible(true);
			}
			SelectNextWindow(MB3D_WND_SIDE);
		}
	}
	else if ((srcmenukind >= SPPLATEMENUKIND_DISP) && (srcmenukind <= SPPLATEMENUKIND_EFFECT)) {
		bool closefirstrow = true;
		CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる


		//#####################
		//プレートメニュー更新
		//#####################
		s_platemenukind = srcmenukind;


		//２段目プレートクリック時には　１段目のCameraAndIK以外の選択状態をオフにする
		int plateno;
		for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
			s_spguisw[plateno].state = false;
		}


		//###########################
		//新しいプレートメニュー表示
		//###########################
		switch (s_platemenukind) {
			//case SPPLATEMENUKIND_GUI:
			//	if ((srcplateno >= 1) && (srcplateno < (SPGUISWNUM + 2))) {
			//		GUISetVisible(srcplateno);//((spgno == 0) && (spgno < SPGUISWNUM))でGUISetVisible(spgno + 2)でGUISetVisible(1)はPlaceFolderWindow用
			//		if (s_placefolderWnd) {
			//			s_placefolderWnd->setVisible(true);
			//		}
			//		SelectNextWindow(MB3D_WND_3D);
			//	}
			//	else {
			//		if (s_placefolderWnd) {
			//			s_placefolderWnd->setVisible(true);
			//		}
			//		SelectNextWindow(MB3D_WND_SIDE);
			//	}
			//	break;
		case SPPLATEMENUKIND_DISP:
			if ((srcplateno >= 1) && (srcplateno <= SPDISPSWNUM)) {
				if (s_customrigdlg) {
					DestroyWindow(s_customrigdlg);
					s_customrigdlg = 0;
				}
				if (s_placefolderWnd) {
					s_placefolderWnd->setVisible(false);
				}
				GUIDispSetVisible(srcplateno);
				SelectNextWindow(MB3D_WND_SIDE);
			}
			else {
				_ASSERT(0);
			}
			break;
		case SPPLATEMENUKIND_RIGID:
			if ((srcplateno >= 1) && (srcplateno <= SPRIGIDSWNUM)) {
				if (s_customrigdlg) {
					DestroyWindow(s_customrigdlg);
					s_customrigdlg = 0;
				}
				if (s_placefolderWnd) {
					s_placefolderWnd->setVisible(false);
				}
				GUIRigidSetVisible(srcplateno);
				SelectNextWindow(MB3D_WND_SIDE);
			}
			else {
				_ASSERT(0);
			}
			break;
		case SPPLATEMENUKIND_RETARGET:
			if ((srcplateno >= 1) && (srcplateno <= SPRETARGETSWNUM)) {
				if (s_customrigdlg) {
					DestroyWindow(s_customrigdlg);
					s_customrigdlg = 0;
				}
				if (s_placefolderWnd) {
					s_placefolderWnd->setVisible(false);
				}
				GUIRetargetSetVisible(srcplateno);
				SelectNextWindow(MB3D_WND_SIDE);
			}
			break;
		case SPPLATEMENUKIND_EFFECT:
			if ((srcplateno >= 1) && (srcplateno <= SPEFFECTSWNUM)) {
				if (s_customrigdlg) {
					DestroyWindow(s_customrigdlg);
					s_customrigdlg = 0;
				}
				if (s_placefolderWnd) {
					s_placefolderWnd->setVisible(false);
				}
				GUIEffectSetVisible(srcplateno);
				SelectNextWindow(MB3D_WND_SIDE);
			}
			break;
		default:
			break;
		}
	}

}

void ChangeToNextPlateMenuKind(int srcmenukind, int srcmenuno)
{
	//###############################################################
	//カエルボタンが押された場合　または　スペースキーが押された場合
	//###############################################################

	if (!s_model) {
		return;
	}


	int nextmenukind = -1;
	int nextplateno = 0;

	if ((srcmenukind >= 0) && (srcmenukind < SPPLATEMENUKINDNUM)) {
		//if (srcmenukind == SPPLATEMENUKIND_GUI) {
		//	nextmenukind = SPPLATEMENUKIND_DISP;
		//	nextplateno = 1;//最初のプレート
		//}
		//else 
		if (srcmenukind == SPPLATEMENUKIND_DISP) {
			nextmenukind = SPPLATEMENUKIND_RIGID;
			nextplateno = 1;//最初のプレート
		}
		else if (srcmenukind == SPPLATEMENUKIND_RIGID) {
			nextmenukind = SPPLATEMENUKIND_RETARGET;
			nextplateno = 1;//最初のプレート
		}
		else if (srcmenukind == SPPLATEMENUKIND_RETARGET) {
			nextmenukind = SPPLATEMENUKIND_EFFECT;
			nextplateno = 1;//最初のプレート
		}
		else if (srcmenukind == SPPLATEMENUKIND_EFFECT) {
			nextmenukind = SPPLATEMENUKIND_DISP;
			nextplateno = 1;//最初のプレート
		}
	}
	else {
		_ASSERT(0);
	}

	if ((nextmenukind >= 0) && (nextplateno != 0)) {
		s_platemenukind = nextmenukind;
		s_platemenuno = nextplateno;
		GUIMenuSetVisible(s_platemenukind, nextplateno);
	}

}

void ChangeToNextPlateMenuPlate(int srcmenukind, int srcmenuno)
{
	//Cキーを押し続けながらスペースキーが押された場合

	if (!s_model) {
		return;
	}





	//########################################################
	//nextplateno は　実際の値に+1したもの(最初のプレートは1)
	//########################################################
	int nextmenukind = -1;
	int nextplateno = 0;

	int currentkind = srcmenukind;
	int currentplate = srcmenuno;


	if ((currentkind >= 0) && (currentkind < SPPLATEMENUKINDNUM)) {
		//if (currentkind == SPPLATEMENUKIND_GUI) {
		//	nextmenukind = SPPLATEMENUKIND_GUI;
		//	nextplateno = currentplate + 1;//次のプレート
		//	if (nextplateno > (SPGUISWNUM + 1)) {//このkindだけplate == 1でplacefolderwnd表示するので１大きいところまで可
		//		nextplateno = 2;//最初のプレート
		//	}
		//}
		//else 
		if (currentkind == SPPLATEMENUKIND_DISP) {
			nextmenukind = SPPLATEMENUKIND_DISP;
			nextplateno = currentplate + 1;//次のプレート
			if (nextplateno > SPDISPSWNUM) {
				nextplateno = 1;//最初のプレート
			}
		}
		else if (currentkind == SPPLATEMENUKIND_RIGID) {
			nextmenukind = SPPLATEMENUKIND_RIGID;
			nextplateno = currentplate + 1;//次のプレート
			if (nextplateno > SPRIGIDSWNUM) {
				nextplateno = 1;//最初のプレート
			}
		}
		else if (currentkind == SPPLATEMENUKIND_RETARGET) {
			nextmenukind = SPPLATEMENUKIND_RETARGET;
			nextplateno = currentplate + 1;//次のプレート
			if (nextplateno > SPRETARGETSWNUM) {
				nextplateno = 1;//最初のプレート
			}
		}
		else if (currentkind == SPPLATEMENUKIND_EFFECT) {
			nextmenukind = SPPLATEMENUKIND_EFFECT;
			nextplateno = currentplate + 1;//次のプレート
			if (nextplateno > SPEFFECTSWNUM) {
				nextplateno = 1;//最初のプレート
			}
		}
	}
	else {
		_ASSERT(0);
	}

	if ((nextmenukind >= 0) && (nextplateno != 0)) {
		s_platemenukind = nextmenukind;
		s_platemenuno = nextplateno;
		GUIMenuSetVisible(s_platemenukind, nextplateno);
	}



}


bool GUIGetNextMenu(POINT ptCursor, int srcmenukind, int* dstmenukind, int* dstplateno)
{
	bool pickflag = false;

	if ((srcmenukind >= 0) && (srcmenukind < SPPLATEMENUKINDNUM)) {

		int nextmenukind = srcmenukind;
		int nextplateno = 1;

		//int spckind = 0;
		int pickguiplateno = 0;
		int pickdispplateno = 0;
		int pickrigidplateno = 0;
		int pickretargetplateno = 0;
		int pickeffectplateno = 0;

		//if (srcmenukind == SPPLATEMENUKIND_GUI) {
		// 
		//１段目は常時表示　常時クリック可能
		pickguiplateno = PickSpGUISW(ptCursor);//カエルボタンを押したときは -2, (SPGUISW_* + 2)が返る
		if (pickguiplateno >= 2) {
			s_guiswflag = true;
			s_guiswplateno = pickguiplateno;

			//２段目は前状態のまま
			*dstmenukind = s_platemenukind;
			*dstplateno = s_platemenuno;

			pickflag = true;
		}
		else {
			if (srcmenukind == SPPLATEMENUKIND_DISP) {
				pickdispplateno = PickSpDispSW(ptCursor);//カエルボタンを押したときは -2
				if (pickdispplateno == -2) {
					nextmenukind = SPPLATEMENUKIND_RIGID;
					nextplateno = 1;//最初のプレート
					pickflag = true;
				}
				else if (pickdispplateno != 0) {
					nextmenukind = srcmenukind;
					nextplateno = pickdispplateno;
					pickflag = true;
				}
				else {
					nextmenukind = -1;
					nextplateno = 1;
				}
			}
			else if (srcmenukind == SPPLATEMENUKIND_RIGID) {
				pickrigidplateno = PickSpRigidSW(ptCursor);//カエルボタンを押したときは -2
				if (pickrigidplateno == -2) {
					nextmenukind = SPPLATEMENUKIND_RETARGET;
					nextplateno = 1;//最初のプレート
					pickflag = true;
				}
				else if (pickrigidplateno != 0) {
					nextmenukind = srcmenukind;
					nextplateno = pickrigidplateno;
					pickflag = true;
				}
				else {
					nextmenukind = -1;
					nextplateno = 1;
				}
			}
			else if (srcmenukind == SPPLATEMENUKIND_RETARGET) {
				pickretargetplateno = PickSpRetargetSW(ptCursor);//カエルボタンを押したときは -2
				if (pickretargetplateno == -2) {
					nextmenukind = SPPLATEMENUKIND_EFFECT;
					nextplateno = 1;//最初のプレート
					pickflag = true;
				}
				else if (pickretargetplateno != 0) {
					nextmenukind = srcmenukind;
					nextplateno = pickretargetplateno;
					pickflag = true;
				}
				else {
					nextmenukind = -1;
					nextplateno = 1;
				}
			}
			else if (srcmenukind == SPPLATEMENUKIND_EFFECT) {
				pickeffectplateno = PickSpEffectSW(ptCursor);//カエルボタンを押したときは -2
				if (pickeffectplateno == -2) {
					nextmenukind = SPPLATEMENUKIND_DISP;
					nextplateno = 1;//最初のプレート
					pickflag = true;
				}
				else if (pickeffectplateno != 0) {
					nextmenukind = srcmenukind;
					nextplateno = pickeffectplateno;
					pickflag = true;
				}
				else {
					nextmenukind = -1;
					nextplateno = 1;
				}
			}

			*dstmenukind = nextmenukind;
			*dstplateno = nextplateno;

			if (pickflag == true) {
				s_guiswflag = false;
				//s_guiswplateno = 1;

				//２段目プレートクリック時には　１段目のCameraAndIK以外の選択状態をオフにする
				int plateno;
				for (plateno = SPGUISW_DISP_AND_LIMITS; plateno < SPGUISWNUM; plateno++) {
					s_spguisw[plateno].state = false;
				}
			}
		}
		
	}
	else {
		_ASSERT(0);
		*dstmenukind = -1;
		*dstplateno = 1;
	}

	return pickflag;
}

void InitDSValues()
{
	//static int s_currentwndid = 0;
	//static HWND s_currenthwnd = 0;
	//static int s_currentctrlid = -1;
	//static HWND s_currentctrlhwnd = 0;

	//static int s_dsbuttondown[MB3D_DSBUTTONNUM];
	//static int s_bef_dsbuttondown[MB3D_DSBUTTONNUM];
	//static int s_dsbuttonup[MB3D_DSBUTTONNUM];
	//static int s_bef_dsbuttonup[MB3D_DSBUTTONNUM];
	//static float s_dsaxisvalue[MB3D_DSAXISNUM];
	//static float s_bef_dsaxisvalue[MB3D_DSAXISNUM];
	//static int s_dsaxisOverSrh[MB3D_DSAXISNUM];
	//static int s_bef_dsaxisOverSrh[MB3D_DSAXISNUM];
	//static int s_dsaxisMOverSrh[MB3D_DSAXISNUM];
	//static int s_bef_dsaxisMOverSrh[MB3D_DSAXISNUM];

	g_enableDS = false;
	s_dsdeviceid = -1;
	s_curaimbarno = -1;

	s_wmlbuttonup = 0;
	s_dspushedOK = 0;
	s_dspushedL3 = 0;
	s_dspushedR3 = 0;
	g_dsmousewait = 0;
	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);

	s_firstmoveaimbar = true;

	s_mqodlghwnd = 0;
	s_underframecopydlg = false;
	s_pcolidlg = 0;
	s_undercolidlg = false;
	s_pgcolidlg = 0;
	s_undergcolidlg = false;
	s_motpropdlghwnd = 0;
	//s_cameradollydlgwnd = 0;
	s_savechadlghwnd = 0;
	s_bvhdlghwnd = 0;
	s_saveredlghwnd = 0;
	s_saveimpdlghwnd = 0;
	s_savegcodlghwnd = 0;
	s_rotzisdlghwnd = 0;
	s_customrighwnd = 0;
	s_exportxdlghwnd = 0;

	s_enumdist.clear();


	s_currentwndid = 0;
	s_currenthwnd = 0;
	s_restorewndid = 0;
	s_restorehwnd = 0;
	s_currentctrlid = -1;
	s_currentctrlhwnd = 0;
	s_wmlbuttonup = 0;
	s_restorecursorpos.x = 0;
	s_restorecursorpos.y = 0;

	s_ofhwnd = 0;
	s_messageboxhwnd = 0;
	s_messageboxpushcnt = 0;
	s_getfilenamehwnd = 0;
	s_getfilenametreeview = 0;

	s_curdsutguikind = 0;
	s_curdsutguino = 0;
	//s_dsutgui0.clear();
	//s_dsutgui1.clear();
	//s_dsutgui2.clear();
	//s_dsutgui3.clear();
	//s_dsutguiid0.clear();
	//s_dsutguiid1.clear();
	//s_dsutguiid2.clear();
	//s_dsutguiid3.clear();

	s_curdstoolctrlno = 0;
	s_dstoolctrls.clear();

	s_curdsplayerbtnno = 0;

	s_curdsrigidctrlno = 0;
	s_dsrigidctrls.clear();

	s_curdsimpulsectrlno = 0;
	s_dsimpulsectrls.clear();

	s_curdsgpctrlno = 0;
	s_dsgpctrls.clear();

	s_curdsdampctrlno = 0;
	s_dsdampctrls.clear();

	s_curdsretargetctrlno = 0;
	s_dsretargetctrls.clear();;

	s_curdseullimitctrlno = 0;
	s_dseullimitctrls.clear();

	g_currentsubmenuid = 0;
	s_currentsubmenuitemid = 0;

	ZeroMemory(s_dsbuttondown, sizeof(int) * MB3D_DSBUTTONNUM);
	ZeroMemory(s_bef_dsbuttondown, sizeof(int) * MB3D_DSBUTTONNUM);
	ZeroMemory(s_dsbuttonup, sizeof(int) * MB3D_DSBUTTONNUM);
	ZeroMemory(s_bef_dsbuttonup, sizeof(int) * MB3D_DSBUTTONNUM);

	ZeroMemory(s_dsaxisvalue, sizeof(float) * MB3D_DSAXISNUM);
	ZeroMemory(s_bef_dsaxisvalue, sizeof(float) * MB3D_DSAXISNUM);

	ZeroMemory(s_dsaxisOverSrh, sizeof(int) * MB3D_DSAXISNUM);
	ZeroMemory(s_bef_dsaxisOverSrh, sizeof(int) * MB3D_DSAXISNUM);
	ZeroMemory(s_dsaxisMOverSrh, sizeof(int) * MB3D_DSAXISNUM);
	ZeroMemory(s_bef_dsaxisMOverSrh, sizeof(int) * MB3D_DSAXISNUM);


}
void OnDSUpdate()
{

	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合にはDS関数でキーボードの矢印キーに対応

		OnArrowKey();

		return;
	}


	//GetDSValues();

	//ChangeMouseSetCapture();//処理前にキャプチャーをセット



	//DSColorAndVibration();

	//DSSelectWindowAndCtrl();//L1, square, triangle
	//DSSelectCharactor();//(L2 or R2) and L1

	//bool firstctrlselect = false;
	//DSCrossButton(firstctrlselect);


	////R1ボタン：３Dウインドウ選択、カレントボーン位置へマウスジャンプ
	//DSR1ButtonSelectCurrentBone();
	//DSR1ButtonSelectMotion();

	////L3, R3ボタンでマウス位置アピール
	//DSL3R3ButtonMouseHere();


	//if (g_undertrackingRMenu == 0) {
	//	//OK button popupmenuを出していないとき
	//	DSAimBarOK();

	//	//optionボタンは右クリック相当
	//	DSOptionButtonRightClick();
	//}
	//else if (g_undertrackingRMenu == 1) {
	//	//OK button popupmenuを出しているとき
	//	DSOButtonSelectedPopupMenu();
	//}

	////Cancel button : メニューのドロップダウンをキャンセルする　Cancel dropdown menu. L2 + X --> Undo, R2 + X --> Redo.
	//DSXButtonCancel();

	////Axis L Mouse Move
	//DSAxisLMouseMove();

	////Axis R MenuBar of MainWindow
	//DSAxisRMainMenuBar();


	//ChangeMouseReleaseCapture();//処理が終わってからキャプチャーを外す

	//OutputToInfoWnd(INFOCOLOR_INFO, L"\n\n");
	//OutputToInfoWnd(INFOCOLOR_INFO, L"Axis 0 : %1.4f\n", axisval0);
	//OutputToInfoWnd(INFOCOLOR_INFO, L"Axis 1 : %1.4f\n", axisval1);
	//OutputToInfoWnd(INFOCOLOR_INFO, L"Axis 2 : %1.4f\n", axisval2);
	//OutputToInfoWnd(INFOCOLOR_INFO, L"Axis 3 : %1.4f\n", axisval3);
	//OutputToInfoWnd(INFOCOLOR_INFO, L"Axis 4 : %1.4f\n", axisval4);
	//OutputToInfoWnd(INFOCOLOR_INFO, L"Axis 5 : %1.4f\n", axisval5);

	//ChangeColor(int id, const UCHAR r, const UCHAR g, const UCHAR b);

}

void GetDSValues()
{
	//static int s_dsbuttondown[MB3D_DSBUTTONNUM];
	//static int s_bef_dsbuttondown[MB3D_DSBUTTONNUM];
	//static int s_dsbuttonup[MB3D_DSBUTTONNUM];
	//static int s_bef_dsbuttonup[MB3D_DSBUTTONNUM];
	//static float s_dsaxisvalue[MB3D_DSAXISNUM];
	//static float s_bef_dsaxisvalue[MB3D_DSAXISNUM];
	//static int s_dsaxisOverSrh[MB3D_DSAXISNUM];
	//static int s_bef_dsaxisOverSrh[MB3D_DSAXISNUM];
	//static int s_dsaxisMOverSrh[MB3D_DSAXISNUM];
	//static int s_bef_dsaxisMOverSrh[MB3D_DSAXISNUM];


	if (!g_enableDS || (s_dsdeviceid < 0) || (s_dsdeviceid >= 3)) {
		//DS deviceが無い場合には何もせずにリターン
		return;
	}

	//UpdateInputReport();
	//SendOutput(0);

	////bool GetButtonDown(int id, UCHAR key);
	////bool GetButtonUp(int id, UCHAR key);

	//int buttonno;
	//for (buttonno = 0; buttonno < MB3D_DSBUTTONNUM; buttonno++) {
	//	s_bef_dsbuttondown[buttonno] = s_dsbuttondown[buttonno];
	//	s_bef_dsbuttonup[buttonno] = s_dsbuttonup[buttonno];

	//	if (GetButtonDown(s_dsdeviceid, buttonno)) {
	//		s_dsbuttondown[buttonno] = GetButtonDown(s_dsdeviceid, buttonno);
	//	}
	//	else {
	//		s_dsbuttondown[buttonno] = 0;
	//	}

	//	if (GetButtonUp(s_dsdeviceid, buttonno)) {
	//		s_dsbuttonup[buttonno] = GetButtonUp(s_dsdeviceid, buttonno);
	//	}
	//	else {
	//		s_dsbuttonup[buttonno] = 0;
	//	}

	//}

	//int axisno;
	//for (axisno = 0; axisno < MB3D_DSAXISNUM; axisno++) {

	//	////for debug
	//	//{
	//	//	if (s_dsbuttonup[4] >= 1) {
	//	//		_ASSERT(0);
	//	//	}
	//	//}


	//	s_bef_dsaxisvalue[axisno] = s_dsaxisvalue[axisno];
	//	s_bef_dsaxisOverSrh[axisno] = s_dsaxisOverSrh[axisno];
	//	s_bef_dsaxisMOverSrh[axisno] = s_dsaxisMOverSrh[axisno];

	//	s_dsaxisvalue[axisno] = GetAxis(s_dsdeviceid, axisno);

	//	s_dsaxisOverSrh[axisno] = (int)(s_dsaxisvalue[axisno] >= MB3D_DSAXISSRH);
	//	s_dsaxisMOverSrh[axisno] = (int)(s_dsaxisvalue[axisno] <= -(MB3D_DSAXISSRH));
	//}


	//if (s_dsbuttondown[2] >= 1) {
	//	s_dspushedOK = 1;
	//}
	//if (s_dsbuttonup[2] >= 1) {
	//	s_dspushedOK = 0;
	//}


	//if (s_dsbuttondown[12] >= 1) {
	//	s_dspushedL3 = 1;
	//}
	//if (s_dsbuttonup[12] >= 1) {
	//	s_dspushedL3 = 0;
	//}
	//if (s_dsbuttondown[13] >= 1) {
	//	s_dspushedR3 = 1;
	//}
	//if (s_dsbuttonup[13] >= 1) {
	//	s_dspushedR3 = 0;
	//}



}
void DSCrossButtonSelectTree(bool firstctrlselect)
{
	//if ((s_dsutgui0.size() <= 0) || (s_dsutgui1.size() <= 0) || (s_dsutgui2.size() <= 0) || (s_dsutgui3.size() <= 0)) {
	//	return;
	//}


	if (!s_owpTimeline) {
		return;
	}

	//select control
	//十字キー移動ブロック
	{
		if ((s_currentwndid >= 0) && (s_currenthwnd != 0)) {


			int parentbuttonid = 4;
			int sisterbuttonid = 5;
			int childbuttonid = 6;
			int brotherbuttonid = 7;
			int accelaxisid1 = 4;//axisid
			int accelaxisid2 = 5;//axisid

			int parentbutton = 0;
			int sisterbutton = 0;
			int childbutton = 0;
			int brotherbutton = 0;
			int accelaxis1 = 0;
			int accelaxis2 = 0;

			parentbutton = s_dsbuttonup[parentbuttonid];
			sisterbutton = s_dsbuttonup[sisterbuttonid];
			childbutton = s_dsbuttonup[childbuttonid];
			brotherbutton = s_dsbuttonup[brotherbuttonid];

			accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
			accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

			bool changeflag = false;

			//WS_TABSTOP
			//VK_TAB
			//WS_GROUP
			//または
			//HWND SetFocus(HWND hWnd);


			if (firstctrlselect) {
				parentbutton = 0;
				sisterbutton = 0;
				childbutton = 0;
				brotherbutton = 0;

				accelaxis1 = 0;
				accelaxis2 = 0;
				changeflag = true;
			}


			if (s_currentwndid == MB3D_WND_TREE) {
				if (s_model && (s_curboneno >= 0)) {
					CBone* curbone = s_model->GetBoneByID(s_curboneno);
					if (curbone) {
						if (parentbutton >= 1) {
							if ((accelaxis1 >= 1) || (accelaxis2 >= 1)) {
								//アクセル　L2またはL3がオンのとき　
								CBone* upperbranchbone = curbone->GetUpperBranchBone();
								if (upperbranchbone) {
									int upperbranchboneno = upperbranchbone->GetBoneNo();
									if (upperbranchboneno >= 0) {
										s_curboneno = upperbranchboneno;
										changeflag = true;
									}
								}
							}
							else {
								CBone* parbone = curbone->GetParent(false);
								if (parbone && parbone->IsSkeleton()) {
									int parboneno = parbone->GetBoneNo();
									if (parboneno >= 0) {
										s_curboneno = parboneno;
										changeflag = true;
									}
								}
							}
						}
						else if (sisterbutton >= 1) {
							CBone* sisterbone = curbone->GetSister(true);
							if (sisterbone) {
								int sisterboneno = sisterbone->GetBoneNo();
								if (sisterboneno >= 0) {
									s_curboneno = sisterboneno;
									changeflag = true;
								}
							}
							else {
								//sister loop
								//brotherがある場合　末端のbrotherに移動
								CBone* brotherbone = curbone->GetBrother(false);
								while (brotherbone && brotherbone->GetBrother(false) && brotherbone->GetBrother(false)->IsSkeleton()) {
									brotherbone = brotherbone->GetBrother(false);
								}
								if (brotherbone) {
									int nextboneno = brotherbone->GetBoneNo();
									if (nextboneno >= 0) {
										s_curboneno = nextboneno;
										changeflag = true;
									}
								}

								//階層的としてのsister, brotherが無い場合には名前としてのsister, brotherをチェックする
								if (changeflag != true) {
									string strcurbonename = curbone->GetBoneName();
									string strLeft = "Left";
									string strRight = "Right";

									string chkLeft = strcurbonename;
									string chkRight = strcurbonename;


									std::string::size_type leftpos = chkLeft.find(strLeft);
									if (leftpos != std::string::npos) {
										//Leftの部分をRightに変えてボーンが存在すればそのボーンに移動
										chkLeft.replace(leftpos, strLeft.length(), strRight);
										CBone* rightbone = s_model->FindBoneByName(chkLeft.c_str());
										if (rightbone) {
											int nextboneno = rightbone->GetBoneNo();
											if (nextboneno >= 0) {
												s_curboneno = nextboneno;
												changeflag = true;
											}
										}
									}
									else {
										std::string::size_type rightpos = chkRight.find(strRight);
										if (rightpos != std::string::npos) {
											//Rightの部分をLeftに変えてボーンが存在すればそのボーンに移動
											chkRight.replace(rightpos, strRight.length(), strLeft);
											CBone* leftbone = s_model->FindBoneByName(chkRight.c_str());
											if (leftbone) {
												int nextboneno = leftbone->GetBoneNo();
												if (nextboneno >= 0) {
													s_curboneno = nextboneno;
													changeflag = true;
												}
											}
										}
									}

								}
							}
						}
						else if (childbutton >= 1) {
							if ((accelaxis1 >= 1) || (accelaxis2 >= 1)) {
								//アクセル　L2またはL3がオンのとき　
								CBone* lowerbranchbone = curbone->GetLowerBranchBone();
								if (lowerbranchbone) {
									int lowerbranchboneno = lowerbranchbone->GetBoneNo();
									if (lowerbranchboneno >= 0) {
										s_curboneno = lowerbranchboneno;
										changeflag = true;
									}
								}
							}
							else {
								CBone* childbone = curbone->GetChild(false);
								if (childbone && childbone->IsSkeleton()) {
									int childboneno = childbone->GetBoneNo();
									if (childboneno >= 0) {
										s_curboneno = childboneno;
										changeflag = true;
									}
								}
							}
						}
						else if (brotherbutton >= 1) {
							CBone* brotherbone = curbone->GetBrother(false);
							if (brotherbone && brotherbone->IsSkeleton()) {
								int brotherboneno = brotherbone->GetBoneNo();
								if (brotherboneno >= 0) {
									s_curboneno = brotherboneno;
									changeflag = true;
								}
							}
							else {
								//brother loop
								//sisterとparentのchildがある場合　parentのchildに移動
								CBone* sisterbone = curbone->GetSister(true);
								if (sisterbone) {
									CBone* parentbone = curbone->GetParent(false);
									if (parentbone && parentbone->IsSkeleton()) {
										CBone* childbone = parentbone->GetChild(false);
										if (childbone && childbone->IsSkeleton()) {
											int nextboneno = childbone->GetBoneNo();
											if (nextboneno >= 0) {
												s_curboneno = nextboneno;
												changeflag = true;
											}
										}
									}
								}
							}

							//階層的としてのsister, brotherが無い場合には名前としてのsister, brotherをチェックする
							if (changeflag != true) {
								string strcurbonename = curbone->GetBoneName();
								string strLeft = "Left";
								string strRight = "Right";

								string chkLeft = strcurbonename;
								string chkRight = strcurbonename;


								std::string::size_type leftpos = chkLeft.find(strLeft);
								if (leftpos != std::string::npos) {
									//Leftの部分をRightに変えてボーンが存在すればそのボーンに移動
									chkLeft.replace(leftpos, strLeft.length(), strRight);
									CBone* rightbone = s_model->FindBoneByName(chkLeft.c_str());
									if (rightbone) {
										int nextboneno = rightbone->GetBoneNo();
										if (nextboneno >= 0) {
											s_curboneno = nextboneno;
											changeflag = true;
										}
									}
								}
								else {
									std::string::size_type rightpos = chkRight.find(strRight);
									if (rightpos != std::string::npos) {
										//Rightの部分をLeftに変えてボーンが存在すればそのボーンに移動
										chkRight.replace(rightpos, strRight.length(), strLeft);
										CBone* leftbone = s_model->GetBoneByName(chkRight.c_str());
										if (leftbone) {
											int nextboneno = leftbone->GetBoneNo();
											if (nextboneno >= 0) {
												s_curboneno = nextboneno;
												changeflag = true;
											}
										}
									}
								}
							}
						}

						if (changeflag && (s_curboneno >= 0)) {
							if (s_owpTimeline) {
								s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);


								//マウスがタイムライン上にあった場合にだけマウスの位置を選択位置へ移動
								//他のダイアログなどを設定中にカーソルがタイムラインに飛ばないように。

								POINT cursorpos;
								GetCursorPos(&cursorpos);
								ScreenToClient(s_timelineWnd->getHWnd(), &cursorpos);
								RECT timelinerect;
								GetClientRect(s_timelineWnd->getHWnd(), &timelinerect);
								if ((cursorpos.x >= timelinerect.left) && (cursorpos.x <= timelinerect.right) &&
									(cursorpos.y >= timelinerect.top) && (cursorpos.y <= timelinerect.bottom)) {

									WindowPos currentpos = s_owpTimeline->getCurrentLinePos();
									POINT mousepos = { 0, 0 };
									mousepos.x = currentpos.x;
									mousepos.y = currentpos.y;

									::ClientToScreen(s_timelineWnd->getHWnd(), &mousepos);
									::SetCursorPos(mousepos.x, mousepos.y);
								}



							}
							ChangeCurrentBone(true);
						}

					}
				}
			}
		}
	}


}



void SelectNextWindow(int nextwndid)
{
	HWND tmptlwnd = 0;
	if (s_timelineWnd) {
		tmptlwnd = s_timelineWnd->getHWnd();
	}
	else {
		tmptlwnd = 0;
	}
	HWND tmptoolwnd = 0;
	if (s_toolWnd) {
		tmptoolwnd = s_toolWnd->getHWnd();
	}
	else {
		tmptoolwnd = 0;
	}
	HWND tmplongtlwnd = 0;
	if (s_LtimelineWnd) {
		tmplongtlwnd = s_LtimelineWnd->getHWnd();
	}
	else {
		tmplongtlwnd = 0;
	}
	HWND tmpsidewnd = 0;
	if (s_sidemenuWnd) {
		tmpsidewnd = s_sidemenuWnd->getHWnd();
	}
	else {
		tmpsidewnd = 0;
	}
	HWND tmptopsliderswnd = 0;
	if (s_topSlidersWnd) {
		tmptopsliderswnd = s_topSlidersWnd->getHWnd();
	}
	else {
		tmptopsliderswnd = 0;
	}


	HWND hwnds[MB3D_WND_MAX];
	ZeroMemory(hwnds, sizeof(HWND) * MB3D_WND_MAX);
	//hwnds[MB3D_WND_MAIN] = g_mainhwnd;
	hwnds[MB3D_WND_MAIN] = tmptopsliderswnd;
	hwnds[MB3D_WND_3D] = s_3dwnd;
	hwnds[MB3D_WND_TREE] = tmptlwnd;
	hwnds[MB3D_WND_TOOL] = tmptoolwnd;
	hwnds[MB3D_WND_TIMELINE] = tmplongtlwnd;
	hwnds[MB3D_WND_SIDE] = tmpsidewnd;

	int dbgcnt = 0;
	HWND nexthwnd = 0;
	nexthwnd = hwnds[nextwndid];
	//while (nexthwnd == 0) {
	//	nextwndid++;
	//	if (nextwndid >= MB3D_WND_MAX) {
	//		nextwndid = 0;
	//	}
	//	dbgcnt++;
	//	if (dbgcnt >= MB3D_WND_MAX) {
	//		nextwndid = 0;
	//		break;
	//	}
	//	nexthwnd = hwnds[nextwndid];
	//}

	if ((nextwndid >= 0) && (nextwndid < MB3D_WND_MAX) && nexthwnd) {

		BYTE selectR = 255;
		BYTE selectG = 128;
		BYTE selectB = 64;

		BYTE unselectR = 70;
		BYTE unselectG = 50;
		BYTE unselectB = 70;

		HBRUSH selectbrush = CreateSolidBrush(RGB(selectR, selectG, selectB));
		HBRUSH unselectbrush = CreateSolidBrush(RGB(unselectR, unselectG, unselectB));

		::SetFocus(nexthwnd);

		if (nextwndid == MB3D_WND_MAIN) {
			//:: SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)selectbrush);
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			//SetThemeAppProperties(STAP_ALLOW_NONCLIENT | STAP_ALLOW_CONTROLS | STAP_ALLOW_WEBCONTENT);//STAP_ALLOW_WEBCONTENT
			//SendMessage(hwnds[0], WM_THEMECHANGED, 0, 0);
			//RedrawWindow(hwnds[0], 0, 0, RDW_UPDATENOW);


			//::SetWindowPos(hwnds[0], HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			::SetWindowPos(g_mainhwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			if (s_topSlidersWnd) {
				s_topSlidersWnd->setBackGroundColor(true);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_3D) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)selectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			//SetThemeAppProperties(STAP_ALLOW_NONCLIENT | STAP_ALLOW_CONTROLS | STAP_ALLOW_WEBCONTENT);//STAP_ALLOW_WEBCONTENT
			//SendMessage(hwnds[1], WM_THEMECHANGED, 0, 0);
			//RedrawWindow(hwnds[1], 0, 0, RDW_UPDATENOW);

			::SetWindowPos(hwnds[1], HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

			if (s_topSlidersWnd) {
				s_topSlidersWnd->setBackGroundColor(false);
			}


			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_TREE) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			if (s_topSlidersWnd) {
				s_topSlidersWnd->setBackGroundColor(false);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(true);
				::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_TOOL) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			if (s_topSlidersWnd) {
				s_topSlidersWnd->setBackGroundColor(false);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(true);
				::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_TIMELINE) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			if (s_topSlidersWnd) {
				s_topSlidersWnd->setBackGroundColor(false);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(true);
				::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(false);
			}
		}
		else if (nextwndid == MB3D_WND_SIDE) {
			//::SetClassLongPtr(hwnds[1], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);
			//::SetClassLongPtr(hwnds[0], GCLP_HBRBACKGROUND, (LONG_PTR)unselectbrush);

			if (s_topSlidersWnd) {
				s_topSlidersWnd->setBackGroundColor(false);
			}

			if (s_timelineWnd) {
				s_timelineWnd->setBackGroundColor(false);
			}
			if (s_toolWnd) {
				s_toolWnd->setBackGroundColor(false);
			}
			if (s_LtimelineWnd) {
				s_LtimelineWnd->setBackGroundColor(false);
			}
			if (s_sidemenuWnd) {
				s_sidemenuWnd->setBackGroundColor(true);
				::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			}
		}
		else {
			_ASSERT(0);
		}




		DeleteObject(selectbrush);
		DeleteObject(unselectbrush);


		//if (s_befactivehwnd) {
		//	ReleaseCapture();
		//}
		//SetCapture(nexthwnd);

		//SetForegroundWindow(nexthwnd);

		//if (s_befactivehwnd) {
		//	ReleaseCapture();
		//}
		//::SetWindowPos(nexthwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
		//HWND befactive;
		//befactive = ::SetActiveWindow(nexthwnd);
		//SetCapture(nexthwnd);


		//SetCaptureWindow !!!!!!!!!!!!!!!!!

		s_currentwndid = nextwndid;
		if ((s_currentwndid >= 0) && (s_currentwndid < MB3D_WND_MAX)) {
			s_currenthwnd = hwnds[s_currentwndid];
		}

		//bool firstctrlselect = true;
		//DSCrossButton(firstctrlselect);

		GUISetVisible_Sel3D();//3DWindowを選択しているかどうかのマークを右上隅に表示

	}
	//OutputToInfoWnd(INFOCOLOR_INFO, L"Button Down %d", buttonL1);
}



void GetHiLiteSubmenu(HMENU* pcommandsubmenu, int* pcommandsubmenunum, int* pcommandsubmenuno)
{
	if (!pcommandsubmenu || !pcommandsubmenunum || !pcommandsubmenuno) {
		return;
	}
	*pcommandsubmenu = 0;
	*pcommandsubmenunum = 0;
	*pcommandsubmenuno = 0;



	int selectedsubmenuitemno = -1;
	int submenuitemnum;
	submenuitemnum = GetMenuItemCount(s_cursubmenu);
	int submenuitemcnt;
	for (submenuitemcnt = 0; submenuitemcnt < submenuitemnum; submenuitemcnt++) {
		UINT submenuitemstate;
		submenuitemstate = GetMenuState(s_cursubmenu, submenuitemcnt, MF_BYPOSITION);
		if (submenuitemstate == MF_HILITE) {
			selectedsubmenuitemno = submenuitemcnt;
			break;
		}
		else {
			//submenu ２段階までは自動でチェック
			HMENU subsubmenu = 0;
			subsubmenu = GetSubMenu(s_cursubmenu, submenuitemcnt);
			if (subsubmenu) {
				int subsubmenuitemnum;
				subsubmenuitemnum = GetMenuItemCount(subsubmenu);
				int subsubmenuitemcnt;
				for (subsubmenuitemcnt = 0; subsubmenuitemcnt < subsubmenuitemnum; subsubmenuitemcnt++) {
					UINT subsubmenuitemstate;
					subsubmenuitemstate = GetMenuState(subsubmenu, subsubmenuitemcnt, MF_BYPOSITION);
					if (subsubmenuitemstate == MF_HILITE) {
						s_cursubmenu = subsubmenu;//!!!!!!!!!
						selectedsubmenuitemno = subsubmenuitemcnt;
						submenuitemnum = subsubmenuitemnum;
						break;//!!!!!!!!!!!!!!!!
					}
				}
			}
		}
	}

	if (selectedsubmenuitemno == -1) {
		HMENU submenu2 = 0;

		if (g_currentsubmenuid == 0) {
			submenu2 = GetSubMenu(s_cursubmenu, 1);
		}
		else if (g_currentsubmenuid == 2) {
			submenu2 = GetSubMenu(s_cursubmenu, 3);
		}
		else if (g_currentsubmenuid == 3) {
			submenu2 = GetSubMenu(s_cursubmenu, 3);
		}
		else if (g_currentsubmenuid == 4) {
			submenu2 = GetSubMenu(s_cursubmenu, 3);
		}
		else if ((g_currentsubmenuid >= 5) && (g_currentsubmenuid <= 8)) {
			submenu2 = GetSubMenu(s_cursubmenu, 0);
		}

		if (submenu2) {
			{
				int tmpselectedsubmenuitemno = -1;
				int tmpsubmenuitemnum;
				tmpsubmenuitemnum = GetMenuItemCount(submenu2);
				int tmpsubmenuitemcnt;
				for (tmpsubmenuitemcnt = 0; tmpsubmenuitemcnt < tmpsubmenuitemnum; tmpsubmenuitemcnt++) {
					UINT submenuitemstate;
					submenuitemstate = GetMenuState(submenu2, tmpsubmenuitemcnt, MF_BYPOSITION);
					if (submenuitemstate == MF_HILITE) {
						tmpselectedsubmenuitemno = tmpsubmenuitemcnt;
						break;
					}
				}
				if (tmpselectedsubmenuitemno >= 0) {
					*pcommandsubmenu = submenu2;
					*pcommandsubmenunum = tmpsubmenuitemnum;
					*pcommandsubmenuno = tmpselectedsubmenuitemno;
				}
			}
		}
	}
	else {
		*pcommandsubmenu = s_cursubmenu;
		*pcommandsubmenunum = submenuitemnum;
		*pcommandsubmenuno = selectedsubmenuitemno;

	}
}

void CALLBACK WinEventProc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread, DWORD dwmsEventTime)
{

	//if ((event >= EVENT_SYSTEM_DIALOGSTART) && (event <= EVENT_SYSTEM_DIALOGEND)) {
	//if((event == EVENT_OBJECT_INVOKED) || (event == EVENT_OBJECT_SELECTION) || (event == EVENT_OBJECT_SELECTIONWITHIN) || (event == EVENT_OBJECT_STATECHANGE)){
	//	WCHAR classname[MAX_PATH] = { 0L };
	//	WCHAR wintext[MAX_PATH] = { 0L };
	//	::GetClassName(hwnd, classname, MAX_PATH);
	//	::GetWindowText(hwnd, wintext, MAX_PATH);
	//	//if (wcscmp(L"Button", classname) == 0) {
	//		if (wcscmp(L"OK", wintext) == 0) {
	//			SendMessage(hwnd, BM_CLICK, 0, 0);
	//		}
	//	//}
	//}
	////::SendMessage(hwnd, WM_COMMAND, IDOK, 0);
	//HWND hwndChild = FindWindowEx(hwnd, 0, L"Button", L"OK");
	//if (hwndChild) {
	//	SendMessage(hwndChild, BM_CLICK, 0, 0);
	//	//::SendMessage(hwndChild, WM_COMMAND, IDOK, 0);
	//}

	//if ((event == EVENT_OBJECT_INVOKED) || (event == EVENT_OBJECT_SELECTION) || (event == EVENT_OBJECT_SELECTIONWITHIN) || (event == EVENT_OBJECT_STATECHANGE)) {
	//if (event == EVENT_SYSTEM_DIALOGSTART) {
	//if(event == EVENT_OBJECT_CREATE){

	if (event == EVENT_SYSTEM_FOREGROUND) {
		WCHAR classname[MAX_PATH] = { 0L };
		WCHAR wintext[MAX_PATH] = { 0L };
		::GetClassName(hwnd, classname, MAX_PATH);
		::GetWindowText(hwnd, wintext, MAX_PATH);


		HWND fgwnd = 0;

		//if (wcscmp(L"error!!!", wintext) == 0) {
		if (wcsstr(wintext, L"error!!!") != 0) {
			//::SendMessage(hwnd, WM_COMMAND, IDOK, 0);
			s_messageboxhwnd = hwnd;
			fgwnd = hwnd;
		}
		if (wcsstr(wintext, L"warning!!!") != 0) {
			s_messageboxhwnd = hwnd;
			fgwnd = hwnd;
		}
		if (wcsstr(wintext, L"check!!!") != 0) {
			s_messageboxhwnd = hwnd;
			fgwnd = hwnd;
		}
		if (wcsstr(wintext, L"GetFileNameDlg") != 0) {
			s_getfilenamehwnd = hwnd;
			fgwnd = hwnd;
		}
		if ((wcscmp(classname, L"#32770") == 0) || (wcsstr(wintext, L"フォルダーの参照") != 0)) {//SHGetSpecialFolderLocation
			s_getfilenamehwnd = hwnd;
			fgwnd = hwnd;
		}

		if (fgwnd) {

			SetDlgPosDesktopCenter(fgwnd, HWND_TOPMOST);

			//機能のボタンを押した際　マウスがアップする前に呼ばれることがある
			//マウスを動かすと　ボタンが機能しないことがあるので　SetCursorPosはコメントアウト
			//この関数の外で　ダイアログ表示時にSetCursorPosすることは大丈夫
			//RECT dlgrect;
			//GetWindowRect(fgwnd, &dlgrect);
			//SetCursorPos(dlgrect.left + 25, dlgrect.top + 10);
		}

		//HWND hwndChild = FindWindowExA(hwnd, 0, "Button", "OK");
		//if (hwndChild) {
		//	SendMessage(hwndChild, BM_CLICK, 0, 0);
		//	::SendMessage(hwndChild, WM_COMMAND, IDOK, 0);
		//}
		//else {
		//	HWND hwndChildW = FindWindowExW(hwnd, 0, L"Button", L"OK");
		//	if (hwndChildW) {
		//		SendMessage(hwndChildW, BM_CLICK, 0, 0);
		//		::SendMessage(hwndChild, WM_COMMAND, IDOK, 0);
		//	}
		//}

	}

	//}

	return;
}


BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam)
{
	if (!lParam) {
		return FALSE;
	}
	HWND* rethwnd = (HWND*)lParam;
	*rethwnd = 0;

	POINT mousepoint;
	::GetCursorPos(&mousepoint);
	::ScreenToClient(hwnd, &mousepoint);

	RECT ctrlrect;
	GetClientRect(hwnd, &ctrlrect);



	if ((mousepoint.x >= ctrlrect.left) && (mousepoint.x <= ctrlrect.right)
		&& (mousepoint.y >= ctrlrect.top) && (mousepoint.y <= ctrlrect.bottom)) {
		//if ((mousepoint.x >= 0) && (mousepoint.x <= (ctrlrect.right - ctrlrect.left))
		//	&& (mousepoint.y >= 0) && (mousepoint.y <= (ctrlrect.bottom - ctrlrect.top))) {

		//#################################################################################################################################################
		//groupboxのclassnameもButton。groupboxの中のコントロールを押すためには距離で判定する必要があった。マウス位置に一番近いコントロールを探すための情報をs_enumdistにpush_back
		//#################################################################################################################################################
		POINT ctrllefttop = { 0, 0 };
		//ctrlcenter.x = (ctrlrect.right - ctrlrect.left) / 2;//ラジオボタンなどはコントロール真ん中ではなく左側を押すことが多いので中央はやめる
		//ctrlcenter.y = (ctrlrect.bottom - ctrlrect.top) / 2;
		ctrllefttop.x = ctrlrect.left;
		ctrllefttop.y = ctrlrect.top;

		ENUMDIST enumdist;
		ZeroMemory(&enumdist, sizeof(ENUMDIST));
		enumdist.hwnd = hwnd;
		enumdist.dist = (float)(mousepoint.x - ctrllefttop.x) * (float)(mousepoint.x - ctrllefttop.x) + (float)(mousepoint.y - ctrllefttop.y) * (float)(mousepoint.y - ctrllefttop.y);
		s_enumdist.push_back(enumdist);


		//*rethwnd = hwnd;
		//return FALSE;//探索終了

		return TRUE;//探索続行
	}
	else {
		*rethwnd = 0;
		return TRUE;//探索続行
	}

}

BOOL CALLBACK EnumTreeViewProc(HWND hwnd, LPARAM lParam)
{
	if (!lParam) {
		return FALSE;
	}
	HWND* rethwnd = (HWND*)lParam;
	*rethwnd = 0;

	WCHAR classname[MAX_PATH] = { 0L };
	::GetClassName(hwnd, classname, MAX_PATH);

	//if ((wcscmp(L"SysListView32", classname) == 0) || (wcscmp(L"SysTreeView32", classname) == 0)) {
	if ((wcsstr(classname, L"ListBox") != 0) || (wcsstr(classname, L"TreeView") != 0)) {
		//*rethwnd = hwnd;
		//return FALSE;//探索終了

		POINT mousepoint;
		::GetCursorPos(&mousepoint);
		::ScreenToClient(hwnd, &mousepoint);
		//::ScreenToClient(s_getfilenamehwnd, &mousepoint);

		RECT ctrlrect;
		GetClientRect(hwnd, &ctrlrect);
		//GetWindowRect(hwnd, &ctrlrect);

		POINT ctrllefttop = { 0, 0 };
		//ctrlcenter.x = (ctrlrect.right - ctrlrect.left) / 2;//ラジオボタンなどはコントロール真ん中ではなく左側を押すことが多いので中央はやめる
		//ctrlcenter.y = (ctrlrect.bottom - ctrlrect.top) / 2;
		ctrllefttop.x = ctrlrect.left;
		ctrllefttop.y = ctrlrect.top;

		ENUMDIST enumdist;
		ZeroMemory(&enumdist, sizeof(ENUMDIST));
		enumdist.hwnd = hwnd;
		enumdist.dist = (float)(mousepoint.x - ctrllefttop.x) * (float)(mousepoint.x - ctrllefttop.x) + (float)(mousepoint.y - ctrllefttop.y) * (float)(mousepoint.y - ctrllefttop.y);
		s_enumdist.push_back(enumdist);

		*rethwnd = 0;
		return TRUE;//探索続行
	}
	else {
		*rethwnd = 0;
		return TRUE;//探索続行
	}
}



BOOL CALLBACK EnumIDOKProc(HWND hwnd, LPARAM lParam)
{
	if (!lParam) {
		return FALSE;
	}
	HWND* rethwnd = (HWND*)lParam;
	*rethwnd = 0;

	WCHAR wintext[MAX_PATH] = { 0L };
	::GetWindowText(hwnd, wintext, MAX_PATH);

	if (wcscmp(L"OK", wintext) == 0) {
		*rethwnd = hwnd;
		return FALSE;//探索終了
	}
	else {
		*rethwnd = 0;
		return TRUE;//探索続行
	}

}



HWND GetNearestEnumDist()
{
	if (s_enumdist.empty()) {
		return 0;
	}
	else {
		bool isfirst = true;
		float nearestdist = 1e20f;
		HWND nearesthwnd = 0;
		std::vector<ENUMDIST>::iterator itrenumdist;
		for (itrenumdist = s_enumdist.begin(); itrenumdist != s_enumdist.end(); itrenumdist++) {
			if (isfirst) {
				nearesthwnd = itrenumdist->hwnd;
				nearestdist = itrenumdist->dist;
				isfirst = false;
			}
			else {
				if (nearestdist > itrenumdist->dist) {
					nearesthwnd = itrenumdist->hwnd;
					nearestdist = itrenumdist->dist;
				}
			}
		}

		return nearesthwnd;
	}
}


HWND GetOFWnd(POINT srcpoint)
{
	HWND retctrlwnd = 0;

	s_ofhwnd = 0;
	s_enumdist.clear();

	CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg(false);


	if (!retctrlwnd && s_getfilenamehwnd) {
		::EnumChildWindows(s_getfilenamehwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_getfilenamehwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_mqodlghwnd) {
		::EnumChildWindows(s_mqodlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_mqodlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_underframecopydlg && curcpdlg && curcpdlg->m_hWnd) {
		::EnumChildWindows(curcpdlg->m_hWnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = curcpdlg->m_hWnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_undercolidlg && s_pcolidlg && s_pcolidlg->m_hWnd && IsWindow(s_pcolidlg->m_hWnd)) {
		::EnumChildWindows(s_pcolidlg->m_hWnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_pcolidlg->m_hWnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_undergcolidlg && s_pgcolidlg && s_pgcolidlg->m_hWnd && IsWindow(s_pgcolidlg->m_hWnd)) {
		::EnumChildWindows(s_pgcolidlg->m_hWnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_pgcolidlg->m_hWnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_motpropdlghwnd) {
		::EnumChildWindows(s_motpropdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_motpropdlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && g_filterdlghwnd) {
		::EnumChildWindows(g_filterdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = g_filterdlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && (s_currentwndid == MB3D_WND_SIDE) && (s_platemenukind == SPPLATEMENUKIND_RETARGET) && (s_platemenuno == (SPRETARGETSW_LIMITEULER + 1))) {
		//if (s_anglelimitdlg && (s_platemenukind == SPPLATEMENUKIND_RETARGET) && (s_platemenuno == (SPRETARGETSW_LIMITEULER + 1))) {
		if ((s_curdseullimitctrlno >= 0) && (s_curdseullimitctrlno < s_dseullimitctrls.size()) && s_dseullimitctrls[s_curdseullimitctrlno]) {
			::EnumChildWindows(s_limiteuldlg.GetHWnd(), EnumChildProc, (LPARAM)&retctrlwnd);
			retctrlwnd = GetNearestEnumDist();
			if (retctrlwnd) {
				s_ofhwnd = s_limiteuldlg.GetHWnd();
				return retctrlwnd;
			}
		}
	}
	else if (!retctrlwnd && s_savechadlghwnd) {
		::EnumChildWindows(s_savechadlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_savechadlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_bvhdlghwnd) {
		::EnumChildWindows(s_bvhdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_bvhdlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_saveredlghwnd) {
		::EnumChildWindows(s_saveredlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_saveredlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_savegcodlghwnd) {
		::EnumChildWindows(s_savegcodlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_savegcodlghwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_rotzisdlghwnd) {
		::EnumChildWindows(s_rotzisdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_rotzisdlghwnd;

			//WCHAR chkclassname[MAX_PATH] = { 0L };
			//::GetClassName(retctrlwnd, chkclassname, MAX_PATH);
			//::DSMessageBox(NULL, chkclassname, L"check!!!", MB_OK);

			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_customrighwnd) {
		::EnumChildWindows(s_customrighwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_customrighwnd;
			return retctrlwnd;
		}
	}
	else if (!retctrlwnd && s_mqodlghwnd) {
		::EnumChildWindows(s_exportxdlghwnd, EnumChildProc, (LPARAM)&retctrlwnd);
		retctrlwnd = GetNearestEnumDist();
		if (retctrlwnd) {
			s_ofhwnd = s_exportxdlghwnd;
			return retctrlwnd;
		}
	}

	return 0;

}



void OrgWindowListenMouse(bool srcflag)
{
	if (s_timelineWnd) {
		s_timelineWnd->setListenMouse(srcflag);
	}
	if (s_LtimelineWnd) {
		s_LtimelineWnd->setListenMouse(srcflag);
	}
	if (s_dampanimdlg.GetVisible()) {
		s_dampanimdlg.ListenMouse(srcflag);
	}
	if (s_sidemenuWnd) {
		s_sidemenuWnd->setListenMouse(srcflag);
	}
	if (s_topSlidersWnd) {
		s_topSlidersWnd->setListenMouse(srcflag);
	}
	if (s_placefolderWnd) {
		s_placefolderWnd->setListenMouse(srcflag);
	}
	if (s_rigidparamsdlg.GetVisible()) {
		s_rigidparamsdlg.ListenMouse(srcflag);
	}
	if (s_displimitsdlg.GetVisible()) {
		s_displimitsdlg.ListenMouse(srcflag);
	}
	if (s_bulletdlg.GetVisible()) {
		s_bulletdlg.ListenMouse(srcflag);
	}
	if (s_shadertypedlg.GetVisible()) {
		s_shadertypedlg.ListenMouse(srcflag);
	}
	if (s_impulsedlg.GetVisible()) {
		s_impulsedlg.ListenMouse(srcflag);
	}
	if (s_gplanedlg.GetVisible()) {
		s_gplanedlg.ListenMouse(srcflag);
	}
	if (s_toolWnd) {
		s_toolWnd->setListenMouse(srcflag);
	}
	if (s_retargetdlg.GetVisible()) {
		s_retargetdlg.ListenMouse(srcflag);
	}
	if (s_layerWnd) {
		s_layerWnd->setListenMouse(srcflag);
	}

	//anglelimitdlgはWindowsDialog

}

void DSMessageBox(HWND srcparenthwnd, const WCHAR* srcmessage, const WCHAR* srctitle, LONG srcok)
{
	if (!srcmessage || !srctitle) {
		return;
	}

	_ASSERT(srcok == MB_OK);

	int cmperror;
	int cmpwarning;
	int cmpcheck;
	cmperror = wcscmp(srctitle, L"error!!!");
	cmpwarning = wcscmp(srctitle, L"warning!!!");
	cmpcheck = wcscmp(srctitle, L"check!!!");
	_ASSERT((cmperror == 0) || (cmpwarning == 0) || (cmpcheck == 0));


	s_messageboxhwnd = 0;
	s_messageboxpushcnt = 0;
	//HWINEVENTHOOK hhook = SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, 0,
	//	WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
	InterlockedExchange(&g_undertrackingRMenu, (LONG)1);

	::MessageBoxW(srcparenthwnd, srcmessage, srctitle, srcok);

	InterlockedExchange(&g_undertrackingRMenu, (LONG)0);
	//UnhookWinEvent(hhook);
	s_messageboxhwnd = 0;
	s_messageboxpushcnt = 0;
}

void SetMainWindowTitle()
{
	if (!g_mainhwnd) {
		return;
	}



	WCHAR strmaintitle[MAX_PATH * 3] = { 0L };
	swprintf_s(strmaintitle, MAX_PATH * 3, L"AdditiveIK Ver1.0.0.30 : No.%d : ", s_appcnt);//本体のバージョン


	if (s_model && s_chascene) {
		//WCHAR strcharactor[MAX_PATH * 3] = { 0L };
		WCHAR strindexedcharactor[MAX_PATH * 3] = { 0L };
		char strmotionA[MAX_PATH * 3] = { 0 };
		WCHAR strmotionW[MAX_PATH * 3] = { 0 };
		WCHAR strrefW[MAX_PATH * 3] = { 0 };

		int modelnum = s_chascene->GetModelNum();

		if ((modelnum >= 1) && (s_curmodelmenuindex >= 0) && (s_curmodelmenuindex < modelnum)) {
			CModel* curmodel;
			curmodel = s_chascene->GetModel(s_curmodelmenuindex);
			if (curmodel) {
				swprintf_s(strindexedcharactor, MAX_PATH * 3, L"%d : %s", s_curmodelmenuindex, curmodel->GetFileName());
				wcscat_s(strmaintitle, (MAX_PATH * 3), strindexedcharactor);
				wcscat_s(strmaintitle, (MAX_PATH * 3), L" : ");

				if (curmodel->GetCurrentMotName(strmotionA, (MAX_PATH * 3)) == 0) {
					MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, strmotionA, (MAX_PATH * 3), strmotionW, (MAX_PATH * 3));
					wcscat_s(strmaintitle, (MAX_PATH * 3), strmotionW);
					wcscat_s(strmaintitle, (MAX_PATH * 3), L" : ");
				}

				int retrefindex = -1;
				REINFO reinfo;
				reinfo = s_model->GetCurrentRigidElemInfo(&retrefindex);
				if (retrefindex >= 0) {
					MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, reinfo.filename, (MAX_PATH * 3), strrefW, (MAX_PATH * 3));
					wcscat_s(strmaintitle, (MAX_PATH * 3), strrefW);
				}
				else {
					wcscat_s(strmaintitle, (MAX_PATH * 3), L"reffile unknown");
				}
			}
		}
	}

	SetWindowText(g_mainhwnd, strmaintitle);

}


int SaveRtgHistory(WCHAR* selectname)
{
	WCHAR saveprojpath[MAX_PATH] = { 0L };
	wcscpy_s(saveprojpath, MAX_PATH, selectname);

	//書き込み処理が成功してから履歴を保存する。rtgファイル。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
	swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProjRtgDir_%04u%02u%02u%02u%02u%02u.txt",
		s_temppath,
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	HANDLE hfile;
	hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile != INVALID_HANDLE_VALUE) {
		//int pathlen;
		//pathlen = (int)wcslen(saveprojpath);
		if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
			DWORD writelen = 0;
			WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
			_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
		}
		CloseHandle(hfile);
	}

	return 0;
}



int Savebvh2FBXHistory(WCHAR* selectname)
{
	WCHAR saveprojpath[MAX_PATH] = { 0L };
	wcscpy_s(saveprojpath, MAX_PATH, selectname);


	//書き込み処理が成功してから履歴を保存する。chaファイルだけ。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
	swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProjBvhDir_%04u%02u%02u%02u%02u%02u.txt",
		s_temppath,
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	HANDLE hfile;
	hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile != INVALID_HANDLE_VALUE) {
		//int pathlen;
		//pathlen = (int)wcslen(saveprojpath);
		if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
			DWORD writelen = 0;
			WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
			_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
		}
		CloseHandle(hfile);
	}

	return 0;
}


int SaveBatchHistory(WCHAR* selectname)
{
	WCHAR saveprojpath[MAX_PATH] = { 0L };
	wcscpy_s(saveprojpath, MAX_PATH, selectname);


	//書き込み処理が成功してから履歴を保存する。chaファイルだけ。
	size_t savepathlen;
	saveprojpath[MAX_PATH - 1] = 0L;
	savepathlen = wcslen(saveprojpath);
	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	WCHAR HistoryForOpeningProjectWithGamePad[MAX_PATH] = { 0L };
	swprintf_s(HistoryForOpeningProjectWithGamePad, MAX_PATH, L"%s\\MB3DOpenProjBatchDir_%04u%02u%02u%02u%02u%02u.txt",
		s_temppath,
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);
	HANDLE hfile;
	hfile = CreateFile(HistoryForOpeningProjectWithGamePad, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile != INVALID_HANDLE_VALUE) {
		//int pathlen;
		//pathlen = (int)wcslen(saveprojpath);
		if ((savepathlen > 0) && (savepathlen < MAX_PATH)) {
			DWORD writelen = 0;
			WriteFile(hfile, saveprojpath, (DWORD)(savepathlen * sizeof(WCHAR)), &writelen, NULL);
			_ASSERT((savepathlen * sizeof(WCHAR)) == writelen);
		}
		CloseHandle(hfile);
	}

	return 0;
}

bool FindAtTheLast(std::wstring const& strsource, std::wstring const& strpat) {
	if (strsource.length() < strpat.length()) {
		return false;
	}
	return (strsource.rfind(strpat) == (strsource.size() - strpat.size()));
}

int GetchaHistoryDir(std::vector<wstring>& dstvecopenfilename, int filter_cha)
{
	//##################################
	//2023/07/22 pagenumをリターンする
	//##################################


	dstvecopenfilename.clear();

	//MB3DOpenProj_20210410215628.txt
	WCHAR searchfilename[MAX_PATH] = { 0L };
	swprintf_s(searchfilename, MAX_PATH, L"%sMB3DOpenProj_*.txt", s_temppath);
	HANDLE hFind;
	WIN32_FIND_DATA win32fd;
	hFind = FindFirstFileW(searchfilename, &win32fd);

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	std::vector<wstring> vecopenfilename;//!!!!!!!! tmpファイル内に書いてあるopenfilename

	vechistory.clear();
	bool notfoundfirst = true;
	if (hFind != INVALID_HANDLE_VALUE) {
		notfoundfirst = false;
		do {
			if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

				HISTORYELEM curelem;
				curelem.Init();
				curelem.filetime = win32fd.ftCreationTime;

				//printf("%s\n", win32fd.cFileName);
				curelem.wfilename[MAX_PATH - 1] = { 0L };
				swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

				vechistory.push_back(curelem);
			}
		} while (FindNextFile(hFind, &win32fd));
		FindClose(hFind);
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		int numhistory = (int)vechistory.size();
		//int dispnum = min(OPENHISTORYMAXNUM, numhistory);

		int foundnum = 0;
		int historyno;
		for (historyno = 0; historyno < numhistory; historyno++) {
			WCHAR openfilename[MAX_PATH] = { 0L };
			wcscpy_s(openfilename, MAX_PATH, vechistory[historyno].wfilename);

			HANDLE hfile;
			hfile = CreateFileW(openfilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				WCHAR readwstr[MAX_PATH] = { 0L };
				DWORD readleng = 0;
				bool bsuccess;
				bsuccess = ReadFile(hfile, readwstr, (MAX_PATH * sizeof(WCHAR)), &readleng, NULL);
				if (bsuccess) {

					CloseHandle(hfile);//読み終わったら閉じる

					bool foundsame = false;
					wstring newwstr = readwstr;
					std::vector<wstring>::iterator itropenfilename;
					for (itropenfilename = vecopenfilename.begin(); itropenfilename != vecopenfilename.end(); itropenfilename++) {
						if (newwstr.compare(*itropenfilename) == 0) {
							foundsame = true;
						}
					}
					if (foundsame == false) {
						bool filtermatch = false;
						if (filter_cha == 1) {
							if (FindAtTheLast(newwstr, L".cha")) {
								filtermatch = true;
							}
							else {
								filtermatch = false;
							}
						}
						else {
							if (FindAtTheLast(newwstr, L".fbx")) {
								filtermatch = true;
							}
							else {
								filtermatch = false;
							}
						}


						if (filtermatch == true) {
							DWORD fattr;
							fattr = GetFileAttributes(readwstr);
							if ((fattr != INVALID_FILE_ATTRIBUTES) && 
								((fattr & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
								((fattr & FILE_ATTRIBUTE_SYSTEM) == 0)
								) {

								//ファイルが存在する場合
								vecopenfilename.push_back(readwstr);
								foundnum++;
							}
							else if (fattr == INVALID_FILE_ATTRIBUTES) {
								//2023/10/04
								//ファイルが存在しない場合　履歴を削除する
								DeleteFileW(openfilename);
							}
						}
						//if (foundnum >= dispnum) {
						if (foundnum >= numhistory) {
							break;
						}
					}
					else {
						//2023/10/04
						//重複する履歴は削除する(履歴が多すぎるとオープン処理が重くなるため)
						DeleteFileW(openfilename);
					}
				}
				else {
					CloseHandle(hfile);//読み終わったら閉じる
				}
			}
		}

		//重複を除いたヒストリー
		//ここではまだカレントページ番号が確定していないのでページングは無し
		int numhistory2 = (int)vecopenfilename.size();
		if (numhistory2 > 0) {
			int nameno;
			for (nameno = 0; nameno < numhistory2; nameno++) {
				wstring currentnanme = vecopenfilename[nameno];
				dstvecopenfilename.push_back(currentnanme);
			}

			//ページ総数は分かる
			int fullpagenum = numhistory2 / OPENHISTORYMAXNUM;//満たされているページの数
			int pagenum = fullpagenum;//端数込みのページ数
			if ((numhistory2 - fullpagenum * OPENHISTORYMAXNUM) > 0) {
				pagenum++;
			}
			return pagenum;

		}
		else {
			dstvecopenfilename.clear();
			return 0;
		}
	}
	else {
		dstvecopenfilename.clear();
		return 0;
	}

	return 0;

}

int GetRtgHistoryDir(std::vector<wstring>& dstvecopenfilename)
{
	//##################################
	//2023/07/22 pagenumをリターンする
	//##################################

	dstvecopenfilename.clear();
	//ZeroMemory(dstname, sizeof(WCHAR) * dstlen);


	//MB3DOpenProj_20210410215628.txt
	WCHAR searchfilename[MAX_PATH] = { 0L };
	swprintf_s(searchfilename, MAX_PATH, L"%sMB3DOpenProjRtgDir_*.txt", s_temppath);
	HANDLE hFind;
	WIN32_FIND_DATA win32fd;
	hFind = FindFirstFileW(searchfilename, &win32fd);

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	std::vector<wstring> vecopenfilename;//!!!!!!!! tmpファイル内に書いてあるopenfilename

	vechistory.clear();
	bool notfoundfirst = true;
	if (hFind != INVALID_HANDLE_VALUE) {
		notfoundfirst = false;
		do {
			if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
				HISTORYELEM curelem;
				curelem.Init();
				curelem.filetime = win32fd.ftCreationTime;

				//printf("%s\n", win32fd.cFileName);
				curelem.wfilename[0] = { 0L };
				curelem.wfilename[MAX_PATH - 1] = { 0L };
				swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

				vechistory.push_back(curelem);
			}
		} while (FindNextFile(hFind, &win32fd));
		FindClose(hFind);
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		int numhistory = (int)vechistory.size();
		//int dispnum = min(OPENHISTORYMAXNUM, numhistory);

		int foundnum = 0;
		int historyno;
		for (historyno = 0; historyno < numhistory; historyno++) {
			WCHAR openfilename[MAX_PATH] = { 0L };
			openfilename[0] = { 0L };
			wcscpy_s(openfilename, MAX_PATH, vechistory[historyno].wfilename);

			HANDLE hfile;
			hfile = CreateFileW(openfilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				WCHAR readwstr[MAX_PATH] = { 0L };
				readwstr[0L] = { 0L };
				DWORD readleng = 0;
				bool bsuccess;
				bsuccess = ReadFile(hfile, readwstr, (MAX_PATH * sizeof(WCHAR)), &readleng, NULL);
				if (bsuccess) {

					CloseHandle(hfile);//読み終わったら閉じる

					bool foundsame = false;
					wstring newwstr = readwstr;
					std::vector<wstring>::iterator itropenfilename;
					for (itropenfilename = vecopenfilename.begin(); itropenfilename != vecopenfilename.end(); itropenfilename++) {
						if (newwstr.compare(*itropenfilename) == 0) {
							foundsame = true;
						}
					}
					if (foundsame == false) {
						DWORD fattr;
						fattr = GetFileAttributes(readwstr);
						if ((fattr != INVALID_FILE_ATTRIBUTES) &&
							((fattr & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
							((fattr & FILE_ATTRIBUTE_SYSTEM) == 0)
							) {

							//ファイルが存在する場合
							vecopenfilename.push_back(readwstr);
							foundnum++;
						}
						else if (fattr == INVALID_FILE_ATTRIBUTES) {
							//2023/10/04
							//ファイルが存在しない場合　履歴を削除する
							DeleteFileW(openfilename);
						}


						//if (foundnum >= dispnum) {
						if (foundnum >= numhistory) {
							break;
						}
					}
					else {
						//2023/10/04
						//重複する履歴は削除する(履歴が多すぎるとオープン処理が重くなるため)
						DeleteFileW(openfilename);
					}

				}
				else {
					CloseHandle(hfile);//読み終わったら閉じる
				}
			}
		}


		//重複を除いたヒストリー
		//ここではまだカレントページ番号が確定していないのでページングは無し
		int numhistory2 = (int)vecopenfilename.size();
		if (numhistory2 > 0) {
			int nameno;
			for (nameno = 0; nameno < numhistory2; nameno++) {
				wstring currentnanme = vecopenfilename[nameno];
				dstvecopenfilename.push_back(currentnanme);
			}

			//ページ総数は分かる
			int fullpagenum = numhistory2 / OPENHISTORYMAXNUM;//満たされているページの数
			int pagenum = fullpagenum;//端数込みのページ数
			if ((numhistory2 - fullpagenum * OPENHISTORYMAXNUM) > 0) {
				pagenum++;
			}
			return pagenum;

		}
		else {
			dstvecopenfilename.clear();
			return 0;
		}
	}
	else {
		dstvecopenfilename.clear();
		return 0;
	}

	return 0;

}


int GetbvhHistoryDir(std::vector<wstring>& dstvecopenfilename)
{
	//##################################
	//2023/07/22 pagenumをリターンする
	//##################################

	dstvecopenfilename.clear();
	//ZeroMemory(dstname, sizeof(WCHAR) * dstlen);


	//MB3DOpenProj_20210410215628.txt
	WCHAR searchfilename[MAX_PATH] = { 0L };
	swprintf_s(searchfilename, MAX_PATH, L"%sMB3DOpenProjBvhDir_*.txt", s_temppath);
	HANDLE hFind;
	WIN32_FIND_DATA win32fd;
	hFind = FindFirstFileW(searchfilename, &win32fd);

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	std::vector<wstring> vecopenfilename;//!!!!!!!! tmpファイル内に書いてあるopenfilename

	vechistory.clear();
	bool notfoundfirst = true;
	if (hFind != INVALID_HANDLE_VALUE) {
		notfoundfirst = false;
		do {
			if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
				HISTORYELEM curelem;
				curelem.Init();
				curelem.filetime = win32fd.ftCreationTime;

				//printf("%s\n", win32fd.cFileName);
				curelem.wfilename[0] = { 0L };
				curelem.wfilename[MAX_PATH - 1] = { 0L };
				swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

				vechistory.push_back(curelem);
			}
		} while (FindNextFile(hFind, &win32fd));
		FindClose(hFind);
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		int numhistory = (int)vechistory.size();
		//int dispnum = min(OPENHISTORYMAXNUM, numhistory);

		int foundnum = 0;
		int historyno;
		for (historyno = 0; historyno < numhistory; historyno++) {
			WCHAR openfilename[MAX_PATH] = { 0L };
			openfilename[0] = { 0L };
			wcscpy_s(openfilename, MAX_PATH, vechistory[historyno].wfilename);

			HANDLE hfile;
			hfile = CreateFileW(openfilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				WCHAR readwstr[MAX_PATH] = { 0L };
				readwstr[0L] = { 0L };
				DWORD readleng = 0;
				bool bsuccess;
				bsuccess = ReadFile(hfile, readwstr, (MAX_PATH * sizeof(WCHAR)), &readleng, NULL);
				if (bsuccess) {

					CloseHandle(hfile);//読み終わったら閉じる

					bool foundsame = false;
					wstring newwstr = readwstr;
					std::vector<wstring>::iterator itropenfilename;
					for (itropenfilename = vecopenfilename.begin(); itropenfilename != vecopenfilename.end(); itropenfilename++) {
						if (newwstr.compare(*itropenfilename) == 0) {
							foundsame = true;
						}
					}
					if (foundsame == false) {
						DWORD fattr;
						fattr = GetFileAttributes(readwstr);
						if ((fattr != INVALID_FILE_ATTRIBUTES) &&
							((fattr & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
							((fattr & FILE_ATTRIBUTE_SYSTEM) == 0)
							) {

							//ファイルが存在する場合
							vecopenfilename.push_back(readwstr);
							foundnum++;
						}
						else if (fattr == INVALID_FILE_ATTRIBUTES) {
							//2023/10/04
							//ファイルが存在しない場合　履歴を削除する
							DeleteFileW(openfilename);
						}

						//if (foundnum >= dispnum) {
						if (foundnum >= numhistory) {
							break;
						}
					}
					else {
						//2023/10/04
						//重複する履歴は削除する(履歴が多すぎるとオープン処理が重くなるため)
						DeleteFileW(openfilename);
					}
				}
				else {
					CloseHandle(hfile);//読み終わったら閉じる
				}
			}
		}

		//重複を除いたヒストリー
		//ここではまだカレントページ番号が確定していないのでページングは無し
		int numhistory2 = (int)vecopenfilename.size();
		if (numhistory2 > 0) {
			int nameno;
			for (nameno = 0; nameno < numhistory2; nameno++) {
				wstring currentnanme = vecopenfilename[nameno];
				dstvecopenfilename.push_back(currentnanme);
			}

			//ページ総数は分かる
			int fullpagenum = numhistory2 / OPENHISTORYMAXNUM;//満たされているページの数
			int pagenum = fullpagenum;//端数込みのページ数
			if ((numhistory2 - fullpagenum * OPENHISTORYMAXNUM) > 0) {
				pagenum++;
			}
			return pagenum;

		}
		else {
			dstvecopenfilename.clear();
			return 0;
		}
	}
	else {
		dstvecopenfilename.clear();
		return 0;
	}

	return 0;
}

int GetCPTFileName(std::vector<HISTORYELEM>& dstvecopenfilename)
{

	dstvecopenfilename.clear();

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	vechistory.clear();

	{
		//MB3DOpenProj_20210410215628.txt
		WCHAR searchfilename[MAX_PATH] = { 0L };
		searchfilename[0] = { 0L };
		swprintf_s(searchfilename, MAX_PATH, L"%sMB3DTempCopyFrames_v1.0.0.18_*.cpt", s_temppath);
		HANDLE hFind;
		WIN32_FIND_DATA win32fd;
		hFind = FindFirstFileW(searchfilename, &win32fd);

		bool notfoundfirst = true;
		if (hFind != INVALID_HANDLE_VALUE) {
			notfoundfirst = false;
			do {
				if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
					HISTORYELEM curelem;
					curelem.Init();
					curelem.filetime = win32fd.ftCreationTime;

					//printf("%s\n", win32fd.cFileName);
					curelem.wfilename[MAX_PATH - 1] = { 0L };
					curelem.wfilename[0] = { 0L };
					swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

					vechistory.push_back(curelem);
				}
			} while (FindNextFile(hFind, &win32fd));
			FindClose(hFind);
		}
	}
	{
		//MB3DOpenProj_20210410215628.txt
		WCHAR searchfilename[MAX_PATH] = { 0L };
		searchfilename[0] = { 0L };
		swprintf_s(searchfilename, MAX_PATH, L"%sMB3DTempCopyFrames_v1.0.0.23_*.cpt", s_temppath);//ファイルのバージョン
		HANDLE hFind;
		WIN32_FIND_DATA win32fd;
		hFind = FindFirstFileW(searchfilename, &win32fd);

		bool notfoundfirst = true;
		if (hFind != INVALID_HANDLE_VALUE) {
			notfoundfirst = false;
			do {
				if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
					HISTORYELEM curelem;
					curelem.Init();
					curelem.filetime = win32fd.ftCreationTime;

					//printf("%s\n", win32fd.cFileName);
					curelem.wfilename[MAX_PATH - 1] = { 0L };
					curelem.wfilename[0] = { 0L };
					swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

					vechistory.push_back(curelem);
				}
			} while (FindNextFile(hFind, &win32fd));
			FindClose(hFind);
		}
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		std::vector<HISTORYELEM>::iterator itrhistoryelem;
		for (itrhistoryelem = vechistory.begin(); itrhistoryelem != vechistory.end(); itrhistoryelem++) {
			HISTORYELEM curelem;
			curelem.Init();
			curelem = *itrhistoryelem;
			int result = LoadCPIFile(&curelem);
			//_ASSERT(result == 0);
			*itrhistoryelem = curelem;//失敗した時にはnewelem.hascpinfo = 0がセットされている
		}
	}

	if (!vechistory.empty()) {
		dstvecopenfilename = vechistory;
	}

	//if (!vecopenfilename.empty()) {
	//	dstvecopenfilename = vecopenfilename;
	//}
	//else {
	//	dstvecopenfilename.clear();
	//}
	return 0;
}

int GetBatchHistoryDir(WCHAR* dstname, int dstlen)
{

	ZeroMemory(dstname, sizeof(WCHAR) * dstlen);


	//MB3DOpenProj_20210410215628.txt
	WCHAR searchfilename[MAX_PATH] = { 0L };
	swprintf_s(searchfilename, MAX_PATH, L"%sMB3DOpenProjBatchDir_*.txt", s_temppath);
	HANDLE hFind;
	WIN32_FIND_DATA win32fd;
	hFind = FindFirstFileW(searchfilename, &win32fd);

	std::vector<HISTORYELEM> vechistory;//!!!!!!!!! tmpファイル名
	std::vector<wstring> vecopenfilename;//!!!!!!!! tmpファイル内に書いてあるopenfilename

	vechistory.clear();
	bool notfoundfirst = true;
	if (hFind != INVALID_HANDLE_VALUE) {
		notfoundfirst = false;
		do {
			if ((win32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
				HISTORYELEM curelem;
				curelem.Init();
				curelem.filetime = win32fd.ftCreationTime;

				//printf("%s\n", win32fd.cFileName);
				curelem.wfilename[MAX_PATH - 1] = { 0L };
				swprintf_s(curelem.wfilename, MAX_PATH, L"%s%s", s_temppath, win32fd.cFileName);

				vechistory.push_back(curelem);
			}
		} while (FindNextFile(hFind, &win32fd));
		FindClose(hFind);
	}

	if (!vechistory.empty()) {

		std::sort(vechistory.begin(), vechistory.end());
		std::reverse(vechistory.begin(), vechistory.end());

		int numhistory = (int)vechistory.size();
		int dispnum = min(OPENHISTORYMAXNUM, numhistory);

		int foundnum = 0;
		int historyno;
		for (historyno = 0; historyno < numhistory; historyno++) {
			WCHAR openfilename[MAX_PATH] = { 0L };
			wcscpy_s(openfilename, MAX_PATH, vechistory[historyno].wfilename);

			HANDLE hfile;
			hfile = CreateFileW(openfilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
				FILE_FLAG_SEQUENTIAL_SCAN, NULL);
			if (hfile != INVALID_HANDLE_VALUE) {
				WCHAR readwstr[MAX_PATH] = { 0L };
				DWORD readleng = 0;
				bool bsuccess;
				bsuccess = ReadFile(hfile, readwstr, (MAX_PATH * sizeof(WCHAR)), &readleng, NULL);
				if (bsuccess) {

					CloseHandle(hfile);//読み終わったら閉じる

					bool foundsame = false;
					wstring newwstr = readwstr;
					std::vector<wstring>::iterator itropenfilename;
					for (itropenfilename = vecopenfilename.begin(); itropenfilename != vecopenfilename.end(); itropenfilename++) {
						if (newwstr.compare(*itropenfilename) == 0) {
							foundsame = true;
						}
					}
					if (foundsame == false) {
						vecopenfilename.push_back(readwstr);
						foundnum++;
						if (foundnum >= dispnum) {
							break;
						}
					}
					else {
						//2023/10/04
						//重複する履歴は削除する(履歴が多すぎるとオープン処理が重くなるため)
						DeleteFileW(openfilename);
					}
				}
				else {
					CloseHandle(hfile);
				}
				
			}
		}
	}

	if (!vecopenfilename.empty()) {
		wcscpy_s(dstname, dstlen, vecopenfilename[0].c_str());
	}
	else {
		*dstname = 0L;
	}

	return 0;
}


//int CopyToClipBoardData(int shdnum, int cpframenum, COPYELEM* cpELem, HGLOBAL* cbhgptr)
//{
//	int ret = 0;
//	HGLOBAL hGlobal = 0;
//	//int datasize;
//	int headerlen, shdnumlen, framenumlen, celen;
//	int dstcharsize;
//
//	headerlen = (int)strlen(clipboardheader2);
//	shdnumlen = sizeof(int);
//	framenumlen = sizeof(int);
//	celen = sizeof(COPYELEM) * shdnum * cpframenum;
//	//datasize = headerlen + numlen + celen;
//	dstcharsize = headerlen + (shdnumlen * 2) + (framenumlen * 2) + (celen * 2) + 1;// char以外の1byte --> 2文字、と終端ＮＵＬＬ
//
//
//	hGlobal = GlobalAlloc(GHND, dstcharsize);
//	if (hGlobal == NULL) {
//		DbgOut("motparamdlg : CopyToClipBoardData : GlobalAlloc error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//
//	char* dstptr;
//	dstptr = (char*)GlobalLock(hGlobal);
//	if (!dstptr) {
//		DbgOut("motparamdlg : CopyToClipBoardData : GlobalLock error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//
//	int dstpos = 0;
//	strcpy_s(dstptr, dstcharsize - dstpos, clipboardheader2);
//	dstpos += headerlen;
//
//	ret = Bin2Char((unsigned char*)&shdnum, dstptr + dstpos, shdnumlen);
//	if (ret) {
//		DbgOut("motparamdlg : CopyToClipBoardData : Bin2Char shdnum error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//	dstpos += shdnumlen * 2;
//
//
//	ret = Bin2Char((unsigned char*)&cpframenum, dstptr + dstpos, framenumlen);
//	if (ret) {
//		DbgOut("motparamdlg : CopyToClipBoardData : Bin2Char cpframenum error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//	dstpos += framenumlen * 2;
//
//
//	ret = Bin2Char((unsigned char*)srcce, dstptr + dstpos, celen);
//	if (ret) {
//		DbgOut("motparamdlg : CopyToClipBoardData : Bin2Char ce error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//	dstpos += celen * 2;
//
//	*(dstptr + dstpos) = 0;//!!!!!
//
//	if (dstpos > dstcharsize) {
//		DbgOut("motparamdlg : CopyToClipBoardData : dstpos error !!!\n");
//		_ASSERT(0);
//		ret = 1;
//		goto cptocbexit;
//	}
//
//
//	goto cptocbexit;
//
//cptocbexit:
//	if (hGlobal)
//		GlobalUnlock(hGlobal);
//	if (ret && hGlobal)
//		GlobalFree(hGlobal);
//
//	*cbhgptr = hGlobal;
//	return ret;
//}
//
//int Bin2Char(unsigned char* srcptr, char* dstptr, int srclen)
//{
//	int srcpos;
//	int dstpos = 0;
//	//int ret;
//	unsigned char curuc;
//	unsigned char lowuc, hiuc;
//	char lowc, hic;
//	for (srcpos = 0; srcpos < srclen; srcpos++) {
//		curuc = *(srcptr + srcpos);
//
//		hiuc = curuc >> 4;
//		if (hiuc <= 9) {
//			hic = '0' + hiuc;
//		}
//		else {
//			hic = 'A' + hiuc - 10;
//		}
//
//		lowuc = curuc & 0x0F;
//		if (lowuc <= 9) {
//			lowc = '0' + lowuc;
//		}
//		else {
//			lowc = 'A' + lowuc - 10;
//		}
//
//		*(dstptr + dstpos) = hic;
//		*(dstptr + dstpos + 1) = lowc;
//		dstpos += 2;
//	}
//
//	return 0;
//}
//
//
//
//int PasteFromClipBoardData(COPYELEM* dstce, int* bufshdnum, int* bufframenum, HGLOBAL cbhg)
//{
//	*bufshdnum = 0;
//	*bufframenum = 0;
//
//	char* srcptr;
//
//	srcptr = (char*)GlobalLock(cbhg);
//	if (!srcptr) {
//		DbgOut("motparamdlg : PasteFromClipBoardData : GlobalLock error !!!\n");
//		_ASSERT(0);
//		return 1;
//	}
//
//	int headerleng;
//	headerleng = (int)strlen(clipboardheader2);
//
//	int srcleng;
//	srcleng = (int)strlen(srcptr);
//	int minimumleng = headerleng + sizeof(int) * 2 + sizeof(int) * 2;
//	if (srcleng <= minimumleng) {
//		DbgOut("motparamdlg : PasteFromClipBoardData : srcleng 0 error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードにデータがありませんでした。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//
//	int srcpos = 0;
//	int cmp0;
//	cmp0 = strncmp(srcptr, clipboardheader2, headerleng);
//	if (cmp0) {
//		DbgOut("motparamdlg : PasteFromClipBoardData : invalid data type error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードのデータの種類が違います。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//	srcpos += headerleng;
//
//
//	int ret;
//	int shdnum;
//	ret = Char2Hex(srcptr + srcpos, (unsigned char*)&shdnum, sizeof(int) * 2);
//	if (ret) {
//		DbgOut("motparamdlg : PasteFromClipBoard : Char2Hex shdnum error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードのデータが不正です。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//	srcpos += (sizeof(int) * 2);
//
//	int framenum;
//	ret = Char2Hex(srcptr + srcpos, (unsigned char*)&framenum, sizeof(int) * 2);
//	if (ret || (framenum <= 0) || (framenum > CPFRAMEMAX)) {
//		DbgOut("motparamdlg : PasteFromClipBoard : Char2Hex framenum error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードのデータが不正です。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//	srcpos += (sizeof(int) * 2);
//
//	int cesize;
//	cesize = shdnum * sizeof(COPYELEM) * framenum;
//	int sizeondata;
//	sizeondata = srcleng - headerleng - (sizeof(int) * 2) - (sizeof(int) * 2);
//	if (sizeondata != (cesize * 2)) {
//		DbgOut("motparamdlg : PasteFromClipBoard : data size error !!!\n");
//		::MessageBox(m_hWnd, "クリップボードのデータ長が不正です。", "ペースト失敗", MB_OK);
//		_ASSERT(0);
//		GlobalUnlock(cbhg);
//		return 1;
//	}
//
//
//	InitCEBuff();//!!!!!!!!!!!!
//
//	int framecnt;
//	int ceno;
//	COPYELEM tempce;
//	for (framecnt = 0; framecnt < framenum; framecnt++) {
//		for (ceno = 0; ceno < shdnum; ceno++) {
//			ret = Char2Hex(srcptr + srcpos, (unsigned char*)&tempce, sizeof(COPYELEM) * 2);
//			if (ret) {
//				DbgOut("motparamdlg : PasteFromClipBoard : Char2Hex ce %d %d error !!!\n", ceno, shdnum);
//				::MessageBox(m_hWnd, "データ変換中にエラーが生じました。", "ペースト失敗", MB_OK);
//				_ASSERT(0);
//				GlobalUnlock(cbhg);
//				return 1;
//			}
//			srcpos += (sizeof(COPYELEM) * 2);
//
//			tempce.mp.m_spp = 0;//!!!!!!!!!!
//
//			if (tempce.mp.m_frameno >= 0) {
//
//				//tempceの名前に対応するserialnoを探し、そのmpにデータをコピーする。
//				int chkleng;
//				chkleng = (int)strlen(tempce.name);
//				if (chkleng >= 256) {
//					DbgOut("motparamdlg : PasteFromClipBoard : check tempce name error %d !!!\n", ceno);
//					::MessageBox(m_hWnd, "不正な名前が見つかりました。１", "ペースト失敗", MB_OK);
//					_ASSERT(0);
//					GlobalUnlock(cbhg);
//					return 1;
//				}
//
//				int findno;
//				//ret = m_thandler->GetPartNoByName( tempce.name, &findno );
//				ret = m_thandler->GetBoneNoByName(tempce.name, &findno, m_shandler, 0);
//				if (ret) {
//					DbgOut("motparamdlg : PasteFromClipBoard : GetPartNoByName error !!!\n");
//					::MessageBox(m_hWnd, "不正な名前が見つかりました。２", "ペースト失敗", MB_OK);
//					_ASSERT(0);
//					GlobalUnlock(cbhg);
//					return 1;
//				}
//
//				if (findno > 0) {
//					*(m_CEBuff + shdnum * framecnt + findno) = tempce;//!!!!!!!!
//				}
//			}
//		}
//	}
//
//	GlobalUnlock(cbhg);
//
//	*bufshdnum = shdnum;
//	*bufframenum = framenum;
//
//	return 0;
//}
//
//
//int Char2Hex(char* orgdata, unsigned char* donedata, DWORD charleng)
//{
//	int ret;
//	DWORD charno;
//	DWORD rest;
//
//	unsigned char ucval;
//	unsigned char* doneptr = 0;
//
//
//	rest = charleng % 2;
//	if (rest) {
//		_ASSERT(0);
//		return 1;
//	}
//
//	doneptr = donedata;
//	for (charno = 0; charno < charleng; charno += 2) {
//		ret = ConvData(orgdata + charno, &ucval, 0);
//		_ASSERT(!ret);
//
//		ret = ConvData(orgdata + charno + 1, &ucval, 1);
//		_ASSERT(!ret);
//
//		*doneptr = ucval;
//		doneptr++;
//	}
//
//	return 0;
//}
//
//int ConvData(char* charptr, unsigned char* ucptr, int pos)
//{
//	char charval;
//	unsigned char convval;
//
//	charval = *charptr;
//	if ((charval >= '0') && (charval <= '9')) {
//		convval = charval - '0';
//	}
//	else if ((charval >= 'A') && (charval <= 'F')) {
//		convval = charval - 'A' + 10;
//	}
//	else {
//		_ASSERT(0);
//		return 1;
//	}
//
//	if (pos == 0) {
//		*ucptr = convval << 4;
//	}
//	else {
//		*ucptr |= convval;
//	}
//
//	return 0;
//}


int WriteCPTFile(WCHAR* dstfilename)
{
	int cpelemnum;
	cpelemnum = (int)s_copymotvec.size();
	if (cpelemnum <= 0) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}
	if (!s_model->ExistCurrentMotion()) {
		return 0;
	}

	if (!dstfilename) {
		return 0;
	}

	*dstfilename = 0L;

	SYSTEMTIME localtime;
	GetLocalTime(&localtime);
	WCHAR cptfilename[MAX_PATH] = { 0L };

	//swprintf_s(cptfilename, MAX_PATH, L"%s\\MB3DTempCopyFrames_v1.0.0.18_%04u%02u%02u%02u%02u%02u.cpt",
	//	s_temppath,
	//	localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);


	//2024/06/07 PM8:30頃　ファイルバージョンアップ AdditiveIK1.0.0.23へ向けて
	swprintf_s(cptfilename, MAX_PATH, L"%s\\MB3DTempCopyFrames_v1.0.0.23_%04u%02u%02u%02u%02u%02u.cpt",//ファイルのバージョン
		s_temppath,
		localtime.wYear, localtime.wMonth, localtime.wDay, localtime.wHour, localtime.wMinute, localtime.wSecond);


	HANDLE hfile = CreateFile(cptfilename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile == INVALID_HANDLE_VALUE) {
		DbgOut(L"CPTFile : WriteCPTFile : file open error !!!\n");
		_ASSERT(0);
		return 1;
	}

	wcscpy_s(dstfilename, MAX_PATH, cptfilename);
	*(dstfilename + MAX_PATH - 1) = 0L;


	char CPTheader[256];
	::ZeroMemory(CPTheader, sizeof(char) * 256);

	//strcpy_s(CPTheader, 256, "MB3DTempCopyFramesFile ver1.0.0.18");//本体ではない

	//2024/06/07 PM8:30頃　ファイルバージョンアップ AdditiveIK1.0.0.23へ向けて
	strcpy_s(CPTheader, 256, "MB3DTempCopyFramesFile ver1.0.0.23");//本体ではない

	DWORD wleng = 0;
	WriteFile(hfile, CPTheader, sizeof(char) * 256, &wleng, NULL);
	if (wleng != (sizeof(char) * 256)) {
		_ASSERT(0);
		return 1;
	}


	wleng = 0;
	WriteFile(hfile, &cpelemnum, sizeof(int), &wleng, NULL);
	if (wleng != sizeof(int)) {
		_ASSERT(0);
		return 1;
	}



	int cpelemno;
	for (cpelemno = 0; cpelemno < cpelemnum; cpelemno++) {
		CPELEM2 curcpelem = s_copymotvec[cpelemno];
		if (curcpelem.bone) {
			char curbonename[MAX_PATH] = { 0 };
			strcpy_s(curbonename, MAX_PATH, curcpelem.bone->GetBoneName());

			wleng = 0;
			WriteFile(hfile, curbonename, sizeof(char) * MAX_PATH, &wleng, NULL);
			if (wleng != (sizeof(char) * MAX_PATH)) {
				_ASSERT(0);
				return 1;
			}

			double curframe;
			curframe = curcpelem.mp.GetFrame();
			wleng = 0;
			WriteFile(hfile, &curframe, sizeof(double), &wleng, NULL);
			if (wleng != (sizeof(double))) {
				_ASSERT(0);
				return 1;
			}

			//ChaMatrix curlocalmat;
			{//file version 1.0.0.18
				//curlocalmat = curcpelem.mp.GetWorldMat();
				//wleng = 0;
				//WriteFile(hfile, &curlocalmat, sizeof(ChaMatrix), &wleng, NULL);
				//if (wleng != (sizeof(ChaMatrix))) {
				//	_ASSERT(0);
				//	return 1;
				//}
			}

			ChaMatrix curlocalmat;
			ChaMatrix curworldmat;
			curlocalmat.SetIdentity();
			curworldmat.SetIdentity();
			{//file version 1.0.0.23
				curlocalmat = curcpelem.mp.GetLocalMat();
				wleng = 0;
				WriteFile(hfile, &curlocalmat, sizeof(ChaMatrix), &wleng, NULL);
				if (wleng != (sizeof(ChaMatrix))) {
					_ASSERT(0);
					return 1;
				}
				curworldmat = curcpelem.mp.GetWorldMat();
				wleng = 0;
				WriteFile(hfile, &curworldmat, sizeof(ChaMatrix), &wleng, NULL);
				if (wleng != (sizeof(ChaMatrix))) {
					_ASSERT(0);
					return 1;
				}
			}


			int localmatflag;
			localmatflag = curcpelem.mp.GetLocalMatFlag();
			wleng = 0;
			WriteFile(hfile, &localmatflag, sizeof(int), &wleng, NULL);
			if (wleng != (sizeof(int))) {
				_ASSERT(0);
				return 1;
			}
		}
		/*
			cpelem.bone = curbone;
			cpelem.mp.SetFrame(curframe);
			cpelem.mp.SetWorldMat(localmat);
			cpelem.mp.SetLocalMatFlag(1);//!!!!!!!!!!
		*/

	}

	FlushFileBuffers(hfile);
	SetEndOfFile(hfile);
	CloseHandle(hfile);


	return 0;
}

int DispCpInfoDlg2(CModel* srcmodel, MOTINFO* curmi, int srctype)
//srctype:0->copy, 1->cameracopy, 2->symcopy
{
	if (!srcmodel) {
		return 0;
	}
	if (!curmi) {
		return 0;
	}

	s_cpmotinfo = *curmi;

	if ((srctype == 0) || (srctype == 1)) {
		s_copymotvec.clear();
		double curframe;
		for (curframe = g_motionbrush_startframe; curframe <= g_motionbrush_endframe; curframe++) {
			InsertCopyMPReq(g_limitdegflag, srcmodel->GetTopBone(false), curframe, curmi);
		}
	}
	else if (srctype == 2) {
		s_copymotvec.clear();
		s_copyKeyInfoList.clear();
		s_copyKeyInfoList = s_owpLTimeline->getSelectedKey();

		list<KeyInfo>::iterator itrcp;
		for (itrcp = s_copyKeyInfoList.begin(); itrcp != s_copyKeyInfoList.end(); itrcp++) {
			double curframe = RoundingTime(itrcp->time);
			InsertSymMPReq(g_limitdegflag, s_model->GetTopBone(false), curframe, s_getsym_retmode);//s_getsym_retmode!!!
		}
	}

	int cpelemnum;
	cpelemnum = (int)s_copymotvec.size();
	if (cpelemnum <= 0) {
		return 0;
	}

	s_cpinfo.Init();
	/*
		typedef struct tag_cpinfo
		{
			WCHAR fbxname[MAX_PATH];
			WCHAR motionname[MAX_PATH];
			double startframe;
			double framenum;
			int bvhtype;//0:undef, 1-144:bvh1 - bvh144, -1:bvh_other
			int importance;//0:undef, 1:tiny, 2:alittle, 3:normal, 4:noticed, 5:imortant, 6:very important
			WCHAR comment[32];//WCHAR * 31文字まで。３２文字目は終端記号

		}CPMOTINFO;
	*/
	s_cpinfo.startframe = s_copymotvec[0].mp.GetFrame();
	s_cpinfo.framenum = s_copymotvec[cpelemnum - 1].mp.GetFrame() - s_cpinfo.startframe + 1;
	wcscpy_s(s_cpinfo.fbxname, MAX_PATH, srcmodel->GetFileName());

	char motname[MAX_PATH] = { 0 };
	strcpy_s(motname, MAX_PATH, curmi->motname);
	//s_model->GetCurrentMotName(motname, MAX_PATH);
	WCHAR wmotname[MAX_PATH] = { 0L };
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, motname, 256, wmotname, MAX_PATH);
	wcscpy_s(s_cpinfo.motionname, MAX_PATH, wmotname);

	s_cpinfodlg2.SetCpInfo(&s_cpinfo);
	s_cpinfodlg2.SetVisible(true);

	s_undercpinfodlg2 = true;//!!!!!!

	return 0;
}


int WriteCPIFile(CModel* srcmodel, MOTINFO* curmi, WCHAR* srccptfilename)
{


	int cpelemnum;
	cpelemnum = (int)s_copymotvec.size();
	if (cpelemnum <= 0) {
		return 0;
	}
	if (!srcmodel) {
		return 0;
	}
	//if (!s_model->ExistCurrentMotion()) {
	//	return 0;
	//}
	if (!curmi) {
		return 0;
	}
	if (!srccptfilename) {
		return 0;
	}

	*(srccptfilename + MAX_PATH - 1) = 0L;
	size_t cptfilenameleng = wcslen(srccptfilename);
	if ((cptfilenameleng <= 0) || (cptfilenameleng >= MAX_PATH)) {
		_ASSERT(0);
		return 1;
	}


	//cpiファイル名はcptファイルの拡張子をcpiに変えたもの
	WCHAR cpifilename[MAX_PATH] = { 0L };
	wcscpy_s(cpifilename, MAX_PATH, srccptfilename);
	WCHAR* pext;
	pext = wcsrchr(cpifilename, TEXT('.'));
	if (!pext) {
		return 1;
	}
	*pext = 0L;
	wcscat_s(cpifilename, MAX_PATH, L".cpi");


	HANDLE hfile = CreateFile(cpifilename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile == INVALID_HANDLE_VALUE) {
		DbgOut(L"CPTFile : WriteCPTFile : file open error !!!\n");
		_ASSERT(0);
		return 1;
	}


	char CPTheader[256];
	::ZeroMemory(CPTheader, sizeof(char) * 256);

	//strcpy_s(CPTheader, 256, "MB3DTempCopyInfoFile ver1.0.0.18");//本体ではない

	//2024/06/07 PM8:30頃　ファイルバージョンアップ AdditiveIK1.0.0.23へ向けて
	strcpy_s(CPTheader, 256, "MB3DTempCopyInfoFile ver1.0.0.23");//本体ではない

	DWORD wleng = 0;
	WriteFile(hfile, CPTheader, sizeof(char) * 256, &wleng, NULL);
	if (wleng != (sizeof(char) * 256)) {
		_ASSERT(0);
		return 1;
	}

	int datasize = sizeof(CPMOTINFO);
	wleng = 0;
	WriteFile(hfile, &datasize, sizeof(int), &wleng, NULL);
	if (wleng != sizeof(int)) {
		_ASSERT(0);
		return 1;
	}

	wleng = 0;
	WriteFile(hfile, &s_cpinfo, sizeof(CPMOTINFO), &wleng, NULL);
	if (wleng != (sizeof(CPMOTINFO))) {
		_ASSERT(0);
		return 1;
	}

	FlushFileBuffers(hfile);
	SetEndOfFile(hfile);
	CloseHandle(hfile);

	return 0;
}


int ValidateCPIFile(char* dstCPIh, int* dstinfosize, char* srcbuf, DWORD bufleng)
{
	if (!dstCPIh || !dstinfosize || !srcbuf || (bufleng <= 0)) {
		_ASSERT(0);
		return 0;
	}

	if (bufleng <= (sizeof(char) * 256 + sizeof(int))) {
		_ASSERT(0);
		return 0;
	}

	MoveMemory(dstCPIh, srcbuf, sizeof(char) * 256);

	size_t magicstrlen;
	magicstrlen = strlen(dstCPIh);
	if ((magicstrlen <= 0) || (magicstrlen >= 256)) {
		_ASSERT(0);
		return 0;
	}

	int cmp18;
	cmp18 = strcmp(dstCPIh, "MB3DTempCopyInfoFile ver1.0.0.18");//本体ではない
	int cmp23;
	cmp23 = strcmp(dstCPIh, "MB3DTempCopyInfoFile ver1.0.0.23");//本体ではない
	if ((cmp18 != 0) && (cmp23 != 0)) {
		_ASSERT(0);
		return 0;
	}


	int infosize;
	MoveMemory(&infosize, srcbuf + sizeof(char) * 256, sizeof(int));

	DWORD datasize;
	datasize = (bufleng - sizeof(char) * 256 - sizeof(int));
	DWORD elemsize;
	elemsize = sizeof(CPMOTINFO);

	if ((infosize != elemsize) || (datasize != elemsize)) {
		_ASSERT(0);
		return 0;
	}

	*dstinfosize = infosize;


	//ファイルのバージョン番号を返す
	if (cmp18 == 0) {
		return 10018;//本体ではない
	}
	else if (cmp23 == 0) {
		return 10023;//本体ではない
	}
	else {
		return 0;
	}


}


int ValidateCPTFile(char* dstCPTh, int* dstcpelemnum, char* srcbuf, DWORD bufleng)
{
	if (!dstCPTh || !dstcpelemnum || !srcbuf || (bufleng <= 0)) {
		_ASSERT(0);
		return 0;
	}

	if (bufleng <= (sizeof(char) * 256 + sizeof(int))) {
		_ASSERT(0);
		return 0;
	}

	MoveMemory(dstCPTh, srcbuf, sizeof(char) * 256);

	//typedef struct tag_CPTheader
	//{
	//	char magicstr[32];//EvaluateGlobalPosition
	//	char version[16];
	//	char fbxdate[256];
	//	int animno;
	//	int jointnum;
	//	int framenum;
	//	int reserved;
	//}CPTHEADER;

	size_t magicstrlen;
	magicstrlen = strlen(dstCPTh);
	if ((magicstrlen <= 0) || (magicstrlen >= 256)) {
		_ASSERT(0);
		return 0;
	}
	//int cmp7;
	//int cmp8;
	//int cmp9;
	//cmp7 = strcmp(dstCPTh, "MB3DTempCopyFramesFile ver1.0.0.7");//本体ではない
	//cmp8 = strcmp(dstCPTh, "MB3DTempCopyFramesFile ver1.0.0.8");//本体ではない
	//cmp9 = strcmp(dstCPTh, "MB3DTempCopyFramesFile ver1.0.0.9");//本体ではない
	//if ((cmp7 != 0) && (cmp8 != 0) && (cmp9 != 0)) {
	//	_ASSERT(0);
	//	return false;
	//}
	int cmp18;
	cmp18 = strcmp(dstCPTh, "MB3DTempCopyFramesFile ver1.0.0.18");//本体ではない
	int cmp23;
	cmp23 = strcmp(dstCPTh, "MB3DTempCopyFramesFile ver1.0.0.23");//本体ではない
	if ((cmp18 != 0) && (cmp23 != 0)) {
		_ASSERT(0);
		return 0;
	}


	int cpelemnum;
	MoveMemory(&cpelemnum, srcbuf + sizeof(char) * 256, sizeof(int));

	DWORD datasize;
	datasize = (bufleng - sizeof(char) * 256 - sizeof(int));
	DWORD elemsize;
	if (cmp18 == 0) {
		elemsize = sizeof(char) * MAX_PATH + sizeof(double) + 
			sizeof(ChaMatrix) + 
			sizeof(int);
	}
	else if (cmp23 == 0) {
		elemsize = sizeof(char) * MAX_PATH + sizeof(double) +
			sizeof(ChaMatrix) +
			sizeof(ChaMatrix) +
			sizeof(int);
	}
	else {
		_ASSERT(0);
		return 0;
	}

	if (datasize != (cpelemnum * elemsize)) {
		_ASSERT(0);
		return 0;
	}

	*dstcpelemnum = cpelemnum;

	//ファイルのバージョン番号を返す
	if (cmp18 == 0) {
		return 10018;//本体ではない
	}
	else if (cmp23 == 0) {
		return 10023;//本体ではない
	}
	else {
		return 0;
	}
}

int LoadCPIFile(HISTORYELEM* srcdstelem)
{

	WCHAR cpifilename[MAX_PATH] = { 0L };
	cpifilename[0] = { 0L };
	wcscpy_s(cpifilename, MAX_PATH, srcdstelem->wfilename);

	WCHAR* pdot = wcsrchr(cpifilename, TEXT('.'));
	if (!pdot) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	*pdot = 0L;
	wcscat_s(cpifilename, MAX_PATH, L".cpi");

	HANDLE hfile;
	hfile = CreateFile(cpifilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile == INVALID_HANDLE_VALUE) {
		//_ASSERT(0);
		srcdstelem->hascpinfo = 0;
		return 1;
	}


	DWORD sizehigh;
	DWORD bufleng;
	bufleng = GetFileSize(hfile, &sizehigh);
	if (bufleng <= 0) {
		_ASSERT(0);
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	if (sizehigh != 0) {
		_ASSERT(0);
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	char* newbuf;
	newbuf = (char*)malloc(sizeof(char) * bufleng);//bufleng + 1
	if (!newbuf) {
		_ASSERT(0);
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	ZeroMemory(newbuf, sizeof(char) * bufleng);
	DWORD rleng, readleng;
	rleng = bufleng;
	BOOL bsuccess;
	bsuccess = ReadFile(hfile, (void*)newbuf, rleng, &readleng, NULL);
	if (!bsuccess || (rleng != readleng)) {
		_ASSERT(0);
		if (newbuf) {
			free(newbuf);
			newbuf = 0;
		}
		CloseHandle(hfile);
		srcdstelem->hascpinfo = 0;
		return 1;
	}

	int infosize = 0;
	char CPIheader[256];
	ZeroMemory(CPIheader, sizeof(char) * 256);
	int validversion;
	validversion = ValidateCPIFile(CPIheader, &infosize, newbuf, bufleng);
	if (validversion <= 0) {
		_ASSERT(0);
		if (newbuf) {
			free(newbuf);
			newbuf = 0;
		}
		CloseHandle(hfile);
		srcdstelem->hascpinfo = 0;
		return 1;
	}

	DWORD curpos;
	curpos = sizeof(char) * 256 + sizeof(int);

	CPMOTINFO cpmotinfo;
	ZeroMemory(&cpmotinfo, sizeof(CPMOTINFO));
	::MoveMemory(&cpmotinfo, newbuf + curpos, sizeof(CPMOTINFO));

	cpmotinfo.fbxname[MAX_PATH - 1] = 0L;
	cpmotinfo.motionname[MAX_PATH - 1] = 0L;
	if (cpmotinfo.fbxname[0] == 0L) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	if (cpmotinfo.motionname[0] == 0L) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}

	if ((cpmotinfo.bvhtype < 0) || (cpmotinfo.bvhtype > 144)) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}
	if ((cpmotinfo.importance < 0) || (cpmotinfo.importance > 6)) {
		srcdstelem->hascpinfo = 0;
		return 1;
	}

	srcdstelem->cpinfo = cpmotinfo;
	srcdstelem->hascpinfo = 1;

	if (newbuf) {
		free(newbuf);
		newbuf = 0;
	}
	CloseHandle(hfile);

	return 0;

}



bool LoadCPTFile(CModel* srcmodel)
{
	if (!srcmodel) {
		_ASSERT(0);
		return false;
	}
	//if (!s_model->ExistCurrentMotion()) {
	//	_ASSERT(0);
	//	return false;
	//}


	s_pastemotvec.clear();

	//std::vector<HISTORYELEM> cptfilename;
	s_cptfilename.clear();
	GetCPTFileName(s_cptfilename);
	s_copyhistorydlg2.SetNames(srcmodel, s_cptfilename);//2024/06/23 srcmodelがs_model以外の場合(s_cameramodel)があるのでセットし直す

	if (s_cptfilename.empty()) {
		_ASSERT(0);
		return false;
	}

	WCHAR infilename[MAX_PATH] = { 0L };
	int result = s_copyhistorydlg2.GetSelectedFileName(srcmodel, infilename);
	infilename[MAX_PATH - 1] = 0L;
	if (result || (infilename[0] == 0L)) {
		//_ASSERT(0);
		//有効ではない履歴を選択時にはfalseをリターンしてペーストしない
		return false;
	}


	HANDLE hfile;
	hfile = CreateFile(infilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hfile == INVALID_HANDLE_VALUE) {
		_ASSERT(0);
		return false;
	}


	DWORD sizehigh;
	DWORD bufleng;
	bufleng = GetFileSize(hfile, &sizehigh);
	if (bufleng <= 0) {
		_ASSERT(0);
		return false;
	}
	if (sizehigh != 0) {
		_ASSERT(0);
		return false;
	}
	char* newbuf;
	newbuf = (char*)malloc(sizeof(char) * bufleng);//bufleng + 1
	if (!newbuf) {
		_ASSERT(0);
		return false;
	}
	ZeroMemory(newbuf, sizeof(char) * bufleng);
	DWORD rleng, readleng;
	rleng = bufleng;
	BOOL bsuccess;
	bsuccess = ReadFile(hfile, (void*)newbuf, rleng, &readleng, NULL);
	if (!bsuccess || (rleng != readleng)) {
		_ASSERT(0);
		if (newbuf) {
			free(newbuf);
			newbuf = 0;
		}
		CloseHandle(hfile);
		return false;
	}

	int cpelemnum = 0;
	char CPTheader[256];
	ZeroMemory(CPTheader, sizeof(char) * 256);
	int validversion;
	validversion = ValidateCPTFile(CPTheader, &cpelemnum, newbuf, bufleng);
	if (validversion <= 0) {
		_ASSERT(0);
		if (newbuf) {
			free(newbuf);
			newbuf = 0;
		}
		CloseHandle(hfile);
		return false;
	}

	DWORD curpos;
	curpos = sizeof(char) * 256 + sizeof(int);

	int cpelemno;
	for (cpelemno = 0; cpelemno < cpelemnum; cpelemno++) {
		char curbonename[MAX_PATH] = { 0 };
		ZeroMemory(curbonename, sizeof(char) * MAX_PATH);
		if ((curpos + (sizeof(char) * MAX_PATH)) > bufleng) {
			_ASSERT(0);
			if (newbuf) {
				free(newbuf);
				newbuf = 0;
			}
			CloseHandle(hfile);
			return false;
		}
		::MoveMemory(curbonename, newbuf + curpos, sizeof(char) * MAX_PATH);
		curpos += (sizeof(char) * MAX_PATH);


		double curframe;
		if ((curpos + sizeof(double)) > bufleng) {
			_ASSERT(0);
			if (newbuf) {
				free(newbuf);
				newbuf = 0;
			}
			CloseHandle(hfile);
			return false;
		}
		::MoveMemory(&curframe, newbuf + curpos, sizeof(double));
		curpos += sizeof(double);


		ChaMatrix curlocalmat;
		ChaMatrix curworldmat;
		curlocalmat.SetIdentity();
		curworldmat.SetIdentity();

		if (validversion == 10018) {
			if ((curpos + sizeof(ChaMatrix)) > bufleng) {
				_ASSERT(0);
				if (newbuf) {
					free(newbuf);
					newbuf = 0;
				}
				CloseHandle(hfile);
				return false;
			}
			::MoveMemory(&curlocalmat, newbuf + curpos, sizeof(ChaMatrix));
			curpos += sizeof(ChaMatrix);
		}
		else if (validversion == 10023) {
			if ((curpos + sizeof(ChaMatrix)) > bufleng) {
				_ASSERT(0);
				if (newbuf) {
					free(newbuf);
					newbuf = 0;
				}
				CloseHandle(hfile);
				return false;
			}
			::MoveMemory(&curlocalmat, newbuf + curpos, sizeof(ChaMatrix));
			curpos += sizeof(ChaMatrix);

			if ((curpos + sizeof(ChaMatrix)) > bufleng) {
				_ASSERT(0);
				if (newbuf) {
					free(newbuf);
					newbuf = 0;
				}
				CloseHandle(hfile);
				return false;
			}
			::MoveMemory(&curworldmat, newbuf + curpos, sizeof(ChaMatrix));
			curpos += sizeof(ChaMatrix);
		}
		else {
			_ASSERT(0);
			return 1;
		}

		int localmatflag = 0;
		if ((curpos + sizeof(int)) > bufleng) {
			_ASSERT(0);
			if (newbuf) {
				free(newbuf);
				newbuf = 0;
			}
			CloseHandle(hfile);
			return false;
		}
		::MoveMemory(&localmatflag, newbuf + curpos, sizeof(int));
		curpos += sizeof(int);



		CBone* curbone;
		//curbone = srcmodel->GetBoneByName(curbonename);
		curbone = srcmodel->FindBoneByName(curbonename);//2023/08/14 _Joint有無対応
		if (curbone) {
			CPELEM2 curcpelem;
			ZeroMemory(&curcpelem, sizeof(CPELEM2));

			curcpelem.bone = curbone;
			curcpelem.mp.SetFrame(curframe);
			if (validversion == 10018) {
				curcpelem.mp.SetWorldMat(curlocalmat);
			}
			else if (validversion == 10023) {
				curcpelem.mp.SetLocalMat(curlocalmat);
				curcpelem.mp.SetWorldMat(curworldmat);
			}
			else {
				_ASSERT(0);
				return 1;
			}
			curcpelem.mp.SetLocalMatFlag(localmatflag);

			s_pastemotvec.push_back(curcpelem);
		}
		else {
			_ASSERT(0);
		}
	}

	if (newbuf) {
		free(newbuf);
		newbuf = 0;
	}
	CloseHandle(hfile);

	return true;
}

void ChangeCurDirFromMameMediaToTest()
{
	//CurrentDirectoryがMameMediaになっていたときにはTestディレクトリに変える
	WCHAR curdir[MAX_PATH] = { 0L };
	ZeroMemory(curdir, sizeof(WCHAR) * MAX_PATH);
	GetCurrentDirectory(MAX_PATH, curdir);
	WCHAR* findpat = wcsstr(curdir, L"\\MameMedia");
	if (findpat) {
		WCHAR initialdir[MAX_PATH] = { 0L };
		wcscpy_s(initialdir, MAX_PATH, g_basedir);
		wcscat_s(initialdir, MAX_PATH, L"..\\Test\\");
		SetCurrentDirectoryW(initialdir);
	}
}

void InitTimelineSelection()
{
	s_editrange.Clear();
	s_buttonselectstart = 1.0;
	s_buttonselectend = 1.0;

	if (g_motionbrush_value) {
		free(g_motionbrush_value);
		g_motionbrush_value = 0;
	}
	g_motionbrush_value = (float*)malloc(sizeof(float) * 1);
	if (g_motionbrush_value) {
		*g_motionbrush_value = 1.0f;
	}

	//g_motionbrush_method = 0;
	g_motionbrush_startframe = 1.0;
	g_motionbrush_endframe = 1.0;
	g_motionbrush_applyframe = 1.0;
	g_motionbrush_numframe = 1.0;
	g_motionbrush_frameleng = 1;

	if (s_owpTimeline) {
		s_owpTimeline->setCurrentTime(1.0, false);
	}
	if (s_owpLTimeline) {
		s_owpLTimeline->setCurrentTime(1.0, false);
	}

	//if (s_model) {
	//	MOTINFO* curmi;
	//	curmi = s_model->GetCurMotInfo();
	//	if (curmi) {
	//		s_model->SetMotionFrame(1.0);
	//	}
	//}

	int tothelastflag = 0;
	OnTimeLineButtonSelectFromSelectStartEnd(tothelastflag);

}

void ClampTimelineSelection()
{
	if (!s_model) {
		InitTimelineSelection();
		return;
	}

	//if (!s_model->ExistCurrentMotion()) {
	//	InitTimelineSelection();
	//	return;
	//}
	MOTINFO curmi = GetEditTargetMotInfo();
	if (curmi.motid <= 0) {
		InitTimelineSelection();
		return;
	}


	//double newstart = min((curmi.frameleng - 1.0), max(1.0, s_buttonselectstart));
	//double newend = min((curmi.frameleng - 1.0), max(newstart, s_buttonselectend));
	double newstart = fmin((curmi.frameleng - 1.0), fmax(1.0, g_motionbrush_startframe));
	double newend = fmin((curmi.frameleng - 1.0), fmax(newstart, g_motionbrush_endframe));
	double newnumframe = newend - newstart + 1.0;
	double newapplyframe;
	if (g_applyrate == 0.0) {
		newapplyframe = newstart;
	}
	else if (g_applyrate == 100.0) {
		newapplyframe = newend;
	}
	else {
		newapplyframe = (double)((int)(newstart + (newend - newstart) * (g_applyrate / 100.0)));
	}

	s_editrange.Clear();
	s_buttonselectstart = newstart;
	s_buttonselectend = newend;


	if (g_motionbrush_value) {
		free(g_motionbrush_value);
		g_motionbrush_value = 0;
	}
	g_motionbrush_value = (float*)malloc(sizeof(float) * 1);
	if (g_motionbrush_value) {
		*g_motionbrush_value = 1.0f;
	}

	//g_motionbrush_method = 0;
	g_motionbrush_startframe = newstart;
	g_motionbrush_endframe = newend;
	g_motionbrush_applyframe = newapplyframe;
	g_motionbrush_numframe = newnumframe;
	g_motionbrush_frameleng = IntTime(newnumframe);

	if (s_owpTimeline) {
		s_owpTimeline->setCurrentTime(newapplyframe, false);
	}
	if (s_owpLTimeline) {
		s_owpLTimeline->setCurrentTime(newapplyframe, false);
	}

	//if (s_model) {
	//	MOTINFO* curmi;
	//	curmi = s_model->GetCurMotInfo();
	//	if (curmi) {
	//		s_model->SetMotionFrame(1.0);
	//	}
	//}

	int tothelastflag = 0;
	OnTimeLineButtonSelectFromSelectStartEnd(tothelastflag);

}

void OnArrowKey()
{

	//マウスカーソルが起動中ソフトのウインドウ内にある場合だけ処理
	//複数個のAdditiveIKを立ち上げたときに操作中のAdditiveIKだけに影響するように
	POINT cursorpoint;
	GetCursorPos(&cursorpoint);
	::ScreenToClient(g_mainhwnd, &cursorpoint);
	RECT appclientrect;
	GetClientRect(g_mainhwnd, &appclientrect);
	if ((cursorpoint.x < appclientrect.left) || (cursorpoint.x > appclientrect.right) ||
		(cursorpoint.y < appclientrect.top) || (cursorpoint.y > appclientrect.bottom)) {
		//MainWindow外につき処理しない
		return;
	}


	int parentbuttonid = 4;
	int sisterbuttonid = 5;
	int childbuttonid = 6;
	int brotherbuttonid = 7;
	int accelaxisid1 = 4;//axisid
	int accelaxisid2 = 5;//axisid

	//int parentbutton = 0;
	//int sisterbutton = 0;
	//int childbutton = 0;
	//int brotherbutton = 0;
	//int accelaxis1 = 0;
	//int accelaxis2 = 0;

	//parentbutton = s_dsbuttonup[parentbuttonid];
	//sisterbutton = s_dsbuttonup[sisterbuttonid];
	//childbutton = s_dsbuttonup[childbuttonid];
	//brotherbutton = s_dsbuttonup[brotherbuttonid];

	//accelaxis1 = ((bool)(s_dsaxisOverSrh[accelaxisid1] + s_dsaxisMOverSrh[accelaxisid1]));
	//accelaxis2 = ((bool)(s_dsaxisOverSrh[accelaxisid2] + s_dsaxisMOverSrh[accelaxisid2]));

	s_dsbuttonup[parentbuttonid] = 0;
	s_dsbuttonup[sisterbuttonid] = 0;
	s_dsbuttonup[childbuttonid] = 0;
	s_dsbuttonup[brotherbuttonid] = 0;

	s_currentwndid = MB3D_WND_TREE;


	bool arrowkeypushed = false;
	if (!FocusEditWnd()) {//2023/08/28 EditCtrl入力中は　矢印キーのショートカット機能を使わない
		if (((g_savekeybuf[VK_UP] & 0x80) == 0) && ((g_keybuf[VK_UP] & 0x80) != 0)) {
			s_dsbuttonup[parentbuttonid] = 1;
			s_dsbuttonup[sisterbuttonid] = 0;
			s_dsbuttonup[childbuttonid] = 0;
			s_dsbuttonup[brotherbuttonid] = 0;
			arrowkeypushed = true;
		}
		else if (((g_savekeybuf[VK_DOWN] & 0x80) == 0) && ((g_keybuf[VK_DOWN] & 0x80) != 0)) {
			s_dsbuttonup[parentbuttonid] = 0;
			s_dsbuttonup[sisterbuttonid] = 0;
			s_dsbuttonup[childbuttonid] = 1;
			s_dsbuttonup[brotherbuttonid] = 0;
			arrowkeypushed = true;
		}
		else if (((g_keybuf['H'] & 0x80) == 0) && ((g_keybuf['F'] & 0x80) == 0) && 
			((g_savekeybuf[VK_LEFT] & 0x80) == 0) && ((g_keybuf[VK_LEFT] & 0x80) != 0)) {
			s_dsbuttonup[parentbuttonid] = 0;
			s_dsbuttonup[sisterbuttonid] = 1;
			s_dsbuttonup[childbuttonid] = 0;
			s_dsbuttonup[brotherbuttonid] = 0;
			arrowkeypushed = true;
		}
		else if (((g_keybuf['H'] & 0x80) == 0) && ((g_keybuf['F'] & 0x80) == 0) && 
			((g_savekeybuf[VK_RIGHT] & 0x80) == 0) && ((g_keybuf[VK_RIGHT] & 0x80) != 0)) {
			s_dsbuttonup[parentbuttonid] = 0;
			s_dsbuttonup[sisterbuttonid] = 0;
			s_dsbuttonup[childbuttonid] = 0;
			s_dsbuttonup[brotherbuttonid] = 1;
			arrowkeypushed = true;
		}
	}

	if (arrowkeypushed == true) {
		bool firstctrlselect = false;
		DSCrossButtonSelectTree(firstctrlselect);
	}

}

//double CalcRefFrame()
//{
//	double startframe = s_editrange.GetStartFrame();
//	double endframe = s_editrange.GetEndFrame();
//	if (startframe != endframe) {
//		double offset = 0;
//		double refframe = (double)((int)(startframe + (endframe - startframe) * g_refpos / 100.0 + offset));
//
//		return refframe;
//	}
//	else {
//		return -1.0;
//	}
//
//}

ChaMatrix CalcRigMat(CUSTOMRIG* currig, CBone* curbone, int curmotid, double curframe, int dispaxis, int disporder, bool posinverse)
{

	ChaMatrix retmat;
	ChaMatrixIdentity(&retmat);
	if (!curbone) {
		_ASSERT(0);
		return retmat;
	}
	if (!curbone->GetParModel()) {
		_ASSERT(0);
		return retmat;
	}
	if (!currig) {
		_ASSERT(0);
		return retmat;
	}

	//int multworld = 1;
	ChaMatrix selm;
	selm.SetIdentity();
	//int multworld = 1;
	//ChaMatrix selm = curbone->CalcManipulatorMatrix(0, 0, multworld, curmotid, curframe);
	//ChaMatrix selm = curbone->CalcManipulatorMatrix(0, multworld, curmotid, curframe);
	if (curbone && curbone->GetParent(false) && curbone->GetParent(false)->IsSkeleton()) {

		//!!!!!! 軸の種類を変えた場合にも　リグの設定が保たれるように　BONEAXIS_CURRENTで統一
		//BONEAXIS_BINDPOSEはXフィットしないので　BONEAXIS_CURRENTを選んだ
		curbone->GetParent(false)->CalcAxisMatX_Manipulator(g_limitdegflag, BONEAXIS_CURRENT, 0, curbone, &selm, 0);
	}
	else {
		//selm.SetIdentity();
		selm = curbone->GetWorldMat(g_limitdegflag, curmotid, curframe, 0);
	}

	//selm.data[MATI_41] = 0.0f;
	//selm.data[MATI_42] = 0.0f;
	//selm.data[MATI_43] = 0.0f;

	CalcSelectScale();//s_selectscaleにセット

	ChaMatrix scalemat;
	ChaMatrixIdentity(&scalemat);
	//ChaMatrixScaling(&scalemat, s_selectscale, s_selectscale, s_selectscale);
	float rigmult;
	switch (currig->shapekind) {
	case RIGSHAPE_SPHERE:
		rigmult = 0.5f * s_selectscale * (float)(currig->shapemult + 1) * 0.5f;
		break;
	case RIGSHAPE_RINGX:
	case RIGSHAPE_RINGY:
	case RIGSHAPE_RINGZ:
		rigmult = s_selectscale * (float)(currig->shapemult + 1) * 0.5f;
		break;
	default:
		rigmult = s_selectscale;
		_ASSERT(0);
		break;
	}
	ChaMatrixScaling(&scalemat, rigmult, rigmult, rigmult);

	//ChaVector3 curbonepos = curbone->GetWorldPos(g_limitdegflag, curmotid, curframe);//world座標系
	//ChaMatrix invmodelwm = ChaMatrixInv(curbone->GetParModel()->GetWorldMat());
	//ChaVector3 curbonepos;
	//ChaVector3TransformCoord(&curbonepos, &curbonepos0, &invmodelwm);

	ChaVector3 jointpos = curbone->GetJointFPos();
	ChaMatrix curwm = curbone->GetWorldMat(g_limitdegflag, curmotid, curframe, 0);
	ChaVector3 curbonepos;
	ChaVector3TransformCoord(&curbonepos, &jointpos, &curwm);


	float curboneleng = (float)curbone->GetBoneLeng();
	float multoffset;
	if (curboneleng != 0.0f) {
		multoffset = curboneleng * 0.25f;
	}
	else {
		multoffset = 1.0f;
	}


	float rigorderoffset = 0.0f;
	rigorderoffset = (float)disporder * 0.25f * multoffset;
	if (posinverse) {
		rigorderoffset *= -1.0f;
	}


	//ChaVector3 offsetorgpos.SetParams(0.0f, 0.0f, 0.0f);
	//ChaVector3 offsetdisppos.SetParams(0.0f, 0.0f, 0.0f);

	//ChaMatrix curwm = curbone->GetWorldMat(g_limitdegflag, curmotid, curframe, 0);
	ChaMatrix curbonerotmat;
	//curbonerotmat = ChaMatrixRot(curwm);
	curbonerotmat = ChaMatrixRot(selm);
	ChaVector3 offsetvec;

	if (dispaxis == 0) {
		offsetvec = curbonerotmat.GetRow(0);
	}
	else if (dispaxis == 1) {
		offsetvec = curbonerotmat.GetRow(1);
	}
	else if (dispaxis == 2) {
		offsetvec = curbonerotmat.GetRow(2);
	}
	else {
		_ASSERT(0);
		offsetvec.SetParams(1.0f, 0.0f, 0.0f);
	}
	offsetvec *= rigorderoffset;
	//ChaVector3TransformCoord(&offsetdisppos, &offsetorgpos, &selm);

	ChaMatrix tramat;
	ChaMatrixIdentity(&tramat);
	ChaMatrixTranslation(&tramat, 
		curbonepos.x + offsetvec.x, curbonepos.y + offsetvec.y, curbonepos.z + offsetvec.z);

	//retmat = scalemat * tramat;
	//retmat = ChaMatrixFromSRT(true, true, curbone->GetNodeMat(), &scalemat, &curbonerotmat, &tramat);

	retmat = scalemat * curbonerotmat;
	retmat.SetTranslation(ChaVector3(curbonepos.x + offsetvec.x, curbonepos.y + offsetvec.y, curbonepos.z + offsetvec.z));
	retmat = retmat * curbone->GetParModel()->GetWorldMat();


	return retmat;
}

int PickRigBone(UIPICKINFO* ppickinfo, bool forrigtip, int* dstrigno)//default:forrigtip = false, dstrigno = 0
{
	if (!s_model || !ppickinfo) {
		return -1;
	}

	if (g_previewFlag != 0) {
		//プレビュー中はマウスでは選択しない
		return -1;
	}
	if (s_camtargetdisp) {
		//カメラターゲット位置にマニピュレータ表示時にはpickしない
		return -1;
	}


	ResetRigModelNum();
	if (s_model->ExistCurrentMotion()) {
		int curmotid = s_model->GetCurrentMotID();
		double curframe = s_model->GetCurrentFrame();

		std::map<int, CBone*>::iterator itrbone;
		for (itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++) {
			CBone* curbone = (CBone*)itrbone->second;
			if (curbone && (curbone->IsSkeleton())) {
				int rigno;
				for (rigno = 0; rigno < MAXRIGNUM; rigno++) {
					CUSTOMRIG currig = curbone->GetCustomRig(rigno);
					if (currig.useflag == 2) {//0: free, 1: allocated, 2: valid
						//s_matrig->SetDif4F(s_matrigmat);

						CModel* currigmodel;
						int instancingno;
						ChaVector4 rigmaterial;
						currigmodel = GetCurRigModel(currig, &instancingno, &rigmaterial);
						if (currigmodel && (instancingno >= 0) && (instancingno < RIGMULTINDEXMAX)) {
							ChaMatrix rigmat;
							ChaMatrixIdentity(&rigmat);
							rigmat = CalcRigMat(&currig, curbone, curmotid, curframe, currig.dispaxis, currig.disporder, currig.posinverse);

							//g_hmWorld->SetMatrix(rigmat.GetDataPtr());
							currigmodel->UpdateMatrix(g_limitdegflag, &rigmat, &s_matView, &s_matProj, true, 0);


							int chkboneno = curbone->GetBoneNo();

							UIPICKINFO chkpickinfo;
							chkpickinfo = *ppickinfo;

							chkpickinfo.buttonflag = PICK_CENTER;
							chkpickinfo.pickobjno = chkboneno;

							int colliobj;
							bool excludeinvface = true;
							colliobj = currigmodel->CollisionNoBoneObj_Mouse(&chkpickinfo, "obj1", excludeinvface);
							if (colliobj > 0) {
								RollbackCurBoneNo();

								if (forrigtip == false) {
									*ppickinfo = chkpickinfo;
									s_curboneno = chkboneno;

									CBone* chkbone = s_model->GetBoneByID(s_curboneno);
									if (chkbone != s_customrigbone) {
										//開いている設定ダイアログを閉じないと、設定ダイアログのrigboneと新たなrigboneが異なってしまい、Applyボタンで異なるリグを保存することがある
										if (s_customrigdlg) {
											DestroyWindow(s_customrigdlg);
											s_customrigdlg = 0;
										}
									}

									if (s_owpTimeline) {
										s_owpTimeline->setCurrentLine(s_boneno2lineno[s_curboneno], true);
										//WindowPos currentpos = s_owpTimeline->getCurrentLinePos();
										//POINT mousepos;
										//mousepos.x = currentpos.x;
										//mousepos.y = currentpos.y;
										//::ClientToScreen(s_timelineWnd->getHWnd(), &mousepos);
										//::SetCursorPos(mousepos.x, mousepos.y);
									}
									ChangeCurrentBone(true);//2021/11/19

									////Bone2CustomRig(rigno);
									//GUIMenuSetVisible(-1, -1);
									bool closefirstrow = true;
									CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる
									DispCustomRigDlg(rigno);//2024/01/21 設定ダイアログ表示をピックしたリグの内容に更新
								}
								else {
									if (dstrigno) {
										*dstrigno = rigno;
									}
								}

								return chkboneno;//!!!!!!!!!!!!!!!!!!!!!!!!!!!! found !!!!!!!!!!!!!!!!!!
							}
							else {
								if (dstrigno) {
									*dstrigno = -1;
								}
							}
						}
					}
				}
			}
		}
	}
	else {
		return -1;
	}

	return -1;

}


int LoadThreshold()
{
	int result = 0;
	WCHAR filepath[MAX_PATH] = { 0L };
	swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjThreshold_0.txt", s_temppath);

	CThresholdFile thresholdfile;
	result = thresholdfile.LoadThresholdFile(filepath);
	return result;
}

int LoadLightsForEdit()
{
	int result = 0;

	int slotindex;
	for (slotindex = 0; slotindex < LIGHTSLOTNUM; slotindex++) {
		WCHAR lightfilepath[MAX_PATH] = { 0L };
		swprintf_s(lightfilepath, MAX_PATH, L"%s\\MB3DOpenProjLightsForEdit_%d.txt", s_temppath, slotindex);

		CLightsForEditFile lightfile;
		result += lightfile.LoadLightsForEditFile(lightfilepath, slotindex);

	}

	return result;
}

int LoadShadowParamsFile()
{
	int result = 0;

	WCHAR filepath[MAX_PATH] = { 0L };
	swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjShadowParams_0.txt", s_temppath);

	CShadowParamsFile shadowparamsfile;
	result = shadowparamsfile.LoadShadowParamsFile(filepath);

	return result;
}

int LoadSkyParamsFile()
{
	int result = 0;

	if (s_sky) {
		int slotindex;
		for (slotindex = 0; slotindex < SKYSLOTNUM; slotindex++) {
			WCHAR filepath[MAX_PATH] = { 0L };
			swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjSkyParams_%d.txt", s_temppath, slotindex);

			CSkyParamsFile skyparamsfile;
			result += skyparamsfile.LoadSkyParamsFile(filepath, &(s_skyparams[slotindex]));
			_ASSERT(result == 0);
		}
		if ((g_skyindex >= 0) && (g_skyindex < SKYSLOTNUM)) {
			SetSkyParamsToSky(s_skyparams[g_skyindex]);
		}
		else {
			g_skyindex = 0;
			SetSkyParamsToSky(s_skyparams[0]);
		}

		return result;
	}
	else {
		_ASSERT(0);
		return 1;
	}
}
int LoadFogParamsFile()
{
	int result = 0;

	int slotindex;
	for (slotindex = 0; slotindex < FOGSLOTNUM; slotindex++) {
		WCHAR filepath[MAX_PATH] = { 0L };
		swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjFogParams_%d.txt", s_temppath, slotindex);

		CFogParamsFile fogparamsfile;
		result += fogparamsfile.LoadFogParamsFile(filepath, slotindex);
	}
	if ((g_fogindex < 0) || (g_fogindex >= FOGSLOTNUM)) {
		g_fogindex = 0;
	}


	return result;
}
int LoadDofParamsFile()
{
	int result = 0;

	int slotindex;
	for (slotindex = 0; slotindex < DOFSLOTNUM; slotindex++) {
		WCHAR filepath[MAX_PATH] = { 0L };
		swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjDofParams_%d.txt", s_temppath, slotindex);

		CDofParamsFile fogparamsfile;
		result += fogparamsfile.LoadDofParamsFile(filepath, slotindex);
	}
	if ((g_dofindex < 0) || (g_dofindex >= DOFSLOTNUM)) {
		g_dofindex = 0;
	}

	return result;
}



int PickManipulator(UIPICKINFO* ppickinfo, bool pickring)
{
	if (!ppickinfo) {
		_ASSERT(0);
		return -1;
	}
	if (!s_select) {
		return -1;
	}
	if (s_camtargetdisp) {
		//カメラターゲット位置にマニピュレータ表示時にはpickしない
		return -1;
	}
	if (FindGrassElem(s_model) != nullptr) {
		//2024/06/22 草選択時にはPickManipulatorしない
		//草選択時にPickManipulator判定をすると
		//読み込み直後に草が選択されている場合に　Model'sPosAndDirでPickAndPutしようとしても　この関数がhit状態を返すのでPickAndPut出来なかった
		//根本的原因としては
		//初期状態で草が選択されている場合
		//草にモーションが無いためにRenderSelectMark()関数が0リターンしてs_select->UpdateMatrixが一回も行われないため
		return -1;
	}

	if (s_dispselect) {
		bool excludeinvface = false;
		int colliobjx, colliobjy, colliobjz, colliringx, colliringy, colliringz;
		colliobjx = 0;
		colliobjy = 0;
		colliobjz = 0; 
		colliringx = 0; 
		colliringy = 0; 
		colliringz = 0;
		colliobjx = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "objX", excludeinvface);
		colliobjy = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "objY", excludeinvface);
		colliobjz = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "objZ", excludeinvface);
		if ((s_ikkind == 0) || (pickring == true)) {
			colliringx = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "ringX", excludeinvface);
			colliringy = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "ringY", excludeinvface);
			colliringz = s_select->CollisionNoBoneObj_Mouse(ppickinfo, "ringZ", excludeinvface);
		}
		else {
			colliringx = 0;
			colliringy = 0;
			colliringz = 0;
		}

		if (colliobjx || colliringx || colliobjy || colliringy || colliobjz || colliringz) {
			RollbackCurBoneNo();
			ppickinfo->pickobjno = s_curboneno;
		}

		if (colliobjx || colliringx) {
			ppickinfo->buttonflag = PICK_X;
		}
		else if (colliobjy || colliringy) {
			ppickinfo->buttonflag = PICK_Y;
		}
		else if (colliobjz || colliringz) {
			ppickinfo->buttonflag = PICK_Z;
		}
		else {
			InitPickInfo(ppickinfo);//2024/02/09 pickinfo->pickobjnoは０ではなく-1で初期化
		}
	}
	else {
		InitPickInfo(ppickinfo);
	}

	return ppickinfo->pickobjno;
}




int LoadChooseColor()
{
	//s_temppathのセットよりも後

	COLORREF savedcolorref[16];
	ZeroMemory(&savedcolorref, sizeof(COLORREF) * 16);
	WCHAR colorfilepath[MAX_PATH] = { 0L };
	swprintf_s(colorfilepath, MAX_PATH, L"%s\\MB3DOpenProjChooseColor_0.txt", s_temppath);
	CChooseColorFile colorfile;
	int resultcolfile = colorfile.LoadChooseColorFile(colorfilepath, &(savedcolorref[0]));
	if (resultcolfile == 0) {
		g_coldlg.SetCustomColor(&(savedcolorref[0]));
	}

	return 0;
}


int LoadIniFile()
{
	WCHAR path[MAX_PATH] = { 0L };
	wcscpy_s(path, MAX_PATH, g_basedir);
	WCHAR* lasten = 0;
	WCHAR* last2en = 0;
	lasten = wcsrchr(path, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return 1;
	}
	*lasten = 0L;
	last2en = wcsrchr(path, TEXT('\\'));
	if (!last2en) {
		_ASSERT(0);
		return 1;
	}
	*last2en = 0L;

	WCHAR inifilepath[MAX_PATH] = { 0L };
	swprintf_s(inifilepath, MAX_PATH, L"%s\\AdditiveIK%d.ini", path, s_appcnt);

	CIniFile inifile;
	inifile.LoadIniFile(inifilepath);

	return 0;
}

int SaveThreshold()
{
	int result = 0;
	WCHAR filepath[MAX_PATH] = { 0L };
	swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjThreshold_0.txt", s_temppath);

	CThresholdFile thresholdfile;
	result = thresholdfile.WriteThresholdFile(filepath);
	_ASSERT(result == 0);

	return result;
}

int SaveLightsForEdit()
{
	int result = 0;

	int slotindex;
	for (slotindex = 0; slotindex < LIGHTSLOTNUM; slotindex++) {
		WCHAR lightfilepath[MAX_PATH] = { 0L };
		swprintf_s(lightfilepath, MAX_PATH, L"%s\\MB3DOpenProjLightsForEdit_%d.txt", s_temppath, slotindex);

		CLightsForEditFile lightfile;
		result += lightfile.WriteLightsForEditFile(lightfilepath, slotindex);
		_ASSERT(result == 0);
	}
	return result;
}

int SaveShadowParamsFile()
{
	int result = 0;

	WCHAR filepath[MAX_PATH] = { 0L };
	swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjShadowParams_0.txt", s_temppath);

	CShadowParamsFile shadowparamsfile;
	result = shadowparamsfile.WriteShadowParamsFile(filepath);
	_ASSERT(result == 0);

	return result;
}

int SaveSkyParamsFile()
{
	int result = 0;

	if (s_sky) {
		int slotindex;
		for (slotindex = 0; slotindex < SKYSLOTNUM; slotindex++) {
			WCHAR filepath[MAX_PATH] = { 0L };
			swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjSkyParams_%d.txt", s_temppath, slotindex);

			CSkyParamsFile skyparamsfile;
			result += skyparamsfile.WriteSkyParamsFile(filepath, s_skyparams[slotindex], slotindex);
			_ASSERT(result == 0);
		}

		return result;
	}
	else {
		_ASSERT(0);
		return 1;
	}
}
int SaveFogParamsFile()
{
	int result = 0;

	int slotindex;
	for (slotindex = 0; slotindex < FOGSLOTNUM; slotindex++) {
		WCHAR filepath[MAX_PATH] = { 0L };
		swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjFogParams_%d.txt", s_temppath, slotindex);

		CFogParamsFile fogparamsfile;
		result += fogparamsfile.WriteFogParamsFile(filepath, slotindex);
		_ASSERT(result == 0);
	}
	return result;
}
int SaveDofParamsFile()
{
	int result = 0;

	int slotindex;
	for (slotindex = 0; slotindex < DOFSLOTNUM; slotindex++) {
		WCHAR filepath[MAX_PATH] = { 0L };
		swprintf_s(filepath, MAX_PATH, L"%s\\MB3DOpenProjDofParams_%d.txt", s_temppath, slotindex);

		CDofParamsFile fogparamsfile;
		result = fogparamsfile.WriteDofParamsFile(filepath, slotindex);
		_ASSERT(result == 0);
	}

	return result;
}


int SaveChooseColor()
{
	COLORREF colforsave[16];
	ZeroMemory(colforsave, sizeof(COLORREF) * 16);
	int resultgetcol = g_coldlg.GetCustomColor(16, &(colforsave[0]));
	if (resultgetcol == 0) {
		WCHAR colorfilepath[MAX_PATH] = { 0L };
		swprintf_s(colorfilepath, MAX_PATH, L"%s\\MB3DOpenProjChooseColor_0.txt", s_temppath);
		CChooseColorFile colorfile;
		int resultcolfile = colorfile.WriteChooseColorFile(colorfilepath, colforsave);
		_ASSERT(resultcolfile == 0);
		return resultcolfile;
	}

	return 0;
}

int SaveIniFile()
{
	WCHAR path[MAX_PATH] = { 0L };
	wcscpy_s(path, MAX_PATH, g_basedir);
	WCHAR* lasten = 0;
	WCHAR* last2en = 0;
	lasten = wcsrchr(path, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		return 1;
	}
	*lasten = 0L;
	last2en = wcsrchr(path, TEXT('\\'));
	if (!last2en) {
		_ASSERT(0);
		return 1;
	}
	*last2en = 0L;

	WCHAR inifilepath[MAX_PATH] = { 0L };
	swprintf_s(inifilepath, MAX_PATH, L"%s\\AdditiveIK%d.ini", path, s_appcnt);

	CIniFile inifile;
	inifile.WriteIniFile(inifilepath);

	return 0;
}

int SetTimelineHasRigFlag()
{
	if (!s_owpTimeline) {
		return 0;
	}
	if (!s_model) {
		return 0;
	}


	std::map<int, CBone*>::iterator itrbone;
	for (itrbone = s_model->GetBoneListBegin(); itrbone != s_model->GetBoneListEnd(); itrbone++) {
		CBone* curbone = (CBone*)itrbone->second;
		if (curbone && (curbone->IsSkeleton())) {
			bool hasrigflag = s_model->ChkBoneHasRig(curbone);
			s_owpTimeline->setHasRigFlag(curbone->GetWBoneName(), hasrigflag);
		}
	}

	return 0;
}


int ClearLimitedWM(CModel* srcmodel)
{
	if (!srcmodel) {
		return 0;
	}

	if (srcmodel && srcmodel->ExistCurrentMotion()) {
		int curmotid = srcmodel->GetCurrentMotID();
		MOTINFO curmi = GetEditTargetMotInfo();
		if (curmi.motid > 0) {
			double frameleng = curmi.frameleng;
			double curframe;
			for (curframe = 0.0; curframe < frameleng; curframe += 1.0) {
				//for (curframe = 1.0; curframe < frameleng; curframe += 1.0) {
				srcmodel->ClearLimitedWM(curmotid, curframe);
			}
		}
	}
	return 0;
}

int SetShowPosTime()
{
	if (s_owpTimeline && s_owpLTimeline && s_owpEulerGraph) {
		double startframe, endframe, applyframe;
		int selnum;
		s_editrange.GetRange(&selnum, &startframe, &endframe, &applyframe);

		double curframe = applyframe;
		double startedgeframe = fmax(1.0, (double)((int)(curframe - s_owpEulerGraph->getShowposWidth() / 2.0)));
		//double startedgeframe = fmax(1.0, (double)((int)(curframe - s_owpEulerGraph->getShowposWidth())));

		//s_owpTimeline->setShowPosTime(curframe);
		//s_owpLTimeline->setShowPosTime(curframe);
		//s_owpEulerGraph->setShowPosTime(curframe);

		s_owpTimeline->setShowPosTime(startedgeframe);
		s_owpLTimeline->setShowPosTime(startedgeframe);
		s_owpEulerGraph->setShowPosTime(startedgeframe);
		//s_owpTimeline->setShowPosTime(curframe);
		//s_owpLTimeline->setShowPosTime(curframe);
		//s_owpEulerGraph->setShowPosTime(curframe);


		s_owpTimeline->setCurrentTime(curframe, false);
		s_owpLTimeline->setCurrentTime(curframe, true);
		s_owpEulerGraph->setCurrentTime(curframe, false);
	}


	return 0;
}

int ChangeUpdateMatrixThreads()
{
	if (!s_chascene) {
		return 0;
	}

	StopBt();

	g_changeUpdateThreadsNum = true;

	//SleepEx(30, false);

	int modelnum = s_chascene->GetModelNum();
	int modelcount;
	for (modelcount = 0; modelcount < modelnum; modelcount++) {
		CModel* curmodel = s_chascene->GetModel(modelcount);
		if (curmodel) {
			curmodel->CreateBoneUpdateMatrix();
		}
	}

	g_changeUpdateThreadsNum = false;


	return 0;
}

CGrassElem* FindGrassElem(CModel* srcmodel)
{
	CGrassElem* retgrasselem = nullptr;

	if (!srcmodel) {
		return nullptr;
	}	
	if (srcmodel->GetGrassFlag() == false) {
		return nullptr;
	}

	int grasselemnum = (int)s_grassElemVec.size();
	int grasselemindex;
	for (grasselemindex = 0; grasselemindex < grasselemnum; grasselemindex++) {
		CGrassElem* curgrasselem = s_grassElemVec[grasselemindex];
		if (curgrasselem && curgrasselem->GetGrass() && (curgrasselem->GetGrass() == srcmodel)) {
			retgrasselem = curgrasselem;
			break;
		}
	}
	return retgrasselem;
}

void RollbackUndoCamera(UNDOCAMERA srcundocamera)
{
	s_spcameramode.state = srcundocamera.spcameramode;
	s_camtargetflag = srcundocamera.camtargetflag;
	s_camtargetdisp = srcundocamera.camtargetdisp;
	s_moveeyepos = srcundocamera.moveeyepos;
	g_camEye = srcundocamera.camEyePos;
	g_camtargetpos = srcundocamera.camtargetpos;
	g_cameraupdir = srcundocamera.camUpVec;
	g_camdist = srcundocamera.camdist;

	PostOpenChaFile();//変数をGUIに反映　SetCamera3DFromEyePosも内部で呼ぶ

}

void RollbackBrushState(BRUSHSTATE srcbrushstate)
{
	g_brushmirrorUflag = srcbrushstate.brushmirrorUflag;
	g_brushmirrorVflag = srcbrushstate.brushmirrorVflag;
	g_ifmirrorVDiv2flag = srcbrushstate.ifmirrorVDiv2flag;
	ChangeLimitDegFlag(srcbrushstate.limitdegflag, false, false);//RollbackBrushState呼び出し元の下方にてApplyNewLimitsToWM();を呼ぶので３番目の引数はfalse
	//g_limitdegflag = srcbrushstate.limitdegflag;
	g_motionbrush_method = srcbrushstate.motionbrush_method;
	g_wallscrapingikflag = srcbrushstate.wallscrapingikflag;
	g_brushrepeats = srcbrushstate.brushrepeats;

	//if (s_BrushMirrorUCheckBox) {
	//	s_BrushMirrorUCheckBox->SetChecked((bool)g_brushmirrorUflag);
	//}
	//if (s_BrushMirrorVCheckBox) {
	//	s_BrushMirrorVCheckBox->SetChecked((bool)g_brushmirrorVflag);
	//}
	//if (s_IfMirrorVDiv2CheckBox) {
	//	s_IfMirrorVDiv2CheckBox->SetChecked((bool)g_ifmirrorVDiv2flag);
	//}
	////if (s_LimitDegCheckBox) {
	////	s_LimitDegCheckBox->SetChecked(g_limitdegflag);
	////}
	////if (s_WallScrapingIKCheckBox) {
	////	s_WallScrapingIKCheckBox->SetChecked((bool)g_wallscrapingikflag);
	////}
	s_splimiteul.state = g_limitdegflag;
	s_spscraping.state = (bool)g_wallscrapingikflag;


	//CDXUTComboBox* pComboBox = g_SampleUI.GetComboBox(IDC_COMBO_MOTIONBRUSH_METHOD);
	//if (pComboBox) {
	//	pComboBox->SetSelectedByData(ULongToPtr(g_motionbrush_method));
	//}

	//CDXUTSlider* pslider = g_SampleUI.GetSlider(IDC_SL_BRUSHREPEATS);
	//if (pslider) {
	//	pslider->SetValue(g_brushrepeats);
	//	CDXUTStatic* pstatic = g_SampleUI.GetStatic(IDC_STATIC_BRUSHREPEATS);
	//	if (pstatic) {
	//		WCHAR sz[100] = { 0L };
	//		swprintf_s(sz, 100, L"Brush Repeats : %d", g_brushrepeats);
	//		pstatic->SetText(sz);
	//	}
	//}

}

int FilterNoDlg(bool copylw2w, CModel* srcmodel, int curmotid)
{
	if (!srcmodel) {
		return 0;
	}
	if (s_smoothFlag && !srcmodel->ExistCurrentMotion()) {
		return 0;
	}
	if (!srcmodel->GetTopBone()) {
		return 0;
	}

	CMotFilter motfilter;

	bool edgesmp;
	if (s_constexeFlag) {
		edgesmp = true;
	}
	else {
		edgesmp = srcmodel->CheckIKTarget();
	}

	//s_filternodlg = true;


	//s_filterState = 3;//deeper//2023/08/09コメントアウト：前回の値を使用


	CBone* opebone = 0;
	if (s_filterState == 1) {
		//######
		//1:All
		//######
		opebone = srcmodel->GetTopBone(false);
	}
	else if ((s_filterState == 2) || (s_filterState == 3)) {
		//########################
		//2:selectedOne, 3:Deeper
		//########################
		CBone* curbone = srcmodel->GetBoneByID(s_curboneno);
		if (curbone) {
			if (curbone->GetParent(false)) {
				opebone = curbone->GetParent(false);
			}
			else {
				opebone = curbone;
			}
		}
		else {
			opebone = srcmodel->GetTopBone(false);
		}
	}
	else {
		//################################
		//the first time : default value
		//################################
		s_filterState = 3;
		CBone* curbone = srcmodel->GetBoneByID(s_curboneno);
		if (curbone) {
			if (curbone->GetParent(false)) {
				opebone = curbone->GetParent(false);
			}
			else {
				opebone = curbone;
			}
		}
		else {
			opebone = srcmodel->GetTopBone(false);
		}
	}

	motfilter.FilterNoDlg(edgesmp, g_limitdegflag, srcmodel, opebone,
		s_filterState,
		curmotid,
		IntTime(s_buttonselectstart), IntTime(s_buttonselectend));

	//s_filterState = 0;//2023/08/09コメントアウト：前回の値を保持

	if (copylw2w) {
		bool cameraanimflag = srcmodel->IsCameraMotion(curmotid);
		if (!cameraanimflag && (g_limitdegflag == true)) {
			bool allframeflag = false;
			bool setcursorflag = false;
			int operatingjointno =srcmodel->GetTopBone(false)->GetBoneNo();
			bool onpasteflag = false;
			CopyLimitedWorldToWorld(srcmodel, allframeflag, setcursorflag, operatingjointno, onpasteflag);
		}
		refreshEulerGraph();
		PrepairUndo();
	}


	return 0;
}



int FilterFuncDlg()
{
	if ((s_filterState == 1) || (s_filterState == 2) || (s_filterState == 3)) {
		//if (s_model){
		//	s_model->SaveUndoMotion(s_curboneno, s_curbaseno, &s_editrange, (double)g_applyrate);
		//}

		//if (s_model && (s_filternodlg == false)) {
		//	PrepairUndo();
		//}

		if (s_model && s_model->ExistCurrentMotion()) {
			if (s_owpTimeline && s_owpLTimeline) {
				s_editrange.Clear();
				//s_editrange.SetRange(s_owpLTimeline->getSelectedKey(), s_owpLTimeline->getCurrentTime());
				//CEditRange::SetApplyRate((double)g_applyrate);

				OnTimeLineButtonSelectFromSelectStartEnd(0);
				OnTimeLineSelectFromSelectedKey();
				int keynum;
				double startframe, endframe, applyframe;
				s_editrange.GetRange(&keynum, &startframe, &endframe, &applyframe);

				CBone* opebone = 0;
				if (s_curboneno >= 0) {
					CBone* curbone = 0;
					curbone = s_model->GetBoneByID(s_curboneno);
					if (curbone) {
						if ((s_ikkind == 0) && curbone->GetParent(false) && curbone->GetParent(false)->IsSkeleton()) {
							opebone = curbone->GetParent(false);
						}
						else {
							opebone = curbone;
						}
					}
					else {
						return 0;//!!!!!!!!
					}
				}
				else {
					return 0;//!!!!!!!!!!
				}


				if (opebone) {

					bool edgesmp;
					if (s_constexeFlag) {
						edgesmp = true;
					}
					else {
						edgesmp = s_model->CheckIKTarget();
					}

					if (keynum >= 2) {
						CMotFilter motfilter;
						motfilter.Filter(edgesmp, g_limitdegflag, s_model, opebone,
							s_filterState,
							s_model->GetCurMotInfo().motid,
							IntTime(startframe), IntTime(endframe));


						if (g_limitdegflag == true) {
							bool allframeflag = false;
							bool setcursorflag = false;
							int operatingjointno = opebone->GetBoneNo();
							bool onpasteflag = false;
							CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);
						}
						refreshEulerGraph();
						PrepairUndo();
					}
					else {
						::DSMessageBox(s_3dwnd, L"Retry After Setting Of Selection MultiFrames.", L"error!!!", MB_OK);
					}
				}
				else {
					::DSMessageBox(s_3dwnd, L"Retry After Selectiong target joint.", L"error!!!", MB_OK);
				}
			}
		}
	}
	return 0;
}



//int CallFilterFunc(int callnum)
//{
//	if (s_model && s_model->GetCurMotInfo()) {
//
//		if (g_iklevel == 1) {
//			s_filterState = 2;//one
//		}
//		else {
//			s_filterState = 3;//deeper
//		}
//		s_filternodlg = true;
//
//		int callcount;
//		for (callcount = 0; callcount < callnum; callcount++) {
//			FilterFunc();
//		}
//
//
//		//limitedへの変更を　worldに反映
//		if (g_limitdegflag == true) {
//			bool allframeflag = false;
//			bool setcursorflag = false;
//			bool onpasteflag = false;
//
//			int operatingjointno = 0;
//			CBone* curbone = s_model->GetBoneByID(s_curboneno);
//			if (curbone) {
//				if (curbone->GetParent()) {
//					operatingjointno = curbone->GetParent()->GetBoneNo();
//				}
//				else {
//					operatingjointno = curbone->GetBoneNo();
//				}
//			}
//			else {
//				if (s_model->GetTopBone()) {
//					operatingjointno = s_model->GetTopBone()->GetBoneNo();
//				}
//			}
//			CopyLimitedWorldToWorld(s_model, allframeflag, setcursorflag, operatingjointno, onpasteflag);
//		}
//
//
//		UpdateEditedEuler();
//	}
//
//
//	s_filterState = 0;
//	s_filternodlg = false;
//
//	return 0;
//}


int CreateToolTip(POINT ptCursor, WCHAR* srctext)
{
	//if (!srctext) {
	//	_ASSERT(0);
	//	return 1;
	//}
	//size_t textlen = wcslen(srctext);
	//if ((textlen == 0) || (textlen >= 512)) {
	//	_ASSERT(0);
	//	return 1;
	//}

	//int tipposx = ptCursor.x + 10;
	//int tipposy = ptCursor.y + 18;

	//if (s_TipText1 && s_TipText2 && s_TipText3 && s_TipText4 && s_TipText5) {
	//	const WCHAR* prevtext = s_TipText1->GetText();
	//	if (prevtext && (wcscmp(prevtext, srctext) == 0)) {
	//		//既に同じテキストを表示中なので位置だけ変更


	//		tipposx = min((s_mainwidth - (int)s_tooltiplen), tipposx);
	//		tipposy = min((s_mainheight - 18), tipposy);
	//		//s_TipText->SetLocation(tipposx, tipposy);
	//		s_TipText1->SetLocation(tipposx - 1, tipposy);
	//		s_TipText2->SetLocation(tipposx + 1, tipposy);
	//		s_TipText3->SetLocation(tipposx, tipposy - 1);
	//		s_TipText4->SetLocation(tipposx, tipposy + 1);
	//		s_TipText5->SetLocation(tipposx, tipposy);
	//	}
	//	else {
	//		//違うテキストを表示中　ToolTipの作り直し
	//		g_SampleUI.RemoveControl(IDC_TIPRIG1);
	//		g_SampleUI.RemoveControl(IDC_TIPRIG2);
	//		g_SampleUI.RemoveControl(IDC_TIPRIG3);
	//		g_SampleUI.RemoveControl(IDC_TIPRIG4);
	//		g_SampleUI.RemoveControl(IDC_TIPRIG5);
	//		s_TipText1 = 0;
	//		s_TipText2 = 0;
	//		s_TipText3 = 0;
	//		s_TipText4 = 0;
	//		s_TipText5 = 0;


	//		WCHAR sz512[512] = { 0L };
	//		swprintf_s(sz512, 512, L"%s", srctext);
	//		size_t szlen = wcslen(sz512);
	//		int displen;
	//		if (szlen <= 511) {
	//			displen = (int)szlen * 10;
	//		}
	//		else {
	//			sz512[511] = 0L;
	//			displen = 511 * 10;
	//		}
	//		s_tooltiplen = (size_t)displen;

	//		tipposx = min((s_mainwidth - (int)s_tooltiplen), tipposx);
	//		tipposy = min((s_mainheight - 18), tipposy);
	//		//g_SampleUI.AddStatic(IDC_TIPRIG, sz512, tipposx, tipposy, displen, 18);
	//		//s_TipText = g_SampleUI.GetStatic(IDC_TIPRIG);
	//		g_SampleUI.AddStatic(IDC_TIPRIG1, sz512, tipposx - 1, tipposy, displen, 18);
	//		g_SampleUI.AddStatic(IDC_TIPRIG2, sz512, tipposx + 1, tipposy, displen, 18);
	//		g_SampleUI.AddStatic(IDC_TIPRIG3, sz512, tipposx, tipposy - 1, displen, 18);
	//		g_SampleUI.AddStatic(IDC_TIPRIG4, sz512, tipposx, tipposy + 1, displen, 18);
	//		g_SampleUI.AddStatic(IDC_TIPRIG5, sz512, tipposx, tipposy, displen, 18);
	//		s_TipText1 = g_SampleUI.GetStatic(IDC_TIPRIG1);
	//		s_TipText2 = g_SampleUI.GetStatic(IDC_TIPRIG2);
	//		s_TipText3 = g_SampleUI.GetStatic(IDC_TIPRIG3);
	//		s_TipText4 = g_SampleUI.GetStatic(IDC_TIPRIG4);
	//		s_TipText5 = g_SampleUI.GetStatic(IDC_TIPRIG5);
	//		s_TipText1->SetTextColor(0xFF000F00);
	//		s_TipText2->SetTextColor(0xFF000F00);
	//		s_TipText3->SetTextColor(0xFF000F00);
	//		s_TipText4->SetTextColor(0xFF000F00);
	//		s_TipText5->SetTextColor(0xFFFFFFFF);
	//	}
	//}
	//else {
	//	//新規ToolTip作成

	//	WCHAR sz512[512] = { 0L };
	//	swprintf_s(sz512, 512, L"%s", srctext);
	//	size_t szlen = wcslen(sz512);
	//	int displen;
	//	if (szlen <= 511) {
	//		displen = (int)szlen * 10;
	//	}
	//	else {
	//		sz512[511] = 0L;
	//		displen = 511 * 10;
	//	}
	//	s_tooltiplen = (size_t)displen;

	//	tipposx = min((s_mainwidth - (int)s_tooltiplen), tipposx);
	//	tipposy = min((s_mainheight - 18), tipposy);
	//	//g_SampleUI.AddStatic(IDC_TIPRIG, sz512, tipposx, tipposy, displen, 18);
	//	//s_TipText = g_SampleUI.GetStatic(IDC_TIPRIG);
	//	g_SampleUI.AddStatic(IDC_TIPRIG1, sz512, tipposx - 1, tipposy, displen, 18);
	//	g_SampleUI.AddStatic(IDC_TIPRIG2, sz512, tipposx + 1, tipposy, displen, 18);
	//	g_SampleUI.AddStatic(IDC_TIPRIG3, sz512, tipposx, tipposy - 1, displen, 18);
	//	g_SampleUI.AddStatic(IDC_TIPRIG4, sz512, tipposx, tipposy + 1, displen, 18);
	//	g_SampleUI.AddStatic(IDC_TIPRIG5, sz512, tipposx, tipposy, displen, 18);
	//	s_TipText1 = g_SampleUI.GetStatic(IDC_TIPRIG1);
	//	s_TipText2 = g_SampleUI.GetStatic(IDC_TIPRIG2);
	//	s_TipText3 = g_SampleUI.GetStatic(IDC_TIPRIG3);
	//	s_TipText4 = g_SampleUI.GetStatic(IDC_TIPRIG4);
	//	s_TipText5 = g_SampleUI.GetStatic(IDC_TIPRIG5);
	//	if (s_TipText1) {
	//		s_TipText1->SetTextColor(0xFF000F00);
	//	}
	//	if (s_TipText2) {
	//		s_TipText2->SetTextColor(0xFF000F00);
	//	}
	//	if (s_TipText3) {
	//		s_TipText3->SetTextColor(0xFF000F00);
	//	}
	//	if (s_TipText4) {
	//		s_TipText4->SetTextColor(0xFF000F00);
	//	}
	//	if (s_TipText5) {
	//		s_TipText5->SetTextColor(0xFFFFFFFF);
	//	}
	//}

	return 0;
}


int CreateTipRig(CBone* currigbone, int currigno, POINT ptCursor)
{
	if (!currigbone || (currigno < 0)) {
		_ASSERT(0);
		return 1;
	}

	s_fontposfortip.Set((float)ptCursor.x, (float)ptCursor.y);


	CUSTOMRIG curcustomrig = currigbone->GetCustomRig(currigno);
	//WCHAR s_strfortip[512] = { 0L };
	swprintf_s(s_strfortip, 512, L"Rig %s : %s", currigbone->GetWBoneName(), curcustomrig.rigname);
	//CreateToolTip(ptCursor, s_strfortip);

	return 0;
}

bool PickAndSelectMeshOfDispGroupDlg()
{
	if (!s_model) {
		return false;
	}
	if (g_previewFlag != 0) {
		return false;
	}
	if (!s_chascene) {
		return false;
	}

	if (s_dispPickfortip && s_spdispsw[SPDISPSW_DISPGROUP].state) {
		if (s_pickmodel && s_pickmqoobj) {// &&
			//((s_pickmodel != s_befselectmodel) || (s_pickmqoobj != s_befselectmqoobj))) {

			s_befselectmodel = s_pickmodel;
			s_befselectmqoobj = s_pickmqoobj;
			s_befselectmaterial = s_pickmaterial;

			bool forceflag = false;
			bool callundo = true;
			OnChangeModel(s_pickmodel, forceflag, callundo);

			//WCHAR objname[256] = { 0L };
			//char tmpobjname[256] = { 0 };
			//strcpy_s(tmpobjname, 256, s_pickmqoobj->GetName());
			//MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, tmpobjname, 256, objname, 256);

			s_dispgroupdlg.ShowPosLineMqoObject(s_pickmodel, s_pickmqoobj);

		}
	}


	return s_dispPickfortip;
}

int SetModelWorldMat()
{
	CGrassElem* curgrasselem = FindGrassElem(s_model);

	if (curgrasselem && (s_removegrassflag == false)) {
		int grassnum = curgrasselem->GetGrassNum();
		if (grassnum >= GRASSINDEXMAX) {//2024/05/11現在GRASSINDEXMAXはRIGINDEXMAXと同じで256
			::MessageBox(s_modelworldmatdlgwnd, L"草のインスタンス数は２５６個までです。", L"これ以上追加できません。", MB_OK);
			return 1;
		}
	}

	ChaVector3 tmppos;
	tmppos.SetParams(0.0f, 0.0f, 0.0f);
	ChaVector3 tmprot;
	tmprot.SetParams(0.0f, 0.0f, 0.0f);
	int result = GetModelWorldMat(&tmppos, &tmprot);//向きはダイアログにセットされている向きを使用
	if (result == 0) {
		if (!curgrasselem) {
			if (s_pickmodelworldmat) {
				s_model->SetModelPosition(s_pickhitpos);//tmpposではなくs_pickhitpos
			}
			else {
				s_model->SetModelPosition(tmppos);
			}
			s_model->SetModelRotation(tmprot);
			s_model->CalcModelWorldMatOnLoad();
		}
		else {
			if (s_removegrassflag == false) {
				if (s_pickmodelworldmat) {
					curgrasselem->AddGrassPosition(s_pickhitpos, tmprot);
				}
				else {
					curgrasselem->AddGrassPosition(tmppos, tmprot);
				}
			}
			else {
				if (s_modelworldmatdlgwnd) {
					WCHAR strval[256] = { 0L };
					GetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_REMOVEDISTANCE, strval, 256);
					float value = (float)_wtof(strval);
					if (value >= 0.0f) {
						s_removegrassdistance = value;
					}
				}
				if (s_pickmodelworldmat) {
					curgrasselem->RemoveGrassPosition(s_pickhitpos, s_removegrassdistance);
				}
				else {
					curgrasselem->RemoveGrassPosition(tmppos, s_removegrassdistance);
				}
			}
		}
	}

	return 0;
}

bool PickAndPut()
{
	//上段カエルボタンの行のModelWorldMatショートカットボタンを押して出すダイアログで
	//Pick&Setにチェックを入れた場合は　マウスクリック位置にモデルを配置する

	if (!s_model) {
		return false;
	}
	if (g_previewFlag != 0) {
		return false;
	}
	if (!s_chascene) {
		return false;
	}

	if (s_dispmodelworldmat && s_pickmodelworldmat) {
		if (s_pickmodel && s_pickmqoobj) {// &&
			//((s_pickmodel != s_befselectmodel) || (s_pickmqoobj != s_befselectmqoobj))) {

			s_befselectmodel = s_pickmodel;
			s_befselectmqoobj = s_pickmqoobj;
			s_befselectmaterial = s_pickmaterial;


			//pickでhitした座標をダイアログにセット
			if (s_modelworldmatdlgwnd != NULL) {
				WCHAR strval[256] = { 0L };
				swprintf_s(strval, 256, L"%.3f", s_pickhitpos.x);
				SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_POSITIONX, strval);
				swprintf_s(strval, 256, L"%.3f", s_pickhitpos.y);
				SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_POSITIONY, strval);
				swprintf_s(strval, 256, L"%.3f", s_pickhitpos.z);
				SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_POSITIONZ, strval);
			}

			SetModelWorldMat();
		}
	}

	return s_dispPickfortip;
}

bool PickAndSelectMaterialOfShaderTypeDlg()
{
	if (!s_model) {
		return false;
	}
	if (g_previewFlag != 0) {
		return false;
	}

	if (s_dispPickfortip && s_spdispsw[SPDISPSW_SHADERTYPE].state) {
		if (s_pickmodel && s_pickmaterial) {// &&
			//((s_pickmodel != s_befselectmodel) || (s_pickmaterial != s_befselectmaterial))) {

			s_befselectmodel = s_pickmodel;
			s_befselectmqoobj = s_pickmqoobj;
			s_befselectmaterial = s_pickmaterial;

			bool forceflag = false;
			bool callundo = true;
			OnChangeModel(s_pickmodel, forceflag, callundo);

			s_shadertypedlg.SelectMaterial(s_pickmodel, s_pickmaterial);
		}
	}


	return s_dispPickfortip;
}

int DispToolTip()
{

	s_dispfontfortip = false;


	if (!s_model) {
		return 0;
	}

	if (g_previewFlag != 0) {
		return 0;
	}

	//2024/02/26 カメラターゲット位置座標表示を最優先で表示
	if (s_camtargetdisp) {
		DispTipSelect();
		s_dispfontfortip = true;
	}



	//2024/02/04 画面のスプライトドラッグ検知を最優先に
	if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
		if ((s_dispfontfortip == false)) {
			s_dispfontfortip = DispTipUI();
		}
		if (s_dispfontfortip == false) {
			s_dispfontfortip = DispTipUIFrog();
		}
	}

	if (s_dispmodelworldmat && s_pickmodelworldmat) {
		//ModelWorldMatダイアログ表示かつPickAndSetにチェックしている場合　メッシュ名を表示
		s_dispPickfortip = DispTipMesh();
	}
	else if ((s_dispfontfortip == false) && s_spdispsw[SPDISPSW_DISPGROUP].state) {
		//DispGroupプレートメニュー選択時　メッシュ名を表示
		s_dispPickfortip = DispTipMesh();
	}
	else if ((s_dispfontfortip == false) && s_spdispsw[SPDISPSW_SHADERTYPE].state) {
		//Shaderプレートメニュー選択時　マテリアル名を表示
		s_dispPickfortip = DispTipMaterial();
	}
	else if(!s_spdispsw[SPDISPSW_DISPGROUP].state && !s_spdispsw[SPDISPSW_SHADERTYPE].state){
		//DispTipMeshとDispTipMaterialの結果はrc->EndFrame()より後で分かる
		//DispGroup, Shaderメニュー時にはボーンとリグはピックしない
		if ((s_dispfontfortip == false) && (g_previewFlag == 0)) {
			if (s_oprigflag == 0) {
				//ジョイント名を表示
				s_dispfontfortip = DispTipBone();
			}
			else {
				//リグ名を表示
				s_dispfontfortip = DispTipRig();
			}
		}
	}

	return 0;
}

bool DispTipUI()
{
	UIPICKINFO tmppickinfo;
	InitPickInfo(&tmppickinfo);
	tmppickinfo.mousebefpos = s_pickinfo.mousepos;
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	tmppickinfo.mousepos = ptCursor;

	tmppickinfo.clickpos = ptCursor;
	tmppickinfo.diffmouse.SetParams(0.0f, 0.0f);
	tmppickinfo.firstdiff.SetParams(0.0f, 0.0f);
	//tmppickinfo.winx = (int)DXUTGetWindowWidth();
	//tmppickinfo.winy = (int)DXUTGetWindowHeight();
	tmppickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	tmppickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	tmppickinfo.pickrange = PICKRANGE;


	s_fontposfortip.Set((float)ptCursor.x, (float)ptCursor.y);

	WCHAR sz512[512];
	ZeroMemory(sz512, sizeof(WCHAR) * 512);


	bool dispfontfortip = false;


	int cameramode;
	cameramode = PickSpCam(ptCursor);
	switch (cameramode) {
	case PICK_CAMROT:
		dispfontfortip = true;
		wcscpy_s(sz512, 512, L"LDrag:CameraRot, RDrag:CameraTwist, RDBLCLK:TwistInit.");
		//CreateToolTip(ptCursor, s_strfortip);
		break;
	case PICK_CAMMOVE:
		dispfontfortip = true;
		wcscpy_s(sz512, 512, L"Drag Camera : Pan");
		//CreateToolTip(ptCursor, s_strfortip);
		break;
	case PICK_CAMDIST:
		dispfontfortip = true;
		wcscpy_s(sz512, 512, L"Drag Camera : Dolly");
		//CreateToolTip(ptCursor, s_strfortip);
		break;
	default:
		break;
	}

	if (dispfontfortip == false) {
		//IK Mode
		int pickikmodeflag = 0;
		pickikmodeflag = PickSpIkModeSW(ptCursor);
		if (pickikmodeflag == 1) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"IKMode : Rotation");
			//CreateToolTip(ptCursor, s_strfortip);
		}
		else if (pickikmodeflag == 2) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"IKMode : Move");
			//CreateToolTip(ptCursor, s_strfortip);
		}
		else if (pickikmodeflag == 3) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"IKMode : Scale");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	if (dispfontfortip == false) {
		int pickundo = 0;
		pickundo = PickSpUndo(ptCursor);
		if (pickundo == PICK_UNDO) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"Undo operation");
			//CreateToolTip(ptCursor, s_strfortip);
		}
		else if (pickundo == PICK_REDO) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"Redo operation");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	if (dispfontfortip == false) {
		//lod switch
		int picklodflag = 0;
		picklodflag = PickSpRefPosSW(ptCursor);
		if (picklodflag == 1) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"Disp ReferencePose");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	if (dispfontfortip == false) {
		//limiteul switch
		int picklimiteulflag = 0;
		picklimiteulflag = PickSpLimitEulSW(ptCursor);
		if (picklimiteulflag == 1) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"Angle Limit on IK Rot");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	if (dispfontfortip == false) {
		//cameramode switch
		int pickcameramodeflag = 0;
		pickcameramodeflag = PickSpCameraModeSW(ptCursor);
		if (pickcameramodeflag == 1) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"With or Without CameraAnim");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	if (dispfontfortip == false) {
		//camerainherit switch
		int pickcamerainheritflag = 0;
		pickcamerainheritflag = PickSpCameraInheritSW(ptCursor);
		if (pickcamerainheritflag == 1) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"CameraAnim InheritMode");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	if (dispfontfortip == false) {
		//wallscraping switch
		int pickscrapingflag = 0;
		pickscrapingflag = PickSpScrapingSW(ptCursor);
		if (pickscrapingflag == 1) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"WallScraping on Limited IK Rot");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	if (dispfontfortip == false) {
		if (PickSpCpLW2W(ptCursor) != 0) {
			if (s_copyLW2WFlag == false) {
				dispfontfortip = true;
				wcscpy_s(sz512, 512, L"Copy LimitedAngleMotion to UnLimitedAngleMotion");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}
	}

	if (dispfontfortip == false) {
		if (PickSpSmooth(ptCursor) != 0) {
			if (s_smoothFlag == false) {
				dispfontfortip = true;
				wcscpy_s(sz512, 512, L"LBtn:Smooth, RBtn:SettingsAndSmooth");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}
	}

	if (dispfontfortip == false) {
		if (PickSpConstExe(ptCursor) != 0) {
			if (s_constexeFlag == false) {
				dispfontfortip = true;
				wcscpy_s(sz512, 512, L"Execute Position Constraint");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}
	}
	if (dispfontfortip == false) {
		if (PickSpConstRefresh(ptCursor) != 0) {
			if (s_constrefreshFlag == false) {
				dispfontfortip = true;
				wcscpy_s(sz512, 512, L"Update TargetPosition of Constraint");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}
	}

	//###########################
	//Command buttons for Camera
	//###########################
	{
		if (dispfontfortip == false) {
			if (PickSpCopyCamera(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Copy Camera Motion");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpPasteCamera(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Paste Camera Motion");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpInterpolateCamera(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Interpolate Camera Motion");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpInitCamera(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Init Camera MotionPoint");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpSmoothCamera(ptCursor) != 0) {
				if (s_smoothFlag == false) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Smooth Camera Angle");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}
	}

	//#################################
	//Command buttons for bone motion
	//#################################
	if (s_toolspritemode == 0) {//ToolShortCut : 0
		if (dispfontfortip == false) {
			if (PickSpCopy(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Copy Motion");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpSymCopy(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"SymCopy Motion");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpPaste(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"LBtn:Paste Motion, RBtn;Settings And Paste Motion");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpCopyHistory(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Disp CopyHistory at Right Pain");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}
	}
	else if (s_toolspritemode == 1) {//ToolShortCut : 1
		if (dispfontfortip == false) {
			int pickinterpolate = 0;
			if ((pickinterpolate = PickSpInterpolate(ptCursor)) != 0) {
				if (s_model) {
					if (pickinterpolate == 1) {
						dispfontfortip = true;
						wcscpy_s(sz512, 512, L"Interpolate Motion");
						//CreateToolTip(ptCursor, s_strfortip);
					}
					else if (pickinterpolate == 2) {
						dispfontfortip = true;
						wcscpy_s(sz512, 512, L"Jump Interpolate HipsLoc");
						//CreateToolTip(ptCursor, s_strfortip);
					}
					else {
						_ASSERT(0);
					}
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpInit(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Init MotionPoint");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpScaleInit(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Init All Scale");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpProperty(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Property of Motion");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}
	}
	else if (s_toolspritemode == 2) {//ToolShortCut : 2
		if (dispfontfortip == false) {
			if (PickSpZeroFrame(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Edit 0 Frame");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpCameraDolly(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Camera Dolly History");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpModelPosDir(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Model's Pos and Dir");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}

		if (dispfontfortip == false) {
			if (PickSpMaterialRate(ptCursor) != 0) {
				if (s_model) {
					dispfontfortip = true;
					wcscpy_s(sz512, 512, L"Material Rate");
					//CreateToolTip(ptCursor, s_strfortip);
				}
			}
		}
	}
	else {
		_ASSERT(0);
	}




	if (dispfontfortip == false) {
		int oprigs_dispfontfortip = 0;
		int pickrigflag = 0;
		pickrigflag = PickSpRig(ptCursor);
		if (pickrigflag == 1) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"Rig On or Off");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	if (dispfontfortip == false) {
		if (s_spguisw[SPGUISW_CAMERA_AND_IK].state) {
			int spakind = PickSpAxis(ptCursor);
			if (spakind == PICK_SPA_X) {
				dispfontfortip = true;
				wcscpy_s(sz512, 512, L"Drag X Axis IK");
				//CreateToolTip(ptCursor, s_strfortip);
			}
			else if (spakind == PICK_SPA_Y) {
				dispfontfortip = true;
				wcscpy_s(sz512, 512, L"Drag Y Axis IK");
				//CreateToolTip(ptCursor, s_strfortip);
			}
			else if (spakind == PICK_SPA_Z) {
				dispfontfortip = true;
				wcscpy_s(sz512, 512, L"Drag Z Axis IK");
				//CreateToolTip(ptCursor, s_strfortip);
			}
		}
	}


	if (sz512[0] != 0L) {
		wcscpy_s(s_strfortip, 512, sz512);
	}
	return dispfontfortip;

}

bool DispTipUIFrog()
{
	UIPICKINFO tmppickinfo;
	InitPickInfo(&tmppickinfo);
	tmppickinfo.mousebefpos = s_pickinfo.mousepos;
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	tmppickinfo.mousepos = ptCursor;

	tmppickinfo.clickpos = ptCursor;
	tmppickinfo.diffmouse.SetParams(0.0f, 0.0f);
	tmppickinfo.firstdiff.SetParams(0.0f, 0.0f);
	//tmppickinfo.winx = (int)DXUTGetWindowWidth();
	//tmppickinfo.winy = (int)DXUTGetWindowHeight();
	tmppickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	tmppickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	tmppickinfo.pickrange = PICKRANGE;


	s_fontposfortip.Set((float)ptCursor.x, (float)ptCursor.y);

	WCHAR sz512[512];
	ZeroMemory(sz512, sizeof(WCHAR) * 512);


	bool dispfontfortip = false;

	if (dispfontfortip == false) {
		//ret2prev
		bool pickfrog = PickSpFrog(ptCursor);
		if (pickfrog == true) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"SpaceKey:Change MenuKind. C+SpaceKey:Change Plate.");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}
	if (dispfontfortip == false) {
		//ret2prev2
		bool pickfrog = PickSpFrog2(ptCursor);
		if (pickfrog == true) {
			dispfontfortip = true;
			wcscpy_s(sz512, 512, L"V + SpaceKey: Change ToolShortCutMenu.");
			//CreateToolTip(ptCursor, s_strfortip);
		}
	}

	if (sz512[0] != 0L) {
		wcscpy_s(s_strfortip, 512, sz512);
	}

	return dispfontfortip;
}

bool DispTipSelect()
{
	ChaMatrix wvpmat = s_selectmat * s_matVP;
	ChaVector3 zeropos;
	zeropos.SetParams(0.0f, 0.0f, 0.0f);
	ChaVector3 screenpos;
	screenpos.SetParams(0.0f, 0.0f, 0.0f);
	ChaVector3TransformCoord(&screenpos, &zeropos, &wvpmat);

	float scposx, scposy;
	scposx = (screenpos.x + 1.0f) * 0.5f * s_mainwidth;
	scposy = (screenpos.y + 1.0f) * 0.5f * s_mainheight;


	s_fontposfortip.Set(scposx, scposy);
	swprintf_s(s_strfortip, 512, L"Target(%.1f, %.1f, %.1f)", s_selectmat.data[MATI_41], s_selectmat.data[MATI_42], s_selectmat.data[MATI_43]);

	return true;

}

bool DispTipBone()
{
	UIPICKINFO tmppickinfo;
	InitPickInfo(&tmppickinfo);
	tmppickinfo.mousebefpos = s_pickinfo.mousepos;
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	tmppickinfo.mousepos = ptCursor;

	tmppickinfo.clickpos = ptCursor;
	tmppickinfo.diffmouse.SetParams(0.0f, 0.0f);
	tmppickinfo.firstdiff.SetParams(0.0f, 0.0f);
	//tmppickinfo.winx = (int)DXUTGetWindowWidth();
	//tmppickinfo.winy = (int)DXUTGetWindowHeight();
	tmppickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	tmppickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	tmppickinfo.pickrange = PICKRANGE;


	s_fontposfortip.Set((float)ptCursor.x, (float)ptCursor.y);

	WCHAR sz512[512];
	ZeroMemory(sz512, sizeof(WCHAR) * 512);


	bool dispfontfortip = false;

	if (g_shiftkey == false) {
		PickBone(&tmppickinfo);
	}
	if (tmppickinfo.pickobjno >= 0) {
		int curboneno = tmppickinfo.pickobjno;
		CBone* curbone = s_model->GetBoneByID(curboneno);
		if (curbone) {
			dispfontfortip = true;
			swprintf_s(s_strfortip, 512, L"Joint : %s", curbone->GetWBoneName());
		}
	}

	return dispfontfortip;
}



bool DispTipRig()
{
	if (!s_model) {
		return false;
	}

	UIPICKINFO tmppickinfo;
	InitPickInfo(&tmppickinfo);
	tmppickinfo.mousebefpos = s_pickinfo.mousepos;
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	tmppickinfo.mousepos = ptCursor;

	tmppickinfo.clickpos = ptCursor;
	tmppickinfo.diffmouse.SetParams(0.0f, 0.0f);
	tmppickinfo.firstdiff.SetParams(0.0f, 0.0f);
	//tmppickinfo.winx = (int)DXUTGetWindowWidth();
	//tmppickinfo.winy = (int)DXUTGetWindowHeight();
	tmppickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	tmppickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	tmppickinfo.pickrange = PICKRANGE;


	//s_customrigのツールチップ表示
	if ((s_oprigflag != 0) && (g_previewFlag == 0)) {
		bool forrigtip = true;
		int currigno = -1;
		int pickrigboneno = PickRigBone(&tmppickinfo, forrigtip, &currigno);
		if ((pickrigboneno >= 0) && (currigno >= 0)) {
			CBone* currigbone = s_model->GetBoneByID(pickrigboneno);
			if (currigbone) {

				s_tiprigboneno = pickrigboneno;
				s_tiprigno = currigno;
				CreateTipRig(currigbone, currigno, ptCursor);
				return true;//!!!!!!
			}
		}
		//else {
		//	//チップ削除
		//	if (s_TipText) {
		//		g_SampleUI.RemoveControl(IDC_TIPRIG);
		//		s_TipText = 0;
		//	}
		//}
	}
	return false;
}

bool DispTipMesh()
{
	if (!s_model) {
		return false;
	}

	if (!s_chascene) {
		return false;
	}

	UIPICKINFO tmppickinfo;
	InitPickInfo(&tmppickinfo);
	tmppickinfo.mousebefpos = s_pickinfo.mousepos;
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	tmppickinfo.mousepos = ptCursor;
	s_fontposfortip.Set((float)ptCursor.x, (float)ptCursor.y);

	tmppickinfo.clickpos = ptCursor;
	tmppickinfo.diffmouse.SetParams(0.0f, 0.0f);
	tmppickinfo.firstdiff.SetParams(0.0f, 0.0f);
	//tmppickinfo.winx = (int)DXUTGetWindowWidth();
	//tmppickinfo.winy = (int)DXUTGetWindowHeight();
	tmppickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	tmppickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	tmppickinfo.pickrange = PICKRANGE;

	bool pickflag = false;

	if (g_previewFlag == 0) {
		WCHAR modelname[256] = { 0L };
		WCHAR objname[256] = { 0L };
		WCHAR materialname[256] = { 0L };
		s_pickmodel = nullptr;
		s_pickmqoobj = nullptr;
		s_pickmaterial = nullptr;
		pickflag = s_chascene->PickPolyMesh(NUMKEYPICK_MQOOBJECT, &tmppickinfo, &s_pickmodel, &s_pickmqoobj, &s_pickmaterial, &s_pickhitpos);

		if (pickflag && s_pickmodel && s_pickmqoobj) {
			s_befpickmodel = s_pickmodel;
			s_befpickmqoobj = s_pickmqoobj;

			wcscpy_s(modelname, 256, s_pickmodel->GetFileName());
			char tmpobjname[256] = { 0 };
			strcpy_s(tmpobjname, 256, s_pickmqoobj->GetName());
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, tmpobjname, 256, objname, 256);

			WCHAR tmptip[512] = { 0L };
			swprintf_s(tmptip, 512, L"Mesh:%s:%s", modelname, objname);
			if (wcscmp(s_strfortip, tmptip) != 0) {
				wcscpy_s(s_strfortip, 512, tmptip);
			}
		}
	}

	return pickflag;
}

bool DispTipMaterial()
{
	if (!s_model) {
		return false;
	}

	if (!s_chascene) {
		return false;
	}

	UIPICKINFO tmppickinfo;
	InitPickInfo(&tmppickinfo);
	tmppickinfo.mousebefpos = s_pickinfo.mousepos;
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	tmppickinfo.mousepos = ptCursor;
	s_fontposfortip.Set((float)ptCursor.x, (float)ptCursor.y);

	tmppickinfo.clickpos = ptCursor;
	tmppickinfo.diffmouse.SetParams(0.0f, 0.0f);
	tmppickinfo.firstdiff.SetParams(0.0f, 0.0f);
	//tmppickinfo.winx = (int)DXUTGetWindowWidth();
	//tmppickinfo.winy = (int)DXUTGetWindowHeight();
	tmppickinfo.winx = (int)g_graphicsEngine->GetFrameBufferWidth();
	tmppickinfo.winy = (int)g_graphicsEngine->GetFrameBufferHeight();
	tmppickinfo.pickrange = PICKRANGE;

	bool pickflag = false;

	if (g_previewFlag == 0) {
		WCHAR modelname[256] = { 0L };
		WCHAR objname[256] = { 0L };
		WCHAR materialname[256] = { 0L };
		s_pickmodel = nullptr;
		s_pickmqoobj = nullptr;
		s_pickmaterial = nullptr;
		pickflag = s_chascene->PickPolyMesh(NUMKEYPICK_MQOMATERIAL, &tmppickinfo, &s_pickmodel, &s_pickmqoobj, &s_pickmaterial, &s_pickhitpos);

		if (pickflag && s_pickmodel && s_pickmaterial) {
			s_befpickmodel = s_pickmodel;
			s_befpickmaterial = s_pickmaterial;

			wcscpy_s(modelname, 256, s_pickmodel->GetFileName());
			char tmpmaterialname[256] = { 0 };
			strcpy_s(tmpmaterialname, 256, s_pickmaterial->GetName());
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, tmpmaterialname, 256, materialname, 256);
			WCHAR tmptip[512] = { 0L };
			swprintf_s(tmptip, 512, L"Material:%s:%s", modelname, materialname);
			if (wcscmp(s_strfortip, tmptip) != 0) {
				wcscpy_s(s_strfortip, 512, tmptip);
			}
		}
	}

	return pickflag;
}



//int CreateCameraDollyWnd()
//{
//
//	//CCameraDollyDlg dlg(g_camEye);
//	//dlg.DoModal();
//	//g_camEye = dlg.GetCameraPos();
//
//	HWND hDlgWnd = CreateDialogW((HMODULE)GetModuleHandle(NULL), 
//		MAKEINTRESOURCE(IDD_DOLLYDLG), g_mainhwnd, (DLGPROC)CameraDollyDlgProc);
//	if (hDlgWnd == NULL) {
//		return 1;
//	}
//	s_cameradollydlgwnd = hDlgWnd;
//	ShowWindow(s_cameradollydlgwnd, SW_HIDE);
//
//	return 0;
//}

int CreateModelWorldMatWnd()
{

	//CCameraDollyDlg dlg(g_camEye);
	//dlg.DoModal();
	//g_camEye = dlg.GetCameraPos();

	HWND hDlgWnd = CreateDialogW((HMODULE)GetModuleHandle(NULL),
		//MAKEINTRESOURCE(IDD_MODELWORLDMATDLG), g_mainhwnd, (DLGPROC)ModelWorldMatDlgProc);
		MAKEINTRESOURCE(IDD_MODELWORLDMATDLG), s_3dwnd, (DLGPROC)ModelWorldMatDlgProc);
	if (hDlgWnd == NULL) {
		return 1;
	}
	s_modelworldmatdlgwnd = hDlgWnd;
	ShowWindow(s_modelworldmatdlgwnd, SW_HIDE);
	s_dispmodelworldmat = false;
	s_pickmodelworldmat = false;

	return 0;
}

int CreateJumpGravityWnd()
{

	HWND hDlgWnd = CreateDialogW((HMODULE)GetModuleHandle(NULL),
		MAKEINTRESOURCE(IDD_JUMPGRAVITYDlg), s_3dwnd, (DLGPROC)JumpGravityDlgProc);
	if (hDlgWnd == NULL) {
		return 1;
	}
	s_jumpgravitydlgwnd = hDlgWnd;
	ShowWindow(s_jumpgravitydlgwnd, SW_HIDE);

	return 0;
}

int OnFrameBlendShape()
{


	if (s_blendshapedlg.GetBlendShapeUnderSelect()) { //2024/06/30 Means SelChange

		//undoFlagが立っていた場合にもフラグをリセット
		s_blendshapedlg.SetBlendShapeUnderSelect(false);

		if (!s_undoFlag && !s_redoFlag && //2024/07/02
			!s_blendshapedlg.GetBlendShapeUnderSelectFromUndo() && 
			!s_blendshapedlg.GetBlendShapeUnderSelectFromRefresh()) {

			int blendshapeindex = s_blendshapedlg.GetBlendShapeOpeIndex();
			if ((blendshapeindex >= 0) && (blendshapeindex < s_blendshapedlg.GetBlendShapeLineNum())) {
				CBlendShapeElem blendshapeelem = s_blendshapedlg.GetBlendShapeElem(blendshapeindex);
				if (blendshapeelem.validflag && blendshapeelem.model && blendshapeelem.mqoobj) {

					SetLTimelineMark(s_curboneno);//playerbuttonのshape名更新
					UpdateEditedEuler();

					PrepairUndo_BlendShape(blendshapeelem);
				}
			}
		}
	}

	if (s_blendshapedlg.GetBlendShapeUnderSelectFromRefresh()) {//2024/07/02 Means SelChange From Undo
		s_blendshapedlg.SetBlendShapeUnderSelectFromRefresh(false);

		int blendshapenum = s_blendshapedlg.GetBlendShapeLineNum();
		int blendshapeUndoindex = s_blendshapedlg.GetBlendShapeUndoOpeIndex();
		if ((blendshapeUndoindex >= 0) && (blendshapeUndoindex < blendshapenum)) {
			s_blendshapedlg.SetBlendShapeOpeIndex(blendshapeUndoindex);
			CBlendShapeElem blendshapeelem = s_blendshapedlg.GetBlendShapeElem(blendshapeUndoindex);
			if (blendshapeelem.validflag && blendshapeelem.model && blendshapeelem.mqoobj) {
				SetLTimelineMark(s_curboneno);//playerbuttonのshape名更新
				UpdateEditedEuler();

				s_blendshapedlg.ParamsToDlg();//valueの変更操作よりも後で呼ぶ

				//!!!! Undoからトリガーされるので　PrepairUndo_BlendShape()呼び出しは無し
			}
		}
	}


	if (s_blendshapedlg.GetBlendShapeUnderEdit()) {//スライダードラッグ中処理
		s_blendshapedlg.SetBlendShapeUnderEdit(false);

		int blendshapeindex = s_blendshapedlg.GetBlendShapeOpeIndex();
		int blendshapenum = s_blendshapedlg.GetBlendShapeLineNum();
		if ((blendshapeindex >= 0) && (blendshapeindex < blendshapenum)) {
			CBlendShapeElem blendshapeelem = s_blendshapedlg.GetBlendShapeElem(blendshapeindex);
			if (blendshapeelem.validflag && blendshapeelem.model && blendshapeelem.mqoobj) {
				int curmotid = s_model->GetCurrentMotID();
				double curframe = s_model->GetCurrentFrame();
				blendshapeelem.mqoobj->SetShapeAnimWeight(blendshapeelem.channelindex,
					curmotid, IntTime(curframe), s_blendshapedlg.GetBlendShapeAfter());

				//SetLTimelineMark(s_curboneno);//playerbuttonのshape名更新
				UpdateEditedEuler();

				s_blendshapedlg.ParamsToDlg();//valueの変更操作よりも後で呼ぶ
			}
		}
	}
	if (s_blendshapedlg.GetBlendShapePostEdit()) {//スライダードラッグ終了処理
		s_blendshapedlg.SetBlendShapePostEdit(false);
		if (s_model) {
			int blendshapeindex = s_blendshapedlg.GetBlendShapeOpeIndex();
			int blendshapenum = s_blendshapedlg.GetBlendShapeLineNum();
			if ((blendshapeindex >= 0) && (blendshapeindex < blendshapenum)) {
				CBlendShapeElem blendshapeelem = s_blendshapedlg.GetBlendShapeElem(blendshapeindex);
				if (blendshapeelem.validflag && blendshapeelem.model && blendshapeelem.mqoobj) {

					float befval = s_blendshapedlg.GetBlendShapeBefore();
					float aftval = s_blendshapedlg.GetBlendShapeAfter();

					if (fabs(aftval - befval) >= 0.020f) {//クリックしただけのときに処理が走らないように、ある程度値が変化した時だけ処理

						int result1 = blendshapeelem.model->OnBlendWeightChanged(&s_editrange,
							blendshapeelem.mqoobj, blendshapeindex, aftval);
						if (result1 != 0) {
							_ASSERT(0);
						}
					}

					SetLTimelineMark(s_curboneno);//playerbuttonのshape名更新
					UpdateEditedEuler();

					s_blendshapedlg.ParamsToDlg();//valueの変更操作よりも後で呼ぶ

					PrepairUndo_BlendShape(blendshapeelem);
				}
			}
		}
	}

	//2024/06/09 ここでBlendShapeAnim2Dlgを呼ぶと
	//毎フレームの処理が重すぎて　描画速度が極端に遅くなる
	//変更があったときのみ処理するように修正
	//s_blendshapedlg.ParamsToDlg();//valueの変更操作よりも後で呼ぶ

	return 0;
}

int OnFrameShaderTypeParamsDlg()//OnFrameToolWnd()から呼び出す
{
	if (s_shadertypedlg.GetShaderTypeParamsFlag()) {
		s_shadertypedlg.SetShaderTypeParamsFlag(false);

		//CloseAllRightPainWindow();//<--これを呼ぶと　SPDISPSW_SHADERTYPE].stateがfalseになってしまい　windowが反応しなくなる

		//s_shadertypeparamsFlagがtrueになるのは
		//s_shadertypeWndからマテリアル名ボタンを押した場合と　PickAndSetでマテリアルを選択した場合

		//if (s_shadertypeWnd) {
		//	//s_shadertypeWnd->setListenMouse(false);//<--- CloseAllRightPainWindow()を呼んだ時にwindowが反応しなくなるのはこの呼び出しが原因だった
		//	s_shadertypeWnd->setVisible(false);
		//}
		s_shadertypedlg.SetVisible(false);

		ShowShaderTypeParamsDlg(true);

		//	if (s_model) {
		//		//int materialnum = s_model->GetMQOMaterialSize();
		//		//if ((s_shadertypedlg.GetShaderTypeParamsIndex() >= 0) && (s_shadertypedlg.GetShaderTypeParamsIndex() < (materialnum + 1))) {
		//		//	ShowShaderTypeParamsDlg(true);
		//		//}
		//	}
	}

	if (s_shaderparamsdlg.GetShaderBackFlag()) {
		s_shaderparamsdlg.SetShaderBackFlag(false);

		ShowShaderTypeWnd(true);
	}
	if (s_shaderparamsdlg.GetShaderStRadioFlag()) {
		s_shaderparamsdlg.SetShaderStRadioFlag(false);
		if (s_model) {
			int shadertype = s_shaderparamsdlg.GetShaderTypeRadio();
			switch (shadertype) {
			case 0:
				s_shadertypeparams.shadertype = -1;
				break;
			case 1:
				s_shadertypeparams.shadertype = MQOSHADER_PBR;
				break;
			case 2:
				s_shadertypeparams.shadertype = MQOSHADER_STD;
				break;
			case 3:
				s_shadertypeparams.shadertype = MQOSHADER_TOON;
				break;
			default:
				_ASSERT(0);
				break;
			}
			s_shadertypedlg.SetShaderType(shadertype);
		}
	}
	if (s_shaderparamsdlg.GetShaderLightChkFlag()) {
		s_shaderparamsdlg.SetShaderLightChkFlag(false);
		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_shaderparamsdlg.GetShaderLightFlagChk();
			if (ischecked) {
				s_shadertypeparams.lightingmat = true;
			}
			else {
				s_shadertypeparams.lightingmat = false;
			}

			if (curmqomat) {
				curmqomat->SetLightingFlag(s_shadertypeparams.lightingmat);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetLightingFlag(s_shadertypeparams.lightingmat);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderShadowCasterChkFlag()) {
		s_shaderparamsdlg.SetShaderShadowCasterChkFlag(false);
		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_shaderparamsdlg.GetShaderShadowCasterChk();
			if (ischecked) {
				s_shadertypeparams.shadowcasterflag = true;
			}
			else {
				s_shadertypeparams.shadowcasterflag = false;
			}

			if (curmqomat) {
				curmqomat->SetShadowCasterFlag(s_shadertypeparams.shadowcasterflag);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetShadowCasterFlag(s_shadertypeparams.shadowcasterflag);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderNormalY0ChkFlag()) {
		s_shaderparamsdlg.SetShaderNormalY0ChkFlag(false);
		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_shaderparamsdlg.GetShadowNormalY0Chk();
			if (ischecked) {
				s_shadertypeparams.normaly0flag = true;
			}
			else {
				s_shadertypeparams.normaly0flag = false;
			}

			if (curmqomat) {
				curmqomat->SetNormalY0Flag(s_shadertypeparams.normaly0flag);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetNormalY0Flag(s_shadertypeparams.normaly0flag);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderSpcCoefSliderFlag()) {
		s_shaderparamsdlg.SetShaderSpcCoefSliderFlag(false);
		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newspcscale = s_shaderparamsdlg.GetShaderSpcCoefSlider();
			s_shadertypeparams.specularcoef = newspcscale;

			if (curmqomat) {
				curmqomat->SetSpecularCoef(newspcscale);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetSpecularCoef(newspcscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderEmissionChkFlag()) {
		s_shaderparamsdlg.SetShaderEmissionChkFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_shaderparamsdlg.GetShaderEmissionChk();
			if (ischecked) {
				s_shadertypeparams.enableEmission = true;
			}
			else {
				s_shadertypeparams.enableEmission = false;
			}

			if (curmqomat) {
				curmqomat->SetEnableEmission(s_shadertypeparams.enableEmission);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetEnableEmission(s_shadertypeparams.enableEmission);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderEmissionSliderFlag()) {
		s_shaderparamsdlg.SetShaderEmissionSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newemiscale = s_shaderparamsdlg.GetShaderEmissionSlider();
			s_shadertypeparams.emissiveScale = newemiscale;

			if (curmqomat) {
				curmqomat->SetEmissiveScale(newemiscale);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetEmissiveScale(newemiscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderMetalSliderFlag()) {
		s_shaderparamsdlg.SetShaderMetalSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newmetalcoef = s_shaderparamsdlg.GetShaderMetalSlider();
			s_shadertypeparams.metalcoef = newmetalcoef;

			if (curmqomat) {
				curmqomat->SetMetalAdd(newmetalcoef);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetMetalAdd(newmetalcoef);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderSmoothSliderFlag()) {
		s_shaderparamsdlg.SetShaderSmoothSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newsmoothcoef = s_shaderparamsdlg.GetShaderSmoothSlider();
			s_shadertypeparams.smoothcoef = newsmoothcoef;

			if (curmqomat) {
				curmqomat->SetSmoothCoef(newsmoothcoef);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetSmoothCoef(newsmoothcoef);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderLitScale1Flag()) {
		s_shaderparamsdlg.SetShaderLitScale1Flag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int litno4 = 0;//!!!
			float newlitscale = s_shaderparamsdlg.GetShaderLitScaleSlider1();
			s_shadertypeparams.lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderLitScale2Flag()) {
		s_shaderparamsdlg.SetShaderLitScale2Flag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int litno4 = 1;//!!!
			float newlitscale = s_shaderparamsdlg.GetShaderLitScaleSlider2();
			s_shadertypeparams.lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderLitScale3Flag()) {
		s_shaderparamsdlg.SetShaderLitScale3Flag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int litno4 = 2;//!!!
			float newlitscale = s_shaderparamsdlg.GetShaderLitScaleSlider3();
			s_shadertypeparams.lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderLitScale4Flag()) {
		s_shaderparamsdlg.SetShaderLitScale4Flag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int litno4 = 3;//!!!
			float newlitscale = s_shaderparamsdlg.GetShaderLitScaleSlider4();
			s_shadertypeparams.lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderLitScale5Flag()) {
		s_shaderparamsdlg.SetShaderLitScale5Flag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int litno4 = 4;//!!!
			float newlitscale = s_shaderparamsdlg.GetShaderLitScaleSlider5();
			s_shadertypeparams.lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderLitScale6Flag()) {
		s_shaderparamsdlg.SetShaderLitScale6Flag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int litno4 = 5;//!!!
			float newlitscale = s_shaderparamsdlg.GetShaderLitScaleSlider6();
			s_shadertypeparams.lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderLitScale7Flag()) {
		s_shaderparamsdlg.SetShaderLitScale7Flag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int litno4 = 6;//!!!
			float newlitscale = s_shaderparamsdlg.GetShaderLitScaleSlider7();
			s_shadertypeparams.lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderLitScale8Flag()) {
		s_shaderparamsdlg.SetShaderLitScale8Flag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int litno4 = 7;//!!!
			float newlitscale = s_shaderparamsdlg.GetShaderLitScaleSlider8();
			s_shadertypeparams.lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonLitRadioFlag()) {
		s_shaderparamsdlg.SetShaderToonLitRadioFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int lightindex = s_shaderparamsdlg.GetShaderToonLitRadio();
			s_shadertypeparams.hsvtoon.lightindex = lightindex;

			if (curmqomat) {
				curmqomat->SetToonLightIndex(lightindex);
			}
			else {
				int materialindex8;
				for (materialindex8 = 0; materialindex8 < materialnum; materialindex8++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex8);
					if (setmqomat) {
						setmqomat->SetToonLightIndex(lightindex);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonHiAddrSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonHiAddrSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float hicolorh = s_shaderparamsdlg.GetShaderToonHiAddrSlider();
			s_shadertypeparams.hsvtoon.hicolorh = hicolorh;

			if (curmqomat) {
				curmqomat->SetToonHiAddrH(s_shadertypeparams.hsvtoon.hicolorh);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddrH(s_shadertypeparams.hsvtoon.hicolorh);
						s_hsvtoonforall.hicolorh = s_shadertypeparams.hsvtoon.hicolorh;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderRemakeToonTextureFlag()) {
		s_shaderparamsdlg.SetShaderRemakeToonTextureFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			if (curmqomat) {
				s_toonmqomaterial = curmqomat;
			}
			else {
				s_toonmqomaterial = nullptr;
			}
			s_toonparamchange = true;
		}
	}
	if (s_shaderparamsdlg.GetShaderToonLowAddrSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonLowAddrSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float lowcolorh = s_shaderparamsdlg.GetShaderToonLowAddrSlider();
			s_shadertypeparams.hsvtoon.lowcolorh = lowcolorh;

			if (curmqomat) {
				curmqomat->SetToonLowAddrH(s_shadertypeparams.hsvtoon.lowcolorh);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddrH(s_shadertypeparams.hsvtoon.lowcolorh);
						s_hsvtoonforall.lowcolorh = s_shadertypeparams.hsvtoon.lowcolorh;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderGradationChkFlag()) {
		s_shaderparamsdlg.SetShaderGradationChkFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_shaderparamsdlg.GetShaderGradationChk();
			if (ischecked) {
				s_shadertypeparams.hsvtoon.gradationflag = true;
			}
			else {
				s_shadertypeparams.hsvtoon.gradationflag = false;
			}

			if (curmqomat) {
				curmqomat->SetToonGradationFlag(s_shadertypeparams.hsvtoon.gradationflag);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonGradationFlag(s_shadertypeparams.hsvtoon.gradationflag);
						s_hsvtoonforall.gradationflag = s_shadertypeparams.hsvtoon.gradationflag;
					}
				}
			}

			if (curmqomat) {
				s_toonmqomaterial = curmqomat;
			}
			else {
				s_toonmqomaterial = nullptr;
			}
			s_toonparamchange = true;
		}
	}
	if (s_shaderparamsdlg.GetShaderPowerToonChkFlag()) {
		s_shaderparamsdlg.SetShaderPowerToonChkFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_shaderparamsdlg.GetShaderPowerToonChk();
			if (ischecked) {
				s_shadertypeparams.hsvtoon.powertoon = true;
			}
			else {
				s_shadertypeparams.hsvtoon.powertoon = false;
			}

			if (curmqomat) {
				curmqomat->SetToonPowerToon(s_shadertypeparams.hsvtoon.powertoon);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonPowerToon(s_shadertypeparams.hsvtoon.powertoon);
						s_hsvtoonforall.powertoon = s_shadertypeparams.hsvtoon.powertoon;
					}
				}
			}

			if (curmqomat) {
				s_toonmqomaterial = curmqomat;
			}
			else {
				s_toonmqomaterial = nullptr;
			}
			s_toonparamchange = true;
		}
	}
	if (s_shaderparamsdlg.GetShaderToonBaseHSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonBaseHSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			s_shadertypeparams.hsvtoon.basehsv.x = s_shaderparamsdlg.GetShaderToonBaseHSlider();

			if (curmqomat) {
				curmqomat->SetToonBaseH(s_shadertypeparams.hsvtoon.basehsv.x);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonBaseH(s_shadertypeparams.hsvtoon.basehsv.x);
						s_hsvtoonforall.basehsv.x = s_shadertypeparams.hsvtoon.basehsv.x;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonBaseSSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonBaseSSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			s_shadertypeparams.hsvtoon.basehsv.y = s_shaderparamsdlg.GetShaderToonBaseSSlider();

			if (curmqomat) {
				curmqomat->SetToonBaseS(s_shadertypeparams.hsvtoon.basehsv.y);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonBaseS(s_shadertypeparams.hsvtoon.basehsv.y);
						s_hsvtoonforall.basehsv.y = s_shadertypeparams.hsvtoon.basehsv.y;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonBaseVSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonBaseVSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			s_shadertypeparams.hsvtoon.basehsv.z = s_shaderparamsdlg.GetShaderToonBaseVSlider();

			if (curmqomat) {
				curmqomat->SetToonBaseV(s_shadertypeparams.hsvtoon.basehsv.z);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonBaseV(s_shadertypeparams.hsvtoon.basehsv.z);
						s_hsvtoonforall.basehsv.z = s_shadertypeparams.hsvtoon.basehsv.z;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonBaseASliderFlag()) {
		s_shaderparamsdlg.SetShaderToonBaseASliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			s_shadertypeparams.hsvtoon.basehsv.w = s_shaderparamsdlg.GetShaderToonBaseASlider();

			if (curmqomat) {
				curmqomat->SetToonBaseA(s_shadertypeparams.hsvtoon.basehsv.w);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonBaseA(s_shadertypeparams.hsvtoon.basehsv.w);
						s_hsvtoonforall.basehsv.w = s_shadertypeparams.hsvtoon.basehsv.w;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonHiHSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonHiHSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newvalue = s_shaderparamsdlg.GetShaderToonHiHSlider();
			s_shadertypeparams.hsvtoon.hiaddhsv.x = newvalue;

			if (curmqomat) {
				curmqomat->SetToonHiAddH(s_shadertypeparams.hsvtoon.hiaddhsv.x);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddH(s_shadertypeparams.hsvtoon.hiaddhsv.x);
						s_hsvtoonforall.hiaddhsv.x = s_shadertypeparams.hsvtoon.hiaddhsv.x;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonHiSSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonHiSSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newvalue = s_shaderparamsdlg.GetShaderToonHiSSlider();
			s_shadertypeparams.hsvtoon.hiaddhsv.y = newvalue;

			if (curmqomat) {
				curmqomat->SetToonHiAddS(s_shadertypeparams.hsvtoon.hiaddhsv.y);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddS(s_shadertypeparams.hsvtoon.hiaddhsv.y);
						s_hsvtoonforall.hiaddhsv.y = s_shadertypeparams.hsvtoon.hiaddhsv.y;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonHiVSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonHiVSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newvalue = s_shaderparamsdlg.GetShaderToonHiVSlider();
			s_shadertypeparams.hsvtoon.hiaddhsv.z = newvalue;

			if (curmqomat) {
				curmqomat->SetToonHiAddV(s_shadertypeparams.hsvtoon.hiaddhsv.z);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddV(s_shadertypeparams.hsvtoon.hiaddhsv.z);
						s_hsvtoonforall.hiaddhsv.z = s_shadertypeparams.hsvtoon.hiaddhsv.z;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonHiASliderFlag()) {
		s_shaderparamsdlg.SetShaderToonHiASliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newvalue = s_shaderparamsdlg.GetShaderToonHiASlider();
			s_shadertypeparams.hsvtoon.hiaddhsv.w = newvalue;

			if (curmqomat) {
				curmqomat->SetToonHiAddA(s_shadertypeparams.hsvtoon.hiaddhsv.w);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddA(s_shadertypeparams.hsvtoon.hiaddhsv.w);
						s_hsvtoonforall.hiaddhsv.w = s_shadertypeparams.hsvtoon.hiaddhsv.w;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonLowHSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonLowHSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);


			float newvalue = s_shaderparamsdlg.GetShaderToonLowHSlider();
			s_shadertypeparams.hsvtoon.lowaddhsv.x = newvalue;

			if (curmqomat) {
				curmqomat->SetToonLowAddH(s_shadertypeparams.hsvtoon.lowaddhsv.x);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddH(s_shadertypeparams.hsvtoon.lowaddhsv.x);
						s_hsvtoonforall.lowaddhsv.x = s_shadertypeparams.hsvtoon.lowaddhsv.x;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonLowSSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonLowSSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);


			float newvalue = s_shaderparamsdlg.GetShaderToonLowSSlider();
			s_shadertypeparams.hsvtoon.lowaddhsv.y = newvalue;

			if (curmqomat) {
				curmqomat->SetToonLowAddS(s_shadertypeparams.hsvtoon.lowaddhsv.y);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddS(s_shadertypeparams.hsvtoon.lowaddhsv.y);
						s_hsvtoonforall.lowaddhsv.y = s_shadertypeparams.hsvtoon.lowaddhsv.y;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonLowVSliderFlag()) {
		s_shaderparamsdlg.SetShaderToonLowVSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);


			float newvalue = s_shaderparamsdlg.GetShaderToonLowVSlider();
			s_shadertypeparams.hsvtoon.lowaddhsv.z = newvalue;

			if (curmqomat) {
				curmqomat->SetToonLowAddV(s_shadertypeparams.hsvtoon.lowaddhsv.z);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddV(s_shadertypeparams.hsvtoon.lowaddhsv.z);
						s_hsvtoonforall.lowaddhsv.z = s_shadertypeparams.hsvtoon.lowaddhsv.z;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderToonLowASliderFlag()) {
		s_shaderparamsdlg.SetShaderToonLowASliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);


			float newvalue = s_shaderparamsdlg.GetShaderToonLowASlider();
			s_shadertypeparams.hsvtoon.lowaddhsv.w = newvalue;

			if (curmqomat) {
				curmqomat->SetToonLowAddA(s_shadertypeparams.hsvtoon.lowaddhsv.w);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddA(s_shadertypeparams.hsvtoon.lowaddhsv.w);
						s_hsvtoonforall.lowaddhsv.w = s_shadertypeparams.hsvtoon.lowaddhsv.w;
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderTilingUSliderFlag()) {
		s_shaderparamsdlg.SetShaderTilingUSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int newvalue = s_shaderparamsdlg.GetShaderTilingUSlider();
			s_shadertypeparams.uvscale.x = (double)newvalue;

			if (curmqomat) {
				curmqomat->SetUVScale(s_shadertypeparams.uvscale);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetUVScale(s_shadertypeparams.uvscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderTilingUSliderUpFlag()) {
		s_shaderparamsdlg.SetShaderTilingUSliderUpFlag(false);

		if (s_model) {
			int newvalue = s_shaderparamsdlg.GetShaderTilingUSlider();
			s_shadertypeparams.uvscale.x = (double)newvalue;
			s_shaderparamsdlg.SetShaderTilingUSlider(newvalue);
			//s_st_tilingUslider->setValue(s_shadertypeparams.uvscale.x, false);//!!! マウスを離したときにintに丸めた値をセットし直す
		}
	}
	if (s_shaderparamsdlg.GetShaderTilingVSliderFlag()) {
		s_shaderparamsdlg.SetShaderTilingVSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int newvalue = s_shaderparamsdlg.GetShaderTilingVSlider();
			s_shadertypeparams.uvscale.y = (double)newvalue;

			if (curmqomat) {
				curmqomat->SetUVScale(s_shadertypeparams.uvscale);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetUVScale(s_shadertypeparams.uvscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderTilingVSliderUpFlag()) {
		s_shaderparamsdlg.SetShaderTilingVSliderUpFlag(false);

		if (s_model) {
			int newvalue = s_shaderparamsdlg.GetShaderTilingVSlider();
			s_shadertypeparams.uvscale.y = (double)newvalue;

			//s_st_tilingVslider->setValue(s_shadertypeparams.uvscale.y, false);//!!! マウスを離したときにintに丸めた値をセットし直す
			s_shaderparamsdlg.SetShaderTilingVSlider(newvalue);
		}
	}
	if (s_shaderparamsdlg.GetShaderAlphaTestSliderFlag()) {
		s_shaderparamsdlg.SetShaderAlphaTestSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			s_shadertypeparams.alphatest = s_shaderparamsdlg.GetShaderAlphaTestSlider();

			if (curmqomat) {
				curmqomat->SetAlphaTestClipVal(s_shadertypeparams.alphatest);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetAlphaTestClipVal(s_shadertypeparams.alphatest);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderDistortionChkFlag()) {
		s_shaderparamsdlg.SetShaderDistortionChkFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_shaderparamsdlg.GetShaderDistortionChk();
			if (ischecked) {
				s_shadertypeparams.distortionflag = true;
			}
			else {
				s_shadertypeparams.distortionflag = false;
			}

			if (curmqomat) {
				curmqomat->SetDistortionFlag(s_shadertypeparams.distortionflag);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetDistortionFlag(s_shadertypeparams.distortionflag);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderDistortionScaleSliderFlag()) {
		s_shaderparamsdlg.SetShaderDistortionScaleSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			double newvalue = s_shaderparamsdlg.GetShaderDistortonScaleSlider();
			s_shadertypeparams.distortionscale = newvalue;

			if (curmqomat) {
				curmqomat->SetDistortionScale(s_shadertypeparams.distortionscale);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetDistortionScale(s_shadertypeparams.distortionscale);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderRiverRadioFlag()) {
		s_shaderparamsdlg.SetShaderRiverRadioFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int riverorsea = s_shaderparamsdlg.GetShaderRiverRadio();
			s_shadertypeparams.riverorsea = riverorsea;

			if (curmqomat) {
				curmqomat->SetRiverOrSea(riverorsea);
			}
			else {
				int materialindex8;
				for (materialindex8 = 0; materialindex8 < materialnum; materialindex8++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex8);
					if (setmqomat) {
						setmqomat->SetRiverOrSea(riverorsea);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderSeaCenterUSliderFlag()) {
		s_shaderparamsdlg.SetShaderSeaCenterUSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newvalueU = s_shaderparamsdlg.GetShaderSeaCenterUSlider();
			float newvalueV = s_shaderparamsdlg.GetShaderSeaCenterVSlider();
			s_shadertypeparams.seacenter.SetParams(newvalueU, newvalueV);

			if (curmqomat) {
				curmqomat->SetSeaCenter(s_shadertypeparams.seacenter);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetSeaCenter(s_shadertypeparams.seacenter);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderSeaCenterVSliderFlag()) {
		s_shaderparamsdlg.SetShaderSeaCenterVSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newvalueU = s_shaderparamsdlg.GetShaderSeaCenterUSlider();
			float newvalueV = s_shaderparamsdlg.GetShaderSeaCenterVSlider();
			s_shadertypeparams.seacenter.SetParams(newvalueU, newvalueV);

			if (curmqomat) {
				curmqomat->SetSeaCenter(s_shadertypeparams.seacenter);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetSeaCenter(s_shadertypeparams.seacenter);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderRiverDirUSliderFlag()) {
		s_shaderparamsdlg.SetShaderRiverDirUSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newvalueU = s_shaderparamsdlg.GetShaderRiverDirUSlider();
			float newvalueV = s_shaderparamsdlg.GetShaderRiverDirVSlider();
			s_shadertypeparams.riverdir.SetParams(newvalueU, newvalueV);

			if (curmqomat) {
				curmqomat->SetRiverDir(s_shadertypeparams.riverdir);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetRiverDir(s_shadertypeparams.riverdir);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderRiverDirVSliderFlag()) {
		s_shaderparamsdlg.SetShaderRiverDirVSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			float newvalueU = s_shaderparamsdlg.GetShaderRiverDirUSlider();
			float newvalueV = s_shaderparamsdlg.GetShaderRiverDirVSlider();
			s_shadertypeparams.riverdir.SetParams(newvalueU, newvalueV);

			if (curmqomat) {
				curmqomat->SetRiverDir(s_shadertypeparams.riverdir);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetRiverDir(s_shadertypeparams.riverdir);
					}
				}
			}
		}
	}
	if (s_shaderparamsdlg.GetShaderFlowRateSliderFlag()) {
		s_shaderparamsdlg.SetShaderFlowRateSliderFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			double newvalue = s_shaderparamsdlg.GetShaderFlowRateSlider();
			s_shadertypeparams.riverflowrate = newvalue;

			if (curmqomat) {
				curmqomat->SetRiverFlowRate(s_shadertypeparams.riverflowrate);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetRiverFlowRate(s_shadertypeparams.riverflowrate);
					}
				}
			}
		}

	}
	if (s_shaderparamsdlg.GetShaderDistortionMapRadioFlag()) {
		s_shaderparamsdlg.SetShaderDistortionMapRadioFlag(false);

		if (s_model) {
			int materialnum = s_model->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = s_shadertypedlg.GetShaderTypeParamsIndex() - 1;
			CMQOMaterial* curmqomat = s_model->GetMQOMaterialByIndex(materialindex);

			int maptype = s_shaderparamsdlg.GetShaderDistortionMapRadio();
			s_shadertypeparams.distortionmaptype = maptype;

			if (curmqomat) {
				curmqomat->SetDistortionMapType(maptype);
			}
			else {
				int materialindex8;
				for (materialindex8 = 0; materialindex8 < materialnum; materialindex8++) {
					CMQOMaterial* setmqomat = s_model->GetMQOMaterialByIndex(materialindex8);
					if (setmqomat) {
						setmqomat->SetDistortionMapType(maptype);
					}
				}
			}
		}
	}

	return 0;
}

int OnFrameSkyParamsDlg()//OnFrameToolWnd()から呼び出す
{
	if (s_skyparamsFlag) {
		s_skyparamsFlag = false;
		if (s_sky) {
			s_platemenukind = SPPLATEMENUKIND_EFFECT;
			s_platemenuno = 1;
			s_guiswflag = false;//2段目メニューを右ペインに表示するときfalse
			GUIMenuSetVisible(s_platemenukind, 1);
		}
	}

	if (s_skyparamsdlg.GetSkySlotFlag()) {
		s_skyparamsdlg.SetSkySlotFlag(false);
		int slotindex = s_skyparamsdlg.GetSkySlotIndex();
		if ((slotindex >= 0) && (slotindex < 8)) {
			g_skyindex = slotindex;

			SetSkyParamsToSky(s_skyparams[g_skyindex]);
			//if (s_sky) {
			//	CMQOMaterial* curmqomat = nullptr;
			//	curmqomat = s_sky->GetMQOMaterialByIndex(0);
			//	s_skyparamsdlg.ParamsToDlg(s_sky, curmqomat, &(s_skyparams[g_skyindex]));
			//}
			ShowSkyWnd(true);
		}
		else {
			_ASSERT(0);
		}
	}


	if (s_skyparamsdlg.GetSkyStRadioFlag()) {
		s_skyparamsdlg.SetSkyStRadioFlag(false);
		if (s_sky) {

			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int shadertype = s_skyparamsdlg.GetSkyTypeRadio();
			switch (shadertype) {
			case 0:
				if (curmqomat) {
					curmqomat->SetShaderType(-1);
					s_skyparams[g_skyindex].shadertype = -1;
				}
				else {
					int materialindex5;
					for (materialindex5 = 0; materialindex5 < materialnum; materialindex5++) {
						CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex5);
						if (setmqomat) {
							setmqomat->SetShaderType(-1);
						}
					}
				}
				break;
			case 1:
				s_skyparams[g_skyindex].shadertype = MQOSHADER_PBR;

				if (curmqomat) {
					curmqomat->SetShaderType(MQOSHADER_PBR);
				}
				else {
					int materialindex6;
					for (materialindex6 = 0; materialindex6 < materialnum; materialindex6++) {
						CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex6);
						if (setmqomat) {
							setmqomat->SetShaderType(MQOSHADER_PBR);
						}
					}
				}
				break;
			case 2:
				s_skyparams[g_skyindex].shadertype = MQOSHADER_STD;

				if (curmqomat) {
					curmqomat->SetShaderType(MQOSHADER_STD);
				}
				else {
					int materialindex7;
					for (materialindex7 = 0; materialindex7 < materialnum; materialindex7++) {
						CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex7);
						if (setmqomat) {
							setmqomat->SetShaderType(MQOSHADER_STD);
						}
					}
				}
				break;
			case 3:
				s_skyparams[g_skyindex].shadertype = MQOSHADER_TOON;

				if (curmqomat) {
					curmqomat->SetShaderType(MQOSHADER_TOON);
				}
				else {
					int materialindex8;
					for (materialindex8 = 0; materialindex8 < materialnum; materialindex8++) {
						CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex8);
						if (setmqomat) {
							setmqomat->SetShaderType(MQOSHADER_TOON);
						}
					}
				}
				break;
			default:
				_ASSERT(0);
				break;
			}

		}
	}
	if (s_skyparamsdlg.GetSkyLightChkFlag()) {
		s_skyparamsdlg.SetSkyLightChkFlag(false);
		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_skyparamsdlg.GetSkyLightFlagChk();
			if (ischecked) {
				s_skyparams[g_skyindex].lightingmat = true;
			}
			else {
				s_skyparams[g_skyindex].lightingmat = false;
			}

			if (curmqomat) {
				curmqomat->SetLightingFlag(s_skyparams[g_skyindex].lightingmat);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetLightingFlag(s_skyparams[g_skyindex].lightingmat);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyShadowCasterChkFlag()) {
		s_skyparamsdlg.SetSkyShadowCasterChkFlag(false);
		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_skyparamsdlg.GetSkyShadowCasterChk();
			if (ischecked) {
				s_skyparams[g_skyindex].shadowcasterflag = true;
			}
			else {
				s_skyparams[g_skyindex].shadowcasterflag = false;
			}

			if (curmqomat) {
				curmqomat->SetShadowCasterFlag(s_skyparams[g_skyindex].shadowcasterflag);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetShadowCasterFlag(s_skyparams[g_skyindex].shadowcasterflag);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyNormalY0ChkFlag()) {
		s_skyparamsdlg.SetSkyNormalY0ChkFlag(false);
		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_skyparamsdlg.GetShadowNormalY0Chk();
			if (ischecked) {
				s_skyparams[g_skyindex].normaly0flag = true;
			}
			else {
				s_skyparams[g_skyindex].normaly0flag = false;
			}

			if (curmqomat) {
				curmqomat->SetNormalY0Flag(s_skyparams[g_skyindex].normaly0flag);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetNormalY0Flag(s_skyparams[g_skyindex].normaly0flag);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkySpcCoefSliderFlag()) {
		s_skyparamsdlg.SetSkySpcCoefSliderFlag(false);
		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float newspcscale = s_skyparamsdlg.GetSkySpcCoefSlider();
			s_skyparams[g_skyindex].specularcoef = newspcscale;

			if (curmqomat) {
				curmqomat->SetSpecularCoef(newspcscale);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetSpecularCoef(newspcscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyEmissionChkFlag()) {
		s_skyparamsdlg.SetSkyEmissionChkFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_skyparamsdlg.GetSkyEmissionChk();
			if (ischecked) {
				s_skyparams[g_skyindex].enableEmission = true;
			}
			else {
				s_skyparams[g_skyindex].enableEmission = false;
			}

			if (curmqomat) {
				curmqomat->SetEnableEmission(s_skyparams[g_skyindex].enableEmission);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetEnableEmission(s_skyparams[g_skyindex].enableEmission);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyEmissionSliderFlag()) {
		s_skyparamsdlg.SetSkyEmissionSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float newemiscale = s_skyparamsdlg.GetSkyEmissionSlider();
			s_skyparams[g_skyindex].emissiveScale = newemiscale;

			if (curmqomat) {
				curmqomat->SetEmissiveScale(newemiscale);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetEmissiveScale(newemiscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyMetalSliderFlag()) {
		s_skyparamsdlg.SetSkyMetalSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float newmetalcoef = s_skyparamsdlg.GetSkyMetalSlider();
			s_skyparams[g_skyindex].metalcoef = newmetalcoef;

			if (curmqomat) {
				curmqomat->SetMetalAdd(newmetalcoef);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetMetalAdd(newmetalcoef);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkySmoothSliderFlag()) {
		s_skyparamsdlg.SetSkySmoothSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float newsmoothcoef = s_skyparamsdlg.GetSkySmoothSlider();
			s_skyparams[g_skyindex].smoothcoef = newsmoothcoef;

			if (curmqomat) {
				curmqomat->SetSmoothCoef(newsmoothcoef);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetSmoothCoef(newsmoothcoef);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyLitScale1Flag()) {
		s_skyparamsdlg.SetSkyLitScale1Flag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int litno4 = 0;//!!!
			float newlitscale = s_skyparamsdlg.GetSkyLitScaleSlider1();
			s_skyparams[g_skyindex].lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyLitScale2Flag()) {
		s_skyparamsdlg.SetSkyLitScale2Flag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int litno4 = 1;//!!!
			float newlitscale = s_skyparamsdlg.GetSkyLitScaleSlider2();
			s_skyparams[g_skyindex].lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyLitScale3Flag()) {
		s_skyparamsdlg.SetSkyLitScale3Flag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int litno4 = 2;//!!!
			float newlitscale = s_skyparamsdlg.GetSkyLitScaleSlider3();
			s_skyparams[g_skyindex].lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyLitScale4Flag()) {
		s_skyparamsdlg.SetSkyLitScale4Flag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int litno4 = 3;//!!!
			float newlitscale = s_skyparamsdlg.GetSkyLitScaleSlider4();
			s_skyparams[g_skyindex].lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyLitScale5Flag()) {
		s_skyparamsdlg.SetSkyLitScale5Flag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int litno4 = 4;//!!!
			float newlitscale = s_skyparamsdlg.GetSkyLitScaleSlider5();
			s_skyparams[g_skyindex].lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyLitScale6Flag()) {
		s_skyparamsdlg.SetSkyLitScale6Flag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int litno4 = 5;//!!!
			float newlitscale = s_skyparamsdlg.GetSkyLitScaleSlider6();
			s_skyparams[g_skyindex].lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyLitScale7Flag()) {
		s_skyparamsdlg.SetSkyLitScale7Flag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int litno4 = 6;//!!!
			float newlitscale = s_skyparamsdlg.GetSkyLitScaleSlider7();
			s_skyparams[g_skyindex].lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyLitScale8Flag()) {
		s_skyparamsdlg.SetSkyLitScale8Flag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int litno4 = 7;//!!!
			float newlitscale = s_skyparamsdlg.GetSkyLitScaleSlider8();
			s_skyparams[g_skyindex].lightscale[litno4] = newlitscale;

			if (curmqomat) {
				curmqomat->SetLightScale(litno4, newlitscale);
			}
			else {
				int materialindex4;
				for (materialindex4 = 0; materialindex4 < materialnum; materialindex4++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex4);
					if (setmqomat) {
						setmqomat->SetLightScale(litno4, newlitscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonLitRadioFlag()) {
		s_skyparamsdlg.SetSkyToonLitRadioFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int lightindex = s_skyparamsdlg.GetSkyToonLitRadio();
			s_skyparams[g_skyindex].hsvtoon.lightindex = lightindex;

			if (curmqomat) {
				curmqomat->SetToonLightIndex(lightindex);
			}
			else {
				int materialindex8;
				for (materialindex8 = 0; materialindex8 < materialnum; materialindex8++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex8);
					if (setmqomat) {
						setmqomat->SetToonLightIndex(lightindex);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonHiAddrSliderFlag()) {
		s_skyparamsdlg.SetSkyToonHiAddrSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float hicolorh = s_skyparamsdlg.GetSkyToonHiAddrSlider();
			s_skyparams[g_skyindex].hsvtoon.hicolorh = hicolorh;

			if (curmqomat) {
				curmqomat->SetToonHiAddrH(s_skyparams[g_skyindex].hsvtoon.hicolorh);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddrH(s_skyparams[g_skyindex].hsvtoon.hicolorh);
						s_hsvtoonforall.hicolorh = s_skyparams[g_skyindex].hsvtoon.hicolorh;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyRemakeToonTextureFlag()) {
		s_skyparamsdlg.SetSkyRemakeToonTextureFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			if (curmqomat) {
				s_toonmqomaterial = curmqomat;
			}
			else {
				s_toonmqomaterial = nullptr;
			}
			s_toonparamchange = true;
		}
	}
	if (s_skyparamsdlg.GetSkyToonLowAddrSliderFlag()) {
		s_skyparamsdlg.SetSkyToonLowAddrSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float lowcolorh = s_skyparamsdlg.GetSkyToonLowAddrSlider();
			s_skyparams[g_skyindex].hsvtoon.lowcolorh = lowcolorh;

			if (curmqomat) {
				curmqomat->SetToonLowAddrH(s_skyparams[g_skyindex].hsvtoon.lowcolorh);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddrH(s_skyparams[g_skyindex].hsvtoon.lowcolorh);
						s_hsvtoonforall.lowcolorh = s_skyparams[g_skyindex].hsvtoon.lowcolorh;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyGradationChkFlag()) {
		s_skyparamsdlg.SetSkyGradationChkFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_skyparamsdlg.GetSkyGradationChk();
			if (ischecked) {
				s_skyparams[g_skyindex].hsvtoon.gradationflag = true;
			}
			else {
				s_skyparams[g_skyindex].hsvtoon.gradationflag = false;
			}

			if (curmqomat) {
				curmqomat->SetToonGradationFlag(s_skyparams[g_skyindex].hsvtoon.gradationflag);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonGradationFlag(s_skyparams[g_skyindex].hsvtoon.gradationflag);
						s_hsvtoonforall.gradationflag = s_skyparams[g_skyindex].hsvtoon.gradationflag;
					}
				}
			}

			if (curmqomat) {
				s_toonmqomaterial = curmqomat;
			}
			else {
				s_toonmqomaterial = nullptr;
			}
			s_toonparamchange = true;
		}
	}
	if (s_skyparamsdlg.GetSkyPowerToonChkFlag()) {
		s_skyparamsdlg.SetSkyPowerToonChkFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_skyparamsdlg.GetSkyPowerToonChk();
			if (ischecked) {
				s_skyparams[g_skyindex].hsvtoon.powertoon = true;
			}
			else {
				s_skyparams[g_skyindex].hsvtoon.powertoon = false;
			}

			if (curmqomat) {
				curmqomat->SetToonPowerToon(s_skyparams[g_skyindex].hsvtoon.powertoon);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonPowerToon(s_skyparams[g_skyindex].hsvtoon.powertoon);
						s_hsvtoonforall.powertoon = s_skyparams[g_skyindex].hsvtoon.powertoon;
					}
				}
			}

			if (curmqomat) {
				s_toonmqomaterial = curmqomat;
			}
			else {
				s_toonmqomaterial = nullptr;
			}
			s_toonparamchange = true;
		}
	}
	if (s_skyparamsdlg.GetSkyToonBaseHSliderFlag()) {
		s_skyparamsdlg.SetSkyToonBaseHSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			s_skyparams[g_skyindex].hsvtoon.basehsv.x = s_skyparamsdlg.GetSkyToonBaseHSlider();

			if (curmqomat) {
				curmqomat->SetToonBaseH(s_skyparams[g_skyindex].hsvtoon.basehsv.x);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonBaseH(s_skyparams[g_skyindex].hsvtoon.basehsv.x);
						s_hsvtoonforall.basehsv.x = s_skyparams[g_skyindex].hsvtoon.basehsv.x;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonBaseSSliderFlag()) {
		s_skyparamsdlg.SetSkyToonBaseSSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			s_skyparams[g_skyindex].hsvtoon.basehsv.y = s_skyparamsdlg.GetSkyToonBaseSSlider();

			if (curmqomat) {
				curmqomat->SetToonBaseS(s_skyparams[g_skyindex].hsvtoon.basehsv.y);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonBaseS(s_skyparams[g_skyindex].hsvtoon.basehsv.y);
						s_hsvtoonforall.basehsv.y = s_skyparams[g_skyindex].hsvtoon.basehsv.y;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonBaseVSliderFlag()) {
		s_skyparamsdlg.SetSkyToonBaseVSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			s_skyparams[g_skyindex].hsvtoon.basehsv.z = s_skyparamsdlg.GetSkyToonBaseVSlider();

			if (curmqomat) {
				curmqomat->SetToonBaseV(s_skyparams[g_skyindex].hsvtoon.basehsv.z);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonBaseV(s_skyparams[g_skyindex].hsvtoon.basehsv.z);
						s_hsvtoonforall.basehsv.z = s_skyparams[g_skyindex].hsvtoon.basehsv.z;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonBaseASliderFlag()) {
		s_skyparamsdlg.SetSkyToonBaseASliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			s_skyparams[g_skyindex].hsvtoon.basehsv.w = s_skyparamsdlg.GetSkyToonBaseASlider();

			if (curmqomat) {
				curmqomat->SetToonBaseA(s_skyparams[g_skyindex].hsvtoon.basehsv.w);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonBaseA(s_skyparams[g_skyindex].hsvtoon.basehsv.w);
						s_hsvtoonforall.basehsv.w = s_skyparams[g_skyindex].hsvtoon.basehsv.w;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonHiHSliderFlag()) {
		s_skyparamsdlg.SetSkyToonHiHSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float newvalue = s_skyparamsdlg.GetSkyToonHiHSlider();
			s_skyparams[g_skyindex].hsvtoon.hiaddhsv.x = newvalue;

			if (curmqomat) {
				curmqomat->SetToonHiAddH(s_skyparams[g_skyindex].hsvtoon.hiaddhsv.x);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddH(s_skyparams[g_skyindex].hsvtoon.hiaddhsv.x);
						s_hsvtoonforall.hiaddhsv.x = s_skyparams[g_skyindex].hsvtoon.hiaddhsv.x;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonHiSSliderFlag()) {
		s_skyparamsdlg.SetSkyToonHiSSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float newvalue = s_skyparamsdlg.GetSkyToonHiSSlider();
			s_skyparams[g_skyindex].hsvtoon.hiaddhsv.y = newvalue;

			if (curmqomat) {
				curmqomat->SetToonHiAddS(s_skyparams[g_skyindex].hsvtoon.hiaddhsv.y);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddS(s_skyparams[g_skyindex].hsvtoon.hiaddhsv.y);
						s_hsvtoonforall.hiaddhsv.y = s_skyparams[g_skyindex].hsvtoon.hiaddhsv.y;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonHiVSliderFlag()) {
		s_skyparamsdlg.SetSkyToonHiVSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float newvalue = s_skyparamsdlg.GetSkyToonHiVSlider();
			s_skyparams[g_skyindex].hsvtoon.hiaddhsv.z = newvalue;

			if (curmqomat) {
				curmqomat->SetToonHiAddV(s_skyparams[g_skyindex].hsvtoon.hiaddhsv.z);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddV(s_skyparams[g_skyindex].hsvtoon.hiaddhsv.z);
						s_hsvtoonforall.hiaddhsv.z = s_skyparams[g_skyindex].hsvtoon.hiaddhsv.z;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonHiASliderFlag()) {
		s_skyparamsdlg.SetSkyToonHiASliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			float newvalue = s_skyparamsdlg.GetSkyToonHiASlider();
			s_skyparams[g_skyindex].hsvtoon.hiaddhsv.w = newvalue;

			if (curmqomat) {
				curmqomat->SetToonHiAddA(s_skyparams[g_skyindex].hsvtoon.hiaddhsv.w);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonHiAddA(s_skyparams[g_skyindex].hsvtoon.hiaddhsv.w);
						s_hsvtoonforall.hiaddhsv.w = s_skyparams[g_skyindex].hsvtoon.hiaddhsv.w;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonLowHSliderFlag()) {
		s_skyparamsdlg.SetSkyToonLowHSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);


			float newvalue = s_skyparamsdlg.GetSkyToonLowHSlider();
			s_skyparams[g_skyindex].hsvtoon.lowaddhsv.x = newvalue;

			if (curmqomat) {
				curmqomat->SetToonLowAddH(s_skyparams[g_skyindex].hsvtoon.lowaddhsv.x);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddH(s_skyparams[g_skyindex].hsvtoon.lowaddhsv.x);
						s_hsvtoonforall.lowaddhsv.x = s_skyparams[g_skyindex].hsvtoon.lowaddhsv.x;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonLowSSliderFlag()) {
		s_skyparamsdlg.SetSkyToonLowSSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);


			float newvalue = s_skyparamsdlg.GetSkyToonLowSSlider();
			s_skyparams[g_skyindex].hsvtoon.lowaddhsv.y = newvalue;

			if (curmqomat) {
				curmqomat->SetToonLowAddS(s_skyparams[g_skyindex].hsvtoon.lowaddhsv.y);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddS(s_skyparams[g_skyindex].hsvtoon.lowaddhsv.y);
						s_hsvtoonforall.lowaddhsv.y = s_skyparams[g_skyindex].hsvtoon.lowaddhsv.y;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonLowVSliderFlag()) {
		s_skyparamsdlg.SetSkyToonLowVSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);


			float newvalue = s_skyparamsdlg.GetSkyToonLowVSlider();
			s_skyparams[g_skyindex].hsvtoon.lowaddhsv.z = newvalue;

			if (curmqomat) {
				curmqomat->SetToonLowAddV(s_skyparams[g_skyindex].hsvtoon.lowaddhsv.z);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddV(s_skyparams[g_skyindex].hsvtoon.lowaddhsv.z);
						s_hsvtoonforall.lowaddhsv.z = s_skyparams[g_skyindex].hsvtoon.lowaddhsv.z;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyToonLowASliderFlag()) {
		s_skyparamsdlg.SetSkyToonLowASliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);


			float newvalue = s_skyparamsdlg.GetSkyToonLowASlider();
			s_skyparams[g_skyindex].hsvtoon.lowaddhsv.w = newvalue;

			if (curmqomat) {
				curmqomat->SetToonLowAddA(s_skyparams[g_skyindex].hsvtoon.lowaddhsv.w);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetToonLowAddA(s_skyparams[g_skyindex].hsvtoon.lowaddhsv.w);
						s_hsvtoonforall.lowaddhsv.w = s_skyparams[g_skyindex].hsvtoon.lowaddhsv.w;
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyTilingUSliderFlag()) {
		s_skyparamsdlg.SetSkyTilingUSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int newvalue = s_skyparamsdlg.GetSkyTilingUSlider();
			s_skyparams[g_skyindex].uvscale.x = (double)newvalue;

			if (curmqomat) {
				curmqomat->SetUVScale(s_skyparams[g_skyindex].uvscale);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetUVScale(s_skyparams[g_skyindex].uvscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyTilingUSliderUpFlag()) {
		s_skyparamsdlg.SetSkyTilingUSliderUpFlag(false);

		if (s_sky) {
			int newvalue = s_skyparamsdlg.GetSkyTilingUSlider();
			s_skyparams[g_skyindex].uvscale.x = (double)newvalue;
			s_skyparamsdlg.SetSkyTilingUSlider(newvalue);
			//s_st_tilingUslider->setValue(s_skyparams[g_skyindex].uvscale.x, false);//!!! マウスを離したときにintに丸めた値をセットし直す
		}
	}
	if (s_skyparamsdlg.GetSkyTilingVSliderFlag()) {
		s_skyparamsdlg.SetSkyTilingVSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			int newvalue = s_skyparamsdlg.GetSkyTilingVSlider();
			s_skyparams[g_skyindex].uvscale.y = (double)newvalue;

			if (curmqomat) {
				curmqomat->SetUVScale(s_skyparams[g_skyindex].uvscale);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetUVScale(s_skyparams[g_skyindex].uvscale);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyTilingVSliderUpFlag()) {
		s_skyparamsdlg.SetSkyTilingVSliderUpFlag(false);

		if (s_sky) {
			int newvalue = s_skyparamsdlg.GetSkyTilingVSlider();
			s_skyparams[g_skyindex].uvscale.y = (double)newvalue;

			//s_st_tilingVslider->setValue(s_skyparams[g_skyindex].uvscale.y, false);//!!! マウスを離したときにintに丸めた値をセットし直す
			s_skyparamsdlg.SetSkyTilingVSlider(newvalue);
		}
	}
	if (s_skyparamsdlg.GetSkyAlphaTestSliderFlag()) {
		s_skyparamsdlg.SetSkyAlphaTestSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			s_skyparams[g_skyindex].alphatest = s_skyparamsdlg.GetSkyAlphaTestSlider();

			if (curmqomat) {
				curmqomat->SetAlphaTestClipVal(s_skyparams[g_skyindex].alphatest);
			}
			else {
				int materialindex2;
				for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
					if (setmqomat) {
						setmqomat->SetAlphaTestClipVal(s_skyparams[g_skyindex].alphatest);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyDistortionChkFlag()) {
		s_skyparamsdlg.SetSkyDistortionChkFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			bool ischecked = s_skyparamsdlg.GetSkyDistortionChk();
			if (ischecked) {
				s_skyparams[g_skyindex].distortionflag = true;
			}
			else {
				s_skyparams[g_skyindex].distortionflag = false;
			}

			if (curmqomat) {
				curmqomat->SetDistortionFlag(s_skyparams[g_skyindex].distortionflag);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetDistortionFlag(s_skyparams[g_skyindex].distortionflag);
					}
				}
			}
		}
	}
	if (s_skyparamsdlg.GetSkyDistortionScaleSliderFlag()) {
		s_skyparamsdlg.SetSkyDistortionScaleSliderFlag(false);

		if (s_sky) {
			int materialnum = s_sky->GetMQOMaterialSize();
			materialnum = min(materialnum, MAXMATERIALNUM);
			int materialindex = 0;//s_skyの最初のマテリアル
			CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

			double newvalue = s_skyparamsdlg.GetSkyDistortonScaleSlider();
			s_skyparams[g_skyindex].distortionscale = newvalue;

			if (curmqomat) {
				curmqomat->SetDistortionScale(s_skyparams[g_skyindex].distortionscale);
			}
			else {
				int materialindex9;
				for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
					CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
					if (setmqomat) {
						setmqomat->SetDistortionScale(s_skyparams[g_skyindex].distortionscale);
					}
				}
			}
		}
	}
	//if (s_skyparamsdlg.GetSkyRiverRadioFlag()) {
	//	s_skyparamsdlg.SetSkyRiverRadioFlag(false);

	//	if (s_sky) {
	//		int materialnum = s_sky->GetMQOMaterialSize();
	//		materialnum = min(materialnum, MAXMATERIALNUM);
	//		int materialindex = 0;//s_skyの最初のマテリアル
	//		CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

	//		int riverorsea = s_skyparamsdlg.GetSkyRiverRadio();
	//		s_skyparams[g_skyindex].riverorsea = riverorsea;

	//		if (curmqomat) {
	//			curmqomat->SetRiverOrSea(riverorsea);
	//		}
	//		else {
	//			int materialindex8;
	//			for (materialindex8 = 0; materialindex8 < materialnum; materialindex8++) {
	//				CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex8);
	//				if (setmqomat) {
	//					setmqomat->SetRiverOrSea(riverorsea);
	//				}
	//			}
	//		}
	//	}
	//}
	//if (s_skyparamsdlg.GetSkySeaCenterUSliderFlag()) {
	//	s_skyparamsdlg.SetSkySeaCenterUSliderFlag(false);

	//	if (s_sky) {
	//		int materialnum = s_sky->GetMQOMaterialSize();
	//		materialnum = min(materialnum, MAXMATERIALNUM);
	//		int materialindex = 0;//s_skyの最初のマテリアル
	//		CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

	//		float newvalueU = s_skyparamsdlg.GetSkySeaCenterUSlider();
	//		float newvalueV = s_skyparamsdlg.GetSkySeaCenterVSlider();
	//		s_skyparams[g_skyindex].seacenter.SetParams(newvalueU, newvalueV);

	//		if (curmqomat) {
	//			curmqomat->SetSeaCenter(s_skyparams[g_skyindex].seacenter);
	//		}
	//		else {
	//			int materialindex9;
	//			for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
	//				CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
	//				if (setmqomat) {
	//					setmqomat->SetSeaCenter(s_skyparams[g_skyindex].seacenter);
	//				}
	//			}
	//		}
	//	}
	//}
	//if (s_skyparamsdlg.GetSkySeaCenterVSliderFlag()) {
	//	s_skyparamsdlg.SetSkySeaCenterVSliderFlag(false);

	//	if (s_sky) {
	//		int materialnum = s_sky->GetMQOMaterialSize();
	//		materialnum = min(materialnum, MAXMATERIALNUM);
	//		int materialindex = 0;//s_skyの最初のマテリアル
	//		CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

	//		float newvalueU = s_skyparamsdlg.GetSkySeaCenterUSlider();
	//		float newvalueV = s_skyparamsdlg.GetSkySeaCenterVSlider();
	//		s_skyparams[g_skyindex].seacenter.SetParams(newvalueU, newvalueV);

	//		if (curmqomat) {
	//			curmqomat->SetSeaCenter(s_skyparams[g_skyindex].seacenter);
	//		}
	//		else {
	//			int materialindex9;
	//			for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
	//				CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
	//				if (setmqomat) {
	//					setmqomat->SetSeaCenter(s_skyparams[g_skyindex].seacenter);
	//				}
	//			}
	//		}
	//	}
	//}
	//if (s_skyparamsdlg.GetSkyRiverDirUSliderFlag()) {
	//	s_skyparamsdlg.SetSkyRiverDirUSliderFlag(false);

	//	if (s_sky) {
	//		int materialnum = s_sky->GetMQOMaterialSize();
	//		materialnum = min(materialnum, MAXMATERIALNUM);
	//		int materialindex = 0;//s_skyの最初のマテリアル
	//		CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

	//		float newvalueU = s_skyparamsdlg.GetSkyRiverDirUSlider();
	//		float newvalueV = s_skyparamsdlg.GetSkyRiverDirVSlider();
	//		s_skyparams[g_skyindex].riverdir.SetParams(newvalueU, newvalueV);

	//		if (curmqomat) {
	//			curmqomat->SetRiverDir(s_skyparams[g_skyindex].riverdir);
	//		}
	//		else {
	//			int materialindex9;
	//			for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
	//				CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
	//				if (setmqomat) {
	//					setmqomat->SetRiverDir(s_skyparams[g_skyindex].riverdir);
	//				}
	//			}
	//		}
	//	}
	//}
	//if (s_skyparamsdlg.GetSkyRiverDirVSliderFlag()) {
	//	s_skyparamsdlg.SetSkyRiverDirVSliderFlag(false);

	//	if (s_sky) {
	//		int materialnum = s_sky->GetMQOMaterialSize();
	//		materialnum = min(materialnum, MAXMATERIALNUM);
	//		int materialindex = 0;//s_skyの最初のマテリアル
	//		CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

	//		float newvalueU = s_skyparamsdlg.GetSkyRiverDirUSlider();
	//		float newvalueV = s_skyparamsdlg.GetSkyRiverDirVSlider();
	//		s_skyparams[g_skyindex].riverdir.SetParams(newvalueU, newvalueV);

	//		if (curmqomat) {
	//			curmqomat->SetRiverDir(s_skyparams[g_skyindex].riverdir);
	//		}
	//		else {
	//			int materialindex9;
	//			for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
	//				CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
	//				if (setmqomat) {
	//					setmqomat->SetRiverDir(s_skyparams[g_skyindex].riverdir);
	//				}
	//			}
	//		}
	//	}
	//}
	//if (s_skyparamsdlg.GetSkyFlowRateSliderFlag()) {
	//	s_skyparamsdlg.SetSkyFlowRateSliderFlag(false);

	//	if (s_sky) {
	//		int materialnum = s_sky->GetMQOMaterialSize();
	//		materialnum = min(materialnum, MAXMATERIALNUM);
	//		int materialindex = 0;//s_skyの最初のマテリアル
	//		CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

	//		double newvalue = s_skyparamsdlg.GetSkyFlowRateSlider();
	//		s_skyparams[g_skyindex].riverflowrate = newvalue;

	//		if (curmqomat) {
	//			curmqomat->SetRiverFlowRate(s_skyparams[g_skyindex].riverflowrate);
	//		}
	//		else {
	//			int materialindex9;
	//			for (materialindex9 = 0; materialindex9 < materialnum; materialindex9++) {
	//				CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex9);
	//				if (setmqomat) {
	//					setmqomat->SetRiverFlowRate(s_skyparams[g_skyindex].riverflowrate);
	//				}
	//			}
	//		}
	//	}

	//}
	//if (s_skyparamsdlg.GetSkyDistortionMapRadioFlag()) {
	//	s_skyparamsdlg.SetSkyDistortionMapRadioFlag(false);

	//	if (s_sky) {
	//		int materialnum = s_sky->GetMQOMaterialSize();
	//		materialnum = min(materialnum, MAXMATERIALNUM);
	//		int materialindex = 0;//s_skyの最初のマテリアル
	//		CMQOMaterial* curmqomat = s_sky->GetMQOMaterialByIndex(materialindex);

	//		int maptype = s_skyparamsdlg.GetSkyDistortionMapRadio();
	//		s_skyparams[g_skyindex].distortionmaptype = maptype;

	//		if (curmqomat) {
	//			curmqomat->SetDistortionMapType(maptype);
	//		}
	//		else {
	//			int materialindex8;
	//			for (materialindex8 = 0; materialindex8 < materialnum; materialindex8++) {
	//				CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex8);
	//				if (setmqomat) {
	//					setmqomat->SetDistortionMapType(maptype);
	//				}
	//			}
	//		}
	//	}
	//}

	//if (m_skyst_distortionscalesliderFlag) {
	//	m_skyst_distortionscalesliderFlag = false;
	//}
	//if (m_skyst_riverradioFlag) {
	//	m_skyst_riverradioFlag = false;
	//}
	//if (m_skyst_seacenterUsliderFlag) {
	//	m_skyst_seacenterUsliderFlag = false;
	//}
	//if (m_skyst_seacenterVsliderFlag) {
	//	m_skyst_seacenterVsliderFlag = false;
	//}
	//if (m_skyst_riverdirUsliderFlag) {
	//	m_skyst_riverdirUsliderFlag = false;
	//}
	//if (m_skyst_riverdirVsliderFlag) {
	//	m_skyst_riverdirVsliderFlag = false;
	//}
	//if (m_skyst_flowratesliderFlag) {
	//	m_skyst_flowratesliderFlag = false;
	//}
	//if (m_skyst_distortionmapradioFlag) {
	//	m_skyst_distortionmapradioFlag = false;
	//}

	return 0;
}

int CreateDofParamsDlg()
{


	if (s_dofWnd) {
		//_ASSERT(0);
		return 0;//作成済
	}

	int windowposx;
	if (g_4kresolution) {
		windowposx = s_timelinewidth + s_mainwidth + s_modelwindowwidth;
	}
	else {
		windowposx = s_timelinewidth + s_mainwidth;
	}

	s_dofWnd = new OrgWindow(
		0,
		_T("DOF_Dlg"),		//ウィンドウクラス名
		GetModuleHandle(NULL),	//インスタンスハンドル
		WindowPos(windowposx, s_sidemenuheight),
		WindowSize(s_sidewidth, s_sideheight),		//サイズ
		_T("DOF_Dlg"),	//タイトル
		g_mainhwnd,	//親ウィンドウハンドル
		false,					//表示・非表示状態
		//70, 50, 70,				//カラー
		0, 0, 0,				//カラー
		true,					//閉じられるか否か
		true);					//サイズ変更の可否

	int labelheight;
	if (g_4kresolution) {
		labelheight = 28;
	}
	else {
		labelheight = 20;
	}

	if (s_dofWnd) {
		double rate50 = 0.50;

		s_dofLabel = new OWP_Label(L"被写界深度 Depth of Field(DOF)", labelheight);
		if (!s_dofLabel) {
			_ASSERT(0);
			abort();
		}
		s_dofslotCombo = new OWP_ComboBoxA(L"DOF_Combo", labelheight);//g_dofindex
		if (!s_dofslotCombo) {
			_ASSERT(0);
			abort();
		}
		int slotindex;
		for (slotindex = 0; slotindex < 8; slotindex++) {
			char strslot[128] = { 0 };
			sprintf_s(strslot, 128, "Slot_%d", slotindex);
			s_dofslotCombo->addString(strslot);
		}
		s_dofslotCombo->setSelectedCombo(g_dofindex);
		s_dofspacerLabel1 = new OWP_Label(L"     ", 32);
		if (!s_dofspacerLabel1) {
			_ASSERT(0);
			abort();
		}
		s_dofdistsp1 = new OWP_Separator(s_dofWnd, true, rate50, true);
		if (!s_dofdistsp1) {
			_ASSERT(0);
			abort();
		}
		s_dofdistsp2 = new OWP_Separator(s_dofWnd, true, rate50, true);
		if (!s_dofdistsp2) {
			_ASSERT(0);
			abort();
		}
		s_dofdistsp3 = new OWP_Separator(s_dofWnd, true, rate50, true);
		if (!s_dofdistsp3) {
			_ASSERT(0);
			abort();
		}
		s_dofdistnearLabel = new OWP_Label(L"near", labelheight);
		if (!s_dofdistnearLabel) {
			_ASSERT(0);
			abort();
		}
		s_dofdistnearEdit = new OWP_EditBox(true, L"DofNearEdit", labelheight, EDIT_BUFLEN_NUM);//g_dofparams[g_dofindex].x
		if (!s_dofdistnearEdit) {
			_ASSERT(0);
			abort();
		}
		s_dofdistfarLabel = new OWP_Label(L"far", labelheight);//g_dofparams[g_dofindex].y
		if (!s_dofdistfarLabel) {
			_ASSERT(0);
			abort();
		}
		s_dofdistfarEdit = new OWP_EditBox(true, L"DofFarEdit", labelheight, EDIT_BUFLEN_NUM);
		if (!s_dofdistfarEdit) {
			_ASSERT(0);
			abort();
		}
		s_dofspacerLabel2 = new OWP_Label(L"     ", 32);
		if (!s_dofspacerLabel2) {
			_ASSERT(0);
			abort();
		}
		s_dofskyChk = new OWP_CheckBoxA(L"Sky DOF", g_skydofflag[g_dofindex], labelheight, false);
		if (!s_dofskyChk) {
			_ASSERT(0);
			abort();
		}
		s_dofspacerLabel3 = new OWP_Label(L"     ", 32);
		if (!s_dofspacerLabel3) {
			_ASSERT(0);
			abort();
		}
		s_dofapplysp = new OWP_Separator(s_dofWnd, true, rate50, true);
		if (!s_dofapplysp) {
			_ASSERT(0);
			abort();
		}
		s_dofapplyB = new OWP_Button(L"Apply(適用)", 38);
		if (!s_dofapplyB) {
			_ASSERT(0);
			abort();
		}
		s_dofapplyB->setTextColor(RGB(168, 129, 129));


		s_dofWnd->addParts(*s_dofLabel);
		s_dofWnd->addParts(*s_dofslotCombo);
		s_dofWnd->addParts(*s_dofspacerLabel1);
		s_dofWnd->addParts(*s_dofdistsp1);
		s_dofdistsp1->addParts1(*s_dofdistsp2);
		s_dofdistsp1->addParts2(*s_dofdistsp3);
		s_dofdistsp2->addParts1(*s_dofdistnearLabel);
		s_dofdistsp2->addParts2(*s_dofdistnearEdit);
		s_dofdistsp3->addParts1(*s_dofdistfarLabel);
		s_dofdistsp3->addParts2(*s_dofdistfarEdit);
		s_dofWnd->addParts(*s_dofspacerLabel2);
		s_dofWnd->addParts(*s_dofskyChk);
		s_dofWnd->addParts(*s_dofspacerLabel3);
		s_dofWnd->addParts(*s_dofapplysp);
		s_dofapplysp->addParts2(*s_dofapplyB);


		s_dofslotCombo->setButtonListener([]() {
			int comboid = s_dofslotCombo->trackPopUpMenu();
			g_dofindex = comboid;

			DofParams2Dlg();
		});

		s_dofskyChk->setButtonListener([]() {
			bool value = s_dofskyChk->getValue();
			g_skydofflag[g_dofindex] = value;
		});

		s_dofapplyB->setButtonListener([]() {
			WCHAR streditbox[256] = { 0L };
			float tempeditvalue;

			if (s_dofdistnearEdit) {
				s_dofdistnearEdit->getName(streditbox, 256);
				tempeditvalue = (float)_wtof(streditbox);
				if ((tempeditvalue >= 0.000010f) && (tempeditvalue <= 500000.0f)) {
					g_dofparams[g_dofindex].x = tempeditvalue;
				}
				else {
					if (s_dofWnd) {
						::MessageBox(s_dofWnd->getHWnd(), L"invalid editbox value : Near", L"Invalid Value", MB_OK);
					}
				}
			}
			if (s_dofdistfarEdit) {
				s_dofdistfarEdit->getName(streditbox, 256);
				tempeditvalue = (float)_wtof(streditbox);
				if ((tempeditvalue >= 0.000010f) && (tempeditvalue <= 500000.0f)) {
					g_dofparams[g_dofindex].y = tempeditvalue;
				}
				else {
					if (s_dofWnd) {
						::MessageBox(s_dofWnd->getHWnd(), L"invalid editbox value : Far", L"Invalid Value", MB_OK);
					}
				}
			}
		});


		s_dofWnd->setSize(WindowSize(s_sidewidth, s_sideheight));
		s_dofWnd->setPos(WindowPos(windowposx, s_sidemenuheight));

		//１クリック目問題対応
		s_dofWnd->refreshPosAndSize();

		s_dofWnd->callRewrite();
	}
	else {
		_ASSERT(0);
		return 1;
	}

	return 0;
}

int SetModel2ModelWorldMatDlg(CModel* srcmodel)
{
	if (srcmodel) {
		WCHAR strname[256] = { 0L };
		ZeroMemory(strname, sizeof(WCHAR) * 256);
		size_t namelen = wcslen(srcmodel->GetFileName());
		if (namelen <= 255) {
			wcscpy_s(strname, 256, srcmodel->GetFileName());
		}
		else {
			wcsncpy_s(strname, 256, srcmodel->GetFileName(), 255);
		}
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_STATICMODELNAME, strname);


		ChaVector3 tmppos = srcmodel->GetModelPosition();
		ChaVector3 tmprot = srcmodel->GetModelRotation();

		WCHAR strval[256] = { 0L };
		swprintf_s(strval, 256, L"%.3f", tmppos.x);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_POSITIONX, strval);
		swprintf_s(strval, 256, L"%.3f", tmppos.y);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_POSITIONY, strval);
		swprintf_s(strval, 256, L"%.3f", tmppos.z);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_POSITIONZ, strval);

		swprintf_s(strval, 256, L"%.3f", tmprot.x);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_ROTATIONX, strval);
		swprintf_s(strval, 256, L"%.3f", tmprot.y);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_ROTATIONY, strval);
		swprintf_s(strval, 256, L"%.3f", tmprot.z);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_ROTATIONZ, strval);

		swprintf_s(strval, 256, L"%.3f", s_removegrassdistance);
		SetDlgItemTextW(s_modelworldmatdlgwnd, IDC_EDIT_REMOVEDISTANCE, strval);

		if (s_pickmodelworldmat == true) {
			CheckDlgButton(s_modelworldmatdlgwnd, IDC_CHECK_PICKANDSET, true);
		}
		else {
			CheckDlgButton(s_modelworldmatdlgwnd, IDC_CHECK_PICKANDSET, false);
		}

		if (s_removegrassflag == true) {
			CheckDlgButton(s_modelworldmatdlgwnd, IDC_CHECK_REMOVEPOS, true);
		}
		else {
			CheckDlgButton(s_modelworldmatdlgwnd, IDC_CHECK_REMOVEPOS, false);
		}

	}

	return 0;
}

int SetSkyParamsToSky(CShaderTypeParams srcparams)
{
	if (!s_sky) {
		_ASSERT(0);
		return 1;
	}
	int materialnum = s_sky->GetMQOMaterialSize();
	if (materialnum == 0) {
		return 0;
	}

	int materialindex2;
	for (materialindex2 = 0; materialindex2 < materialnum; materialindex2++) {
		CMQOMaterial* setmqomat = s_sky->GetMQOMaterialByIndex(materialindex2);
		if (setmqomat) {
			setmqomat->SetMetalAdd(srcparams.metalcoef);
			setmqomat->SetSmoothCoef(srcparams.smoothcoef);
			setmqomat->SetEmissiveScale(srcparams.emissiveScale);
			setmqomat->SetSpecularCoef(srcparams.specularcoef);
			setmqomat->SetUVScale(srcparams.uvscale);
			setmqomat->SetHSVToon(srcparams.hsvtoon);
			//setmqomat->SetToonHiAddrH(srcparams.hsvtoon.hicolorh);
			//setmqomat->SetToonLowAddrH(srcparams.hsvtoon.lowcolorh);
			//setmqomat->SetToonBaseH(srcparams.hsvtoon.basehsv.x);
			//setmqomat->SetToonBaseS(srcparams.hsvtoon.basehsv.y);
			//setmqomat->SetToonBaseV(srcparams.hsvtoon.basehsv.z);
			//setmqomat->SetToonBaseA(srcparams.hsvtoon.basehsv.w);
			//setmqomat->SetToonHiAddH(srcparams.hsvtoon.hiaddhsv.x);
			//setmqomat->SetToonLowAddH(srcparams.hsvtoon.lowaddhsv.x);
			//setmqomat->SetToonHiAddS(srcparams.hsvtoon.hiaddhsv.y);
			//setmqomat->SetToonLowAddS(srcparams.hsvtoon.lowaddhsv.y);
			//setmqomat->SetToonHiAddV(srcparams.hsvtoon.hiaddhsv.z);
			//setmqomat->SetToonLowAddV(srcparams.hsvtoon.lowaddhsv.z);
			//setmqomat->SetToonHiAddA(srcparams.hsvtoon.hiaddhsv.w);
			//setmqomat->SetToonLowAddA(srcparams.hsvtoon.lowaddhsv.w);
			//setmqomat->SetToonLightIndex(srcparams.hsvtoon.lightindex);
			int litno4;
			for (litno4 = 0; litno4 < LIGHTNUMMAX; litno4++) {
				setmqomat->SetLightScale(litno4, srcparams.lightscale[litno4]);
			}
			setmqomat->SetShaderType(srcparams.shadertype);
			setmqomat->SetLightingFlag(srcparams.lightingmat);
			setmqomat->SetShadowCasterFlag(srcparams.shadowcasterflag);
			setmqomat->SetEnableEmission(srcparams.enableEmission);
			setmqomat->SetNormalY0Flag(srcparams.normaly0flag);
			setmqomat->SetToonGradationFlag(srcparams.hsvtoon.gradationflag);
			setmqomat->SetToonPowerToon(srcparams.hsvtoon.powertoon);
		}
	}

	s_skytoonparamchange = true;//to remake toon texture

	return 0;
}

int DofParams2Dlg()
{
	if (!s_dofWnd) {
		_ASSERT(0);
		return 1;
	}

	if ((g_dofindex < 0) || (g_dofindex >= DOFSLOTNUM)) {
		_ASSERT(0);
		return 1;
	}

	//#########
	//ComboBox
	//#########
	if (s_dofslotCombo) {
		s_dofslotCombo->setSelectedCombo(g_dofindex);
	}

	//#####
	//Text
	//#####
	WCHAR strdlg[256] = { 0L };
	swprintf_s(strdlg, 256, L"%.2f", g_dofparams[g_dofindex].x);
	if (s_dofdistnearEdit) {
		s_dofdistnearEdit->setName(strdlg);
	}

	swprintf_s(strdlg, 256, L"%.2f", g_dofparams[g_dofindex].y);
	if (s_dofdistfarEdit) {
		s_dofdistfarEdit->setName(strdlg);
	}


	//#########
	//CheckBox
	//#########
	if (s_dofskyChk) {
		s_dofskyChk->setValue(g_skydofflag[g_dofindex], false);
	}


	s_dofWnd->callRewrite();

	return 0;
}


int ShowModelWorldMatDlg()
{

	if (s_modelworldmatdlgwnd) {
		if (s_model) {
			SetModel2ModelWorldMatDlg(s_model);

			ShowWindow(s_modelworldmatdlgwnd, SW_SHOW);
			UpdateWindow(s_modelworldmatdlgwnd);
			s_dispmodelworldmat = true;
		}
	}

	return 0;
}

int ShowJumpGravityDlg()
{

	if (s_jumpgravitydlgwnd) {
		if (s_model) {
			ShowWindow(s_jumpgravitydlgwnd, SW_SHOW);
			UpdateWindow(s_jumpgravitydlgwnd);
		}
	}

	return 0;
}


int ShowShaderTypeParamsDlg(bool srcflag)
{
	if (s_model && srcflag) {

		int materialnum = s_model->GetMQOMaterialSize();

		if ((materialnum > 0) && (materialnum < MAXMATERIALNUM)) {//2024/03/03
			CMQOMaterial* curmqomat = nullptr;
			int shadertypeparamsindex = s_shadertypedlg.GetShaderTypeParamsIndex();
			if ((shadertypeparamsindex >= 0) && (shadertypeparamsindex < (materialnum + 1))) {
				int materialindex = shadertypeparamsindex - 1;
				if (materialindex >= 0) {
					curmqomat = s_model->GetMQOMaterialByIndex(materialindex);
				}
			}
			if (!curmqomat) {
				int dbgflag1 = 1;
			}
			s_shaderparamsdlg.ParamsToDlg(curmqomat, &s_shadertypeparams);
			s_shaderparamsdlg.SetVisible(srcflag);

		}
		else {
			//2024/03/03
			if (materialnum != 0) {
				MessageBoxW(s_3dwnd, L"ERROR : MaterialNum Overflow.", L"Can't open dialog for settings.", MB_OK | MB_ICONERROR);
			}
			////s_st_paramsWnd->setListenMouse(false);
			//s_st_paramsWnd->setVisible(false);

			s_shaderparamsdlg.SetVisible(srcflag);
		}
	}
	else {
		////s_st_paramsWnd->setListenMouse(false);
		//s_st_paramsWnd->setVisible(false);

		s_shaderparamsdlg.SetVisible(false);
	}

	return 0;
}

void ShowSkyWnd(bool srcflag)
{
	if (s_sky && srcflag) {

		int materialnum = s_sky->GetMQOMaterialSize();

		if ((materialnum > 0) && (materialnum < MAXMATERIALNUM)) {//2024/03/03
			CMQOMaterial* curmqomat = nullptr;
			curmqomat = s_sky->GetMQOMaterialByIndex(0);

			s_skyparamsdlg.ParamsToDlg(s_sky, curmqomat, &(s_skyparams[g_skyindex]));
			s_skyparamsdlg.SetVisible(srcflag);
		}
		else {
			//2024/03/03
			if (materialnum != 0) {
				MessageBoxW(s_3dwnd, L"ERROR : MaterialNum Overflow.", L"Can't open dialog for settings.", MB_OK | MB_ICONERROR);
			}
			////m_skyst_paramsWnd->setListenMouse(false);
			//m_skyst_paramsWnd->setVisible(false);
			s_skyparamsdlg.SetVisible(false);
		}
	}
	else {
		////m_skyst_paramsWnd->setListenMouse(false);
		//m_skyst_paramsWnd->setVisible(false);
		s_skyparamsdlg.SetVisible(false);
	}

	s_speffectsw[SPEFFECTSW_SKY].state = srcflag;

}
void ShowFogWnd(bool srcflag)
{
	s_fogdlg.SetVisible(srcflag);

	s_speffectsw[SPEFFECTSW_FOG].state = srcflag;
}
void ShowDofWnd(bool srcflag)
{
	if (srcflag == true) {
		int result1 = CreateDofParamsDlg();
		if ((result1 == 0) && s_dofWnd) {
			DofParams2Dlg();

			s_dofWnd->setVisible(true);
			s_dofWnd->setListenMouse(true);
		}
	}
	else {
		if (s_dofWnd) {
			s_dofWnd->setVisible(false);
			s_dofWnd->setListenMouse(false);
		}
	}

	s_speffectsw[SPEFFECTSW_DOF].state = srcflag;

}


int CreateMaterialRateWnd()
{

	//CCameraDollyDlg dlg(g_camEye);
	//dlg.DoModal();
	//g_camEye = dlg.GetCameraPos();

	HWND hDlgWnd = CreateDialogW((HMODULE)GetModuleHandle(NULL),
		//MAKEINTRESOURCE(IDD_MATERIALRATEDLG), g_mainhwnd, (DLGPROC)MaterialRateDlgProc);
		MAKEINTRESOURCE(IDD_MATERIALRATEDLG), s_3dwnd, (DLGPROC)MaterialRateDlgProc);
	if (hDlgWnd == NULL) {
		return 1;
	}
	s_materialratedlgwnd = hDlgWnd;
	ShowWindow(s_materialratedlgwnd, SW_HIDE);

	return 0;
}

int SetModel2MaterialRateDlg(CModel* srcmodel)
{
	if (srcmodel) {
		WCHAR strname[256] = { 0L };
		ZeroMemory(strname, sizeof(WCHAR) * 256);
		size_t namelen = wcslen(srcmodel->GetFileName());
		if (namelen <= 255) {
			wcscpy_s(strname, 256, srcmodel->GetFileName());
		}
		else {
			wcsncpy_s(strname, 256, srcmodel->GetFileName(), 255);
		}
		SetDlgItemTextW(s_materialratedlgwnd, IDC_STATICMODELNAME, strname);


		WCHAR strval[256] = { 0L };
		ChaVector4 materialdisprate = srcmodel->GetMaterialDispRate();

		swprintf_s(strval, 256, L"%.3f", materialdisprate.x);
		SetDlgItemTextW(s_materialratedlgwnd, IDC_EDIT_DIFFUSERATE, strval);
		swprintf_s(strval, 256, L"%.3f", materialdisprate.y);
		SetDlgItemTextW(s_materialratedlgwnd, IDC_EDIT_SPECULARRATE, strval);
		swprintf_s(strval, 256, L"%.3f", materialdisprate.z);
		SetDlgItemTextW(s_materialratedlgwnd, IDC_EDIT_EMISSIVERATE, strval);
		swprintf_s(strval, 256, L"%.3f", materialdisprate.w);
		SetDlgItemTextW(s_materialratedlgwnd, IDC_EDIT_AMBIENTRATE, strval);
	}

	return 0;

}

int ShowMaterialRateDlg()
{
	if (s_materialratedlgwnd) {
		if (s_model) {
			SetModel2MaterialRateDlg(s_model);

			ShowWindow(s_materialratedlgwnd, SW_SHOW);
			UpdateWindow(s_materialratedlgwnd);
		}

	}

	return 0;
}

int ShowCameraDollyDlg()
{

	//GUIMenuSetVisible(-1, -1);
	bool closefirstrow = true;
	CloseAllRightPainWindow(closefirstrow);//対応ウインドウを開く前に　１段目と２段目を全部閉じる

	//std::vector<DOLLYELEM> vecdolly;
	//vecdolly.clear();
	//s_dollyhistorydlg.SetOnShow(true);//2024/02/27 ダイアログを出したときにカメラが動いてしまうのを防止
	//s_dollyhistorydlg.LoadDollyHistory(vecdolly);
	//s_dollyhistorydlg.SetNames(vecdolly);
	//s_dollyhistorydlg.ShowWindow(SW_SHOW);
	////s_dollyhistorydlg.SetOnShow(false);//2024/02/27 この時点ではまだカメラ位置を変えようとしていない　OFFはdollyhistorydlgのOnPaint()で行う

	//2024/07/25
	//SetNames()呼び出しはInitApp()で行う
	//開いたり閉じたりした場合にもウインドウの状態が保たれるようにここではSetNames()を呼ばない
	s_dollyhistorydlg2.SetVisible(true);

	return 0;
}

int UpdateCameraPosAndTarget()
{
	//#replacing comment out#g_Camera->SetViewParamsWithUpVec(g_camEye.XMVECTOR(1.0f), g_camtargetpos.XMVECTOR(1.0f), g_cameraupdir.XMVECTOR(0.0f));
	//#replacing comment out#s_matView = //#replacing comment out#g_Camera->GetViewMatrix();
	//#replacing comment out#s_matProj = //#replacing comment out#g_Camera->GetProjMatrix();

	ChaVector3 diffv;
	diffv = g_camEye - g_camtargetpos;
	g_camdist = (float)ChaVector3LengthDbl(&diffv);
	if (g_camdist >= 1e-4) {
		//return 0;//2024/07/29 後にも処理がある　return文をコメントアウト
	}
	else {
		_ASSERT(0);
		return 1;
	}

	SetCamera3DFromEyePos();

	return 0;
}

bool IsClickedSpriteButton()
{
	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);


	//Camera rot, pan, dolly
	if (PickSpCam(ptCursor) != 0){
		return true;
	}


	//UndoRedo
	int pickundo = 0;
	pickundo = PickSpUndo(ptCursor);
	if (pickundo == PICK_UNDO) {
		return true;
	}
	else if (pickundo == PICK_REDO)
	{
		return true;
	}

	//IK Mode
	int pickikmodeflag = 0;
	pickikmodeflag = PickSpIkModeSW(ptCursor);
	if (pickikmodeflag == 1) {
		return true;
	}
	else if (pickikmodeflag == 2) {
		return true;
	}
	else if (pickikmodeflag == 3) {
		return true;
	}
	{
		//lod switch
		int picklodflag = 0;
		picklodflag = PickSpRefPosSW(ptCursor);
		if (picklodflag == 1) {
			return true;
		}
	}
	{
		//limiteul switch
		int picklimiteulflag = 0;
		picklimiteulflag = PickSpLimitEulSW(ptCursor);
		if (picklimiteulflag == 1) {
			return true;
		}
	}
	{
		//cameramode switch
		int pickcameramodeflag = 0;
		pickcameramodeflag = PickSpCameraModeSW(ptCursor);
		if (pickcameramodeflag == 1) {
			return true;
		}
	}
	{
		//camerainherit switch
		int pickcamerainheritflag = 0;
		pickcamerainheritflag = PickSpCameraInheritSW(ptCursor);
		if (pickcamerainheritflag == 1) {
			return true;
		}
	}
	{
		//wallscraping switch
		int pickscrapingflag = 0;
		pickscrapingflag = PickSpScrapingSW(ptCursor);
		if (pickscrapingflag == 1) {
			return true;
		}
	}

	//2023/02/04
	//Bake LimitedWorld-->World : currentmotion fullframe
	if (PickSpCpLW2W(ptCursor) != 0) {
		return true;
	}

	if (PickSpSmooth(ptCursor) != 0) {
		return true;
	}

	if (PickSpConstExe(ptCursor) != 0) {
		return true;
	}
	if (PickSpConstRefresh(ptCursor) != 0) {
		return true;
	}


	if (PickSpFrog2(ptCursor) != 0) {
		return true;
	}
	if (PickSpCopy(ptCursor) != 0) {
		return true;
	}
	if (PickSpSymCopy(ptCursor) != 0) {
		return true;
	}
	if (PickSpPaste(ptCursor) != 0) {
		return true;
	}
	if (PickSpCopyHistory(ptCursor) != 0) {
		return true;
	}

	if (PickSpInterpolate(ptCursor) != 0) {
		return true;
	}
	if (PickSpInit(ptCursor) != 0) {
		return true;
	}
	if (PickSpScaleInit(ptCursor) != 0) {
		return true;
	}
	if (PickSpProperty(ptCursor) != 0) {
		return true;
	}


	if (PickSpZeroFrame(ptCursor) != 0) {
		return true;
	}
	if (PickSpCameraDolly(ptCursor) != 0) {
		return true;
	}
	if (PickSpModelPosDir(ptCursor) != 0) {
		return true;
	}
	if (PickSpMaterialRate(ptCursor) != 0) {
		return true;
	}

	return false;

}

void InitRootSignature(RootSignature& rs)
{
	rs.Init(D3D12_FILTER_MIN_MAG_MIP_LINEAR,
		D3D12_TEXTURE_ADDRESS_MODE_WRAP,
		D3D12_TEXTURE_ADDRESS_MODE_WRAP,
		D3D12_TEXTURE_ADDRESS_MODE_WRAP);
}

int ChangeCameraDist(float newcamdist, bool moveeyeposflag, bool calledbyslider)
{
	float savecamdist = g_camdist;

	g_camdist = (float)fmin(s_maxcamdist, newcamdist);//2024/06/04 最大値でクランプしてからtargetを再計算する

	if (g_camdist >= 0.01f) {//2022/10/29 0.0001では近づきすぎたときに固まるので0.01に変更
		ChaVector3 camvec = g_camEye - g_camtargetpos;
		ChaVector3Normalize(&camvec, &camvec);

		if (moveeyeposflag == true) {//2024/02/26
			g_befcamEye = g_camEye;
			g_camEye = g_camtargetpos + camvec * g_camdist;
		}
		else {
			g_befcamtargetpos = g_camtargetpos;
			g_camtargetpos = g_camEye - camvec * g_camdist;
		}
	}
	else {

		//2023/03/23
		//カメラ位置がターゲットに近づきすぎた場合　止めないで　ターゲット位置を視線方向に延長するように

		ChaVector3 camvec2 = g_camtargetpos - g_camEye;
		ChaVector3Normalize(&camvec2, &camvec2);

		float savedist3 = (float)fmin(s_maxcamdist, (savecamdist * 3.0f));//2024/06/04

		g_befcamEye = g_camEye;
		g_befcamtargetpos = g_camtargetpos;

		if (moveeyeposflag == true) {//2024/02/26
			g_camtargetpos = g_camEye + camvec2 * savedist3;
			g_camEye = g_camtargetpos - camvec2 * savedist3;
		}
		else {
			g_camEye = g_camtargetpos + camvec2 * savedist3;
			g_camtargetpos = g_camEye - camvec2 * savedist3;
		}



		g_camdist = savedist3;
	}

	SetCamera3DFromEyePos();


	if (s_sidemenuWnd && s_sidemenu_camdistSlider && (calledbyslider == false)) {
		s_sidemenu_camdistSlider->setValue(g_camdist, false);
		s_sidemenuWnd->callRewrite();
	}


	return 0;
}

void SetCamera3DFromEyePos()
{
	g_camera3D->SetNear(g_projnear);
	g_camera3D->SetFar(g_projfar);
	//g_camera3D->SetViewAngle(60.0f / 180.0f * (float)PI);
	g_camera3D->SetViewAngle(g_fovy);//2023/12/30
	Vector3 cameye;
	cameye.Set(g_camEye.x, g_camEye.y, g_camEye.z);
	g_camera3D->SetPosition(cameye);
	Vector3 target;
	target.Set(g_camtargetpos.x, g_camtargetpos.y, g_camtargetpos.z);
	g_camera3D->SetTarget(target);
	g_camera3D->SetUp(Vector3(g_cameraupdir.x, g_cameraupdir.y, g_cameraupdir.z));
	g_camera3D->SetWidth((float)g_graphicsEngine->GetFrameBufferWidth());//2023/11/20
	g_camera3D->SetHeight((float)g_graphicsEngine->GetFrameBufferHeight());//2023/11/20
	g_camera3D->Update();

	if (s_model) {
		s_matWorld = s_model->GetWorldMat();
	}
	else {
		s_matWorld.SetIdentity();
	}
	s_matView.SetParams(g_camera3D->GetViewMatrix(false));
	s_matProj.SetParams(g_camera3D->GetProjectionMatrix());
	s_matVP = s_matView * s_matProj;


//// camera for shadowmap
	if (s_model) {
		ChaVector3 dirright;
		dirright.SetParams(g_camera3D->GetRight());
		ChaVector3 dirup;
		dirup.SetParams(g_camera3D->GetUp());
		ChaVector3 dirforward;
		dirforward.SetParams(g_camera3D->GetForward());
		ChaVector3 modelpos = ChaMatrixTraVec(s_model->GetWorldMat());
		ChaVector3 camdiff = g_camtargetpos - g_camEye;

		g_cameraShadow->Update();

		if ((g_shadowmap_slotno < 0) || (g_shadowmap_slotno >= SHADOWSLOTNUM)) {
			_ASSERT(0);
			g_shadowmap_slotno = 0;
		}

		ChaVector3 ldirxz;//2024/02/25 lightの下向き加減とshadowcameraの下向き加減は別に設定するようにしてある
		if ((g_shadowmap_lightdir[g_shadowmap_slotno] >= 1) && 
			(g_shadowmap_lightdir[g_shadowmap_slotno] <= 8)) {
			ChaVector4 lightdir;
			lightdir = g_lightdirforall[g_shadowmap_lightdir[g_shadowmap_slotno] - 1];
			ldirxz.SetParams(lightdir.x, 0.0f, lightdir.z);
		}
		else {
			ChaVector4 lightdir;
			lightdir = g_lightdirforall[0];
			ldirxz.SetParams(lightdir.x, 0.0f, lightdir.z);
		}


		ChaVector3 targetshadow;
		targetshadow = g_camtargetpos;

		ChaVector3 lpos;
		//lpos = g_camEye + ldir * (g_shadowmap_distscale * g_shadowmap_projscale);
		//lpos = g_camtargetpos - ldir * (ChaVector3LengthDbl(&camdiff) *
		
		//2024/02/25 lightindex == 0のときldirはtargetからeyeposへの向き よってshadowcameraposはtarget+ldirxz*scale
		lpos = g_camtargetpos + ldirxz * (ChaVector3LengthDbl(&camdiff) *
			g_shadowmap_distscale[g_shadowmap_slotno] * g_shadowmap_projscale[g_shadowmap_slotno]);
		//lpos.y = targetshadow.y + g_shadowmap_plusup[g_shadowmap_slotno] * g_shadowmap_projscale[g_shadowmap_slotno];

		//2024/02/25
		//shadowcameraのyはeyeposの上方
		lpos.y = g_camEye.y + g_shadowmap_plusup[g_shadowmap_slotno] * g_shadowmap_projscale[g_shadowmap_slotno];

		g_cameraShadow->SetPosition(Vector3(lpos.x, lpos.y, lpos.z));
		g_cameraShadow->SetTarget(Vector3(targetshadow.x, targetshadow.y, targetshadow.z));

		g_cameraShadow->SetNear(g_shadowmap_near[g_shadowmap_slotno] * g_shadowmap_projscale[g_shadowmap_slotno]);
		g_cameraShadow->SetFar(g_shadowmap_far[g_shadowmap_slotno] * g_shadowmap_projscale[g_shadowmap_slotno]);
		g_cameraShadow->SetViewAngle(g_shadowmap_fov[g_shadowmap_slotno] / 180.0f * (float)PI);
		g_cameraShadow->SetUp(Vector3(0.0f, 1.0f, 0.0f));
		g_cameraShadow->SetWidth((float)SHADOWMAP_SIZE);//2023/12/11 RenderingEngin::InitShadowMapでのバッファのサイズに合わせる
		g_cameraShadow->SetHeight((float)SHADOWMAP_SIZE);//2023/12/11 RenderingEngin::InitShadowMapでのバッファのサイズに合わせる
		g_cameraShadow->Update();
	}

}

int CreateSprites()
{
	char cpath[MAX_PATH];
	char cfxpath[MAX_PATH];

	char cbasedir[MAX_PATH] = { 0 };
	WideCharToMultiByte(CP_ACP, 0, g_basedir, -1, cbasedir, MAX_PATH, NULL, NULL);

	strcpy_s(cpath, MAX_PATH, cbasedir);
	char* clasten = 0;
	char* clast2en = 0;
	clasten = strrchr(cpath, '\\');
	if (!clasten) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	*clasten = 0;
	clast2en = strrchr(cpath, '\\');
	if (!clast2en) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	*clast2en = 0;
	strcat_s(cpath, MAX_PATH, "\\Media\\");


	SetCurrentDirectoryW(g_basedir);


	SpriteInitData spriteinitdata;
	spriteinitdata.m_width = 256;//仮　ファイルから読込時は上書きされる
	spriteinitdata.m_height = 256;//仮　ファイルから読込時は上書きされる
	spriteinitdata.m_colorBufferFormat[0] = DXGI_FORMAT_R32G32B32A32_FLOAT;

	bool screenvertexflag = true;//!!!!!!!!!!!!



	//strcpy_s(cfilepath, MAX_PATH, cpath);
	//strcat_s(cfilepath, MAX_PATH, "MameMedia\\bonecircle.dds");
	//spriteinitdata.m_ddsFilePath[0] = cfilepath;
	//s_bcircle.Init(spriteinitdata, screenvertexflag);
	//spriteinitdata.m_ddsFilePath[0] = 0;



	/////

	
	WCHAR mpath[MAX_PATH];
	WCHAR filepath[MAX_PATH];
	WCHAR* lasten;
	WCHAR* last2en;
	wcscpy_s(mpath, MAX_PATH, g_basedir);
	lasten = 0;
	last2en = 0;
	lasten = wcsrchr(mpath, TEXT('\\'));
	if (!lasten) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	*lasten = 0L;
	last2en = wcsrchr(mpath, TEXT('\\'));
	if (!last2en) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	*last2en = 0L;
	wcscat_s(mpath, MAX_PATH, L"\\Media\\");


	s_undosprite.CreateSprites(mpath);
	s_fpssprite.CreateSprites(mpath);


	strcpy_s(cfxpath, MAX_PATH, cpath);
	strcat_s(cfxpath, MAX_PATH, "Shader\\preset\\InstancedSprite.fx");//!!!!!!!! Set Shader
	spriteinitdata.m_fxFilePath = cfxpath;
	//spriteinitdata.m_alphaBlendMode = AlphaBlendMode_Add;
	spriteinitdata.m_alphaBlendMode = AlphaBlendMode_Trans;


	wcscpy_s(filepath, MAX_PATH, mpath);
	//wcscat_s(filepath, MAX_PATH, L"MameMedia\\JointMark_1.png");
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\boneimage.bmp");//2024/01/12
	s_spritetex0 = new Texture();
	s_spritetex0->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex0;
	s_bcircle.Init(spriteinitdata);//InstancedSprite

	
	strcpy_s(cfxpath, MAX_PATH, cpath);
	strcat_s(cfxpath, MAX_PATH, "Shader\\preset\\sprite.fx");//!!!!!!!! Set Shader
	spriteinitdata.m_fxFilePath = cfxpath;
	spriteinitdata.m_alphaBlendMode = AlphaBlendMode_Trans;

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Undo_1.png");
	s_spritetex1 = new Texture();
	s_spritetex1->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex1;
	s_spundo[0].sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Undo_1_pushed.png");
	s_spritetex_pushed1 = new Texture();
	s_spritetex_pushed1->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed1;
	s_spundo[0].sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Redo_1.png");
	s_spritetex2 = new Texture();
	s_spritetex2->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex2;
	s_spundo[1].sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Redo_1_pushed.png");
	s_spritetex_pushed2 = new Texture();
	s_spritetex_pushed2->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed2;
	s_spundo[1].sprite_pushed.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\X.gif");
	s_spritetex5 = new Texture();
	s_spritetex5->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex5;
	s_spaxis[0].sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\X_pushed.gif");
	s_spritetex_pushed5 = new Texture();
	s_spritetex_pushed5->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed5;
	s_spaxis[0].sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Y.gif");
	s_spritetex6 = new Texture();
	s_spritetex6->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex6;
	s_spaxis[1].sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Y_pushed.gif");
	s_spritetex_pushed6 = new Texture();
	s_spritetex_pushed6->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed6;
	s_spaxis[1].sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Z.gif");
	s_spritetex7 = new Texture();
	s_spritetex7->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex7;
	s_spaxis[2].sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Z_pushed.gif");
	s_spritetex_pushed7 = new Texture();
	s_spritetex_pushed7->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed7;
	s_spaxis[2].sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\RefPosON.gif");
	s_spritetex8 = new Texture();
	s_spritetex8->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex8;
	s_sprefpos.spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\RefPosOFF.gif");
	s_spritetex9 = new Texture();
	s_spritetex9->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex9;
	s_sprefpos.spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\LimitEul_ON.png");
	s_spritetex10 = new Texture();
	s_spritetex10->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex10;
	s_splimiteul.spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\LimitEul_OFF.png");
	s_spritetex11 = new Texture();
	s_spritetex11->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex11;
	s_splimiteul.spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CamAnimON.png");
	s_spritetex12 = new Texture();
	s_spritetex12->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex12;
	s_spcameramode.spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CamAnimOFF.png");
	s_spritetex13 = new Texture();
	s_spritetex13->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex13;
	s_spcameramode.spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CameraInherit_All.png");
	s_spritetex14 = new Texture();
	s_spritetex14->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex14;
	s_spcamerainherit.sprite1.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CameraInherit_CancelNull1.png");
	s_spritetex15 = new Texture();
	s_spritetex15->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex15;
	s_spcamerainherit.sprite2.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CameraInherit_CancelNull2.png");
	s_spritetex16 = new Texture();
	s_spritetex16->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex16;
	s_spcamerainherit.sprite3.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\WallScrapingIK_ON.png");
	s_spritetex17 = new Texture();
	s_spritetex17->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex17;
	s_spscraping.spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\WallScrapingIK_OFF.png");
	s_spritetex18 = new Texture();
	s_spritetex18->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex18;
	s_spscraping.spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKRot2ON.gif");
	s_spritetex19 = new Texture();
	s_spritetex19->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex19;
	s_spikmodesw[0].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKRot2OFF.gif");
	s_spritetex20 = new Texture();
	s_spritetex20->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex20;
	s_spikmodesw[0].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKMove2ON.gif");
	s_spritetex21 = new Texture();
	s_spritetex21->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex21;
	s_spikmodesw[1].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKMove2OFF.gif");
	s_spritetex22 = new Texture();
	s_spritetex22->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex22;
	s_spikmodesw[1].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKScale2ON.gif");
	s_spritetex23 = new Texture();
	s_spritetex23->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex23;
	s_spikmodesw[2].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\IKScale2OFF.gif");
	s_spritetex24 = new Texture();
	s_spritetex24->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex24;
	s_spikmodesw[2].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_CameraAndIK140ON.png");
	s_spritetex25 = new Texture();
	s_spritetex25->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex25;
	s_spguisw[SPGUISW_CAMERA_AND_IK].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DispAndLimits140ON.png");
	s_spritetex26 = new Texture();
	s_spritetex26->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex26;
	s_spguisw[SPGUISW_DISP_AND_LIMITS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	//wcscpy_s(filepath, MAX_PATH, mpath);
	//wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BrushParams140ON.png");
	//s_spritetex27 = new Texture();
	//s_spritetex27->InitFromWICFile(filepath);
	//spriteinitdata.m_textures[0] = s_spritetex27;
	//s_spguisw[SPGUISW_BRUSHPARAMS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BulletPhysics140ON.png");
	s_spritetex28 = new Texture();
	s_spritetex28->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex28;
	s_spguisw[SPGUISW_BULLETPHYSICS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_LOD140ON.png");
	s_spritetex29 = new Texture();
	s_spritetex29->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex29;
	s_spguisw[SPGUISW_PROJ_AND_LOD].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BlendShape140ON.png");
	s_spritetex92 = new Texture();
	s_spritetex92->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex92;
	s_spguisw[SPGUISW_BLENDSHAPE].spriteON.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_CameraAndIK140OFF.png");
	s_spritetex30 = new Texture();
	s_spritetex30->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex30;
	s_spguisw[SPGUISW_CAMERA_AND_IK].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DispAndLimits140OFF.png");
	s_spritetex31 = new Texture();
	s_spritetex31->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex31;
	s_spguisw[SPGUISW_DISP_AND_LIMITS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	//wcscpy_s(filepath, MAX_PATH, mpath);
	//wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BrushParams140OFF.png");
	//s_spritetex32 = new Texture();
	//s_spritetex32->InitFromWICFile(filepath);
	//spriteinitdata.m_textures[0] = s_spritetex32;
	//s_spguisw[SPGUISW_BRUSHPARAMS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BulletPhysics140OFF.png");
	s_spritetex33 = new Texture();
	s_spritetex33->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex33;
	s_spguisw[SPGUISW_BULLETPHYSICS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_LOD140OFF.png");
	s_spritetex34 = new Texture();
	s_spritetex34->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex34;
	s_spguisw[SPGUISW_PROJ_AND_LOD].spriteOFF.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_BlendShape140OFF.png");
	s_spritetex93 = new Texture();
	s_spritetex93->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex93;
	s_spguisw[SPGUISW_BLENDSHAPE].spriteOFF.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Lights140ON.png");
	s_spritetex35 = new Texture();
	s_spritetex35->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex35;
	s_spdispsw[SPDISPSW_LIGHTS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DispGroup140ON.png");
	s_spritetex36 = new Texture();
	s_spritetex36->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex36;
	s_spdispsw[SPDISPSW_DISPGROUP].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_LaterTransparent140ON.png");
	s_spritetex37 = new Texture();
	s_spritetex37->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex37;
	s_spdispsw[SPDISPSW_LATERTRANSPARENT].spriteON.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Shader140ON.png");
	s_spritetex37_1 = new Texture();
	s_spritetex37_1->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex37_1;
	s_spdispsw[SPDISPSW_SHADERTYPE].spriteON.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Shadow140ON.png");
	s_spritetex80 = new Texture();
	s_spritetex80->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex80;
	s_spdispsw[SPDISPSW_SHADOWPARAMS].spriteON.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Lights140OFF.png");
	s_spritetex38 = new Texture();
	s_spritetex38->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex38;
	s_spdispsw[SPDISPSW_LIGHTS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DispGroup140OFF.png");
	s_spritetex39 = new Texture();
	s_spritetex39->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex39;
	s_spdispsw[SPDISPSW_DISPGROUP].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_LaterTransparent140OFF.png");
	s_spritetex40 = new Texture();
	s_spritetex40->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex40;
	s_spdispsw[SPDISPSW_LATERTRANSPARENT].spriteOFF.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Shader140OFF.png");
	s_spritetex40_1 = new Texture();
	s_spritetex40_1->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex40_1;
	s_spdispsw[SPDISPSW_SHADERTYPE].spriteOFF.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Shadow140OFF.png");
	s_spritetex81 = new Texture();
	s_spritetex81->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex81;
	s_spdispsw[SPDISPSW_SHADOWPARAMS].spriteOFF.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuRigid140ON.png");
	s_spritetex41 = new Texture();
	s_spritetex41->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex41;
	s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuImpulse140ON.png");
	s_spritetex42 = new Texture();
	s_spritetex42->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex42;
	s_sprigidsw[SPRIGIDSW_IMPULSE].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuGP140ON.png");
	s_spritetex43 = new Texture();
	s_spritetex43->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex43;
	s_sprigidsw[SPRIGIDSW_GROUNDPLANE].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuDamp140ON.png");
	s_spritetex44 = new Texture();
	s_spritetex44->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex44;
	s_sprigidsw[SPRIGIDSW_DAMPANIM].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuRigid140OFF.png");
	s_spritetex45 = new Texture();
	s_spritetex45->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex45;
	s_sprigidsw[SPRIGIDSW_RIGIDPARAMS].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuImpulse140OFF.png");
	s_spritetex46 = new Texture();
	s_spritetex46->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex46;
	s_sprigidsw[SPRIGIDSW_IMPULSE].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuGP140OFF.png");
	s_spritetex47 = new Texture();
	s_spritetex47->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex47;
	s_sprigidsw[SPRIGIDSW_GROUNDPLANE].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_menuDamp140OFF.png");
	s_spritetex48 = new Texture();
	s_spritetex48->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex48;
	s_sprigidsw[SPRIGIDSW_DAMPANIM].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlateRetarget140ON.png");
	s_spritetex49 = new Texture();
	s_spritetex49->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex49;
	s_spretargetsw[SPRETARGETSW_RETARGET].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlateRetarget140OFF.png");
	s_spritetex50 = new Texture();
	s_spritetex50->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex50;
	s_spretargetsw[SPRETARGETSW_RETARGET].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlateLimitEuler140ON.png");
	s_spritetex51 = new Texture();
	s_spritetex51->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex51;
	s_spretargetsw[SPRETARGETSW_LIMITEULER].spriteON.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlateLimitEuler140OFF.png");
	s_spritetex52 = new Texture();
	s_spritetex52->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex52;
	s_spretargetsw[SPRETARGETSW_LIMITEULER].spriteOFF.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Q2EulThreshold140ON.png");
	s_spritetex82 = new Texture();
	s_spritetex82->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex82;
	s_spretargetsw[SPRETARGETSW_THRESHOLD].spriteON.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Q2EulThreshold140OFF.png");
	s_spritetex83 = new Texture();
	s_spritetex83->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex83;
	s_spretargetsw[SPRETARGETSW_THRESHOLD].spriteOFF.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Sky140ON.png");
	s_spritetex86 = new Texture();
	s_spritetex86->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex86;
	s_speffectsw[SPEFFECTSW_SKY].spriteON.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Sky140OFF.png");
	s_spritetex87 = new Texture();
	s_spritetex87->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex87;
	s_speffectsw[SPEFFECTSW_SKY].spriteOFF.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Fog140ON.png");
	s_spritetex88 = new Texture();
	s_spritetex88->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex88;
	s_speffectsw[SPEFFECTSW_FOG].spriteON.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_Fog140OFF.png");
	s_spritetex89 = new Texture();
	s_spritetex89->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex89;
	s_speffectsw[SPEFFECTSW_FOG].spriteOFF.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DOF140ON.png");
	s_spritetex90 = new Texture();
	s_spritetex90->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex90;
	s_speffectsw[SPEFFECTSW_DOF].spriteON.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\GUIPlate_DOF140OFF.png");
	s_spritetex91 = new Texture();
	s_spritetex91->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex91;
	s_speffectsw[SPEFFECTSW_DOF].spriteOFF.Init(spriteinitdata, screenvertexflag);



	//{
	//	int aimno;
	//	for (aimno = 0; aimno < SPAIMBARNUM; aimno++) {
	//		strcpy_s(filepath, MAX_PATH, path);
	//		strcat_s(filepath, MAX_PATH, "MameMedia\\GUIPlateAim140ON.png");
	//		spriteinitdata.m_wicFilePath[0] = filepath; 
	//		s_spaimbar[aimno].spriteON.Init(spriteinitdata, screenvertexflag);
	//
	//		strcpy_s(filepath, MAX_PATH, path);
	//		strcat_s(filepath, MAX_PATH, "MameMedia\\GUIPlateAim140OFF.png");
	//		spriteinitdata.m_wicFilePath[0] = filepath; 
	//		s_spaimbar[aimno].spriteOFF.Init(spriteinitdata, screenvertexflag);
	//	}
	//}
	//{
	//	int aimno;
	//	for (aimno = 0; aimno < SPMENU_MAX; aimno++) {
	//		strcpy_s(filepath, MAX_PATH, path);
	//		strcat_s(filepath, MAX_PATH, "MameMedia\\GUIPlateAim140ON.png");
	//		spriteinitdata.m_wicFilePath[0] = filepath; 
	//		s_spmenuaimbar[aimno].spriteON.Init(spriteinitdata, screenvertexflag);
	//		
	//		strcpy_s(filepath, MAX_PATH, path);
	//		strcat_s(filepath, MAX_PATH, "MameMedia\\GUIPlateAim140OFF.png");
	//		spriteinitdata.m_wicFilePath[0] = filepath; 
	//		s_spmenuaimbar[aimno].spriteOFF.Init(spriteinitdata, screenvertexflag);
	//	}
	//}
	
	{
		wcscpy_s(filepath, MAX_PATH, mpath);
		wcscat_s(filepath, MAX_PATH, L"MameMedia\\button101_Select.tif");
		s_spritetex53 = new Texture();
		s_spritetex53->InitFromWICFile(filepath);
		spriteinitdata.m_textures[0] = s_spritetex53;
		s_spsel3d.spriteON.Init(spriteinitdata, screenvertexflag);
		
		wcscpy_s(filepath, MAX_PATH, mpath);
		wcscat_s(filepath, MAX_PATH, L"MameMedia\\button101_UnSelect.tif");
		s_spritetex54 = new Texture();
		s_spritetex54->InitFromWICFile(filepath);
		spriteinitdata.m_textures[0] = s_spritetex54;
		s_spsel3d.spriteOFF.Init(spriteinitdata, screenvertexflag);
	}
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\cam_i.gif");
	s_spritetex55 = new Texture();
	s_spritetex55->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex55;
	s_spcam[SPR_CAM_I].sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\cam_i_pushed.gif");
	s_spritetex_pushed55 = new Texture();
	s_spritetex_pushed55->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed55;
	s_spcam[SPR_CAM_I].sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\cam_kai.gif");
	s_spritetex56 = new Texture();
	s_spritetex56->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex56;
	s_spcam[SPR_CAM_KAI].sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\cam_kai_pushed.gif");
	s_spritetex_pushed56 = new Texture();
	s_spritetex_pushed56->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed56;
	s_spcam[SPR_CAM_KAI].sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\cam_kaku.gif");
	s_spritetex57 = new Texture();
	s_spritetex57->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex57;
	s_spcam[SPR_CAM_KAKU].sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\cam_kaku_pushed.gif");
	s_spritetex_pushed57 = new Texture();
	s_spritetex_pushed57->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed57;
	s_spcam[SPR_CAM_KAKU].sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\RigOFF.png");//2024/02/14 gif-->pngに
	s_spritetex58 = new Texture();
	s_spritetex58->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex58;
	s_sprig[SPRIG_INACTIVE].sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\RigON.png");//2024/02/14 gif-->pngに
	s_spritetex59 = new Texture();
	s_spritetex59->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex59;
	s_sprig[SPRIG_ACTIVE].sprite.Init(spriteinitdata, screenvertexflag);
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\img_l105.png");
	s_spritetex60 = new Texture();
	s_spritetex60->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex60;
	s_spmousehere.sprite.Init(spriteinitdata, screenvertexflag);
	

	{
		WCHAR pngpath[MAX_PATH];
		swprintf_s(pngpath, MAX_PATH, L"%sMameMedia\\img_l105.png", mpath);
		//swprintf_s(bmppath, MAX_PATH, L"%simg_l105.bmp", mpath);
		//g_mouseherebmp = (HBITMAP)::LoadImage(GetModuleHandle(NULL), bmppath, IMAGE_BITMAP, 52, 50, LR_LOADFROMFILE);
		//_ASSERT(g_mouseherebmp);
		//g_tranbmp = 0xFF000000;
		g_mousehereimage = new Gdiplus::Image(pngpath);
		if (!g_mousehereimage) {
			_ASSERT(0);
			PostQuitMessage(1);
			return S_FALSE;
		}
	}
	
	{
		WCHAR filename[SKNUMBUTTON_MAX][MAX_PATH] = {
			L"MameMedia\\num0_48.png",
			L"MameMedia\\num1_48.png",
			L"MameMedia\\num2_48.png",
			L"MameMedia\\num3_48.png",
			L"MameMedia\\num4_48.png",
			L"MameMedia\\num5_48.png",
			L"MameMedia\\num6_48.png",
			L"MameMedia\\num7_48.png",
			L"MameMedia\\num8_48.png",
			L"MameMedia\\num9_48.png",
			L"MameMedia\\num_period_48.png",
			L"MameMedia\\num_signe_48.png",
			L"MameMedia\\num_BS_48.png",
			L"MameMedia\\num_Clear_48.png",
			L"MameMedia\\num_cp1_48.png",
			L"MameMedia\\num_cp2_48.png",
			L"MameMedia\\num_cp3_48.png",
			L"MameMedia\\num_ps1_48.png",
			L"MameMedia\\num_ps2_48.png",
			L"MameMedia\\num_ps3_48.png",
			L"MameMedia\\num_close_48.png"
		};
		WCHAR filename_pushed[SKNUMBUTTON_MAX][MAX_PATH] = {
			L"MameMedia\\num0_48_pushed.png",
			L"MameMedia\\num1_48_pushed.png",
			L"MameMedia\\num2_48_pushed.png",
			L"MameMedia\\num3_48_pushed.png",
			L"MameMedia\\num4_48_pushed.png",
			L"MameMedia\\num5_48_pushed.png",
			L"MameMedia\\num6_48_pushed.png",
			L"MameMedia\\num7_48_pushed.png",
			L"MameMedia\\num8_48_pushed.png",
			L"MameMedia\\num9_48_pushed.png",
			L"MameMedia\\num_period_48_pushed.png",
			L"MameMedia\\num_signe_48_pushed.png",
			L"MameMedia\\num_BS_48_pushed.png",
			L"MameMedia\\num_Clear_48_pushed.png",
			L"MameMedia\\num_cp1_48_pushed.png",
			L"MameMedia\\num_cp2_48_pushed.png",
			L"MameMedia\\num_cp3_48_pushed.png",
			L"MameMedia\\num_ps1_48_pushed.png",
			L"MameMedia\\num_ps2_48_pushed.png",
			L"MameMedia\\num_ps3_48_pushed.png",
			L"MameMedia\\num_close_48_pushed.png"
		};

		{
			WCHAR pngpath[MAX_PATH];
			swprintf_s(pngpath, MAX_PATH, L"%s%s", mpath, L"MameMedia\\num_BG_480x256.png");
			g_numBG = new Gdiplus::Image(pngpath);
			if (!g_numBG) {
				_ASSERT(0);
				PostQuitMessage(1);
				return S_FALSE;
			}
		}
		int numindex;
		for (numindex = 0; numindex < SKNUMBUTTON_MAX; numindex++) {
			WCHAR pngpath[MAX_PATH];
			swprintf_s(pngpath, MAX_PATH, L"%s%s", mpath, filename[numindex]);
			g_numbutton[numindex] = new Gdiplus::Image(pngpath);
			if (!g_numbutton[numindex]) {
				_ASSERT(0);
				PostQuitMessage(1);
				return S_FALSE;
			}

			WCHAR pngpath_pushed[MAX_PATH];
			swprintf_s(pngpath_pushed, MAX_PATH, L"%s%s", mpath, filename_pushed[numindex]);
			g_numbutton_pushed[numindex] = new Gdiplus::Image(pngpath_pushed);
			if (!g_numbutton_pushed[numindex]) {
				_ASSERT(0);
				PostQuitMessage(1);
				return S_FALSE;
			}
		}
	}

	{
		WCHAR filename[SKALNUM_MAX][MAX_PATH] = {
			L"MameMedia\\Q_48.png",
			L"MameMedia\\W_48.png",
			L"MameMedia\\E_48.png",
			L"MameMedia\\R_48.png",
			L"MameMedia\\T_48.png",
			L"MameMedia\\Y_48.png",
			L"MameMedia\\U_48.png",
			L"MameMedia\\I_48.png",
			L"MameMedia\\O_48.png",
			L"MameMedia\\P_48.png",
			L"MameMedia\\A_48.png",
			L"MameMedia\\S_48.png",
			L"MameMedia\\D_48.png",
			L"MameMedia\\F_48.png",
			L"MameMedia\\G_48.png",
			L"MameMedia\\H_48.png",
			L"MameMedia\\J_48.png",
			L"MameMedia\\K_48.png",
			L"MameMedia\\L_48.png",
			L"MameMedia\\Z_48.png",
			L"MameMedia\\X_48.png",
			L"MameMedia\\C_48.png",
			L"MameMedia\\V_48.png",
			L"MameMedia\\B_48.png",
			L"MameMedia\\N_48.png",
			L"MameMedia\\M_48.png",

			L"MameMedia\\num0_48.png",
			L"MameMedia\\num1_48.png",
			L"MameMedia\\num2_48.png",
			L"MameMedia\\num3_48.png",
			L"MameMedia\\num4_48.png",
			L"MameMedia\\num5_48.png",
			L"MameMedia\\num6_48.png",
			L"MameMedia\\num7_48.png",
			L"MameMedia\\num8_48.png",
			L"MameMedia\\num9_48.png",
			L"MameMedia\\num_period_48.png",
			L"MameMedia\\num_signe_48.png",
			L"MameMedia\\num_BS_48.png",
			L"MameMedia\\num_Clear_48.png",
			L"MameMedia\\num_cp1_48.png",
			L"MameMedia\\num_cp2_48.png",
			L"MameMedia\\num_cp3_48.png",
			L"MameMedia\\num_ps1_48.png",
			L"MameMedia\\num_ps2_48.png",
			L"MameMedia\\num_ps3_48.png",
			L"MameMedia\\num_close_48.png"
		};

		WCHAR filename_pushed[SKALNUM_MAX][MAX_PATH] = {
			L"MameMedia\\Q_48_pushed.png",
			L"MameMedia\\W_48_pushed.png",
			L"MameMedia\\E_48_pushed.png",
			L"MameMedia\\R_48_pushed.png",
			L"MameMedia\\T_48_pushed.png",
			L"MameMedia\\Y_48_pushed.png",
			L"MameMedia\\U_48_pushed.png",
			L"MameMedia\\I_48_pushed.png",
			L"MameMedia\\O_48_pushed.png",
			L"MameMedia\\P_48_pushed.png",
			L"MameMedia\\A_48_pushed.png",
			L"MameMedia\\S_48_pushed.png",
			L"MameMedia\\D_48_pushed.png",
			L"MameMedia\\F_48_pushed.png",
			L"MameMedia\\G_48_pushed.png",
			L"MameMedia\\H_48_pushed.png",
			L"MameMedia\\J_48_pushed.png",
			L"MameMedia\\K_48_pushed.png",
			L"MameMedia\\L_48_pushed.png",
			L"MameMedia\\Z_48_pushed.png",
			L"MameMedia\\X_48_pushed.png",
			L"MameMedia\\C_48_pushed.png",
			L"MameMedia\\V_48_pushed.png",
			L"MameMedia\\B_48_pushed.png",
			L"MameMedia\\N_48_pushed.png",
			L"MameMedia\\M_48_pushed.png",

			L"MameMedia\\num0_48_pushed.png",
			L"MameMedia\\num1_48_pushed.png",
			L"MameMedia\\num2_48_pushed.png",
			L"MameMedia\\num3_48_pushed.png",
			L"MameMedia\\num4_48_pushed.png",
			L"MameMedia\\num5_48_pushed.png",
			L"MameMedia\\num6_48_pushed.png",
			L"MameMedia\\num7_48_pushed.png",
			L"MameMedia\\num8_48_pushed.png",
			L"MameMedia\\num9_48_pushed.png",
			L"MameMedia\\num_period_48_pushed.png",
			L"MameMedia\\num_signe_48_pushed.png",
			L"MameMedia\\num_BS_48_pushed.png",
			L"MameMedia\\num_Clear_48_pushed.png",
			L"MameMedia\\num_cp1_48_pushed.png",
			L"MameMedia\\num_cp2_48_pushed.png",
			L"MameMedia\\num_cp3_48_pushed.png",
			L"MameMedia\\num_ps1_48_pushed.png",
			L"MameMedia\\num_ps2_48_pushed.png",
			L"MameMedia\\num_ps3_48_pushed.png",
			L"MameMedia\\num_close_48_pushed.png"
		};

		int alnumindex;
		for (alnumindex = 0; alnumindex < SKALNUM_MAX; alnumindex++) {
			WCHAR pngpath[MAX_PATH];
			swprintf_s(pngpath, MAX_PATH, L"%s%s", mpath, filename[alnumindex]);
			g_alnumbutton[alnumindex] = new Gdiplus::Image(pngpath);
			if (!g_alnumbutton[alnumindex]) {
				_ASSERT(0);
				PostQuitMessage(1);
				return S_FALSE;
			}

			WCHAR pngpath_pushed[MAX_PATH];
			swprintf_s(pngpath_pushed, MAX_PATH, L"%s%s", mpath, filename_pushed[alnumindex]);
			g_alnumbutton_pushed[alnumindex] = new Gdiplus::Image(pngpath_pushed);
			if (!g_alnumbutton_pushed[alnumindex]) {
				_ASSERT(0);
				PostQuitMessage(1);
				return S_FALSE;
			}
		}
	}

	{
		WCHAR pngpath[MAX_PATH];
		swprintf_s(pngpath, MAX_PATH, L"%sMenuAimBar140.png", mpath);
		//swprintf_s(bmppath, MAX_PATH, L"%simg_l105.bmp", mpath);
		//g_mouseherebmp = (HBITMAP)::LoadImage(GetModuleHandle(NULL), bmppath, IMAGE_BITMAP, 52, 50, LR_LOADFROMFILE);
		//_ASSERT(g_mouseherebmp);
		//g_tranbmp = 0xFF000000;
		g_menuaimbarimage = new Gdiplus::Image(pngpath);
		if (!g_menuaimbarimage) {
			_ASSERT(0);
			PostQuitMessage(1);
			return S_FALSE;
		}
	}
	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\UpperBar.png");
	s_spritetex84 = new Texture();
	s_spritetex84->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex84;
	s_spupperbar.sprite.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\img_ret2prev.png");
	s_spritetex61 = new Texture();
	s_spritetex61->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex61;
	s_spret2prev.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\targetbutton_inv.png");
	s_spritetex_pushed61 = new Texture();
	s_spritetex_pushed61->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed61;
	s_spret2prev.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\img_ret2prev2.png");
	s_spritetex62 = new Texture();
	s_spritetex62->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex62;
	s_spret2prev2.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\targetbutton_inv.png");
	s_spritetex_pushed62 = new Texture();
	s_spritetex_pushed62->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed62;
	s_spret2prev2.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\targetbutton26.png");
	g_playerbutton_target26 = new Gdiplus::Image(filepath);
	if (!g_playerbutton_target26) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\targetbutton_inv26.png");
	g_playerbutton_target_inv26 = new Gdiplus::Image(filepath);
	if (!g_playerbutton_target_inv26) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\targetbutton40.png");
	g_playerbutton_target40 = new Gdiplus::Image(filepath);
	if (!g_playerbutton_target40) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\targetbutton_inv40.png");
	g_playerbutton_target_inv40 = new Gdiplus::Image(filepath);
	if (!g_playerbutton_target_inv40) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\BakeLW2W.png");
	s_spritetex63 = new Texture();
	s_spritetex63->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex63;
	s_spcplw2w.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\BakeLW2W_pushed.png");
	s_spritetex_pushed63 = new Texture();
	s_spritetex_pushed63->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed63;
	s_spcplw2w.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\SmoothFilter.png");
	s_spritetex64 = new Texture();
	s_spritetex64->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex64;
	s_spsmooth.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\SmoothFilter_pushed.png");
	s_spritetex_pushed64 = new Texture();
	s_spritetex_pushed64->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed64;
	s_spsmooth.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Constraint_Execute.png");
	s_spritetex65 = new Texture();
	s_spritetex65->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex65;
	s_spconstexe.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Constraint_Execute_pushed.png");
	s_spritetex_pushed65 = new Texture();
	s_spritetex_pushed65->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed65;
	s_spconstexe.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Constraint_refresh.png");
	s_spritetex66 = new Texture();
	s_spritetex66->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex66;
	s_spconstrefresh.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Constraint_refresh_pushed.png");
	s_spritetex_pushed66 = new Texture();
	s_spritetex_pushed66->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed66;
	s_spconstrefresh.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CopyButton.gif");
	s_spritetex67 = new Texture();
	s_spritetex67->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex67;
	s_spcopy.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CopyButton_pushed.gif");
	s_spritetex_pushed67 = new Texture();
	s_spritetex_pushed67->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed67;
	s_spcopy.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\SymCopyButton3.png");
	s_spritetex68 = new Texture();
	s_spritetex68->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex68;
	s_spsymcopy.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\SymCopyButton3_pushed.png");
	s_spritetex_pushed68 = new Texture();
	s_spritetex_pushed68->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed68;
	s_spsymcopy.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\PasteButton.gif");
	s_spritetex69 = new Texture();
	s_spritetex69->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex69;
	s_sppaste.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\PasteButton_pushed.gif");
	s_spritetex_pushed69 = new Texture();
	s_spritetex_pushed69->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed69;
	s_sppaste.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CopyHistoryButton.gif");
	s_spritetex70 = new Texture();
	s_spritetex70->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex70;
	s_spcopyhistory.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CopyHistoryButton_pushed.gif");
	s_spritetex_pushed70 = new Texture();
	s_spritetex_pushed70->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed70;
	s_spcopyhistory.sprite_pushed.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\JumpInterpolation_1.png");
	s_spritetex85 = new Texture();
	s_spritetex85->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex85;
	s_spjumpinterpolate.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\JumpInterpolation_1_pushed.png");
	s_spritetex_pushed85 = new Texture();
	s_spritetex_pushed85->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed85;
	s_spjumpinterpolate.sprite_pushed.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\InterpolateButton.png");
	s_spritetex71 = new Texture();
	s_spritetex71->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex71;
	s_spinterpolate.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\InterpolateButton_pushed.png");
	s_spritetex_pushed71 = new Texture();
	s_spritetex_pushed71->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed71;
	s_spinterpolate.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\InitButton.png");
	s_spritetex72 = new Texture();
	s_spritetex72->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex72;
	s_spinit.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\InitButton_pushed.png");
	s_spritetex_pushed72 = new Texture();
	s_spritetex_pushed72->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed72;
	s_spinit.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\ScaleInitButton.png");
	s_spritetex73 = new Texture();
	s_spritetex73->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex73;
	s_spscaleinit.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\ScaleInitButton_pushed.png");
	s_spritetex_pushed73 = new Texture();
	s_spritetex_pushed73->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed73;
	s_spscaleinit.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\PropertyButton.png");
	s_spritetex74 = new Texture();
	s_spritetex74->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex74;
	s_spproperty.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\PropertyButton_pushed.png");
	s_spritetex_pushed74 = new Texture();
	s_spritetex_pushed74->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed74;
	s_spproperty.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Edit0FrameButton.png");
	s_spritetex75 = new Texture();
	s_spritetex75->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex75;
	s_spzeroframe.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Edit0FrameButton_pushed.png");
	s_spritetex_pushed75 = new Texture();
	s_spritetex_pushed75->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed75;
	s_spzeroframe.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CameraDollyButton.png");
	s_spritetex76 = new Texture();
	s_spritetex76->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex76;
	s_spcameradolly.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\CameraDollyButton_pushed.png");
	s_spritetex_pushed76 = new Texture();
	s_spritetex_pushed76->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed76;
	s_spcameradolly.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\ModelPosDirButton.png");
	s_spritetex77 = new Texture();
	s_spritetex77->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex77;
	s_spmodelposdir.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\ModelPosDirButton_pushed.png");
	s_spritetex_pushed77 = new Texture();
	s_spritetex_pushed77->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed77;
	s_spmodelposdir.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\MaterialRateButton.png");
	s_spritetex78 = new Texture();
	s_spritetex78->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex78;
	s_spmaterialrate.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\MaterialRateButton_pushed.png");
	s_spritetex_pushed78 = new Texture();
	s_spritetex_pushed78->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex_pushed78;
	s_spmaterialrate.sprite_pushed.Init(spriteinitdata, screenvertexflag);


	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Camera_CopyButton.gif");
	s_spritetexCamera67 = new Texture();
	s_spritetexCamera67->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera67;
	s_spcopy_camera.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Camera_CopyButton_pushed.gif");
	s_spritetexCamera_pushed67 = new Texture();
	s_spritetexCamera_pushed67->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera_pushed67;
	s_spcopy_camera.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Camera_PasteButton.gif");
	s_spritetexCamera69 = new Texture();
	s_spritetexCamera69->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera69;
	s_sppaste_camera.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Camera_PasteButton_pushed.gif");
	s_spritetexCamera_pushed69 = new Texture();
	s_spritetexCamera_pushed69->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera_pushed69;
	s_sppaste_camera.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Camera_InterpolateButton.png");
	s_spritetexCamera71 = new Texture();
	s_spritetexCamera71->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera71;
	s_spinterpolate_camera.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Camera_InterpolateButton_pushed.png");
	s_spritetexCamera_pushed71 = new Texture();
	s_spritetexCamera_pushed71->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera_pushed71;
	s_spinterpolate_camera.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Camera_InitButton.png");
	s_spritetexCamera72 = new Texture();
	s_spritetexCamera72->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera72;
	s_spinit_camera.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Camera_InitButton_pushed.png");
	s_spritetexCamera_pushed72 = new Texture();
	s_spritetexCamera_pushed72->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera_pushed72;
	s_spinit_camera.sprite_pushed.Init(spriteinitdata, screenvertexflag);

	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\Camera_SmoothFilter.png");
	s_spritetexCamera64 = new Texture();
	s_spritetexCamera64->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera64;
	s_spsmooth_camera.sprite.Init(spriteinitdata, screenvertexflag);
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\SmoothFilter_pushed.png");
	s_spritetexCamera_pushed64 = new Texture();
	s_spritetexCamera_pushed64->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetexCamera_pushed64;
	s_spsmooth_camera.sprite_pushed.Init(spriteinitdata, screenvertexflag);



	
	wcscpy_s(filepath, MAX_PATH, mpath);
	wcscat_s(filepath, MAX_PATH, L"MameMedia\\MouseCenterButtonON.png");
	s_spritetex79 = new Texture();
	s_spritetex79->InitFromWICFile(filepath);
	spriteinitdata.m_textures[0] = s_spritetex79;
	s_mousecenteron.sprite.Init(spriteinitdata, screenvertexflag);
	
	return 0;
}

void InitSprites()
{
	s_spritetex0 = 0;
	s_spritetex1 = 0;
	s_spritetex2 = 0;
	s_spritetex3 = 0;
	s_spritetex4 = 0;
	s_spritetex5 = 0;
	s_spritetex6 = 0;
	s_spritetex7 = 0;
	s_spritetex8 = 0;
	s_spritetex9 = 0;
	s_spritetex10 = 0;
	s_spritetex11 = 0;
	s_spritetex12 = 0;
	s_spritetex13 = 0;
	s_spritetex14 = 0;
	s_spritetex15 = 0;
	s_spritetex16 = 0;
	s_spritetex17 = 0;
	s_spritetex18 = 0;
	s_spritetex19 = 0;
	s_spritetex20 = 0;
	s_spritetex21 = 0;
	s_spritetex22 = 0;
	s_spritetex23 = 0;
	s_spritetex24 = 0;
	s_spritetex25 = 0;
	s_spritetex26 = 0;
	s_spritetex27 = 0;
	s_spritetex28 = 0;
	s_spritetex29 = 0;
	s_spritetex30 = 0;
	s_spritetex31 = 0;
	s_spritetex32 = 0;
	s_spritetex33 = 0;
	s_spritetex34 = 0;
	s_spritetex35 = 0;
	s_spritetex36 = 0;
	s_spritetex37 = 0;
	s_spritetex37_1 = 0;
	s_spritetex38 = 0;
	s_spritetex39 = 0;
	s_spritetex40 = 0;
	s_spritetex40_1 = 0;
	s_spritetex41 = 0;
	s_spritetex42 = 0;
	s_spritetex43 = 0;
	s_spritetex44 = 0;
	s_spritetex45 = 0;
	s_spritetex46 = 0;
	s_spritetex47 = 0;
	s_spritetex48 = 0;
	s_spritetex49 = 0;
	s_spritetex50 = 0;
	s_spritetex51 = 0;
	s_spritetex52 = 0;
	s_spritetex53 = 0;
	s_spritetex54 = 0;
	s_spritetex55 = 0;
	s_spritetex56 = 0;
	s_spritetex57 = 0;
	s_spritetex58 = 0;
	s_spritetex59 = 0;
	s_spritetex60 = 0;
	s_spritetex61 = 0;
	s_spritetex62 = 0;
	s_spritetex63 = 0;
	s_spritetex64 = 0;
	s_spritetex65 = 0;
	s_spritetex66 = 0;
	s_spritetex67 = 0;
	s_spritetex68 = 0;
	s_spritetex69 = 0;
	s_spritetex70 = 0;
	s_spritetex71 = 0;
	s_spritetex72 = 0;
	s_spritetex73 = 0;
	s_spritetex74 = 0;
	s_spritetex75 = 0;
	s_spritetex76 = 0;
	s_spritetex77 = 0;
	s_spritetex78 = 0;
	s_spritetex79 = 0;
	s_spritetex80 = 0;
	s_spritetex81 = 0;
	s_spritetex82 = 0;
	s_spritetex83 = 0;
	s_spritetex84 = 0;
	s_spritetex85 = 0;
	s_spritetex86 = 0;
	s_spritetex87 = 0;
	s_spritetex88 = 0;
	s_spritetex89 = 0;
	s_spritetex90 = 0;
	s_spritetex91 = 0;
	s_spritetex92 = 0;
	s_spritetex93 = 0;
}

void DestroySprites()
{
	if (s_spritetex0) {
		delete s_spritetex0;
		s_spritetex0 = 0;
	}
	if (s_spritetex1) {
		delete s_spritetex1;
		s_spritetex1 = 0;
	}
	if (s_spritetex2) {
		delete s_spritetex2;
		s_spritetex2 = 0;
	}
	if (s_spritetex3) {
		delete s_spritetex3;
		s_spritetex3 = 0;
	}
	if (s_spritetex4) {
		delete s_spritetex4;
		s_spritetex4 = 0;
	}
	if (s_spritetex5) {
		delete s_spritetex5;
		s_spritetex5 = 0;
	}
	if (s_spritetex6) {
		delete s_spritetex6;
		s_spritetex6 = 0;
	}
	if (s_spritetex7) {
		delete s_spritetex7;
		s_spritetex7 = 0;
	}
	if (s_spritetex8) {
		delete s_spritetex8;
		s_spritetex8 = 0;
	}
	if (s_spritetex9) {
		delete s_spritetex9;
		s_spritetex9 = 0;
	}
	if (s_spritetex10) {
		delete s_spritetex10;
		s_spritetex10 = 0;
	}

	if (s_spritetex11) {
		delete s_spritetex11;
		s_spritetex11 = 0;
	}
	if (s_spritetex12) {
		delete s_spritetex12;
		s_spritetex12 = 0;
	}
	if (s_spritetex13) {
		delete s_spritetex13;
		s_spritetex13 = 0;
	}
	if (s_spritetex14) {
		delete s_spritetex14;
		s_spritetex14 = 0;
	}
	if (s_spritetex15) {
		delete s_spritetex15;
		s_spritetex15 = 0;
	}
	if (s_spritetex16) {
		delete s_spritetex16;
		s_spritetex16 = 0;
	}
	if (s_spritetex17) {
		delete s_spritetex17;
		s_spritetex17 = 0;
	}
	if (s_spritetex18) {
		delete s_spritetex18;
		s_spritetex18 = 0;
	}
	if (s_spritetex19) {
		delete s_spritetex19;
		s_spritetex19 = 0;
	}
	if (s_spritetex20) {
		delete s_spritetex20;
		s_spritetex20 = 0;
	}

	if (s_spritetex21) {
		delete s_spritetex21;
		s_spritetex21 = 0;
	}
	if (s_spritetex22) {
		delete s_spritetex22;
		s_spritetex22 = 0;
	}
	if (s_spritetex23) {
		delete s_spritetex23;
		s_spritetex23 = 0;
	}
	if (s_spritetex24) {
		delete s_spritetex24;
		s_spritetex24 = 0;
	}
	if (s_spritetex25) {
		delete s_spritetex25;
		s_spritetex25 = 0;
	}
	if (s_spritetex26) {
		delete s_spritetex26;
		s_spritetex26 = 0;
	}
	if (s_spritetex27) {
		delete s_spritetex27;
		s_spritetex27 = 0;
	}
	if (s_spritetex28) {
		delete s_spritetex28;
		s_spritetex28 = 0;
	}
	if (s_spritetex29) {
		delete s_spritetex29;
		s_spritetex29 = 0;
	}
	if (s_spritetex30) {
		delete s_spritetex30;
		s_spritetex30 = 0;
	}

	if (s_spritetex31) {
		delete s_spritetex31;
		s_spritetex31 = 0;
	}
	if (s_spritetex32) {
		delete s_spritetex32;
		s_spritetex32 = 0;
	}
	if (s_spritetex33) {
		delete s_spritetex33;
		s_spritetex33 = 0;
	}
	if (s_spritetex34) {
		delete s_spritetex34;
		s_spritetex34 = 0;
	}
	if (s_spritetex35) {
		delete s_spritetex35;
		s_spritetex35 = 0;
	}
	if (s_spritetex36) {
		delete s_spritetex36;
		s_spritetex36 = 0;
	}
	if (s_spritetex37) {
		delete s_spritetex37;
		s_spritetex37 = 0;
	}
	if (s_spritetex37_1) {
		delete s_spritetex37_1;
		s_spritetex37_1 = 0;
	}
	if (s_spritetex38) {
		delete s_spritetex38;
		s_spritetex38 = 0;
	}
	if (s_spritetex39) {
		delete s_spritetex39;
		s_spritetex39 = 0;
	}
	if (s_spritetex40) {
		delete s_spritetex40;
		s_spritetex40 = 0;
	}
	if (s_spritetex40_1) {
		delete s_spritetex40_1;
		s_spritetex40_1 = 0;
	}

	
	if (s_spritetex41) {
		delete s_spritetex41;
		s_spritetex41 = 0;
	}
	if (s_spritetex42) {
		delete s_spritetex42;
		s_spritetex42 = 0;
	}
	if (s_spritetex43) {
		delete s_spritetex43;
		s_spritetex43 = 0;
	}
	if (s_spritetex44) {
		delete s_spritetex44;
		s_spritetex44 = 0;
	}
	if (s_spritetex45) {
		delete s_spritetex45;
		s_spritetex45 = 0;
	}
	if (s_spritetex46) {
		delete s_spritetex46;
		s_spritetex46 = 0;
	}
	if (s_spritetex47) {
		delete s_spritetex47;
		s_spritetex47 = 0;
	}
	if (s_spritetex48) {
		delete s_spritetex48;
		s_spritetex48 = 0;
	}
	if (s_spritetex49) {
		delete s_spritetex49;
		s_spritetex49 = 0;
	}
	if (s_spritetex50) {
		delete s_spritetex50;
		s_spritetex50 = 0;
	}


	if (s_spritetex51) {
		delete s_spritetex51;
		s_spritetex51 = 0;
	}
	if (s_spritetex52) {
		delete s_spritetex52;
		s_spritetex52 = 0;
	}
	if (s_spritetex53) {
		delete s_spritetex53;
		s_spritetex53 = 0;
	}
	if (s_spritetex54) {
		delete s_spritetex54;
		s_spritetex54 = 0;
	}
	if (s_spritetex55) {
		delete s_spritetex55;
		s_spritetex55 = 0;
	}
	if (s_spritetex56) {
		delete s_spritetex56;
		s_spritetex56 = 0;
	}
	if (s_spritetex57) {
		delete s_spritetex57;
		s_spritetex57 = 0;
	}
	if (s_spritetex58) {
		delete s_spritetex58;
		s_spritetex58 = 0;
	}
	if (s_spritetex59) {
		delete s_spritetex59;
		s_spritetex59 = 0;
	}
	if (s_spritetex60) {
		delete s_spritetex60;
		s_spritetex60 = 0;
	}


	if (s_spritetex61) {
		delete s_spritetex61;
		s_spritetex61 = 0;
	}
	if (s_spritetex62) {
		delete s_spritetex62;
		s_spritetex62 = 0;
	}
	if (s_spritetex63) {
		delete s_spritetex63;
		s_spritetex63 = 0;
	}
	if (s_spritetex64) {
		delete s_spritetex64;
		s_spritetex64 = 0;
	}
	if (s_spritetex65) {
		delete s_spritetex65;
		s_spritetex65 = 0;
	}
	if (s_spritetex66) {
		delete s_spritetex66;
		s_spritetex66 = 0;
	}
	if (s_spritetex67) {
		delete s_spritetex67;
		s_spritetex67 = 0;
	}
	if (s_spritetex68) {
		delete s_spritetex68;
		s_spritetex68 = 0;
	}
	if (s_spritetex69) {
		delete s_spritetex69;
		s_spritetex69 = 0;
	}
	if (s_spritetex70) {
		delete s_spritetex70;
		s_spritetex70 = 0;
	}



	if (s_spritetex71) {
		delete s_spritetex71;
		s_spritetex71 = 0;
	}
	if (s_spritetex72) {
		delete s_spritetex72;
		s_spritetex72 = 0;
	}
	if (s_spritetex73) {
		delete s_spritetex73;
		s_spritetex73 = 0;
	}
	if (s_spritetex74) {
		delete s_spritetex74;
		s_spritetex74 = 0;
	}
	if (s_spritetex75) {
		delete s_spritetex75;
		s_spritetex75 = 0;
	}
	if (s_spritetex76) {
		delete s_spritetex76;
		s_spritetex76 = 0;
	}
	if (s_spritetex77) {
		delete s_spritetex77;
		s_spritetex77 = 0;
	}
	if (s_spritetex78) {
		delete s_spritetex78;
		s_spritetex78 = 0;
	}
	if (s_spritetex79) {
		delete s_spritetex79;
		s_spritetex79 = 0;
	}
	if (s_spritetex80) {
		delete s_spritetex80;
		s_spritetex80 = 0;
	}
	if (s_spritetex81) {
		delete s_spritetex81;
		s_spritetex81 = 0;
	}
	if (s_spritetex82) {
		delete s_spritetex82;
		s_spritetex82 = 0;
	}
	if (s_spritetex83) {
		delete s_spritetex83;
		s_spritetex83 = 0;
	}
	if (s_spritetex84) {
		delete s_spritetex84;
		s_spritetex84 = 0;
	}
	if (s_spritetex85) {
		delete s_spritetex85;
		s_spritetex85 = 0;
	}
	if (s_spritetex86) {
		delete s_spritetex86;
		s_spritetex86 = 0;
	}
	if (s_spritetex87) {
		delete s_spritetex87;
		s_spritetex87 = 0;
	}
	if (s_spritetex88) {
		delete s_spritetex88;
		s_spritetex88 = 0;
	}
	if (s_spritetex89) {
		delete s_spritetex89;
		s_spritetex89 = 0;
	}
	if (s_spritetex90) {
		delete s_spritetex90;
		s_spritetex90 = 0;
	}
	if (s_spritetex91) {
		delete s_spritetex91;
		s_spritetex91 = 0;
	}
	if (s_spritetex92) {
		delete s_spritetex92;
		s_spritetex92 = 0;
	}
	if (s_spritetex93) {
		delete s_spritetex93;
		s_spritetex93 = 0;
	}



	if (s_spritetex_pushed1) {
		delete s_spritetex_pushed1;
		s_spritetex_pushed1 = 0;
	}
	if (s_spritetex_pushed2) {
		delete s_spritetex_pushed2;
		s_spritetex_pushed2 = 0;
	}
	if (s_spritetex_pushed5) {
		delete s_spritetex_pushed5;
		s_spritetex_pushed5 = 0;
	}
	if (s_spritetex_pushed6) {
		delete s_spritetex_pushed6;
		s_spritetex_pushed6 = 0;
	}
	if (s_spritetex_pushed7) {
		delete s_spritetex_pushed7;
		s_spritetex_pushed7 = 0;
	}
	if (s_spritetex_pushed55) {
		delete s_spritetex_pushed55;
		s_spritetex_pushed55 = 0;
	}
	if (s_spritetex_pushed56) {
		delete s_spritetex_pushed56;
		s_spritetex_pushed56 = 0;
	}
	if (s_spritetex_pushed57) {
		delete s_spritetex_pushed57;
		s_spritetex_pushed57 = 0;
	}
	if (s_spritetex_pushed63) {
		delete s_spritetex_pushed63;
		s_spritetex_pushed63 = 0;
	}
	if (s_spritetex_pushed64) {
		delete s_spritetex_pushed64;
		s_spritetex_pushed64 = 0;
	}
	if (s_spritetex_pushed65) {
		delete s_spritetex_pushed65;
		s_spritetex_pushed65 = 0;
	}
	if (s_spritetex_pushed66) {
		delete s_spritetex_pushed66;
		s_spritetex_pushed66 = 0;
	}
	if (s_spritetex_pushed67) {
		delete s_spritetex_pushed67;
		s_spritetex_pushed67 = 0;
	}
	if (s_spritetex_pushed68) {
		delete s_spritetex_pushed68;
		s_spritetex_pushed68 = 0;
	}
	if (s_spritetex_pushed69) {
		delete s_spritetex_pushed69;
		s_spritetex_pushed69 = 0;
	}
	if (s_spritetex_pushed70) {
		delete s_spritetex_pushed70;
		s_spritetex_pushed70 = 0;
	}
	if (s_spritetex_pushed85) {
		delete s_spritetex_pushed85;
		s_spritetex_pushed85 = 0;
	}
	if (s_spritetex_pushed71) {
		delete s_spritetex_pushed71;
		s_spritetex_pushed71 = 0;
	}
	if (s_spritetex_pushed72) {
		delete s_spritetex_pushed72;
		s_spritetex_pushed72 = 0;
	}
	if (s_spritetex_pushed73) {
		delete s_spritetex_pushed73;
		s_spritetex_pushed73 = 0;
	}
	if (s_spritetex_pushed74) {
		delete s_spritetex_pushed74;
		s_spritetex_pushed74 = 0;
	}
	if (s_spritetex_pushed75) {
		delete s_spritetex_pushed75;
		s_spritetex_pushed75 = 0;
	}
	if (s_spritetex_pushed76) {
		delete s_spritetex_pushed76;
		s_spritetex_pushed76 = 0;
	}
	if (s_spritetex_pushed77) {
		delete s_spritetex_pushed77;
		s_spritetex_pushed77 = 0;
	}
	if (s_spritetex_pushed78) {
		delete s_spritetex_pushed78;
		s_spritetex_pushed78 = 0;
	}
	if (s_spritetex_pushed61) {
		delete s_spritetex_pushed61;
		s_spritetex_pushed61 = 0;
	}
	if (s_spritetex_pushed62) {
		delete s_spritetex_pushed62;
		s_spritetex_pushed62 = 0;
	}


	if (s_spritetexCamera67) {
		delete s_spritetexCamera67;
		s_spritetexCamera67 = 0;
	}
	if (s_spritetexCamera_pushed67) {
		delete s_spritetexCamera_pushed67;
		s_spritetexCamera_pushed67 = 0;
	}
	if (s_spritetexCamera69) {
		delete s_spritetexCamera69;
		s_spritetexCamera69 = 0;
	}
	if (s_spritetexCamera_pushed69) {
		delete s_spritetexCamera_pushed69;
		s_spritetexCamera_pushed69 = 0;
	}
	if (s_spritetexCamera71) {
		delete s_spritetexCamera71;
		s_spritetexCamera71 = 0;
	}
	if (s_spritetexCamera_pushed71) {
		delete s_spritetexCamera_pushed71;
		s_spritetexCamera_pushed71 = 0;
	}
	if (s_spritetexCamera72) {
		delete s_spritetexCamera72;
		s_spritetexCamera72 = 0;
	}
	if (s_spritetexCamera_pushed72) {
		delete s_spritetexCamera_pushed72;
		s_spritetexCamera_pushed72 = 0;
	}
	if (s_spritetexCamera64) {
		delete s_spritetexCamera64;
		s_spritetexCamera64 = 0;
	}
	if (s_spritetexCamera_pushed64) {
		delete s_spritetexCamera_pushed64;
		s_spritetexCamera_pushed64 = 0;
	}


	int delindex;
	s_spundo[0].DestroyObjs();
	s_spundo[1].DestroyObjs();
	for (delindex = 0; delindex < SPAXISNUM; delindex++) {
		s_spaxis[delindex].DestroyObjs();
	}
	for (delindex = 0; delindex < SPR_CAM_MAX; delindex++) {
		s_spcam[delindex].DestroyObjs();
	}
	for (delindex = 0; delindex < SPRIGMAX; delindex++) {
		s_sprig[delindex].DestroyObjs();
	}
	s_spret2prev.DestroyObjs();
	s_spret2prev2.DestroyObjs();
	s_spcplw2w.DestroyObjs();
	s_spsmooth.DestroyObjs();
	s_spupperbar.DestroyObjs();
	s_spconstexe.DestroyObjs();
	s_spconstrefresh.DestroyObjs();
	s_spcopy.DestroyObjs();
	s_spsymcopy.DestroyObjs();
	s_sppaste.DestroyObjs();
	s_spcopyhistory.DestroyObjs();
	s_spjumpinterpolate.DestroyObjs();
	s_spinterpolate.DestroyObjs();
	s_spinit.DestroyObjs();
	s_spscaleinit.DestroyObjs();
	s_spproperty.DestroyObjs();
	s_spzeroframe.DestroyObjs();
	s_spcameradolly.DestroyObjs();
	s_spmodelposdir.DestroyObjs();
	s_spmaterialrate.DestroyObjs();

	s_spcopy_camera.DestroyObjs();
	s_sppaste_camera.DestroyObjs();
	s_spinterpolate_camera.DestroyObjs();
	s_spinit_camera.DestroyObjs();
	s_spsmooth_camera.DestroyObjs();

	for (delindex = 0; delindex < SPGUISWNUM; delindex++) {
		s_spguisw[delindex].DestroyObjs();
	}
	for (delindex = 0; delindex < SPDISPSWNUM; delindex++) {
		s_spdispsw[delindex].DestroyObjs();
	}
	for (delindex = 0; delindex < SPRIGIDSWNUM; delindex++) {
		s_sprigidsw[delindex].DestroyObjs();
	}
	for (delindex = 0; delindex < SPRETARGETSWNUM; delindex++) {
		s_spretargetsw[delindex].DestroyObjs();
	}
	for (delindex = 0; delindex < SPEFFECTSWNUM; delindex++) {
		s_speffectsw[delindex].DestroyObjs();
	}
	s_spsel3d.DestroyObjs();
	s_spmousehere.DestroyObjs();
	for (delindex = 0; delindex < 3; delindex++) {
		s_spikmodesw[delindex].DestroyObjs();
	}
	s_sprefpos.DestroyObjs();
	s_splimiteul.DestroyObjs();
	s_spscraping.DestroyObjs();
	s_mousecenteron.DestroyObjs();
	s_spcameramode.DestroyObjs();
	s_spcamerainherit.DestroyObjs();
	//static InstancedSprite s_bcircle;
	s_kinsprite.DestroyObjs();
	s_undosprite.DestroySprites();
	s_fpssprite.DestroySprites();



}


///////////////////////////////////////////////////////////////////
// ウィンドウの初期化。
///////////////////////////////////////////////////////////////////
RECT InitWindow(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPWSTR lpCmdLine, int nCmdShow, const TCHAR* appName,
	HWND srcparentwnd,
	int srcposx, int srcposy,
	int srcwidth, int srcheight)
{
	//ウィンドウクラスのパラメータを設定(単なる構造体の変数の初期化です。)
	WNDCLASSEX wc =
	{
		sizeof(WNDCLASSEX),		//構造体のサイズ。
		//CS_CLASSDC,				//ウィンドウのスタイル。
		CS_CLASSDC | CS_DBLCLKS,
		//ここの指定でスクロールバーをつけたりできるが、ゲームでは不要なのでCS_CLASSDCでよい。
		//MsgProc,				//メッセージプロシージャ(後述)
		//srcmsgproc,
		AppMsgProc,
		0,						//0でいい。
		0,						//0でいい。
		//GetModuleHandle(NULL),	//このクラスのためのウインドウプロシージャがあるインスタンスハンドル。
		hInstance,
		//何も気にしなくてよい。
		NULL,					//アイコンのハンドル。アイコンを変えたい場合ここを変更する。とりあえずこれでいい。
		//NULL,					//マウスカーソルのハンドル。NULLの場合はデフォルト。
		LoadCursor(nullptr, IDC_ARROW),
		//NULL,					//ウィンドウの背景色。NULLの場合はデフォルト。
		//(HBRUSH)GetStockObject(BLACK_BRUSH),
		//(HBRUSH)GetStockObject(GRAY_BRUSH),
		NULL,
		NULL,					//メニュー名。NULLでいい。
		appName,				//ウィンドウクラスに付ける名前。
		NULL					//NULLでいい。
	};
	//ウィンドウクラスの登録。
	RegisterClassEx(&wc);

	HMENU hMenu = NULL;
	LONG winstyle = WS_OVERLAPPEDWINDOW;
	winstyle &= ~WS_CAPTION;
	winstyle &= ~WS_THICKFRAME;
	winstyle |= WS_CHILD;
	//LONG winstyle = WS_CHILD;

	RECT rc;
	SetRect(&rc, 0, 0, srcwidth, srcheight);
	AdjustWindowRect(&rc, winstyle, (hMenu) ? true : false);
	//s_mainwidth = rc.right - rc.left;
	//s_mainheight = rc.bottom - rc.top;
	//s_bufwidth = rc.right - rc.left;
	//s_bufheight = rc.bottom - rc.top;


	// ウィンドウの作成。
	g_hWnd = CreateWindow(
		appName,				//使用するウィンドウクラスの名前。
		//先ほど作成したウィンドウクラスと同じ名前にする。
		appName,				//ウィンドウの名前。ウィンドウクラスの名前と別名でもよい。
		//WS_OVERLAPPEDWINDOW,	//ウィンドウスタイル。ゲームでは基本的にWS_OVERLAPPEDWINDOWでいい、
		winstyle,
		srcposx,						//ウィンドウの初期X座標。
		srcposy,						//ウィンドウの初期Y座標。
		//s_mainwidth,			//ウィンドウの幅。
		//s_mainheight,			//ウィンドウの高さ。
		(rc.right - rc.left),
		(rc.bottom - rc.top),
		//srcwidth,
		//srcheight,
		srcparentwnd,			//親ウィンドウ。ゲームでは基本的にNULLでいい。
		NULL,					//メニュー。今はNULLでいい。
		hInstance,				//アプリケーションのインスタンス。
		NULL
	);
	if (!g_hWnd) {
		_ASSERT(0);
		::MessageBox(g_mainhwnd, L"ウインドウの作成でエラー.アプリを終了します.", L"CreateWindow Error!!!", MB_OK);
		abort();
	}


	ShowWindow(g_hWnd, nCmdShow);

	return rc;
}


//ゲームの初期化。
RECT InitGame(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow, const TCHAR* appName,
	HWND srcparentwnd,
	int srcposx, int srcposy,
	int srcwidth, int srcheight)
{
	//ウィンドウを初期化。
	RECT rc = InitWindow(hInstance, hPrevInstance, lpCmdLine, nCmdShow, appName,
		srcparentwnd,
		srcposx, srcposy,
		srcwidth, srcheight);
	//TKエンジンの初期化。
	g_engine = new TkEngine;
	g_engine->Init(g_hWnd, srcwidth, srcheight);

	if (g_graphicsEngine->GetD3DDevice()) {
		g_graphicsEngine->GetD3DDevice()->QueryInterface(s_debugDevice.GetAddressOf());//2024/02/14
	}
	else {
		_ASSERT(0);
	}

	return rc;
}
//ウィンドウメッセージをディスパッチ。falseが返ってきたら、ゲーム終了。
bool DispatchWindowMessage()
{
	MSG msg = { 0 };
	while (WM_QUIT != msg.message) {
		//ウィンドウからのメッセージを受け取る。
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else {
			//ウィンドウメッセージが空になった。
			break;
		}
	}
	return msg.message != WM_QUIT;
}

int OnCreateDevice()
{
	CalcTotalBound();
	
	
	//CallF(GetShaderHandle(), return S_FALSE);
	
	CallF(IMCompute::InitStaticMem(s_pdev), return 1);



	if (!g_texbank) {
		g_texbank = new CTexBank(s_pdev);
		if (!g_texbank) {
			_ASSERT(0);
			PostQuitMessage(1);
			return 0;
		}
	}
	CreateSprites();
	SetSpParams();

	CBone::InitColDisp();

	s_select = new CModel();
	if (!s_select) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_select->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\select_2.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_select->MakeDispObj(), return S_FALSE;);
	
	s_matred = s_select->GetMQOMaterialByName("matred");
	if (!s_matred) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_ringred = s_select->GetMQOMaterialByName("ringred");
	if (!s_ringred) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_matblue = s_select->GetMQOMaterialByName("matblue");
	if (!s_matblue) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_ringblue = s_select->GetMQOMaterialByName("ringblue");
	if (!s_ringblue) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_matgreen = s_select->GetMQOMaterialByName("matgreen");
	if (!s_matgreen) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_ringgreen = s_select->GetMQOMaterialByName("ringgreen");
	if (!s_ringgreen) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_matyellow = s_select->GetMQOMaterialByName("matyellow");
	if (!s_matyellow) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	
	s_selectobj_objx = s_select->GetMQOObjectByName("objX");
	if (!s_selectobj_objx) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_ringx = s_select->GetMQOObjectByName("ringX");
	if (!s_selectobj_ringx) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_objy = s_select->GetMQOObjectByName("objY");
	if (!s_selectobj_objy) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_ringy = s_select->GetMQOObjectByName("ringY");
	if (!s_selectobj_ringy) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_objz = s_select->GetMQOObjectByName("objZ");
	if (!s_selectobj_objz) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_ringz = s_select->GetMQOObjectByName("ringZ");
	if (!s_selectobj_ringz) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_selectobj_center = s_select->GetMQOObjectByName("obj_CENTER");
	if (!s_selectobj_center) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}



	//s_matredmat = s_matred->GetDif4F();
	//s_ringredmat = s_ringred->GetDif4F();
	//s_matbluemat = s_matblue->GetDif4F();
	//s_ringbluemat = s_ringblue->GetDif4F();
	//s_matgreenmat = s_matgreen->GetDif4F();
	//s_ringgreenmat = s_ringgreen->GetDif4F();
	//s_matyellowmat = s_matyellow->GetDif4F();
	s_matredmat.SetParams(255.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f, 1.0f);
	s_ringredmat.SetParams(255.0f / 255.0f, 128.0f / 255.0f, 128.0f / 255.0f, 1.0f);
	s_matbluemat.SetParams(150.0f / 255.0f, 200.0f / 255.0f, 255.0f / 255.0f, 1.0f);
	s_ringbluemat.SetParams(150.0f / 255.0f, 200.0f / 255.0f, 255.0f / 255.0f, 1.0f);
	s_matgreenmat.SetParams(0.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f, 1.0f);
	s_ringgreenmat.SetParams(0.0f / 255.0f, 255.0f / 255.0f, 0.0f / 255.0f, 1.0f);
	s_matyellowmat = s_matyellow->GetDif4F();
	
	
	
	
	s_select_posture = new CModel();
	if (!s_select_posture) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_select_posture->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\select_2_posture.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_select_posture->MakeDispObj(), return S_FALSE);



	s_sky = new CModel();
	if (!s_sky) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	FbxScene* pScene = 0;
	FbxImporter* pImporter = 0;
	BOOL motioncachebatchflag = FALSE;
	WCHAR skypath[1024] = { 0L };
	//swprintf_s(skypath, 1024, L"%s..\\Media\\MameMedia\\SkySphere1.fbx", g_basedir);
	swprintf_s(skypath, 1024, L"%s..\\Media\\CelestialSphere\\SkySphere1.fbx", g_basedir);//2024/03/02
	//swprintf_s(skypath, 1024, L"%s..\\Media\\SkyBox\\SkyBox1.fbx", g_basedir);//2024/03/04
	CallF(s_sky->LoadFBX(1, s_pdev, 
		skypath, L"SkySphere1_1", 1.0f,
		s_psdk, &pImporter, &pScene, s_forcenewaxis, motioncachebatchflag), return S_FALSE);
	s_sky->SetSkyFlag(true);//!!!!!!!!!!!! for no clipping
	s_sky->SetLightFlag(false);//2024/03/07



	//2024/03/02
	//読込場所が変わる場合に　カレントディレクトリ位置を直す必要
	SetCurrentDirectoryW(g_basedir);


	float rigmult = 1.0f;
	s_rigopemark_sphere = new CModel();
	if (!s_rigopemark_sphere) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_rigopemark_sphere->SetInstancingNum(RIGMULTINDEXMAX);
	CallF(s_rigopemark_sphere->LoadMQO(s_pdev,
		L"..\\Media\\MameMedia\\rigmark.mqo", 0, rigmult, 0), return S_FALSE);

	s_rigopemark_ringX = new CModel();
	if (!s_rigopemark_ringX) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_rigopemark_ringX->SetInstancingNum(RIGMULTINDEXMAX);
	CallF(s_rigopemark_ringX->LoadMQO(s_pdev,
		L"..\\Media\\MameMedia\\ringX.mqo", 0, rigmult, 0), return S_FALSE);

	s_rigopemark_ringY = new CModel();
	if (!s_rigopemark_ringY) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_rigopemark_ringY->SetInstancingNum(RIGMULTINDEXMAX);
	CallF(s_rigopemark_ringY->LoadMQO(s_pdev,
		L"..\\Media\\MameMedia\\ringY.mqo", 0, rigmult, 0), return S_FALSE);

	s_rigopemark_ringZ = new CModel();
	if (!s_rigopemark_ringZ) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	s_rigopemark_ringZ->SetInstancingNum(RIGMULTINDEXMAX);
	CallF(s_rigopemark_ringZ->LoadMQO(s_pdev,
		L"..\\Media\\MameMedia\\ringZ.mqo", 0, rigmult, 0), return S_FALSE);

	s_matrigmat.SetParams(255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f);
	
	
	s_bmark = new CModel();
	if (!s_bmark) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_bmark->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\bonemark.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_bmark->MakeDispObj(), return S_FALSE);
	
	
	
	
	s_ground = new CModel();
	if (!s_ground) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_ground->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\ground2.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_ground->MakeDispObj(), return S_FALSE);
	s_ground->SetGroundFlag(true);

	s_gplane = new CModel();
	if (!s_gplane) {
		_ASSERT(0);
		PostQuitMessage(1);
		return S_FALSE;
	}
	CallF(s_gplane->LoadMQO(s_pdev, L"..\\Media\\MameMedia\\gplane.mqo", 0, 1.0f, 0), return S_FALSE);
	//CallF(s_gplane->MakeDispObj(), return S_FALSE);
	ChaVector3 tra(0.0f, 0.0, 0.0f);
	ChaVector3 mult(5.0f, 1.0f, 5.0f);
	CallF(s_gplane->MultDispObj(mult, tra), return S_FALSE);


	//WCHAR initialdir[MAX_PATH] = { 0L };
	//wcscpy_s(initialdir, MAX_PATH, g_basedir);
	//wcscat_s(initialdir, MAX_PATH, L"..\\Test\\");
	//SetCurrentDirectoryW(initialdir);

return 0;
}

void CloseAllRightPainWindow(bool closefirstraw)
{
	//platemenu用のウインドウ以外を閉じるまたは破棄する
	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);
	}
	if (s_copyhistorydlg2.GetCreatedFlag() == true) {
		s_copyhistorydlg2.SetVisible(false);
	}
	
	if (s_dollyhistorydlg2.GetCreatedFlag() == true) {
		s_dollyhistorydlg2.SetVisible(false);
	}
	//if (s_limitWnd) {
	//	s_underanglelimithscroll = 0;
	//	ShowLimitEulerWnd(false);
	//}
	if (s_rotaxisdlg) {
		DestroyWindow(s_rotaxisdlg);
		s_rotaxisdlg = 0;
	}
	if (s_customrigdlg) {
		DestroyWindow(s_customrigdlg);
		s_customrigdlg = 0;
	}


	//platemenuのwindowを閉じる
	GUIRigidSetVisible(-2);
	GUIRetargetSetVisible(-2);
	GUIEffectSetVisible(-2);
	GUIDispSetVisible(-2);

	if (closefirstraw) {//CameraAndIKクリック時には閉じない
		CloseTheFirstRowGUI();
	}
}

void CloseAllAndDispPlaceFolder()
{
	CloseAllRightPainWindow(true);

	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(true);
	}
}


void CloseTheFirstRowGUI()
{
	ShowGUIDlgDispParams(false);
	//ShowGUIDlgBrushes(false);
	ShowGUIDlgBullet(false);
	ShowGUIDlgLOD(false);
	ShowGUIDlgBlendShape(false);

	if (s_placefolderWnd) {
		s_placefolderWnd->setVisible(false);//2024/07/09
	}
}


void InitPickInfo(UIPICKINFO* ppickinfo)
{
	if (ppickinfo) {
		::ZeroMemory(ppickinfo, sizeof(UIPICKINFO));
		ppickinfo->pickobjno = -1;//!!!!!
	}
	else {
		_ASSERT(0);
	}
}

int PickBone(UIPICKINFO* ppickinfo)
{
	if (!s_model) {
		return 0;
	}
	if (!ppickinfo) {
		_ASSERT(0);
		return 0;
	}
	//if (s_camtargetdisp) {
	//	//カメラターゲット位置にマニピュレータ表示時にはpickしない
	//	return 0;
	//}

	if (s_spdispsw[SPDISPSW_DISPGROUP].state || s_spdispsw[SPDISPSW_SHADERTYPE].state){
		//2024/03/08 Pick&Set中には　ボーンをピックしない
		return 0;
	}

	int result0 = s_model->PickBone(ppickinfo);
	return result0;
}

bool GetResultOfPickRay()
{
	if (g_previewFlag != 0) {
		return false;
	}


	POINT ptCursor;
	GetCursorPos(&ptCursor);
	::ScreenToClient(s_3dwnd, &ptCursor);
	s_fontposfortip.Set((float)ptCursor.x, (float)ptCursor.y);

	WCHAR modelname[256] = { 0L };
	WCHAR objname[256] = { 0L };
	WCHAR materialname[256] = { 0L };
	

	s_pickmodel = nullptr;
	s_pickmqoobj = nullptr;
	s_pickmaterial = nullptr;
	bool dispPickfortip = false;
	int pickkind;
	if (s_spdispsw[SPDISPSW_DISPGROUP].state) {
		pickkind = NUMKEYPICK_MQOOBJECT;
		dispPickfortip = s_chascene->GetResultOfPickRay(pickkind, &s_pickmodel, &s_pickmqoobj, &s_pickmaterial, &s_pickhitpos);
		if (dispPickfortip &&
			s_pickmodel && s_pickmqoobj) {// &&
			//((s_pickmodel != s_befpickmodel) || (s_pickmqoobj != s_befpickmqoobj))) {

			s_befpickmodel = s_pickmodel;
			s_befpickmqoobj = s_pickmqoobj;

			wcscpy_s(modelname, 256, s_pickmodel->GetFileName());
			char tmpobjname[256] = { 0 };
			strcpy_s(tmpobjname, 256, s_pickmqoobj->GetName());
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, tmpobjname, 256, objname, 256);

			WCHAR tmptip[512] = { 0L };
			swprintf_s(tmptip, 512, L"Mesh:%s:%s", modelname, objname);
			if (wcscmp(s_strfortip, tmptip) != 0) {
				wcscpy_s(s_strfortip, 512, tmptip);
			}
			//s_fontposfortip.Set((float)ptCursor.x, (float)ptCursor.y);
		}
	}
	else if (s_spdispsw[SPDISPSW_SHADERTYPE].state) {
		pickkind = NUMKEYPICK_MQOMATERIAL;
		dispPickfortip = s_chascene->GetResultOfPickRay(pickkind, &s_pickmodel, &s_pickmqoobj, &s_pickmaterial, &s_pickhitpos);

		if (dispPickfortip &&
			s_pickmodel && s_pickmaterial) {// &&
			//((s_pickmodel != s_befpickmodel) || (s_pickmaterial != s_befpickmaterial))) {

			s_befpickmodel = s_pickmodel;
			s_befpickmaterial = s_pickmaterial;

			wcscpy_s(modelname, 256, s_pickmodel->GetFileName());
			char tmpmaterialname[256] = { 0 };
			strcpy_s(tmpmaterialname, 256, s_pickmaterial->GetName());
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, tmpmaterialname, 256, materialname, 256);
			WCHAR tmptip[512] = { 0L };
			swprintf_s(tmptip, 512, L"Material:%s:%s", modelname, materialname);
			if (wcscmp(s_strfortip, tmptip) != 0) {
				wcscpy_s(s_strfortip, 512, tmptip);
			}
			//s_fontposfortip.Set((float)ptCursor.x, (float)ptCursor.y);
		}
	}
	else {
		pickkind = -1;
	}
	
	return dispPickfortip;
}

void DestroyGrassElem()
{
	int grasselemnum = (int)s_grassElemVec.size();
	int grasselemindex;
	for (grasselemindex = 0; grasselemindex < grasselemnum; grasselemindex++) {
		CGrassElem* delgrasselem = s_grassElemVec[grasselemindex];
		if (delgrasselem) {
			delete delgrasselem;//delgrasselem->m_grassはChaSceneのデストラクタで破棄される
		}
	}
	s_grassElemVec.clear();
}

bool InBlendShapeMode(CModel** ppmodel, CMQOObject** ppmqoobj, int* pchannelindex)
{
	if (!ppmodel || !ppmqoobj || !pchannelindex) {
		return false;
	}

	*ppmodel = 0;
	*ppmqoobj = 0;
	*pchannelindex = -1;

	//if (s_blendshapeWnd && s_spguisw[SPGUISW_BLENDSHAPE].state &&
	//	!s_blendshapeelemvec.empty() && (s_blendshapeOpeIndex >= 0)) {
	if (s_blendshapedlg.GetVisible() && s_spguisw[SPGUISW_BLENDSHAPE].state &&
		(s_blendshapedlg.GetBlendShapeLineNum() > 0) && (s_blendshapedlg.GetBlendShapeOpeIndex() >= 0)) {

		int blendshapenum = s_blendshapedlg.GetBlendShapeLineNum();
		int blendshapeindex = s_blendshapedlg.GetBlendShapeOpeIndex();
		if ((blendshapeindex >= 0) && (blendshapeindex < blendshapenum)) {
			CBlendShapeElem blendshape = s_blendshapedlg.GetBlendShapeElem(blendshapeindex);
			if (blendshape.validflag && blendshape.model && blendshape.mqoobj) {
				*ppmodel = blendshape.model;
				*ppmqoobj = blendshape.mqoobj;
				*pchannelindex = blendshapeindex;

				return true;//!!!!!!!!!!!!
			}
			else {
				return false;
			}
		}
		else {
			return false;
		}
	}
	else {
		return false;
	}
}

MOTINFO GetCameraMotInfo()
{
	MOTINFO curmi;
	if (s_cameramodel) {
		int cameramotid = s_cameramodel->GetCameraMotionId();
		if (cameramotid > 0) {
			curmi = s_cameramodel->GetMotInfo(cameramotid);
		}
		else {
			curmi.Init();
		}
	}
	else {
		curmi.Init();
	}
	if (curmi.motid <= 0) {
		curmi.Init();
	}
	return curmi;
}

MOTINFO GetEditTargetMotInfo()
{
	MOTINFO curmi;
	if (g_edittarget == EDITTARGET_CAMERA) {
		if (s_cameramodel) {
			int cameramotid = s_cameramodel->GetCameraMotionId();
			if (cameramotid > 0) {
				curmi = s_cameramodel->GetMotInfo(cameramotid);
			}
			else {
				curmi.Init();
			}
		}
		else {
			curmi.Init();
		}
	}
	else {
		curmi = s_model->GetCurMotInfo();
	}
	if (curmi.motid <= 0) {
		curmi.Init();
	}
	return curmi;
}

CBone* GetEditTargetOpeBone(int* pmotid, int* pframeleng)
{
	if (!pmotid || !pframeleng) {
		_ASSERT(0);
		return nullptr;
	}

	int frameleng = 100;
	int graphmotid = 0;
	CBone* opebone = nullptr;
	if (g_edittarget == EDITTARGET_BONE) {

		graphmotid = s_model->GetCurrentMotID();
		frameleng = IntTime(s_model->GetCurrentMaxFrame());

		if (s_curboneno < 0) {
			CBone* topbone = s_model->GetTopBone();
			if (topbone) {
				//選択状態がない場合にはtopboneのオイラーグラフを表示する。
				s_curboneno = topbone->GetBoneNo();
			}
		}

		if (s_model && (s_curboneno >= 0)) {
			opebone = s_model->GetBoneByID(s_curboneno);
			if (opebone) {
				CBone* parentbone = opebone->GetParent(false);
				if (s_ikkind == 0) {
					//ikkind がROT(0)の場合はIK　それ以外のMV, SCALEの場合にはFK
					if (parentbone && parentbone->IsSkeleton()) {
						opebone = parentbone;
					}
				}
			}
			else {
				opebone = nullptr;
			}
		}
		else {
			opebone = nullptr;
		}
	}
	else if (g_edittarget == EDITTARGET_CAMERA) {
		if (s_cameramodel) {
			graphmotid = s_cameramodel->GetCameraMotionId();
			if (graphmotid > 0) {
				MOTINFO camerami = s_cameramodel->GetMotInfo(graphmotid);
				frameleng = IntTime(camerami.frameleng);
				CAMERANODE* cnptr = s_cameramodel->GetCAMERANODE(graphmotid);
				if (cnptr && cnptr->pbone) {
					opebone = cnptr->pbone->GetParent(false);
					_ASSERT(opebone->IsNullAndChildIsCamera());
				}
				else {
					opebone = nullptr;
				}
			}
			else {
				opebone = nullptr;
			}
		}
		else {
			opebone = nullptr;
		}
	}
	else {
		opebone = nullptr;
	}

	*pmotid = graphmotid;
	*pframeleng = frameleng;

	return opebone;
}


int OnCameraAnimMouseMove(int opekind, int pickxyz, float deltax)
{
	int cameramotid = 0;
	int cameraframeleng = 100;
	CBone* opebone0 = GetEditTargetOpeBone(&cameramotid, &cameraframeleng);
	if (s_cameramodel && opebone0) {

		bool doneflag = false;
		if (opekind == CAMERAANIMEDIT_ROT) {
			s_editcameraflag = s_cameramodel->CameraRotateAxisDelta(
				g_limitdegflag,
				&s_editrange, pickxyz,
				deltax, s_ikcnt);

			doneflag = true;
		}
		else if (opekind == CAMERAANIMEDIT_MV) {
			s_editcameraflag = s_cameramodel->CameraTranslateAxisDelta(
				&s_editrange, pickxyz - PICK_X, deltax, s_matView);

			doneflag = true;
		}
		else if (opekind == CAMERAANIMEDIT_DIST) {
			//s_editcameraflag = s_cameramodel->CameraTranslateAxisDelta(
			//	&s_editrange, PICK_Z - PICK_X, deltax, s_matView);

			//2024/07/30
			//camaradist操作は　カメラが回転していく場合には　回転に応じてカメラ位置を動かす必要がある
			//よってZ方向の移動ではうまくいかないことが多かった
			//CameraDist操作専用の関数作成
			s_editcameraflag = s_cameramodel->CameraDistDelta(&s_editrange, deltax, s_camtargetflag);
			g_camdist += deltax;

			//OutputToInfoWnd(INFOCOLOR_INFO, L"deltax %f, g_camdist %f", deltax, g_camdist);
			doneflag = true;
		}
		else if (opekind == CAMERAANIMEDIT_TWIST) {
			s_editcameraflag = s_cameramodel->CameraTwistDelta(&s_editrange, deltax);

			doneflag = true;
		}

		if (doneflag) {
			ChaVector3 tmpcamtarget;
			s_cameramodel->GetCameraAnimParams(s_cameraframe,
				g_camdist,
				&g_camEye, &tmpcamtarget, &g_cameraupdir,
				0, g_cameraInheritMode);//g_camdist

			if (s_camtargetflag) {
				//g_camtargetposはそのまま
			}
			else {
				g_camtargetpos = tmpcamtarget;
			}

			ChaVector3 diffvec = g_camtargetpos - g_camEye;
			float newcamdist = (float)ChaVector3LengthDbl(&diffvec);
			ChangeCameraDist(newcamdist, false, false);

			UpdateEditedEuler();//twist時には右ドラッグなのでLBUTTONUPメッセージでのUpdateEditedEuler()が呼ばれない.ここで呼ぶことに.
		}
	}
	//SetCamera3DFromEyePos();

	return 0;
}

int OnCameraAnimPaste()
{

	//現在のカメラ行列をカメラアニメにペーストする

	if (s_cameramodel) {
		//2024/08/02
		//カメラ履歴セレクト時には　カメラアニメスイッチオンまたはカメラグラフモードの場合に　カメラアニメにペースト
		if (s_spcameramode.state || (g_edittarget == EDITTARGET_CAMERA)) {
			int cameramotid = s_cameramodel->GetCameraMotionId();
			MOTINFO camerami = s_cameramodel->GetMotInfo(cameramotid);
			if (camerami.motid > 0) {
				double curframe = RoundingTime(camerami.curframe);
				s_editcameraflag = s_cameramodel->CameraAnimPaste(curframe, s_matView);


				UpdateEditedEuler();
				PrepairUndo();
			}
		}
	}

	return 0;
}


bool ChkEnableIK()
{
	if (!s_model) {
		return false;
	}

	int curmotid = s_model->GetCurrentMotID();
	if (curmotid <= 0) {
		return false;
	}

	if (g_edittarget != EDITTARGET_BONE) {
		return false;
	}

	bool cameraanimflag = s_model->IsCameraMotion(curmotid);
	if (cameraanimflag) {
		return false;
	}

	return true;
}

int SetModel2Dlgs(CModel* srcmodel)
{
	if (srcmodel) {
		CFrameCopyDlg* curcpdlg = GetCurrentFrameCopyDlg(false);
		if (!curcpdlg) {
			curcpdlg = new CFrameCopyDlg();
			if (!curcpdlg) {
				_ASSERT(0);
				s_underselectmodel = false;
				return 1;//!!!!!!!!!
			}
			s_selbonedlgmap[srcmodel] = curcpdlg;
			curcpdlg->SetModel(srcmodel);
		}

		if (s_materialratedlgwnd) {
			if (srcmodel) {
				SetModel2MaterialRateDlg(srcmodel);
			}
		}

		if (s_modelworldmatdlgwnd) {
			if (srcmodel) {
				SetModel2ModelWorldMatDlg(srcmodel);
			}
		}

		if (InterlockedAdd(&g_retargetbatchflag, 0) == 0) {
			{
				GetCPTFileName(s_cptfilename);
				s_copyhistorydlg2.SetNames(srcmodel, s_cptfilename);
			}
		}

		s_rigidparamsdlg.SetModel(srcmodel, s_curboneno, s_reindexmap, s_rgdindexmap);
		s_limiteuldlg.SetModel(srcmodel, s_curboneno);

		s_dispgroupdlg.SetModel(srcmodel);

		s_latertransparentdlg.SetModel(srcmodel);

		s_shadertypedlg.SetModel(srcmodel);

		s_shaderparamsdlg.SetModel(srcmodel, &s_shadertypeparams);

		if (s_blendshapedlg.GetVisible()) {
			s_blendshapedlg.SetModel(srcmodel);
		}

		if (!s_retargetdlg.GetRetargetRetargetGUIFlag() && //2024/06/27 GUIからのリターゲット実行中に設定を初期化しないようにスキップ
			((s_dispconvbone == true) && 
			(InterlockedAdd(&g_bvh2fbxbatchflag, 0) == 0) && (InterlockedAdd(&g_retargetbatchflag, 0) == 0))
			) {
			//CreateConvBoneWnd();//!!!!!!!!!!!!! モデル選択変更によりリターゲットウインドウ作り直し
			s_retargetdlg.SetModel(srcmodel);
		}

	}

	return 0;
}